// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AddApplicationCloudWatchLoggingOptionInput`](crate::input::AddApplicationCloudWatchLoggingOptionInput)
pub mod add_application_cloud_watch_logging_option_input {
    /// A builder for [`AddApplicationCloudWatchLoggingOptionInput`](crate::input::AddApplicationCloudWatchLoggingOptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) cloud_watch_logging_option:
            std::option::Option<crate::model::CloudWatchLoggingOption>,
        pub(crate) conditional_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Kinesis Data Analytics application name.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The Kinesis Data Analytics application name.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The version ID of the Kinesis Data Analytics application. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The version ID of the Kinesis Data Analytics application. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN). </p>
        pub fn cloud_watch_logging_option(
            mut self,
            input: crate::model::CloudWatchLoggingOption,
        ) -> Self {
            self.cloud_watch_logging_option = Some(input);
            self
        }
        /// <p>Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN). </p>
        pub fn set_cloud_watch_logging_option(
            mut self,
            input: std::option::Option<crate::model::CloudWatchLoggingOption>,
        ) -> Self {
            self.cloud_watch_logging_option = input;
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.conditional_token = Some(input.into());
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conditional_token = input;
            self
        }
        /// Consumes the builder and constructs a [`AddApplicationCloudWatchLoggingOptionInput`](crate::input::AddApplicationCloudWatchLoggingOptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddApplicationCloudWatchLoggingOptionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddApplicationCloudWatchLoggingOptionInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                cloud_watch_logging_option: self.cloud_watch_logging_option,
                conditional_token: self.conditional_token,
            })
        }
    }
}
#[doc(hidden)]
pub type AddApplicationCloudWatchLoggingOptionInputOperationOutputAlias =
    crate::operation::AddApplicationCloudWatchLoggingOption;
#[doc(hidden)]
pub type AddApplicationCloudWatchLoggingOptionInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl AddApplicationCloudWatchLoggingOptionInput {
    /// Consumes the builder and constructs an Operation<[`AddApplicationCloudWatchLoggingOption`](crate::operation::AddApplicationCloudWatchLoggingOption)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddApplicationCloudWatchLoggingOption,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AddApplicationCloudWatchLoggingOptionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AddApplicationCloudWatchLoggingOptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AddApplicationCloudWatchLoggingOptionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.AddApplicationCloudWatchLoggingOption",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_add_application_cloud_watch_logging_option(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddApplicationCloudWatchLoggingOption::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddApplicationCloudWatchLoggingOption",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddApplicationCloudWatchLoggingOptionInput`](crate::input::AddApplicationCloudWatchLoggingOptionInput)
    pub fn builder() -> crate::input::add_application_cloud_watch_logging_option_input::Builder {
        crate::input::add_application_cloud_watch_logging_option_input::Builder::default()
    }
}

/// See [`AddApplicationInputInput`](crate::input::AddApplicationInputInput)
pub mod add_application_input_input {
    /// A builder for [`AddApplicationInputInput`](crate::input::AddApplicationInputInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) input: std::option::Option<crate::model::Input>,
    }
    impl Builder {
        /// <p>The name of your existing application to which you want to add the streaming
        /// source.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of your existing application to which you want to add the streaming
        /// source.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The current version of your application.
        /// You must provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>.You can use the <a>DescribeApplication</a> operation to find the current application version.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The current version of your application.
        /// You must provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>.You can use the <a>DescribeApplication</a> operation to find the current application version.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The <a>Input</a> to add.</p>
        pub fn input(mut self, input: crate::model::Input) -> Self {
            self.input = Some(input);
            self
        }
        /// <p>The <a>Input</a> to add.</p>
        pub fn set_input(mut self, input: std::option::Option<crate::model::Input>) -> Self {
            self.input = input;
            self
        }
        /// Consumes the builder and constructs a [`AddApplicationInputInput`](crate::input::AddApplicationInputInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddApplicationInputInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddApplicationInputInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                input: self.input,
            })
        }
    }
}
#[doc(hidden)]
pub type AddApplicationInputInputOperationOutputAlias = crate::operation::AddApplicationInput;
#[doc(hidden)]
pub type AddApplicationInputInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddApplicationInputInput {
    /// Consumes the builder and constructs an Operation<[`AddApplicationInput`](crate::operation::AddApplicationInput)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddApplicationInput,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AddApplicationInputInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AddApplicationInputInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AddApplicationInputInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.AddApplicationInput",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_add_application_input(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddApplicationInput::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddApplicationInput",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddApplicationInputInput`](crate::input::AddApplicationInputInput)
    pub fn builder() -> crate::input::add_application_input_input::Builder {
        crate::input::add_application_input_input::Builder::default()
    }
}

/// See [`AddApplicationInputProcessingConfigurationInput`](crate::input::AddApplicationInputProcessingConfigurationInput)
pub mod add_application_input_processing_configuration_input {
    /// A builder for [`AddApplicationInputProcessingConfigurationInput`](crate::input::AddApplicationInputProcessingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) input_id: std::option::Option<std::string::String>,
        pub(crate) input_processing_configuration:
            std::option::Option<crate::model::InputProcessingConfiguration>,
    }
    impl Builder {
        /// <p>The name of the application to which you want to add the input processing
        /// configuration.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application to which you want to add the input processing
        /// configuration.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The version of the application to which you want to add the input processing
        /// configuration. You can use the <a>DescribeApplication</a> operation to get the
        /// current application version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The version of the application to which you want to add the input processing
        /// configuration. You can use the <a>DescribeApplication</a> operation to get the
        /// current application version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The ID of the input configuration to add the input processing configuration to. You
        /// can get a list of the input IDs for an application using the <a>DescribeApplication</a> operation.</p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_id = Some(input.into());
            self
        }
        /// <p>The ID of the input configuration to add the input processing configuration to. You
        /// can get a list of the input IDs for an application using the <a>DescribeApplication</a> operation.</p>
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_id = input;
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> to add to the application.</p>
        pub fn input_processing_configuration(
            mut self,
            input: crate::model::InputProcessingConfiguration,
        ) -> Self {
            self.input_processing_configuration = Some(input);
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> to add to the application.</p>
        pub fn set_input_processing_configuration(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfiguration>,
        ) -> Self {
            self.input_processing_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AddApplicationInputProcessingConfigurationInput`](crate::input::AddApplicationInputProcessingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddApplicationInputProcessingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::AddApplicationInputProcessingConfigurationInput {
                    application_name: self.application_name,
                    current_application_version_id: self.current_application_version_id,
                    input_id: self.input_id,
                    input_processing_configuration: self.input_processing_configuration,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type AddApplicationInputProcessingConfigurationInputOperationOutputAlias =
    crate::operation::AddApplicationInputProcessingConfiguration;
#[doc(hidden)]
pub type AddApplicationInputProcessingConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl AddApplicationInputProcessingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`AddApplicationInputProcessingConfiguration`](crate::operation::AddApplicationInputProcessingConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddApplicationInputProcessingConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AddApplicationInputProcessingConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AddApplicationInputProcessingConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AddApplicationInputProcessingConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.AddApplicationInputProcessingConfiguration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_add_application_input_processing_configuration(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddApplicationInputProcessingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddApplicationInputProcessingConfiguration",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddApplicationInputProcessingConfigurationInput`](crate::input::AddApplicationInputProcessingConfigurationInput)
    pub fn builder() -> crate::input::add_application_input_processing_configuration_input::Builder
    {
        crate::input::add_application_input_processing_configuration_input::Builder::default()
    }
}

/// See [`AddApplicationOutputInput`](crate::input::AddApplicationOutputInput)
pub mod add_application_output_input {
    /// A builder for [`AddApplicationOutputInput`](crate::input::AddApplicationOutputInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) output: std::option::Option<crate::model::Output>,
    }
    impl Builder {
        /// <p>The name of the application to which you want to add the output configuration.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application to which you want to add the output configuration.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The version of the application to which you want to add the output configuration. You can
        /// use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned. </p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The version of the application to which you want to add the output configuration. You can
        /// use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned. </p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>An array of objects, each describing one output configuration. In the output
        /// configuration, you specify the name of an in-application stream, a destination (that is, a
        /// Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and
        /// record the formation to use when writing to the destination.</p>
        pub fn output(mut self, input: crate::model::Output) -> Self {
            self.output = Some(input);
            self
        }
        /// <p>An array of objects, each describing one output configuration. In the output
        /// configuration, you specify the name of an in-application stream, a destination (that is, a
        /// Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and
        /// record the formation to use when writing to the destination.</p>
        pub fn set_output(mut self, input: std::option::Option<crate::model::Output>) -> Self {
            self.output = input;
            self
        }
        /// Consumes the builder and constructs a [`AddApplicationOutputInput`](crate::input::AddApplicationOutputInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddApplicationOutputInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddApplicationOutputInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                output: self.output,
            })
        }
    }
}
#[doc(hidden)]
pub type AddApplicationOutputInputOperationOutputAlias = crate::operation::AddApplicationOutput;
#[doc(hidden)]
pub type AddApplicationOutputInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddApplicationOutputInput {
    /// Consumes the builder and constructs an Operation<[`AddApplicationOutput`](crate::operation::AddApplicationOutput)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddApplicationOutput,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AddApplicationOutputInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AddApplicationOutputInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AddApplicationOutputInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.AddApplicationOutput",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_add_application_output(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddApplicationOutput::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddApplicationOutput",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddApplicationOutputInput`](crate::input::AddApplicationOutputInput)
    pub fn builder() -> crate::input::add_application_output_input::Builder {
        crate::input::add_application_output_input::Builder::default()
    }
}

/// See [`AddApplicationReferenceDataSourceInput`](crate::input::AddApplicationReferenceDataSourceInput)
pub mod add_application_reference_data_source_input {
    /// A builder for [`AddApplicationReferenceDataSourceInput`](crate::input::AddApplicationReferenceDataSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) reference_data_source: std::option::Option<crate::model::ReferenceDataSource>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The version of the application for which you are adding the reference data source.
        /// You can
        /// use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The version of the application for which you are adding the reference data source.
        /// You can
        /// use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data
        /// into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting
        /// in-application table that is
        /// created. </p>
        pub fn reference_data_source(mut self, input: crate::model::ReferenceDataSource) -> Self {
            self.reference_data_source = Some(input);
            self
        }
        /// <p>The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data
        /// into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting
        /// in-application table that is
        /// created. </p>
        pub fn set_reference_data_source(
            mut self,
            input: std::option::Option<crate::model::ReferenceDataSource>,
        ) -> Self {
            self.reference_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`AddApplicationReferenceDataSourceInput`](crate::input::AddApplicationReferenceDataSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddApplicationReferenceDataSourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddApplicationReferenceDataSourceInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                reference_data_source: self.reference_data_source,
            })
        }
    }
}
#[doc(hidden)]
pub type AddApplicationReferenceDataSourceInputOperationOutputAlias =
    crate::operation::AddApplicationReferenceDataSource;
#[doc(hidden)]
pub type AddApplicationReferenceDataSourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddApplicationReferenceDataSourceInput {
    /// Consumes the builder and constructs an Operation<[`AddApplicationReferenceDataSource`](crate::operation::AddApplicationReferenceDataSource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddApplicationReferenceDataSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AddApplicationReferenceDataSourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AddApplicationReferenceDataSourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AddApplicationReferenceDataSourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.AddApplicationReferenceDataSource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_add_application_reference_data_source(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddApplicationReferenceDataSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddApplicationReferenceDataSource",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddApplicationReferenceDataSourceInput`](crate::input::AddApplicationReferenceDataSourceInput)
    pub fn builder() -> crate::input::add_application_reference_data_source_input::Builder {
        crate::input::add_application_reference_data_source_input::Builder::default()
    }
}

/// See [`AddApplicationVpcConfigurationInput`](crate::input::AddApplicationVpcConfigurationInput)
pub mod add_application_vpc_configuration_input {
    /// A builder for [`AddApplicationVpcConfigurationInput`](crate::input::AddApplicationVpcConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::VpcConfiguration>,
        pub(crate) conditional_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The version of the application to which you want to add the VPC configuration. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// can use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned. For better concurrency support,
        /// use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The version of the application to which you want to add the VPC configuration. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// can use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned. For better concurrency support,
        /// use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>Description of the VPC to add to the application.</p>
        pub fn vpc_configuration(mut self, input: crate::model::VpcConfiguration) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Description of the VPC to add to the application.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::VpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>. You get
        /// the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.conditional_token = Some(input.into());
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>. You get
        /// the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conditional_token = input;
            self
        }
        /// Consumes the builder and constructs a [`AddApplicationVpcConfigurationInput`](crate::input::AddApplicationVpcConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddApplicationVpcConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddApplicationVpcConfigurationInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                vpc_configuration: self.vpc_configuration,
                conditional_token: self.conditional_token,
            })
        }
    }
}
#[doc(hidden)]
pub type AddApplicationVpcConfigurationInputOperationOutputAlias =
    crate::operation::AddApplicationVpcConfiguration;
#[doc(hidden)]
pub type AddApplicationVpcConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddApplicationVpcConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`AddApplicationVpcConfiguration`](crate::operation::AddApplicationVpcConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddApplicationVpcConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AddApplicationVpcConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AddApplicationVpcConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AddApplicationVpcConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.AddApplicationVpcConfiguration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_add_application_vpc_configuration(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddApplicationVpcConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddApplicationVpcConfiguration",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddApplicationVpcConfigurationInput`](crate::input::AddApplicationVpcConfigurationInput)
    pub fn builder() -> crate::input::add_application_vpc_configuration_input::Builder {
        crate::input::add_application_vpc_configuration_input::Builder::default()
    }
}

/// See [`CreateApplicationInput`](crate::input::CreateApplicationInput)
pub mod create_application_input {
    /// A builder for [`CreateApplicationInput`](crate::input::CreateApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) application_description: std::option::Option<std::string::String>,
        pub(crate) runtime_environment: std::option::Option<crate::model::RuntimeEnvironment>,
        pub(crate) service_execution_role: std::option::Option<std::string::String>,
        pub(crate) application_configuration:
            std::option::Option<crate::model::ApplicationConfiguration>,
        pub(crate) cloud_watch_logging_options:
            std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOption>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) application_mode: std::option::Option<crate::model::ApplicationMode>,
    }
    impl Builder {
        /// <p>The name of your application (for example, <code>sample-app</code>).</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of your application (for example, <code>sample-app</code>).</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>A summary description of the application.</p>
        pub fn application_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_description = Some(input.into());
            self
        }
        /// <p>A summary description of the application.</p>
        pub fn set_application_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_description = input;
            self
        }
        /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
        pub fn runtime_environment(mut self, input: crate::model::RuntimeEnvironment) -> Self {
            self.runtime_environment = Some(input);
            self
        }
        /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
        pub fn set_runtime_environment(
            mut self,
            input: std::option::Option<crate::model::RuntimeEnvironment>,
        ) -> Self {
            self.runtime_environment = input;
            self
        }
        /// <p>The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose
        /// delivery streams, Amazon S3 objects, and other external resources.</p>
        pub fn service_execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_execution_role = Some(input.into());
            self
        }
        /// <p>The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose
        /// delivery streams, Amazon S3 objects, and other external resources.</p>
        pub fn set_service_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_execution_role = input;
            self
        }
        /// <p>Use this parameter to configure the application.</p>
        pub fn application_configuration(
            mut self,
            input: crate::model::ApplicationConfiguration,
        ) -> Self {
            self.application_configuration = Some(input);
            self
        }
        /// <p>Use this parameter to configure the application.</p>
        pub fn set_application_configuration(
            mut self,
            input: std::option::Option<crate::model::ApplicationConfiguration>,
        ) -> Self {
            self.application_configuration = input;
            self
        }
        /// Appends an item to `cloud_watch_logging_options`.
        ///
        /// To override the contents of this collection use [`set_cloud_watch_logging_options`](Self::set_cloud_watch_logging_options).
        ///
        /// <p>Use this parameter to configure an Amazon CloudWatch log stream to monitor application
        /// configuration errors.
        /// </p>
        pub fn cloud_watch_logging_options(
            mut self,
            input: impl Into<crate::model::CloudWatchLoggingOption>,
        ) -> Self {
            let mut v = self.cloud_watch_logging_options.unwrap_or_default();
            v.push(input.into());
            self.cloud_watch_logging_options = Some(v);
            self
        }
        /// <p>Use this parameter to configure an Amazon CloudWatch log stream to monitor application
        /// configuration errors.
        /// </p>
        pub fn set_cloud_watch_logging_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOption>>,
        ) -> Self {
            self.cloud_watch_logging_options = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an
        /// application. Note that the maximum number of application tags includes system tags. The maximum number of
        /// user-defined application tags is 50.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an
        /// application. Note that the maximum number of application tags includes system tags. The maximum number of
        /// user-defined application tags is 50.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Use the <code>STREAMING</code> mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the
        /// <code>INTERACTIVE</code> mode.</p>
        pub fn application_mode(mut self, input: crate::model::ApplicationMode) -> Self {
            self.application_mode = Some(input);
            self
        }
        /// <p>Use the <code>STREAMING</code> mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the
        /// <code>INTERACTIVE</code> mode.</p>
        pub fn set_application_mode(
            mut self,
            input: std::option::Option<crate::model::ApplicationMode>,
        ) -> Self {
            self.application_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateApplicationInput`](crate::input::CreateApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateApplicationInput {
                application_name: self.application_name,
                application_description: self.application_description,
                runtime_environment: self.runtime_environment,
                service_execution_role: self.service_execution_role,
                application_configuration: self.application_configuration,
                cloud_watch_logging_options: self.cloud_watch_logging_options,
                tags: self.tags,
                application_mode: self.application_mode,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateApplicationInputOperationOutputAlias = crate::operation::CreateApplication;
#[doc(hidden)]
pub type CreateApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateApplicationInput {
    /// Consumes the builder and constructs an Operation<[`CreateApplication`](crate::operation::CreateApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.CreateApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateApplicationInput`](crate::input::CreateApplicationInput)
    pub fn builder() -> crate::input::create_application_input::Builder {
        crate::input::create_application_input::Builder::default()
    }
}

/// See [`CreateApplicationPresignedUrlInput`](crate::input::CreateApplicationPresignedUrlInput)
pub mod create_application_presigned_url_input {
    /// A builder for [`CreateApplicationPresignedUrlInput`](crate::input::CreateApplicationPresignedUrlInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) url_type: std::option::Option<crate::model::UrlType>,
        pub(crate) session_expiration_duration_in_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The type of the extension for which to create and return a URL. Currently, the only valid
        /// extension URL type is <code>FLINK_DASHBOARD_URL</code>. </p>
        pub fn url_type(mut self, input: crate::model::UrlType) -> Self {
            self.url_type = Some(input);
            self
        }
        /// <p>The type of the extension for which to create and return a URL. Currently, the only valid
        /// extension URL type is <code>FLINK_DASHBOARD_URL</code>. </p>
        pub fn set_url_type(mut self, input: std::option::Option<crate::model::UrlType>) -> Self {
            self.url_type = input;
            self
        }
        /// <p>The duration in seconds for which the returned URL will be valid.</p>
        pub fn session_expiration_duration_in_seconds(mut self, input: i64) -> Self {
            self.session_expiration_duration_in_seconds = Some(input);
            self
        }
        /// <p>The duration in seconds for which the returned URL will be valid.</p>
        pub fn set_session_expiration_duration_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.session_expiration_duration_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateApplicationPresignedUrlInput`](crate::input::CreateApplicationPresignedUrlInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateApplicationPresignedUrlInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateApplicationPresignedUrlInput {
                application_name: self.application_name,
                url_type: self.url_type,
                session_expiration_duration_in_seconds: self.session_expiration_duration_in_seconds,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateApplicationPresignedUrlInputOperationOutputAlias =
    crate::operation::CreateApplicationPresignedUrl;
#[doc(hidden)]
pub type CreateApplicationPresignedUrlInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateApplicationPresignedUrlInput {
    /// Consumes the builder and constructs an Operation<[`CreateApplicationPresignedUrl`](crate::operation::CreateApplicationPresignedUrl)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateApplicationPresignedUrl,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateApplicationPresignedUrlInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateApplicationPresignedUrlInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateApplicationPresignedUrlInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.CreateApplicationPresignedUrl",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_application_presigned_url(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateApplicationPresignedUrl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateApplicationPresignedUrl",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateApplicationPresignedUrlInput`](crate::input::CreateApplicationPresignedUrlInput)
    pub fn builder() -> crate::input::create_application_presigned_url_input::Builder {
        crate::input::create_application_presigned_url_input::Builder::default()
    }
}

/// See [`CreateApplicationSnapshotInput`](crate::input::CreateApplicationSnapshotInput)
pub mod create_application_snapshot_input {
    /// A builder for [`CreateApplicationSnapshotInput`](crate::input::CreateApplicationSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing application</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>An identifier for the application snapshot.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>An identifier for the application snapshot.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateApplicationSnapshotInput`](crate::input::CreateApplicationSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateApplicationSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateApplicationSnapshotInput {
                application_name: self.application_name,
                snapshot_name: self.snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateApplicationSnapshotInputOperationOutputAlias =
    crate::operation::CreateApplicationSnapshot;
#[doc(hidden)]
pub type CreateApplicationSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateApplicationSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateApplicationSnapshot`](crate::operation::CreateApplicationSnapshot)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateApplicationSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateApplicationSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateApplicationSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateApplicationSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.CreateApplicationSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_application_snapshot(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateApplicationSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateApplicationSnapshot",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateApplicationSnapshotInput`](crate::input::CreateApplicationSnapshotInput)
    pub fn builder() -> crate::input::create_application_snapshot_input::Builder {
        crate::input::create_application_snapshot_input::Builder::default()
    }
}

/// See [`DeleteApplicationInput`](crate::input::DeleteApplicationInput)
pub mod delete_application_input {
    /// A builder for [`DeleteApplicationInput`](crate::input::DeleteApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) create_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the application to delete.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application to delete.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>Use the <code>DescribeApplication</code> operation to get this value.</p>
        pub fn create_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_timestamp = Some(input);
            self
        }
        /// <p>Use the <code>DescribeApplication</code> operation to get this value.</p>
        pub fn set_create_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationInput`](crate::input::DeleteApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteApplicationInput {
                application_name: self.application_name,
                create_timestamp: self.create_timestamp,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationInputOperationOutputAlias = crate::operation::DeleteApplication;
#[doc(hidden)]
pub type DeleteApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplication`](crate::operation::DeleteApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationInput`](crate::input::DeleteApplicationInput)
    pub fn builder() -> crate::input::delete_application_input::Builder {
        crate::input::delete_application_input::Builder::default()
    }
}

/// See [`DeleteApplicationCloudWatchLoggingOptionInput`](crate::input::DeleteApplicationCloudWatchLoggingOptionInput)
pub mod delete_application_cloud_watch_logging_option_input {
    /// A builder for [`DeleteApplicationCloudWatchLoggingOptionInput`](crate::input::DeleteApplicationCloudWatchLoggingOptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) cloud_watch_logging_option_id: std::option::Option<std::string::String>,
        pub(crate) conditional_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The application name.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The application name.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The version ID of the application. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The version ID of the application. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The <code>CloudWatchLoggingOptionId</code> of the Amazon CloudWatch logging option to
        /// delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a>DescribeApplication</a> operation. </p>
        pub fn cloud_watch_logging_option_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logging_option_id = Some(input.into());
            self
        }
        /// <p>The <code>CloudWatchLoggingOptionId</code> of the Amazon CloudWatch logging option to
        /// delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a>DescribeApplication</a> operation. </p>
        pub fn set_cloud_watch_logging_option_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logging_option_id = input;
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must provide
        /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
        /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.conditional_token = Some(input.into());
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must provide
        /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
        /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conditional_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationCloudWatchLoggingOptionInput`](crate::input::DeleteApplicationCloudWatchLoggingOptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationCloudWatchLoggingOptionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteApplicationCloudWatchLoggingOptionInput {
                    application_name: self.application_name,
                    current_application_version_id: self.current_application_version_id,
                    cloud_watch_logging_option_id: self.cloud_watch_logging_option_id,
                    conditional_token: self.conditional_token,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationCloudWatchLoggingOptionInputOperationOutputAlias =
    crate::operation::DeleteApplicationCloudWatchLoggingOption;
#[doc(hidden)]
pub type DeleteApplicationCloudWatchLoggingOptionInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationCloudWatchLoggingOptionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplicationCloudWatchLoggingOption`](crate::operation::DeleteApplicationCloudWatchLoggingOption)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplicationCloudWatchLoggingOption,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationCloudWatchLoggingOptionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationCloudWatchLoggingOptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationCloudWatchLoggingOptionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplicationCloudWatchLoggingOption",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application_cloud_watch_logging_option(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplicationCloudWatchLoggingOption::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplicationCloudWatchLoggingOption",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationCloudWatchLoggingOptionInput`](crate::input::DeleteApplicationCloudWatchLoggingOptionInput)
    pub fn builder() -> crate::input::delete_application_cloud_watch_logging_option_input::Builder {
        crate::input::delete_application_cloud_watch_logging_option_input::Builder::default()
    }
}

/// See [`DeleteApplicationInputProcessingConfigurationInput`](crate::input::DeleteApplicationInputProcessingConfigurationInput)
pub mod delete_application_input_processing_configuration_input {
    /// A builder for [`DeleteApplicationInputProcessingConfigurationInput`](crate::input::DeleteApplicationInputProcessingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) input_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The application version.
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.
        /// </p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The application version.
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.
        /// </p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The ID of the input configuration from which to delete the input processing
        /// configuration. You can get a list of the input IDs for an application by using the <a>DescribeApplication</a> operation.</p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_id = Some(input.into());
            self
        }
        /// <p>The ID of the input configuration from which to delete the input processing
        /// configuration. You can get a list of the input IDs for an application by using the <a>DescribeApplication</a> operation.</p>
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationInputProcessingConfigurationInput`](crate::input::DeleteApplicationInputProcessingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationInputProcessingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteApplicationInputProcessingConfigurationInput {
                    application_name: self.application_name,
                    current_application_version_id: self.current_application_version_id,
                    input_id: self.input_id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationInputProcessingConfigurationInputOperationOutputAlias =
    crate::operation::DeleteApplicationInputProcessingConfiguration;
#[doc(hidden)]
pub type DeleteApplicationInputProcessingConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationInputProcessingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplicationInputProcessingConfiguration`](crate::operation::DeleteApplicationInputProcessingConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplicationInputProcessingConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationInputProcessingConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationInputProcessingConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationInputProcessingConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplicationInputProcessingConfiguration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application_input_processing_configuration(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplicationInputProcessingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplicationInputProcessingConfiguration",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationInputProcessingConfigurationInput`](crate::input::DeleteApplicationInputProcessingConfigurationInput)
    pub fn builder(
    ) -> crate::input::delete_application_input_processing_configuration_input::Builder {
        crate::input::delete_application_input_processing_configuration_input::Builder::default()
    }
}

/// See [`DeleteApplicationOutputInput`](crate::input::DeleteApplicationOutputInput)
pub mod delete_application_output_input {
    /// A builder for [`DeleteApplicationOutputInput`](crate::input::DeleteApplicationOutputInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) output_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The application name.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The application name.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The application version.
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.
        /// </p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The application version.
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.
        /// </p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The ID of the configuration to delete. Each output configuration that is added to the
        /// application (either when the application is created or later) using the <a>AddApplicationOutput</a> operation has a unique ID. You need to provide the ID to
        /// uniquely identify the output configuration that you want to delete from the application
        /// configuration. You can use the <a>DescribeApplication</a> operation to get the
        /// specific <code>OutputId</code>. </p>
        pub fn output_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_id = Some(input.into());
            self
        }
        /// <p>The ID of the configuration to delete. Each output configuration that is added to the
        /// application (either when the application is created or later) using the <a>AddApplicationOutput</a> operation has a unique ID. You need to provide the ID to
        /// uniquely identify the output configuration that you want to delete from the application
        /// configuration. You can use the <a>DescribeApplication</a> operation to get the
        /// specific <code>OutputId</code>. </p>
        pub fn set_output_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationOutputInput`](crate::input::DeleteApplicationOutputInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationOutputInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteApplicationOutputInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                output_id: self.output_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationOutputInputOperationOutputAlias =
    crate::operation::DeleteApplicationOutput;
#[doc(hidden)]
pub type DeleteApplicationOutputInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationOutputInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplicationOutput`](crate::operation::DeleteApplicationOutput)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplicationOutput,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationOutputInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationOutputInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationOutputInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplicationOutput",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application_output(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplicationOutput::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplicationOutput",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationOutputInput`](crate::input::DeleteApplicationOutputInput)
    pub fn builder() -> crate::input::delete_application_output_input::Builder {
        crate::input::delete_application_output_input::Builder::default()
    }
}

/// See [`DeleteApplicationReferenceDataSourceInput`](crate::input::DeleteApplicationReferenceDataSourceInput)
pub mod delete_application_reference_data_source_input {
    /// A builder for [`DeleteApplicationReferenceDataSourceInput`](crate::input::DeleteApplicationReferenceDataSourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) reference_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The current application version.  
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified
        /// is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The current application version.  
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified
        /// is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The ID of the reference data source. When you add a reference data source to your
        /// application using the <a>AddApplicationReferenceDataSource</a>, Kinesis Data Analytics assigns an ID.
        /// You can use the <a>DescribeApplication</a> operation to
        /// get the reference ID. </p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The ID of the reference data source. When you add a reference data source to your
        /// application using the <a>AddApplicationReferenceDataSource</a>, Kinesis Data Analytics assigns an ID.
        /// You can use the <a>DescribeApplication</a> operation to
        /// get the reference ID. </p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationReferenceDataSourceInput`](crate::input::DeleteApplicationReferenceDataSourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationReferenceDataSourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteApplicationReferenceDataSourceInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                reference_id: self.reference_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationReferenceDataSourceInputOperationOutputAlias =
    crate::operation::DeleteApplicationReferenceDataSource;
#[doc(hidden)]
pub type DeleteApplicationReferenceDataSourceInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationReferenceDataSourceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplicationReferenceDataSource`](crate::operation::DeleteApplicationReferenceDataSource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplicationReferenceDataSource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationReferenceDataSourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationReferenceDataSourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationReferenceDataSourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplicationReferenceDataSource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application_reference_data_source(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplicationReferenceDataSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplicationReferenceDataSource",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationReferenceDataSourceInput`](crate::input::DeleteApplicationReferenceDataSourceInput)
    pub fn builder() -> crate::input::delete_application_reference_data_source_input::Builder {
        crate::input::delete_application_reference_data_source_input::Builder::default()
    }
}

/// See [`DeleteApplicationSnapshotInput`](crate::input::DeleteApplicationSnapshotInput)
pub mod delete_application_snapshot_input {
    /// A builder for [`DeleteApplicationSnapshotInput`](crate::input::DeleteApplicationSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The identifier for the snapshot delete.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The identifier for the snapshot delete.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// <p>The creation timestamp of the application snapshot to delete. You can retrieve this value
        /// using
        /// or .</p>
        pub fn snapshot_creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_creation_timestamp = Some(input);
            self
        }
        /// <p>The creation timestamp of the application snapshot to delete. You can retrieve this value
        /// using
        /// or .</p>
        pub fn set_snapshot_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_creation_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationSnapshotInput`](crate::input::DeleteApplicationSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteApplicationSnapshotInput {
                application_name: self.application_name,
                snapshot_name: self.snapshot_name,
                snapshot_creation_timestamp: self.snapshot_creation_timestamp,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationSnapshotInputOperationOutputAlias =
    crate::operation::DeleteApplicationSnapshot;
#[doc(hidden)]
pub type DeleteApplicationSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplicationSnapshot`](crate::operation::DeleteApplicationSnapshot)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplicationSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplicationSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application_snapshot(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplicationSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplicationSnapshot",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationSnapshotInput`](crate::input::DeleteApplicationSnapshotInput)
    pub fn builder() -> crate::input::delete_application_snapshot_input::Builder {
        crate::input::delete_application_snapshot_input::Builder::default()
    }
}

/// See [`DeleteApplicationVpcConfigurationInput`](crate::input::DeleteApplicationVpcConfigurationInput)
pub mod delete_application_vpc_configuration_input {
    /// A builder for [`DeleteApplicationVpcConfigurationInput`](crate::input::DeleteApplicationVpcConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) vpc_configuration_id: std::option::Option<std::string::String>,
        pub(crate) conditional_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The current application version ID. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The current application version ID. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>The ID of the VPC configuration to delete.</p>
        pub fn vpc_configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_configuration_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC configuration to delete.</p>
        pub fn set_vpc_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_configuration_id = input;
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must provide
        /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
        /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.conditional_token = Some(input.into());
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must provide
        /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
        /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conditional_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteApplicationVpcConfigurationInput`](crate::input::DeleteApplicationVpcConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteApplicationVpcConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteApplicationVpcConfigurationInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                vpc_configuration_id: self.vpc_configuration_id,
                conditional_token: self.conditional_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteApplicationVpcConfigurationInputOperationOutputAlias =
    crate::operation::DeleteApplicationVpcConfiguration;
#[doc(hidden)]
pub type DeleteApplicationVpcConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteApplicationVpcConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteApplicationVpcConfiguration`](crate::operation::DeleteApplicationVpcConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteApplicationVpcConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteApplicationVpcConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteApplicationVpcConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteApplicationVpcConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DeleteApplicationVpcConfiguration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_application_vpc_configuration(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteApplicationVpcConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteApplicationVpcConfiguration",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteApplicationVpcConfigurationInput`](crate::input::DeleteApplicationVpcConfigurationInput)
    pub fn builder() -> crate::input::delete_application_vpc_configuration_input::Builder {
        crate::input::delete_application_vpc_configuration_input::Builder::default()
    }
}

/// See [`DescribeApplicationInput`](crate::input::DescribeApplicationInput)
pub mod describe_application_input {
    /// A builder for [`DescribeApplicationInput`](crate::input::DescribeApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) include_additional_details: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.</p>
        pub fn include_additional_details(mut self, input: bool) -> Self {
            self.include_additional_details = Some(input);
            self
        }
        /// <p>Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.</p>
        pub fn set_include_additional_details(mut self, input: std::option::Option<bool>) -> Self {
            self.include_additional_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeApplicationInput`](crate::input::DescribeApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeApplicationInput {
                application_name: self.application_name,
                include_additional_details: self.include_additional_details,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeApplicationInputOperationOutputAlias = crate::operation::DescribeApplication;
#[doc(hidden)]
pub type DescribeApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeApplicationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeApplication`](crate::operation::DescribeApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DescribeApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeApplicationInput`](crate::input::DescribeApplicationInput)
    pub fn builder() -> crate::input::describe_application_input::Builder {
        crate::input::describe_application_input::Builder::default()
    }
}

/// See [`DescribeApplicationSnapshotInput`](crate::input::DescribeApplicationSnapshotInput)
pub mod describe_application_snapshot_input {
    /// A builder for [`DescribeApplicationSnapshotInput`](crate::input::DescribeApplicationSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The identifier of an application snapshot. You can retrieve this value using
        /// .</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The identifier of an application snapshot. You can retrieve this value using
        /// .</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeApplicationSnapshotInput`](crate::input::DescribeApplicationSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeApplicationSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeApplicationSnapshotInput {
                application_name: self.application_name,
                snapshot_name: self.snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeApplicationSnapshotInputOperationOutputAlias =
    crate::operation::DescribeApplicationSnapshot;
#[doc(hidden)]
pub type DescribeApplicationSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeApplicationSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`DescribeApplicationSnapshot`](crate::operation::DescribeApplicationSnapshot)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeApplicationSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeApplicationSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeApplicationSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeApplicationSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DescribeApplicationSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_application_snapshot(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeApplicationSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeApplicationSnapshot",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeApplicationSnapshotInput`](crate::input::DescribeApplicationSnapshotInput)
    pub fn builder() -> crate::input::describe_application_snapshot_input::Builder {
        crate::input::describe_application_snapshot_input::Builder::default()
    }
}

/// See [`DescribeApplicationVersionInput`](crate::input::DescribeApplicationVersionInput)
pub mod describe_application_version_input {
    /// A builder for [`DescribeApplicationVersionInput`](crate::input::DescribeApplicationVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) application_version_id: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the application for which you want to get the version description.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application for which you want to get the version description.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The ID of the application version for which you want to get the description.</p>
        pub fn application_version_id(mut self, input: i64) -> Self {
            self.application_version_id = Some(input);
            self
        }
        /// <p>The ID of the application version for which you want to get the description.</p>
        pub fn set_application_version_id(mut self, input: std::option::Option<i64>) -> Self {
            self.application_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeApplicationVersionInput`](crate::input::DescribeApplicationVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeApplicationVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeApplicationVersionInput {
                application_name: self.application_name,
                application_version_id: self.application_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeApplicationVersionInputOperationOutputAlias =
    crate::operation::DescribeApplicationVersion;
#[doc(hidden)]
pub type DescribeApplicationVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeApplicationVersionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeApplicationVersion`](crate::operation::DescribeApplicationVersion)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeApplicationVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeApplicationVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeApplicationVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeApplicationVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DescribeApplicationVersion",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_application_version(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeApplicationVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeApplicationVersion",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeApplicationVersionInput`](crate::input::DescribeApplicationVersionInput)
    pub fn builder() -> crate::input::describe_application_version_input::Builder {
        crate::input::describe_application_version_input::Builder::default()
    }
}

/// See [`DiscoverInputSchemaInput`](crate::input::DiscoverInputSchemaInput)
pub mod discover_input_schema_input {
    /// A builder for [`DiscoverInputSchemaInput`](crate::input::DiscoverInputSchemaInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) service_execution_role: std::option::Option<std::string::String>,
        pub(crate) input_starting_position_configuration:
            std::option::Option<crate::model::InputStartingPositionConfiguration>,
        pub(crate) s3_configuration: std::option::Option<crate::model::S3Configuration>,
        pub(crate) input_processing_configuration:
            std::option::Option<crate::model::InputProcessingConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the streaming source.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the streaming source.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the role that is used to access the streaming source.</p>
        pub fn service_execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_execution_role = Some(input.into());
            self
        }
        /// <p>The ARN of the role that is used to access the streaming source.</p>
        pub fn set_service_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_execution_role = input;
            self
        }
        /// <p>The point at which you want Kinesis Data Analytics to start reading records from the
        /// specified streaming source discovery purposes.</p>
        pub fn input_starting_position_configuration(
            mut self,
            input: crate::model::InputStartingPositionConfiguration,
        ) -> Self {
            self.input_starting_position_configuration = Some(input);
            self
        }
        /// <p>The point at which you want Kinesis Data Analytics to start reading records from the
        /// specified streaming source discovery purposes.</p>
        pub fn set_input_starting_position_configuration(
            mut self,
            input: std::option::Option<crate::model::InputStartingPositionConfiguration>,
        ) -> Self {
            self.input_starting_position_configuration = input;
            self
        }
        /// <p>Specify this parameter to discover a schema from data in an Amazon S3
        /// object.</p>
        pub fn s3_configuration(mut self, input: crate::model::S3Configuration) -> Self {
            self.s3_configuration = Some(input);
            self
        }
        /// <p>Specify this parameter to discover a schema from data in an Amazon S3
        /// object.</p>
        pub fn set_s3_configuration(
            mut self,
            input: std::option::Option<crate::model::S3Configuration>,
        ) -> Self {
            self.s3_configuration = input;
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> to use to preprocess the records
        /// before discovering the schema of the records.</p>
        pub fn input_processing_configuration(
            mut self,
            input: crate::model::InputProcessingConfiguration,
        ) -> Self {
            self.input_processing_configuration = Some(input);
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> to use to preprocess the records
        /// before discovering the schema of the records.</p>
        pub fn set_input_processing_configuration(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfiguration>,
        ) -> Self {
            self.input_processing_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DiscoverInputSchemaInput`](crate::input::DiscoverInputSchemaInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DiscoverInputSchemaInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DiscoverInputSchemaInput {
                resource_arn: self.resource_arn,
                service_execution_role: self.service_execution_role,
                input_starting_position_configuration: self.input_starting_position_configuration,
                s3_configuration: self.s3_configuration,
                input_processing_configuration: self.input_processing_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type DiscoverInputSchemaInputOperationOutputAlias = crate::operation::DiscoverInputSchema;
#[doc(hidden)]
pub type DiscoverInputSchemaInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DiscoverInputSchemaInput {
    /// Consumes the builder and constructs an Operation<[`DiscoverInputSchema`](crate::operation::DiscoverInputSchema)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DiscoverInputSchema,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DiscoverInputSchemaInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DiscoverInputSchemaInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DiscoverInputSchemaInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.DiscoverInputSchema",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_discover_input_schema(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DiscoverInputSchema::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DiscoverInputSchema",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DiscoverInputSchemaInput`](crate::input::DiscoverInputSchemaInput)
    pub fn builder() -> crate::input::discover_input_schema_input::Builder {
        crate::input::discover_input_schema_input::Builder::default()
    }
}

/// See [`ListApplicationsInput`](crate::input::ListApplicationsInput)
pub mod list_applications_input {
    /// A builder for [`ListApplicationsInput`](crate::input::ListApplicationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of applications to list.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The maximum number of applications to list.</p>
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>If a previous command returned a pagination token,
        /// pass it into this value to retrieve the next set of results.
        /// For more information about pagination, see
        /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If a previous command returned a pagination token,
        /// pass it into this value to retrieve the next set of results.
        /// For more information about pagination, see
        /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListApplicationsInput`](crate::input::ListApplicationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListApplicationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListApplicationsInput {
                limit: self.limit,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListApplicationsInputOperationOutputAlias = crate::operation::ListApplications;
#[doc(hidden)]
pub type ListApplicationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListApplicationsInput {
    /// Consumes the builder and constructs an Operation<[`ListApplications`](crate::operation::ListApplications)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListApplications,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListApplicationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListApplicationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListApplicationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.ListApplications",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_applications(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListApplications::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListApplications",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListApplicationsInput`](crate::input::ListApplicationsInput)
    pub fn builder() -> crate::input::list_applications_input::Builder {
        crate::input::list_applications_input::Builder::default()
    }
}

/// See [`ListApplicationSnapshotsInput`](crate::input::ListApplicationSnapshotsInput)
pub mod list_application_snapshots_input {
    /// A builder for [`ListApplicationSnapshotsInput`](crate::input::ListApplicationSnapshotsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of an existing application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The maximum number of application snapshots to list.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The maximum number of application snapshots to list.</p>
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>Use this parameter if you receive a <code>NextToken</code> response in a previous request that indicates that there is more
        /// output available. Set it to the value of the previous call's <code>NextToken</code> response to indicate where the output should
        /// continue from. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Use this parameter if you receive a <code>NextToken</code> response in a previous request that indicates that there is more
        /// output available. Set it to the value of the previous call's <code>NextToken</code> response to indicate where the output should
        /// continue from. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListApplicationSnapshotsInput`](crate::input::ListApplicationSnapshotsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListApplicationSnapshotsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListApplicationSnapshotsInput {
                application_name: self.application_name,
                limit: self.limit,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListApplicationSnapshotsInputOperationOutputAlias =
    crate::operation::ListApplicationSnapshots;
#[doc(hidden)]
pub type ListApplicationSnapshotsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListApplicationSnapshotsInput {
    /// Consumes the builder and constructs an Operation<[`ListApplicationSnapshots`](crate::operation::ListApplicationSnapshots)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListApplicationSnapshots,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListApplicationSnapshotsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListApplicationSnapshotsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListApplicationSnapshotsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.ListApplicationSnapshots",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_application_snapshots(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListApplicationSnapshots::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListApplicationSnapshots",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListApplicationSnapshotsInput`](crate::input::ListApplicationSnapshotsInput)
    pub fn builder() -> crate::input::list_application_snapshots_input::Builder {
        crate::input::list_application_snapshots_input::Builder::default()
    }
}

/// See [`ListApplicationVersionsInput`](crate::input::ListApplicationVersionsInput)
pub mod list_application_versions_input {
    /// A builder for [`ListApplicationVersionsInput`](crate::input::ListApplicationVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the application for which you want to list all versions.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application for which you want to list all versions.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The maximum number of versions to list in this invocation of the operation.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The maximum number of versions to list in this invocation of the operation.</p>
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see
        /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see
        /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListApplicationVersionsInput`](crate::input::ListApplicationVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListApplicationVersionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListApplicationVersionsInput {
                application_name: self.application_name,
                limit: self.limit,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListApplicationVersionsInputOperationOutputAlias =
    crate::operation::ListApplicationVersions;
#[doc(hidden)]
pub type ListApplicationVersionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListApplicationVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListApplicationVersions`](crate::operation::ListApplicationVersions)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListApplicationVersions,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListApplicationVersionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListApplicationVersionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListApplicationVersionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.ListApplicationVersions",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_application_versions(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListApplicationVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListApplicationVersions",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListApplicationVersionsInput`](crate::input::ListApplicationVersionsInput)
    pub fn builder() -> crate::input::list_application_versions_input::Builder {
        crate::input::list_application_versions_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the application for which to retrieve tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application for which to retrieve tags.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.ListTagsForResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_tags_for_resource(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`RollbackApplicationInput`](crate::input::RollbackApplicationInput)
pub mod rollback_application_input {
    /// A builder for [`RollbackApplicationInput`](crate::input::RollbackApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The current application version ID. You can retrieve the application version ID using
        /// <a>DescribeApplication</a>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The current application version ID. You can retrieve the application version ID using
        /// <a>DescribeApplication</a>.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RollbackApplicationInput`](crate::input::RollbackApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RollbackApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RollbackApplicationInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RollbackApplicationInputOperationOutputAlias = crate::operation::RollbackApplication;
#[doc(hidden)]
pub type RollbackApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RollbackApplicationInput {
    /// Consumes the builder and constructs an Operation<[`RollbackApplication`](crate::operation::RollbackApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RollbackApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RollbackApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RollbackApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RollbackApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.RollbackApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_rollback_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RollbackApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RollbackApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RollbackApplicationInput`](crate::input::RollbackApplicationInput)
    pub fn builder() -> crate::input::rollback_application_input::Builder {
        crate::input::rollback_application_input::Builder::default()
    }
}

/// See [`StartApplicationInput`](crate::input::StartApplicationInput)
pub mod start_application_input {
    /// A builder for [`StartApplicationInput`](crate::input::StartApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) run_configuration: std::option::Option<crate::model::RunConfiguration>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.</p>
        pub fn run_configuration(mut self, input: crate::model::RunConfiguration) -> Self {
            self.run_configuration = Some(input);
            self
        }
        /// <p>Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.</p>
        pub fn set_run_configuration(
            mut self,
            input: std::option::Option<crate::model::RunConfiguration>,
        ) -> Self {
            self.run_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`StartApplicationInput`](crate::input::StartApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartApplicationInput {
                application_name: self.application_name,
                run_configuration: self.run_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type StartApplicationInputOperationOutputAlias = crate::operation::StartApplication;
#[doc(hidden)]
pub type StartApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartApplicationInput {
    /// Consumes the builder and constructs an Operation<[`StartApplication`](crate::operation::StartApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.StartApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartApplicationInput`](crate::input::StartApplicationInput)
    pub fn builder() -> crate::input::start_application_input::Builder {
        crate::input::start_application_input::Builder::default()
    }
}

/// See [`StopApplicationInput`](crate::input::StopApplicationInput)
pub mod stop_application_input {
    /// A builder for [`StopApplicationInput`](crate::input::StopApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the running application to stop.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the running application to stop.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>Set to <code>true</code> to force the application to stop. If you set <code>Force</code>
        /// to <code>true</code>, Kinesis Data Analytics stops the application without taking a snapshot.
        /// </p>
        /// <note>
        /// <p>Force-stopping your application may lead to data loss or duplication.
        /// To prevent data loss or duplicate processing of data during application restarts,
        /// we recommend you to take frequent snapshots of your application.</p>
        /// </note>
        /// <p>You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application.</p>
        /// <p>The application must be in the
        /// <code>STARTING</code>, <code>UPDATING</code>, <code>STOPPING</code>, <code>AUTOSCALING</code>, or
        /// <code>RUNNING</code> status. </p>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>Set to <code>true</code> to force the application to stop. If you set <code>Force</code>
        /// to <code>true</code>, Kinesis Data Analytics stops the application without taking a snapshot.
        /// </p>
        /// <note>
        /// <p>Force-stopping your application may lead to data loss or duplication.
        /// To prevent data loss or duplicate processing of data during application restarts,
        /// we recommend you to take frequent snapshots of your application.</p>
        /// </note>
        /// <p>You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application.</p>
        /// <p>The application must be in the
        /// <code>STARTING</code>, <code>UPDATING</code>, <code>STOPPING</code>, <code>AUTOSCALING</code>, or
        /// <code>RUNNING</code> status. </p>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// Consumes the builder and constructs a [`StopApplicationInput`](crate::input::StopApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopApplicationInput {
                application_name: self.application_name,
                force: self.force,
            })
        }
    }
}
#[doc(hidden)]
pub type StopApplicationInputOperationOutputAlias = crate::operation::StopApplication;
#[doc(hidden)]
pub type StopApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopApplicationInput {
    /// Consumes the builder and constructs an Operation<[`StopApplication`](crate::operation::StopApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.StopApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_stop_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopApplicationInput`](crate::input::StopApplicationInput)
    pub fn builder() -> crate::input::stop_application_input::Builder {
        crate::input::stop_application_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the application to assign the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application to assign the tags.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The key-value tags to assign to the application.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The key-value tags to assign to the application.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.TagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the Kinesis Data Analytics application from which to remove the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Kinesis Data Analytics application from which to remove the tags.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of keys of tags to remove from the specified application.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>A list of keys of tags to remove from the specified application.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.UntagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateApplicationInput`](crate::input::UpdateApplicationInput)
pub mod update_application_input {
    /// A builder for [`UpdateApplicationInput`](crate::input::UpdateApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) current_application_version_id: std::option::Option<i64>,
        pub(crate) application_configuration_update:
            std::option::Option<crate::model::ApplicationConfigurationUpdate>,
        pub(crate) service_execution_role_update: std::option::Option<std::string::String>,
        pub(crate) run_configuration_update:
            std::option::Option<crate::model::RunConfigurationUpdate>,
        pub(crate) cloud_watch_logging_option_updates:
            std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOptionUpdate>>,
        pub(crate) conditional_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the application to update.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application to update.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The current application version ID. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.current_application_version_id = Some(input);
            self
        }
        /// <p>The current application version ID. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.current_application_version_id = input;
            self
        }
        /// <p>Describes application configuration updates.</p>
        pub fn application_configuration_update(
            mut self,
            input: crate::model::ApplicationConfigurationUpdate,
        ) -> Self {
            self.application_configuration_update = Some(input);
            self
        }
        /// <p>Describes application configuration updates.</p>
        pub fn set_application_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ApplicationConfigurationUpdate>,
        ) -> Self {
            self.application_configuration_update = input;
            self
        }
        /// <p>Describes updates to the service execution role.</p>
        pub fn service_execution_role_update(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.service_execution_role_update = Some(input.into());
            self
        }
        /// <p>Describes updates to the service execution role.</p>
        pub fn set_service_execution_role_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_execution_role_update = input;
            self
        }
        /// <p>Describes updates to the application's starting parameters.</p>
        pub fn run_configuration_update(
            mut self,
            input: crate::model::RunConfigurationUpdate,
        ) -> Self {
            self.run_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to the application's starting parameters.</p>
        pub fn set_run_configuration_update(
            mut self,
            input: std::option::Option<crate::model::RunConfigurationUpdate>,
        ) -> Self {
            self.run_configuration_update = input;
            self
        }
        /// Appends an item to `cloud_watch_logging_option_updates`.
        ///
        /// To override the contents of this collection use [`set_cloud_watch_logging_option_updates`](Self::set_cloud_watch_logging_option_updates).
        ///
        /// <p>Describes application Amazon CloudWatch logging option updates. You can only update
        /// existing CloudWatch logging options with this action. To add a new CloudWatch logging option,
        /// use <a>AddApplicationCloudWatchLoggingOption</a>.</p>
        pub fn cloud_watch_logging_option_updates(
            mut self,
            input: impl Into<crate::model::CloudWatchLoggingOptionUpdate>,
        ) -> Self {
            let mut v = self.cloud_watch_logging_option_updates.unwrap_or_default();
            v.push(input.into());
            self.cloud_watch_logging_option_updates = Some(v);
            self
        }
        /// <p>Describes application Amazon CloudWatch logging option updates. You can only update
        /// existing CloudWatch logging options with this action. To add a new CloudWatch logging option,
        /// use <a>AddApplicationCloudWatchLoggingOption</a>.</p>
        pub fn set_cloud_watch_logging_option_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOptionUpdate>>,
        ) -> Self {
            self.cloud_watch_logging_option_updates = input;
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.conditional_token = Some(input.into());
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conditional_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateApplicationInput`](crate::input::UpdateApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateApplicationInput {
                application_name: self.application_name,
                current_application_version_id: self.current_application_version_id,
                application_configuration_update: self.application_configuration_update,
                service_execution_role_update: self.service_execution_role_update,
                run_configuration_update: self.run_configuration_update,
                cloud_watch_logging_option_updates: self.cloud_watch_logging_option_updates,
                conditional_token: self.conditional_token,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateApplicationInputOperationOutputAlias = crate::operation::UpdateApplication;
#[doc(hidden)]
pub type UpdateApplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateApplicationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateApplication`](crate::operation::UpdateApplication)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateApplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateApplicationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateApplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateApplicationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.UpdateApplication",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_application(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateApplication",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateApplicationInput`](crate::input::UpdateApplicationInput)
    pub fn builder() -> crate::input::update_application_input::Builder {
        crate::input::update_application_input::Builder::default()
    }
}

/// See [`UpdateApplicationMaintenanceConfigurationInput`](crate::input::UpdateApplicationMaintenanceConfigurationInput)
pub mod update_application_maintenance_configuration_input {
    /// A builder for [`UpdateApplicationMaintenanceConfigurationInput`](crate::input::UpdateApplicationMaintenanceConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) application_maintenance_configuration_update:
            std::option::Option<crate::model::ApplicationMaintenanceConfigurationUpdate>,
    }
    impl Builder {
        /// <p>The name of the application for which you want to update the maintenance configuration.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application for which you want to update the maintenance configuration.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>Describes the application maintenance configuration update.</p>
        pub fn application_maintenance_configuration_update(
            mut self,
            input: crate::model::ApplicationMaintenanceConfigurationUpdate,
        ) -> Self {
            self.application_maintenance_configuration_update = Some(input);
            self
        }
        /// <p>Describes the application maintenance configuration update.</p>
        pub fn set_application_maintenance_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ApplicationMaintenanceConfigurationUpdate>,
        ) -> Self {
            self.application_maintenance_configuration_update = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateApplicationMaintenanceConfigurationInput`](crate::input::UpdateApplicationMaintenanceConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateApplicationMaintenanceConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::UpdateApplicationMaintenanceConfigurationInput {
                    application_name: self.application_name,
                    application_maintenance_configuration_update: self
                        .application_maintenance_configuration_update,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type UpdateApplicationMaintenanceConfigurationInputOperationOutputAlias =
    crate::operation::UpdateApplicationMaintenanceConfiguration;
#[doc(hidden)]
pub type UpdateApplicationMaintenanceConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl UpdateApplicationMaintenanceConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateApplicationMaintenanceConfiguration`](crate::operation::UpdateApplicationMaintenanceConfiguration)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateApplicationMaintenanceConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateApplicationMaintenanceConfigurationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateApplicationMaintenanceConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateApplicationMaintenanceConfigurationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "KinesisAnalytics_20180523.UpdateApplicationMaintenanceConfiguration",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_application_maintenance_configuration(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateApplicationMaintenanceConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateApplicationMaintenanceConfiguration",
            "kinesisanalyticsv2",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateApplicationMaintenanceConfigurationInput`](crate::input::UpdateApplicationMaintenanceConfigurationInput)
    pub fn builder() -> crate::input::update_application_maintenance_configuration_input::Builder {
        crate::input::update_application_maintenance_configuration_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateApplicationMaintenanceConfigurationInput {
    /// <p>The name of the application for which you want to update the maintenance configuration.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>Describes the application maintenance configuration update.</p>
    pub application_maintenance_configuration_update:
        std::option::Option<crate::model::ApplicationMaintenanceConfigurationUpdate>,
}
impl UpdateApplicationMaintenanceConfigurationInput {
    /// <p>The name of the application for which you want to update the maintenance configuration.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>Describes the application maintenance configuration update.</p>
    pub fn application_maintenance_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationMaintenanceConfigurationUpdate> {
        self.application_maintenance_configuration_update.as_ref()
    }
}
impl std::fmt::Debug for UpdateApplicationMaintenanceConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateApplicationMaintenanceConfigurationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "application_maintenance_configuration_update",
            &self.application_maintenance_configuration_update,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateApplicationInput {
    /// <p>The name of the application to update.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The current application version ID. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>Describes application configuration updates.</p>
    pub application_configuration_update:
        std::option::Option<crate::model::ApplicationConfigurationUpdate>,
    /// <p>Describes updates to the service execution role.</p>
    pub service_execution_role_update: std::option::Option<std::string::String>,
    /// <p>Describes updates to the application's starting parameters.</p>
    pub run_configuration_update: std::option::Option<crate::model::RunConfigurationUpdate>,
    /// <p>Describes application Amazon CloudWatch logging option updates. You can only update
    /// existing CloudWatch logging options with this action. To add a new CloudWatch logging option,
    /// use <a>AddApplicationCloudWatchLoggingOption</a>.</p>
    pub cloud_watch_logging_option_updates:
        std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOptionUpdate>>,
    /// <p>A value you use to implement strong concurrency for application updates. You must
    /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    /// <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub conditional_token: std::option::Option<std::string::String>,
}
impl UpdateApplicationInput {
    /// <p>The name of the application to update.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The current application version ID. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>Describes application configuration updates.</p>
    pub fn application_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationConfigurationUpdate> {
        self.application_configuration_update.as_ref()
    }
    /// <p>Describes updates to the service execution role.</p>
    pub fn service_execution_role_update(&self) -> std::option::Option<&str> {
        self.service_execution_role_update.as_deref()
    }
    /// <p>Describes updates to the application's starting parameters.</p>
    pub fn run_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::RunConfigurationUpdate> {
        self.run_configuration_update.as_ref()
    }
    /// <p>Describes application Amazon CloudWatch logging option updates. You can only update
    /// existing CloudWatch logging options with this action. To add a new CloudWatch logging option,
    /// use <a>AddApplicationCloudWatchLoggingOption</a>.</p>
    pub fn cloud_watch_logging_option_updates(
        &self,
    ) -> std::option::Option<&[crate::model::CloudWatchLoggingOptionUpdate]> {
        self.cloud_watch_logging_option_updates.as_deref()
    }
    /// <p>A value you use to implement strong concurrency for application updates. You must
    /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    /// <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn conditional_token(&self) -> std::option::Option<&str> {
        self.conditional_token.as_deref()
    }
}
impl std::fmt::Debug for UpdateApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field(
            "application_configuration_update",
            &self.application_configuration_update,
        );
        formatter.field(
            "service_execution_role_update",
            &self.service_execution_role_update,
        );
        formatter.field("run_configuration_update", &self.run_configuration_update);
        formatter.field(
            "cloud_watch_logging_option_updates",
            &self.cloud_watch_logging_option_updates,
        );
        formatter.field("conditional_token", &self.conditional_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The ARN of the Kinesis Data Analytics application from which to remove the tags.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of keys of tags to remove from the specified application.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The ARN of the Kinesis Data Analytics application from which to remove the tags.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of keys of tags to remove from the specified application.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The ARN of the application to assign the tags.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The key-value tags to assign to the application.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The ARN of the application to assign the tags.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The key-value tags to assign to the application.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopApplicationInput {
    /// <p>The name of the running application to stop.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>Set to <code>true</code> to force the application to stop. If you set <code>Force</code>
    /// to <code>true</code>, Kinesis Data Analytics stops the application without taking a snapshot.
    /// </p>
    /// <note>
    /// <p>Force-stopping your application may lead to data loss or duplication.
    /// To prevent data loss or duplicate processing of data during application restarts,
    /// we recommend you to take frequent snapshots of your application.</p>
    /// </note>
    /// <p>You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application.</p>
    /// <p>The application must be in the
    /// <code>STARTING</code>, <code>UPDATING</code>, <code>STOPPING</code>, <code>AUTOSCALING</code>, or
    /// <code>RUNNING</code> status. </p>
    pub force: std::option::Option<bool>,
}
impl StopApplicationInput {
    /// <p>The name of the running application to stop.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>Set to <code>true</code> to force the application to stop. If you set <code>Force</code>
    /// to <code>true</code>, Kinesis Data Analytics stops the application without taking a snapshot.
    /// </p>
    /// <note>
    /// <p>Force-stopping your application may lead to data loss or duplication.
    /// To prevent data loss or duplicate processing of data during application restarts,
    /// we recommend you to take frequent snapshots of your application.</p>
    /// </note>
    /// <p>You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application.</p>
    /// <p>The application must be in the
    /// <code>STARTING</code>, <code>UPDATING</code>, <code>STOPPING</code>, <code>AUTOSCALING</code>, or
    /// <code>RUNNING</code> status. </p>
    pub fn force(&self) -> std::option::Option<bool> {
        self.force
    }
}
impl std::fmt::Debug for StopApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("force", &self.force);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartApplicationInput {
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.</p>
    pub run_configuration: std::option::Option<crate::model::RunConfiguration>,
}
impl StartApplicationInput {
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.</p>
    pub fn run_configuration(&self) -> std::option::Option<&crate::model::RunConfiguration> {
        self.run_configuration.as_ref()
    }
}
impl std::fmt::Debug for StartApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("run_configuration", &self.run_configuration);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RollbackApplicationInput {
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The current application version ID. You can retrieve the application version ID using
    /// <a>DescribeApplication</a>.</p>
    pub current_application_version_id: std::option::Option<i64>,
}
impl RollbackApplicationInput {
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The current application version ID. You can retrieve the application version ID using
    /// <a>DescribeApplication</a>.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
}
impl std::fmt::Debug for RollbackApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RollbackApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The ARN of the application for which to retrieve tags.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The ARN of the application for which to retrieve tags.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListApplicationVersionsInput {
    /// <p>The name of the application for which you want to list all versions.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of versions to list in this invocation of the operation.</p>
    pub limit: std::option::Option<i32>,
    /// <p>If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see
    /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListApplicationVersionsInput {
    /// <p>The name of the application for which you want to list all versions.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The maximum number of versions to list in this invocation of the operation.</p>
    pub fn limit(&self) -> std::option::Option<i32> {
        self.limit
    }
    /// <p>If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see
    /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListApplicationVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListApplicationVersionsInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("limit", &self.limit);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListApplicationSnapshotsInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of application snapshots to list.</p>
    pub limit: std::option::Option<i32>,
    /// <p>Use this parameter if you receive a <code>NextToken</code> response in a previous request that indicates that there is more
    /// output available. Set it to the value of the previous call's <code>NextToken</code> response to indicate where the output should
    /// continue from. </p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListApplicationSnapshotsInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The maximum number of application snapshots to list.</p>
    pub fn limit(&self) -> std::option::Option<i32> {
        self.limit
    }
    /// <p>Use this parameter if you receive a <code>NextToken</code> response in a previous request that indicates that there is more
    /// output available. Set it to the value of the previous call's <code>NextToken</code> response to indicate where the output should
    /// continue from. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListApplicationSnapshotsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListApplicationSnapshotsInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("limit", &self.limit);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListApplicationsInput {
    /// <p>The maximum number of applications to list.</p>
    pub limit: std::option::Option<i32>,
    /// <p>If a previous command returned a pagination token,
    /// pass it into this value to retrieve the next set of results.
    /// For more information about pagination, see
    /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListApplicationsInput {
    /// <p>The maximum number of applications to list.</p>
    pub fn limit(&self) -> std::option::Option<i32> {
        self.limit
    }
    /// <p>If a previous command returned a pagination token,
    /// pass it into this value to retrieve the next set of results.
    /// For more information about pagination, see
    /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the Amazon Command Line Interface's Pagination Options</a>.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListApplicationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListApplicationsInput");
        formatter.field("limit", &self.limit);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiscoverInputSchemaInput {
    /// <p>The Amazon Resource Name (ARN) of the streaming source.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the role that is used to access the streaming source.</p>
    pub service_execution_role: std::option::Option<std::string::String>,
    /// <p>The point at which you want Kinesis Data Analytics to start reading records from the
    /// specified streaming source discovery purposes.</p>
    pub input_starting_position_configuration:
        std::option::Option<crate::model::InputStartingPositionConfiguration>,
    /// <p>Specify this parameter to discover a schema from data in an Amazon S3
    /// object.</p>
    pub s3_configuration: std::option::Option<crate::model::S3Configuration>,
    /// <p>The <a>InputProcessingConfiguration</a> to use to preprocess the records
    /// before discovering the schema of the records.</p>
    pub input_processing_configuration:
        std::option::Option<crate::model::InputProcessingConfiguration>,
}
impl DiscoverInputSchemaInput {
    /// <p>The Amazon Resource Name (ARN) of the streaming source.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the role that is used to access the streaming source.</p>
    pub fn service_execution_role(&self) -> std::option::Option<&str> {
        self.service_execution_role.as_deref()
    }
    /// <p>The point at which you want Kinesis Data Analytics to start reading records from the
    /// specified streaming source discovery purposes.</p>
    pub fn input_starting_position_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InputStartingPositionConfiguration> {
        self.input_starting_position_configuration.as_ref()
    }
    /// <p>Specify this parameter to discover a schema from data in an Amazon S3
    /// object.</p>
    pub fn s3_configuration(&self) -> std::option::Option<&crate::model::S3Configuration> {
        self.s3_configuration.as_ref()
    }
    /// <p>The <a>InputProcessingConfiguration</a> to use to preprocess the records
    /// before discovering the schema of the records.</p>
    pub fn input_processing_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InputProcessingConfiguration> {
        self.input_processing_configuration.as_ref()
    }
}
impl std::fmt::Debug for DiscoverInputSchemaInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiscoverInputSchemaInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("service_execution_role", &self.service_execution_role);
        formatter.field(
            "input_starting_position_configuration",
            &self.input_starting_position_configuration,
        );
        formatter.field("s3_configuration", &self.s3_configuration);
        formatter.field(
            "input_processing_configuration",
            &self.input_processing_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeApplicationVersionInput {
    /// <p>The name of the application for which you want to get the version description.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The ID of the application version for which you want to get the description.</p>
    pub application_version_id: std::option::Option<i64>,
}
impl DescribeApplicationVersionInput {
    /// <p>The name of the application for which you want to get the version description.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The ID of the application version for which you want to get the description.</p>
    pub fn application_version_id(&self) -> std::option::Option<i64> {
        self.application_version_id
    }
}
impl std::fmt::Debug for DescribeApplicationVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeApplicationVersionInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("application_version_id", &self.application_version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeApplicationSnapshotInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The identifier of an application snapshot. You can retrieve this value using
    /// .</p>
    pub snapshot_name: std::option::Option<std::string::String>,
}
impl DescribeApplicationSnapshotInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The identifier of an application snapshot. You can retrieve this value using
    /// .</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeApplicationSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeApplicationSnapshotInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("snapshot_name", &self.snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeApplicationInput {
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.</p>
    pub include_additional_details: std::option::Option<bool>,
}
impl DescribeApplicationInput {
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.</p>
    pub fn include_additional_details(&self) -> std::option::Option<bool> {
        self.include_additional_details
    }
}
impl std::fmt::Debug for DescribeApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "include_additional_details",
            &self.include_additional_details,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationVpcConfigurationInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The current application version ID. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The ID of the VPC configuration to delete.</p>
    pub vpc_configuration_id: std::option::Option<std::string::String>,
    /// <p>A value you use to implement strong concurrency for application updates. You must provide
    /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
    /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub conditional_token: std::option::Option<std::string::String>,
}
impl DeleteApplicationVpcConfigurationInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The current application version ID. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The ID of the VPC configuration to delete.</p>
    pub fn vpc_configuration_id(&self) -> std::option::Option<&str> {
        self.vpc_configuration_id.as_deref()
    }
    /// <p>A value you use to implement strong concurrency for application updates. You must provide
    /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
    /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn conditional_token(&self) -> std::option::Option<&str> {
        self.conditional_token.as_deref()
    }
}
impl std::fmt::Debug for DeleteApplicationVpcConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationVpcConfigurationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("vpc_configuration_id", &self.vpc_configuration_id);
        formatter.field("conditional_token", &self.conditional_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationSnapshotInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The identifier for the snapshot delete.</p>
    pub snapshot_name: std::option::Option<std::string::String>,
    /// <p>The creation timestamp of the application snapshot to delete. You can retrieve this value
    /// using
    /// or .</p>
    pub snapshot_creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeleteApplicationSnapshotInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The identifier for the snapshot delete.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
    /// <p>The creation timestamp of the application snapshot to delete. You can retrieve this value
    /// using
    /// or .</p>
    pub fn snapshot_creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_creation_timestamp.as_ref()
    }
}
impl std::fmt::Debug for DeleteApplicationSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationSnapshotInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("snapshot_name", &self.snapshot_name);
        formatter.field(
            "snapshot_creation_timestamp",
            &self.snapshot_creation_timestamp,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationReferenceDataSourceInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The current application version.  
    /// You can use the <a>DescribeApplication</a> operation to get the current application version.
    /// If the version specified
    /// is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The ID of the reference data source. When you add a reference data source to your
    /// application using the <a>AddApplicationReferenceDataSource</a>, Kinesis Data Analytics assigns an ID.
    /// You can use the <a>DescribeApplication</a> operation to
    /// get the reference ID. </p>
    pub reference_id: std::option::Option<std::string::String>,
}
impl DeleteApplicationReferenceDataSourceInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The current application version.  
    /// You can use the <a>DescribeApplication</a> operation to get the current application version.
    /// If the version specified
    /// is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The ID of the reference data source. When you add a reference data source to your
    /// application using the <a>AddApplicationReferenceDataSource</a>, Kinesis Data Analytics assigns an ID.
    /// You can use the <a>DescribeApplication</a> operation to
    /// get the reference ID. </p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteApplicationReferenceDataSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationReferenceDataSourceInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("reference_id", &self.reference_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationOutputInput {
    /// <p>The application name.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The application version.
    /// You can use the <a>DescribeApplication</a> operation to get the current application version.
    /// If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.
    /// </p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The ID of the configuration to delete. Each output configuration that is added to the
    /// application (either when the application is created or later) using the <a>AddApplicationOutput</a> operation has a unique ID. You need to provide the ID to
    /// uniquely identify the output configuration that you want to delete from the application
    /// configuration. You can use the <a>DescribeApplication</a> operation to get the
    /// specific <code>OutputId</code>. </p>
    pub output_id: std::option::Option<std::string::String>,
}
impl DeleteApplicationOutputInput {
    /// <p>The application name.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The application version.
    /// You can use the <a>DescribeApplication</a> operation to get the current application version.
    /// If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.
    /// </p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The ID of the configuration to delete. Each output configuration that is added to the
    /// application (either when the application is created or later) using the <a>AddApplicationOutput</a> operation has a unique ID. You need to provide the ID to
    /// uniquely identify the output configuration that you want to delete from the application
    /// configuration. You can use the <a>DescribeApplication</a> operation to get the
    /// specific <code>OutputId</code>. </p>
    pub fn output_id(&self) -> std::option::Option<&str> {
        self.output_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteApplicationOutputInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationOutputInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("output_id", &self.output_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationInputProcessingConfigurationInput {
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The application version.
    /// You can use the <a>DescribeApplication</a> operation to get the current application version.
    /// If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.
    /// </p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The ID of the input configuration from which to delete the input processing
    /// configuration. You can get a list of the input IDs for an application by using the <a>DescribeApplication</a> operation.</p>
    pub input_id: std::option::Option<std::string::String>,
}
impl DeleteApplicationInputProcessingConfigurationInput {
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The application version.
    /// You can use the <a>DescribeApplication</a> operation to get the current application version.
    /// If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.
    /// </p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The ID of the input configuration from which to delete the input processing
    /// configuration. You can get a list of the input IDs for an application by using the <a>DescribeApplication</a> operation.</p>
    pub fn input_id(&self) -> std::option::Option<&str> {
        self.input_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteApplicationInputProcessingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationInputProcessingConfigurationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("input_id", &self.input_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationCloudWatchLoggingOptionInput {
    /// <p>The application name.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The version ID of the application. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The <code>CloudWatchLoggingOptionId</code> of the Amazon CloudWatch logging option to
    /// delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a>DescribeApplication</a> operation. </p>
    pub cloud_watch_logging_option_id: std::option::Option<std::string::String>,
    /// <p>A value you use to implement strong concurrency for application updates. You must provide
    /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
    /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub conditional_token: std::option::Option<std::string::String>,
}
impl DeleteApplicationCloudWatchLoggingOptionInput {
    /// <p>The application name.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The version ID of the application. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The <code>CloudWatchLoggingOptionId</code> of the Amazon CloudWatch logging option to
    /// delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a>DescribeApplication</a> operation. </p>
    pub fn cloud_watch_logging_option_id(&self) -> std::option::Option<&str> {
        self.cloud_watch_logging_option_id.as_deref()
    }
    /// <p>A value you use to implement strong concurrency for application updates. You must provide
    /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
    /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn conditional_token(&self) -> std::option::Option<&str> {
        self.conditional_token.as_deref()
    }
}
impl std::fmt::Debug for DeleteApplicationCloudWatchLoggingOptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationCloudWatchLoggingOptionInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field(
            "cloud_watch_logging_option_id",
            &self.cloud_watch_logging_option_id,
        );
        formatter.field("conditional_token", &self.conditional_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteApplicationInput {
    /// <p>The name of the application to delete.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>Use the <code>DescribeApplication</code> operation to get this value.</p>
    pub create_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeleteApplicationInput {
    /// <p>The name of the application to delete.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>Use the <code>DescribeApplication</code> operation to get this value.</p>
    pub fn create_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_timestamp.as_ref()
    }
}
impl std::fmt::Debug for DeleteApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("create_timestamp", &self.create_timestamp);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateApplicationSnapshotInput {
    /// <p>The name of an existing application</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>An identifier for the application snapshot.</p>
    pub snapshot_name: std::option::Option<std::string::String>,
}
impl CreateApplicationSnapshotInput {
    /// <p>The name of an existing application</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>An identifier for the application snapshot.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for CreateApplicationSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateApplicationSnapshotInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("snapshot_name", &self.snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateApplicationPresignedUrlInput {
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The type of the extension for which to create and return a URL. Currently, the only valid
    /// extension URL type is <code>FLINK_DASHBOARD_URL</code>. </p>
    pub url_type: std::option::Option<crate::model::UrlType>,
    /// <p>The duration in seconds for which the returned URL will be valid.</p>
    pub session_expiration_duration_in_seconds: std::option::Option<i64>,
}
impl CreateApplicationPresignedUrlInput {
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The type of the extension for which to create and return a URL. Currently, the only valid
    /// extension URL type is <code>FLINK_DASHBOARD_URL</code>. </p>
    pub fn url_type(&self) -> std::option::Option<&crate::model::UrlType> {
        self.url_type.as_ref()
    }
    /// <p>The duration in seconds for which the returned URL will be valid.</p>
    pub fn session_expiration_duration_in_seconds(&self) -> std::option::Option<i64> {
        self.session_expiration_duration_in_seconds
    }
}
impl std::fmt::Debug for CreateApplicationPresignedUrlInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateApplicationPresignedUrlInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("url_type", &self.url_type);
        formatter.field(
            "session_expiration_duration_in_seconds",
            &self.session_expiration_duration_in_seconds,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateApplicationInput {
    /// <p>The name of your application (for example, <code>sample-app</code>).</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>A summary description of the application.</p>
    pub application_description: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
    pub runtime_environment: std::option::Option<crate::model::RuntimeEnvironment>,
    /// <p>The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose
    /// delivery streams, Amazon S3 objects, and other external resources.</p>
    pub service_execution_role: std::option::Option<std::string::String>,
    /// <p>Use this parameter to configure the application.</p>
    pub application_configuration: std::option::Option<crate::model::ApplicationConfiguration>,
    /// <p>Use this parameter to configure an Amazon CloudWatch log stream to monitor application
    /// configuration errors.
    /// </p>
    pub cloud_watch_logging_options:
        std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOption>>,
    /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an
    /// application. Note that the maximum number of application tags includes system tags. The maximum number of
    /// user-defined application tags is 50.
    /// For more information, see
    /// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Use the <code>STREAMING</code> mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the
    /// <code>INTERACTIVE</code> mode.</p>
    pub application_mode: std::option::Option<crate::model::ApplicationMode>,
}
impl CreateApplicationInput {
    /// <p>The name of your application (for example, <code>sample-app</code>).</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>A summary description of the application.</p>
    pub fn application_description(&self) -> std::option::Option<&str> {
        self.application_description.as_deref()
    }
    /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
    pub fn runtime_environment(&self) -> std::option::Option<&crate::model::RuntimeEnvironment> {
        self.runtime_environment.as_ref()
    }
    /// <p>The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose
    /// delivery streams, Amazon S3 objects, and other external resources.</p>
    pub fn service_execution_role(&self) -> std::option::Option<&str> {
        self.service_execution_role.as_deref()
    }
    /// <p>Use this parameter to configure the application.</p>
    pub fn application_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationConfiguration> {
        self.application_configuration.as_ref()
    }
    /// <p>Use this parameter to configure an Amazon CloudWatch log stream to monitor application
    /// configuration errors.
    /// </p>
    pub fn cloud_watch_logging_options(
        &self,
    ) -> std::option::Option<&[crate::model::CloudWatchLoggingOption]> {
        self.cloud_watch_logging_options.as_deref()
    }
    /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an
    /// application. Note that the maximum number of application tags includes system tags. The maximum number of
    /// user-defined application tags is 50.
    /// For more information, see
    /// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>Use the <code>STREAMING</code> mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the
    /// <code>INTERACTIVE</code> mode.</p>
    pub fn application_mode(&self) -> std::option::Option<&crate::model::ApplicationMode> {
        self.application_mode.as_ref()
    }
}
impl std::fmt::Debug for CreateApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateApplicationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field("application_description", &self.application_description);
        formatter.field("runtime_environment", &self.runtime_environment);
        formatter.field("service_execution_role", &self.service_execution_role);
        formatter.field("application_configuration", &self.application_configuration);
        formatter.field(
            "cloud_watch_logging_options",
            &self.cloud_watch_logging_options,
        );
        formatter.field("tags", &self.tags);
        formatter.field("application_mode", &self.application_mode);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddApplicationVpcConfigurationInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The version of the application to which you want to add the VPC configuration. You must
    /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    /// can use the <a>DescribeApplication</a> operation to get the current application
    /// version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned. For better concurrency support,
    /// use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>Description of the VPC to add to the application.</p>
    pub vpc_configuration: std::option::Option<crate::model::VpcConfiguration>,
    /// <p>A value you use to implement strong concurrency for application updates. You must
    /// provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>. You get
    /// the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    /// <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub conditional_token: std::option::Option<std::string::String>,
}
impl AddApplicationVpcConfigurationInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The version of the application to which you want to add the VPC configuration. You must
    /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    /// can use the <a>DescribeApplication</a> operation to get the current application
    /// version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned. For better concurrency support,
    /// use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>Description of the VPC to add to the application.</p>
    pub fn vpc_configuration(&self) -> std::option::Option<&crate::model::VpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>A value you use to implement strong concurrency for application updates. You must
    /// provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>. You get
    /// the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    /// <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn conditional_token(&self) -> std::option::Option<&str> {
        self.conditional_token.as_deref()
    }
}
impl std::fmt::Debug for AddApplicationVpcConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddApplicationVpcConfigurationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("vpc_configuration", &self.vpc_configuration);
        formatter.field("conditional_token", &self.conditional_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddApplicationReferenceDataSourceInput {
    /// <p>The name of an existing application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The version of the application for which you are adding the reference data source.
    /// You can
    /// use the <a>DescribeApplication</a> operation to get the current application
    /// version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data
    /// into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting
    /// in-application table that is
    /// created. </p>
    pub reference_data_source: std::option::Option<crate::model::ReferenceDataSource>,
}
impl AddApplicationReferenceDataSourceInput {
    /// <p>The name of an existing application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The version of the application for which you are adding the reference data source.
    /// You can
    /// use the <a>DescribeApplication</a> operation to get the current application
    /// version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data
    /// into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting
    /// in-application table that is
    /// created. </p>
    pub fn reference_data_source(&self) -> std::option::Option<&crate::model::ReferenceDataSource> {
        self.reference_data_source.as_ref()
    }
}
impl std::fmt::Debug for AddApplicationReferenceDataSourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddApplicationReferenceDataSourceInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("reference_data_source", &self.reference_data_source);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddApplicationOutputInput {
    /// <p>The name of the application to which you want to add the output configuration.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The version of the application to which you want to add the output configuration. You can
    /// use the <a>DescribeApplication</a> operation to get the current application
    /// version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned. </p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>An array of objects, each describing one output configuration. In the output
    /// configuration, you specify the name of an in-application stream, a destination (that is, a
    /// Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and
    /// record the formation to use when writing to the destination.</p>
    pub output: std::option::Option<crate::model::Output>,
}
impl AddApplicationOutputInput {
    /// <p>The name of the application to which you want to add the output configuration.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The version of the application to which you want to add the output configuration. You can
    /// use the <a>DescribeApplication</a> operation to get the current application
    /// version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned. </p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>An array of objects, each describing one output configuration. In the output
    /// configuration, you specify the name of an in-application stream, a destination (that is, a
    /// Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and
    /// record the formation to use when writing to the destination.</p>
    pub fn output(&self) -> std::option::Option<&crate::model::Output> {
        self.output.as_ref()
    }
}
impl std::fmt::Debug for AddApplicationOutputInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddApplicationOutputInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("output", &self.output);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddApplicationInputProcessingConfigurationInput {
    /// <p>The name of the application to which you want to add the input processing
    /// configuration.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The version of the application to which you want to add the input processing
    /// configuration. You can use the <a>DescribeApplication</a> operation to get the
    /// current application version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The ID of the input configuration to add the input processing configuration to. You
    /// can get a list of the input IDs for an application using the <a>DescribeApplication</a> operation.</p>
    pub input_id: std::option::Option<std::string::String>,
    /// <p>The <a>InputProcessingConfiguration</a> to add to the application.</p>
    pub input_processing_configuration:
        std::option::Option<crate::model::InputProcessingConfiguration>,
}
impl AddApplicationInputProcessingConfigurationInput {
    /// <p>The name of the application to which you want to add the input processing
    /// configuration.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The version of the application to which you want to add the input processing
    /// configuration. You can use the <a>DescribeApplication</a> operation to get the
    /// current application version. If the version specified is not the current version, the
    /// <code>ConcurrentModificationException</code> is returned.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The ID of the input configuration to add the input processing configuration to. You
    /// can get a list of the input IDs for an application using the <a>DescribeApplication</a> operation.</p>
    pub fn input_id(&self) -> std::option::Option<&str> {
        self.input_id.as_deref()
    }
    /// <p>The <a>InputProcessingConfiguration</a> to add to the application.</p>
    pub fn input_processing_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InputProcessingConfiguration> {
        self.input_processing_configuration.as_ref()
    }
}
impl std::fmt::Debug for AddApplicationInputProcessingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddApplicationInputProcessingConfigurationInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("input_id", &self.input_id);
        formatter.field(
            "input_processing_configuration",
            &self.input_processing_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddApplicationInputInput {
    /// <p>The name of your existing application to which you want to add the streaming
    /// source.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The current version of your application.
    /// You must provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>.You can use the <a>DescribeApplication</a> operation to find the current application version.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>The <a>Input</a> to add.</p>
    pub input: std::option::Option<crate::model::Input>,
}
impl AddApplicationInputInput {
    /// <p>The name of your existing application to which you want to add the streaming
    /// source.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The current version of your application.
    /// You must provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>.You can use the <a>DescribeApplication</a> operation to find the current application version.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>The <a>Input</a> to add.</p>
    pub fn input(&self) -> std::option::Option<&crate::model::Input> {
        self.input.as_ref()
    }
}
impl std::fmt::Debug for AddApplicationInputInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddApplicationInputInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field("input", &self.input);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddApplicationCloudWatchLoggingOptionInput {
    /// <p>The Kinesis Data Analytics application name.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The version ID of the Kinesis Data Analytics application. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub current_application_version_id: std::option::Option<i64>,
    /// <p>Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN). </p>
    pub cloud_watch_logging_option: std::option::Option<crate::model::CloudWatchLoggingOption>,
    /// <p>A value you use to implement strong concurrency for application updates. You must
    /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    /// <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub conditional_token: std::option::Option<std::string::String>,
}
impl AddApplicationCloudWatchLoggingOptionInput {
    /// <p>The Kinesis Data Analytics application name.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The version ID of the Kinesis Data Analytics application. You must provide the
    /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
    /// retrieve the application version ID using <a>DescribeApplication</a>. For better
    /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn current_application_version_id(&self) -> std::option::Option<i64> {
        self.current_application_version_id
    }
    /// <p>Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN). </p>
    pub fn cloud_watch_logging_option(
        &self,
    ) -> std::option::Option<&crate::model::CloudWatchLoggingOption> {
        self.cloud_watch_logging_option.as_ref()
    }
    /// <p>A value you use to implement strong concurrency for application updates. You must
    /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    /// <code>ConditionalToken</code> parameter instead of
    /// <code>CurrentApplicationVersionId</code>.</p>
    pub fn conditional_token(&self) -> std::option::Option<&str> {
        self.conditional_token.as_deref()
    }
}
impl std::fmt::Debug for AddApplicationCloudWatchLoggingOptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddApplicationCloudWatchLoggingOptionInput");
        formatter.field("application_name", &self.application_name);
        formatter.field(
            "current_application_version_id",
            &self.current_application_version_id,
        );
        formatter.field(
            "cloud_watch_logging_option",
            &self.cloud_watch_logging_option,
        );
        formatter.field("conditional_token", &self.conditional_token);
        formatter.finish()
    }
}
