// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_application_cloud_watch_logging_option(
        &self,
    ) -> fluent_builders::AddApplicationCloudWatchLoggingOption<C> {
        fluent_builders::AddApplicationCloudWatchLoggingOption::new(self.handle.clone())
    }
    pub fn add_application_input(&self) -> fluent_builders::AddApplicationInput<C> {
        fluent_builders::AddApplicationInput::new(self.handle.clone())
    }
    pub fn add_application_input_processing_configuration(
        &self,
    ) -> fluent_builders::AddApplicationInputProcessingConfiguration<C> {
        fluent_builders::AddApplicationInputProcessingConfiguration::new(self.handle.clone())
    }
    pub fn add_application_output(&self) -> fluent_builders::AddApplicationOutput<C> {
        fluent_builders::AddApplicationOutput::new(self.handle.clone())
    }
    pub fn add_application_reference_data_source(
        &self,
    ) -> fluent_builders::AddApplicationReferenceDataSource<C> {
        fluent_builders::AddApplicationReferenceDataSource::new(self.handle.clone())
    }
    pub fn add_application_vpc_configuration(
        &self,
    ) -> fluent_builders::AddApplicationVpcConfiguration<C> {
        fluent_builders::AddApplicationVpcConfiguration::new(self.handle.clone())
    }
    pub fn create_application(&self) -> fluent_builders::CreateApplication<C> {
        fluent_builders::CreateApplication::new(self.handle.clone())
    }
    pub fn create_application_presigned_url(
        &self,
    ) -> fluent_builders::CreateApplicationPresignedUrl<C> {
        fluent_builders::CreateApplicationPresignedUrl::new(self.handle.clone())
    }
    pub fn create_application_snapshot(&self) -> fluent_builders::CreateApplicationSnapshot<C> {
        fluent_builders::CreateApplicationSnapshot::new(self.handle.clone())
    }
    pub fn delete_application(&self) -> fluent_builders::DeleteApplication<C> {
        fluent_builders::DeleteApplication::new(self.handle.clone())
    }
    pub fn delete_application_cloud_watch_logging_option(
        &self,
    ) -> fluent_builders::DeleteApplicationCloudWatchLoggingOption<C> {
        fluent_builders::DeleteApplicationCloudWatchLoggingOption::new(self.handle.clone())
    }
    pub fn delete_application_input_processing_configuration(
        &self,
    ) -> fluent_builders::DeleteApplicationInputProcessingConfiguration<C> {
        fluent_builders::DeleteApplicationInputProcessingConfiguration::new(self.handle.clone())
    }
    pub fn delete_application_reference_data_source(
        &self,
    ) -> fluent_builders::DeleteApplicationReferenceDataSource<C> {
        fluent_builders::DeleteApplicationReferenceDataSource::new(self.handle.clone())
    }
    pub fn delete_application_snapshot(&self) -> fluent_builders::DeleteApplicationSnapshot<C> {
        fluent_builders::DeleteApplicationSnapshot::new(self.handle.clone())
    }
    pub fn delete_application_vpc_configuration(
        &self,
    ) -> fluent_builders::DeleteApplicationVpcConfiguration<C> {
        fluent_builders::DeleteApplicationVpcConfiguration::new(self.handle.clone())
    }
    pub fn describe_application(&self) -> fluent_builders::DescribeApplication<C> {
        fluent_builders::DescribeApplication::new(self.handle.clone())
    }
    pub fn describe_application_snapshot(&self) -> fluent_builders::DescribeApplicationSnapshot<C> {
        fluent_builders::DescribeApplicationSnapshot::new(self.handle.clone())
    }
    pub fn describe_application_version(&self) -> fluent_builders::DescribeApplicationVersion<C> {
        fluent_builders::DescribeApplicationVersion::new(self.handle.clone())
    }
    pub fn discover_input_schema(&self) -> fluent_builders::DiscoverInputSchema<C> {
        fluent_builders::DiscoverInputSchema::new(self.handle.clone())
    }
    pub fn list_applications(&self) -> fluent_builders::ListApplications<C> {
        fluent_builders::ListApplications::new(self.handle.clone())
    }
    pub fn list_application_snapshots(&self) -> fluent_builders::ListApplicationSnapshots<C> {
        fluent_builders::ListApplicationSnapshots::new(self.handle.clone())
    }
    pub fn list_application_versions(&self) -> fluent_builders::ListApplicationVersions<C> {
        fluent_builders::ListApplicationVersions::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn rollback_application(&self) -> fluent_builders::RollbackApplication<C> {
        fluent_builders::RollbackApplication::new(self.handle.clone())
    }
    pub fn start_application(&self) -> fluent_builders::StartApplication<C> {
        fluent_builders::StartApplication::new(self.handle.clone())
    }
    pub fn stop_application(&self) -> fluent_builders::StopApplication<C> {
        fluent_builders::StopApplication::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_application(&self) -> fluent_builders::UpdateApplication<C> {
        fluent_builders::UpdateApplication::new(self.handle.clone())
    }
    pub fn update_application_maintenance_configuration(
        &self,
    ) -> fluent_builders::UpdateApplicationMaintenanceConfiguration<C> {
        fluent_builders::UpdateApplicationMaintenanceConfiguration::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddApplicationCloudWatchLoggingOption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_application_cloud_watch_logging_option_input::Builder,
    }
    impl<C> AddApplicationCloudWatchLoggingOption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddApplicationCloudWatchLoggingOptionOutput,
            smithy_http::result::SdkError<crate::error::AddApplicationCloudWatchLoggingOptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Kinesis Data Analytics application name.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The version ID of the Kinesis Data Analytics application. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN). </p>
        pub fn cloud_watch_logging_option(
            mut self,
            input: crate::model::CloudWatchLoggingOption,
        ) -> Self {
            self.inner = self.inner.cloud_watch_logging_option(input);
            self
        }
        pub fn set_cloud_watch_logging_option(
            mut self,
            input: std::option::Option<crate::model::CloudWatchLoggingOption>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_logging_option(input);
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conditional_token(input);
            self
        }
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_conditional_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddApplicationInput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_application_input_input::Builder,
    }
    impl<C> AddApplicationInput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddApplicationInputOutput,
            smithy_http::result::SdkError<crate::error::AddApplicationInputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your existing application to which you want to add the streaming
        /// source.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The current version of your application.
        /// You must provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>.You can use the <a>DescribeApplication</a> operation to find the current application version.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The <a>Input</a> to add.</p>
        pub fn input(mut self, input: crate::model::Input) -> Self {
            self.inner = self.inner.input(input);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<crate::model::Input>) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddApplicationInputProcessingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_application_input_processing_configuration_input::Builder,
    }
    impl<C> AddApplicationInputProcessingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddApplicationInputProcessingConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::AddApplicationInputProcessingConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application to which you want to add the input processing
        /// configuration.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The version of the application to which you want to add the input processing
        /// configuration. You can use the <a>DescribeApplication</a> operation to get the
        /// current application version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The ID of the input configuration to add the input processing configuration to. You
        /// can get a list of the input IDs for an application using the <a>DescribeApplication</a> operation.</p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_id(input);
            self
        }
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input_id(input);
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> to add to the application.</p>
        pub fn input_processing_configuration(
            mut self,
            input: crate::model::InputProcessingConfiguration,
        ) -> Self {
            self.inner = self.inner.input_processing_configuration(input);
            self
        }
        pub fn set_input_processing_configuration(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_input_processing_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddApplicationOutput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_application_output_input::Builder,
    }
    impl<C> AddApplicationOutput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddApplicationOutputOutput,
            smithy_http::result::SdkError<crate::error::AddApplicationOutputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application to which you want to add the output configuration.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The version of the application to which you want to add the output configuration. You can
        /// use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned. </p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>An array of objects, each describing one output configuration. In the output
        /// configuration, you specify the name of an in-application stream, a destination (that is, a
        /// Kinesis data stream, a Kinesis Data Firehose delivery stream, or an AWS Lambda function), and
        /// record the formation to use when writing to the destination.</p>
        pub fn output(mut self, input: crate::model::Output) -> Self {
            self.inner = self.inner.output(input);
            self
        }
        pub fn set_output(mut self, input: std::option::Option<crate::model::Output>) -> Self {
            self.inner = self.inner.set_output(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddApplicationReferenceDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_application_reference_data_source_input::Builder,
    }
    impl<C> AddApplicationReferenceDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddApplicationReferenceDataSourceOutput,
            smithy_http::result::SdkError<crate::error::AddApplicationReferenceDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The version of the application for which you are adding the reference data source.
        /// You can
        /// use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data
        /// into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting
        /// in-application table that is
        /// created. </p>
        pub fn reference_data_source(mut self, input: crate::model::ReferenceDataSource) -> Self {
            self.inner = self.inner.reference_data_source(input);
            self
        }
        pub fn set_reference_data_source(
            mut self,
            input: std::option::Option<crate::model::ReferenceDataSource>,
        ) -> Self {
            self.inner = self.inner.set_reference_data_source(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddApplicationVpcConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_application_vpc_configuration_input::Builder,
    }
    impl<C> AddApplicationVpcConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddApplicationVpcConfigurationOutput,
            smithy_http::result::SdkError<crate::error::AddApplicationVpcConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The version of the application to which you want to add the VPC configuration. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// can use the <a>DescribeApplication</a> operation to get the current application
        /// version. If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned. For better concurrency support,
        /// use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>Description of the VPC to add to the application.</p>
        pub fn vpc_configuration(mut self, input: crate::model::VpcConfiguration) -> Self {
            self.inner = self.inner.vpc_configuration(input);
            self
        }
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::VpcConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_vpc_configuration(input);
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>. You get
        /// the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conditional_token(input);
            self
        }
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_conditional_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_application_input::Builder,
    }
    impl<C> CreateApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApplicationOutput,
            smithy_http::result::SdkError<crate::error::CreateApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your application (for example, <code>sample-app</code>).</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>A summary description of the application.</p>
        pub fn application_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_description(input);
            self
        }
        pub fn set_application_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_description(input);
            self
        }
        /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
        pub fn runtime_environment(mut self, input: crate::model::RuntimeEnvironment) -> Self {
            self.inner = self.inner.runtime_environment(input);
            self
        }
        pub fn set_runtime_environment(
            mut self,
            input: std::option::Option<crate::model::RuntimeEnvironment>,
        ) -> Self {
            self.inner = self.inner.set_runtime_environment(input);
            self
        }
        /// <p>The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose
        /// delivery streams, Amazon S3 objects, and other external resources.</p>
        pub fn service_execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_execution_role(input);
            self
        }
        pub fn set_service_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_execution_role(input);
            self
        }
        /// <p>Use this parameter to configure the application.</p>
        pub fn application_configuration(
            mut self,
            input: crate::model::ApplicationConfiguration,
        ) -> Self {
            self.inner = self.inner.application_configuration(input);
            self
        }
        pub fn set_application_configuration(
            mut self,
            input: std::option::Option<crate::model::ApplicationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_application_configuration(input);
            self
        }
        /// <p>Use this parameter to configure an Amazon CloudWatch log stream to monitor application
        /// configuration errors.
        /// </p>
        pub fn cloud_watch_logging_options(
            mut self,
            inp: impl Into<crate::model::CloudWatchLoggingOption>,
        ) -> Self {
            self.inner = self.inner.cloud_watch_logging_options(inp);
            self
        }
        pub fn set_cloud_watch_logging_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOption>>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_logging_options(input);
            self
        }
        /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an
        /// application. Note that the maximum number of application tags includes system tags. The maximum number of
        /// user-defined application tags is 50.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Use the <code>STREAMING</code> mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the
        /// <code>INTERACTIVE</code> mode.</p>
        pub fn application_mode(mut self, input: crate::model::ApplicationMode) -> Self {
            self.inner = self.inner.application_mode(input);
            self
        }
        pub fn set_application_mode(
            mut self,
            input: std::option::Option<crate::model::ApplicationMode>,
        ) -> Self {
            self.inner = self.inner.set_application_mode(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateApplicationPresignedUrl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_application_presigned_url_input::Builder,
    }
    impl<C> CreateApplicationPresignedUrl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApplicationPresignedUrlOutput,
            smithy_http::result::SdkError<crate::error::CreateApplicationPresignedUrlError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The type of the extension for which to create and return a URL. Currently, the only valid
        /// extension URL type is <code>FLINK_DASHBOARD_URL</code>. </p>
        pub fn url_type(mut self, input: crate::model::UrlType) -> Self {
            self.inner = self.inner.url_type(input);
            self
        }
        pub fn set_url_type(mut self, input: std::option::Option<crate::model::UrlType>) -> Self {
            self.inner = self.inner.set_url_type(input);
            self
        }
        /// <p>The duration in seconds for which the returned URL will be valid.</p>
        pub fn session_expiration_duration_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.session_expiration_duration_in_seconds(input);
            self
        }
        pub fn set_session_expiration_duration_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_session_expiration_duration_in_seconds(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateApplicationSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_application_snapshot_input::Builder,
    }
    impl<C> CreateApplicationSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApplicationSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateApplicationSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>An identifier for the application snapshot.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_name(input);
            self
        }
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_input::Builder,
    }
    impl<C> DeleteApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationOutput,
            smithy_http::result::SdkError<crate::error::DeleteApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application to delete.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>Use the <code>DescribeApplication</code> operation to get this value.</p>
        pub fn create_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.create_timestamp(input);
            self
        }
        pub fn set_create_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_create_timestamp(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplicationCloudWatchLoggingOption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_cloud_watch_logging_option_input::Builder,
    }
    impl<C> DeleteApplicationCloudWatchLoggingOption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationCloudWatchLoggingOptionOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteApplicationCloudWatchLoggingOptionError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The application name.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The version ID of the application. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The <code>CloudWatchLoggingOptionId</code> of the Amazon CloudWatch logging option to
        /// delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a>DescribeApplication</a> operation. </p>
        pub fn cloud_watch_logging_option_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.cloud_watch_logging_option_id(input);
            self
        }
        pub fn set_cloud_watch_logging_option_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_logging_option_id(input);
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must provide
        /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
        /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conditional_token(input);
            self
        }
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_conditional_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplicationInputProcessingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_input_processing_configuration_input::Builder,
    }
    impl<C> DeleteApplicationInputProcessingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationInputProcessingConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteApplicationInputProcessingConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The application version.
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified is not the current version, the
        /// <code>ConcurrentModificationException</code> is returned.
        /// </p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The ID of the input configuration from which to delete the input processing
        /// configuration. You can get a list of the input IDs for an application by using the <a>DescribeApplication</a> operation.</p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_id(input);
            self
        }
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplicationReferenceDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_reference_data_source_input::Builder,
    }
    impl<C> DeleteApplicationReferenceDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationReferenceDataSourceOutput,
            smithy_http::result::SdkError<crate::error::DeleteApplicationReferenceDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The current application version.  
        /// You can use the <a>DescribeApplication</a> operation to get the current application version.
        /// If the version specified
        /// is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The ID of the reference data source. When you add a reference data source to your
        /// application using the <a>AddApplicationReferenceDataSource</a>, Kinesis Data Analytics assigns an ID.
        /// You can use the <a>DescribeApplication</a> operation to
        /// get the reference ID. </p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reference_id(input);
            self
        }
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reference_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplicationSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_snapshot_input::Builder,
    }
    impl<C> DeleteApplicationSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteApplicationSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The identifier for the snapshot delete.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_name(input);
            self
        }
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_name(input);
            self
        }
        /// <p>The creation timestamp of the application snapshot to delete. You can retrieve this value
        /// using
        /// or .</p>
        pub fn snapshot_creation_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.snapshot_creation_timestamp(input);
            self
        }
        pub fn set_snapshot_creation_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_creation_timestamp(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplicationVpcConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_vpc_configuration_input::Builder,
    }
    impl<C> DeleteApplicationVpcConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationVpcConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteApplicationVpcConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The current application version ID. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>The ID of the VPC configuration to delete.</p>
        pub fn vpc_configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_configuration_id(input);
            self
        }
        pub fn set_vpc_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_configuration_id(input);
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must provide
        /// the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
        /// application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conditional_token(input);
            self
        }
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_conditional_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_application_input::Builder,
    }
    impl<C> DescribeApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeApplicationOutput,
            smithy_http::result::SdkError<crate::error::DescribeApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.</p>
        pub fn include_additional_details(mut self, input: bool) -> Self {
            self.inner = self.inner.include_additional_details(input);
            self
        }
        pub fn set_include_additional_details(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_additional_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeApplicationSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_application_snapshot_input::Builder,
    }
    impl<C> DescribeApplicationSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeApplicationSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DescribeApplicationSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The identifier of an application snapshot. You can retrieve this value using
        /// .</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_name(input);
            self
        }
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeApplicationVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_application_version_input::Builder,
    }
    impl<C> DescribeApplicationVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeApplicationVersionOutput,
            smithy_http::result::SdkError<crate::error::DescribeApplicationVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application for which you want to get the version description.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The ID of the application version for which you want to get the description.</p>
        pub fn application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.application_version_id(input);
            self
        }
        pub fn set_application_version_id(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_application_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DiscoverInputSchema<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::discover_input_schema_input::Builder,
    }
    impl<C> DiscoverInputSchema<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DiscoverInputSchemaOutput,
            smithy_http::result::SdkError<crate::error::DiscoverInputSchemaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the streaming source.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The ARN of the role that is used to access the streaming source.</p>
        pub fn service_execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_execution_role(input);
            self
        }
        pub fn set_service_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_execution_role(input);
            self
        }
        /// <p>The point at which you want Kinesis Data Analytics to start reading records from the
        /// specified streaming source discovery purposes.</p>
        pub fn input_starting_position_configuration(
            mut self,
            input: crate::model::InputStartingPositionConfiguration,
        ) -> Self {
            self.inner = self.inner.input_starting_position_configuration(input);
            self
        }
        pub fn set_input_starting_position_configuration(
            mut self,
            input: std::option::Option<crate::model::InputStartingPositionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_input_starting_position_configuration(input);
            self
        }
        /// <p>Specify this parameter to discover a schema from data in an Amazon S3
        /// object.</p>
        pub fn s3_configuration(mut self, input: crate::model::S3Configuration) -> Self {
            self.inner = self.inner.s3_configuration(input);
            self
        }
        pub fn set_s3_configuration(
            mut self,
            input: std::option::Option<crate::model::S3Configuration>,
        ) -> Self {
            self.inner = self.inner.set_s3_configuration(input);
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> to use to preprocess the records
        /// before discovering the schema of the records.</p>
        pub fn input_processing_configuration(
            mut self,
            input: crate::model::InputProcessingConfiguration,
        ) -> Self {
            self.inner = self.inner.input_processing_configuration(input);
            self
        }
        pub fn set_input_processing_configuration(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_input_processing_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApplications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_applications_input::Builder,
    }
    impl<C> ListApplications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApplicationsOutput,
            smithy_http::result::SdkError<crate::error::ListApplicationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of applications to list.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>If a previous command returned a pagination token,
        /// pass it into this value to retrieve the next set of results.
        /// For more information about pagination, see
        /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the AWS Command Line Interface's Pagination Options</a>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApplicationSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_application_snapshots_input::Builder,
    }
    impl<C> ListApplicationSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApplicationSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::ListApplicationSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The maximum number of application snapshots to list.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>Use this parameter if you receive a <code>NextToken</code> response in a previous request that indicates that there is more
        /// output available. Set it to the value of the previous call's <code>NextToken</code> response to indicate where the output should
        /// continue from. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApplicationVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_application_versions_input::Builder,
    }
    impl<C> ListApplicationVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApplicationVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListApplicationVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application for which you want to list all versions.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The maximum number of versions to list in this invocation of the operation.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see
        /// <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the AWS Command Line Interface's Pagination Options</a>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the application for which to retrieve tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RollbackApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::rollback_application_input::Builder,
    }
    impl<C> RollbackApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RollbackApplicationOutput,
            smithy_http::result::SdkError<crate::error::RollbackApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The current application version ID. You can retrieve the application version ID using
        /// <a>DescribeApplication</a>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_application_input::Builder,
    }
    impl<C> StartApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartApplicationOutput,
            smithy_http::result::SdkError<crate::error::StartApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.</p>
        pub fn run_configuration(mut self, input: crate::model::RunConfiguration) -> Self {
            self.inner = self.inner.run_configuration(input);
            self
        }
        pub fn set_run_configuration(
            mut self,
            input: std::option::Option<crate::model::RunConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_run_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_application_input::Builder,
    }
    impl<C> StopApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopApplicationOutput,
            smithy_http::result::SdkError<crate::error::StopApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the running application to stop.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>Set to <code>true</code> to force the application to stop. If you set <code>Force</code>
        /// to <code>true</code>, Kinesis Data Analytics stops the application without taking a snapshot.
        /// </p>
        /// <note>
        /// <p>Force-stopping your application may lead to data loss or duplication.
        /// To prevent data loss or duplicate processing of data during application restarts,
        /// we recommend you to take frequent snapshots of your application.</p>
        /// </note>
        /// <p>You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application.</p>
        /// <p>The application must be in the
        /// <code>STARTING</code>, <code>UPDATING</code>, <code>STOPPING</code>, <code>AUTOSCALING</code>, or
        /// <code>RUNNING</code> status. </p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the application to assign the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The key-value tags to assign to the application.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Kinesis Data Analytics application from which to remove the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of keys of tags to remove from the specified application.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_application_input::Builder,
    }
    impl<C> UpdateApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApplicationOutput,
            smithy_http::result::SdkError<crate::error::UpdateApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application to update.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The current application version ID. You must provide the
        /// <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
        /// retrieve the application version ID using <a>DescribeApplication</a>. For better
        /// concurrency support, use the <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn current_application_version_id(mut self, input: i64) -> Self {
            self.inner = self.inner.current_application_version_id(input);
            self
        }
        pub fn set_current_application_version_id(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_current_application_version_id(input);
            self
        }
        /// <p>Describes application configuration updates.</p>
        pub fn application_configuration_update(
            mut self,
            input: crate::model::ApplicationConfigurationUpdate,
        ) -> Self {
            self.inner = self.inner.application_configuration_update(input);
            self
        }
        pub fn set_application_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ApplicationConfigurationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_application_configuration_update(input);
            self
        }
        /// <p>Describes updates to the service execution role.</p>
        pub fn service_execution_role_update(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.service_execution_role_update(input);
            self
        }
        pub fn set_service_execution_role_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_execution_role_update(input);
            self
        }
        /// <p>Describes updates to the application's starting parameters.</p>
        pub fn run_configuration_update(
            mut self,
            input: crate::model::RunConfigurationUpdate,
        ) -> Self {
            self.inner = self.inner.run_configuration_update(input);
            self
        }
        pub fn set_run_configuration_update(
            mut self,
            input: std::option::Option<crate::model::RunConfigurationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_run_configuration_update(input);
            self
        }
        /// <p>Describes application Amazon CloudWatch logging option updates. You can only update
        /// existing CloudWatch logging options with this action. To add a new CloudWatch logging option,
        /// use <a>AddApplicationCloudWatchLoggingOption</a>.</p>
        pub fn cloud_watch_logging_option_updates(
            mut self,
            inp: impl Into<crate::model::CloudWatchLoggingOptionUpdate>,
        ) -> Self {
            self.inner = self.inner.cloud_watch_logging_option_updates(inp);
            self
        }
        pub fn set_cloud_watch_logging_option_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOptionUpdate>>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_logging_option_updates(input);
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates. You must
        /// provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
        /// get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
        /// <code>ConditionalToken</code> parameter instead of
        /// <code>CurrentApplicationVersionId</code>.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conditional_token(input);
            self
        }
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_conditional_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApplicationMaintenanceConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_application_maintenance_configuration_input::Builder,
    }
    impl<C> UpdateApplicationMaintenanceConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApplicationMaintenanceConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::UpdateApplicationMaintenanceConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application for which you want to update the maintenance configuration.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>Describes the application maintenance configuration update.</p>
        pub fn application_maintenance_configuration_update(
            mut self,
            input: crate::model::ApplicationMaintenanceConfigurationUpdate,
        ) -> Self {
            self.inner = self
                .inner
                .application_maintenance_configuration_update(input);
            self
        }
        pub fn set_application_maintenance_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ApplicationMaintenanceConfigurationUpdate>,
        ) -> Self {
            self.inner = self
                .inner
                .set_application_maintenance_configuration_update(input);
            self
        }
    }
}
