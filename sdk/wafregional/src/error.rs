// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateXssMatchSetErrorKind = UpdateXssMatchSetError;
/// Error type for the `UpdateXssMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateXssMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateXssMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateXssMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateXssMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateXssMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateXssMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateXssMatchSetError {
    /// Creates the `UpdateXssMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateXssMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateXssMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateXssMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafStaleDataException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafStaleDataException {
    /// Creates a new builder-style object to manufacture [`WafStaleDataException`](crate::error::WafStaleDataException).
    pub fn builder() -> crate::error::waf_stale_data_exception::Builder {
        crate::error::waf_stale_data_exception::Builder::default()
    }
}
/// See [`WafStaleDataException`](crate::error::WafStaleDataException).
pub mod waf_stale_data_exception {

    /// A builder for [`WafStaleDataException`](crate::error::WafStaleDataException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafStaleDataException`](crate::error::WafStaleDataException).
        pub fn build(self) -> crate::error::WafStaleDataException {
            crate::error::WafStaleDataException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafStaleDataException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafStaleDataException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafStaleDataException [WAFStaleDataException]")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafStaleDataException {}
impl aws_http::request_id::RequestId for crate::error::WafStaleDataException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafStaleDataException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because the referenced object doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafNonexistentItemException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafNonexistentItemException {
    /// Creates a new builder-style object to manufacture [`WafNonexistentItemException`](crate::error::WafNonexistentItemException).
    pub fn builder() -> crate::error::waf_nonexistent_item_exception::Builder {
        crate::error::waf_nonexistent_item_exception::Builder::default()
    }
}
/// See [`WafNonexistentItemException`](crate::error::WafNonexistentItemException).
pub mod waf_nonexistent_item_exception {

    /// A builder for [`WafNonexistentItemException`](crate::error::WafNonexistentItemException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafNonexistentItemException`](crate::error::WafNonexistentItemException).
        pub fn build(self) -> crate::error::WafNonexistentItemException {
            crate::error::WafNonexistentItemException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafNonexistentItemException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafNonexistentItemException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafNonexistentItemException [WAFNonexistentItemException]"
        )?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafNonexistentItemException {}
impl aws_http::request_id::RequestId for crate::error::WafNonexistentItemException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafNonexistentItemException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
/// <ul>
/// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
/// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
/// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
/// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafNonexistentContainerException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafNonexistentContainerException {
    /// Creates a new builder-style object to manufacture [`WafNonexistentContainerException`](crate::error::WafNonexistentContainerException).
    pub fn builder() -> crate::error::waf_nonexistent_container_exception::Builder {
        crate::error::waf_nonexistent_container_exception::Builder::default()
    }
}
/// See [`WafNonexistentContainerException`](crate::error::WafNonexistentContainerException).
pub mod waf_nonexistent_container_exception {

    /// A builder for [`WafNonexistentContainerException`](crate::error::WafNonexistentContainerException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafNonexistentContainerException`](crate::error::WafNonexistentContainerException).
        pub fn build(self) -> crate::error::WafNonexistentContainerException {
            crate::error::WafNonexistentContainerException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafNonexistentContainerException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafNonexistentContainerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafNonexistentContainerException [WAFNonexistentContainerException]"
        )?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafNonexistentContainerException {}
impl aws_http::request_id::RequestId for crate::error::WafNonexistentContainerException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafNonexistentContainerException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafLimitsExceededException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafLimitsExceededException {
    /// Creates a new builder-style object to manufacture [`WafLimitsExceededException`](crate::error::WafLimitsExceededException).
    pub fn builder() -> crate::error::waf_limits_exceeded_exception::Builder {
        crate::error::waf_limits_exceeded_exception::Builder::default()
    }
}
/// See [`WafLimitsExceededException`](crate::error::WafLimitsExceededException).
pub mod waf_limits_exceeded_exception {

    /// A builder for [`WafLimitsExceededException`](crate::error::WafLimitsExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafLimitsExceededException`](crate::error::WafLimitsExceededException).
        pub fn build(self) -> crate::error::WafLimitsExceededException {
            crate::error::WafLimitsExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafLimitsExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafLimitsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafLimitsExceededException [WAFLimitsExceededException]")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafLimitsExceededException {}
impl aws_http::request_id::RequestId for crate::error::WafLimitsExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafLimitsExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
/// <ul>
/// <li> <p>You specified an invalid parameter name.</p> </li>
/// <li> <p>You specified an invalid value.</p> </li>
/// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
/// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
/// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
/// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
/// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
/// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
/// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafInvalidParameterException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub field: std::option::Option<crate::model::ParameterExceptionField>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub parameter: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::ParameterExceptionReason>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafInvalidParameterException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn field(&self) -> std::option::Option<&crate::model::ParameterExceptionField> {
        self.field.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn parameter(&self) -> std::option::Option<&str> {
        self.parameter.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn reason(&self) -> std::option::Option<&crate::model::ParameterExceptionReason> {
        self.reason.as_ref()
    }
}
impl WafInvalidParameterException {
    /// Creates a new builder-style object to manufacture [`WafInvalidParameterException`](crate::error::WafInvalidParameterException).
    pub fn builder() -> crate::error::waf_invalid_parameter_exception::Builder {
        crate::error::waf_invalid_parameter_exception::Builder::default()
    }
}
/// See [`WafInvalidParameterException`](crate::error::WafInvalidParameterException).
pub mod waf_invalid_parameter_exception {

    /// A builder for [`WafInvalidParameterException`](crate::error::WafInvalidParameterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<crate::model::ParameterExceptionField>,
        pub(crate) parameter: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::ParameterExceptionReason>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn field(mut self, input: crate::model::ParameterExceptionField) -> Self {
            self.field = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_field(
            mut self,
            input: std::option::Option<crate::model::ParameterExceptionField>,
        ) -> Self {
            self.field = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_parameter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameter = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn reason(mut self, input: crate::model::ParameterExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::ParameterExceptionReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafInvalidParameterException`](crate::error::WafInvalidParameterException).
        pub fn build(self) -> crate::error::WafInvalidParameterException {
            crate::error::WafInvalidParameterException {
                field: self.field,
                parameter: self.parameter,
                reason: self.reason,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafInvalidParameterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafInvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafInvalidParameterException [WAFInvalidParameterException]"
        )?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafInvalidParameterException {}
impl aws_http::request_id::RequestId for crate::error::WafInvalidParameterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafInvalidParameterException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because there was nothing to do. For example:</p>
/// <ul>
/// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
/// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
/// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
/// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
/// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafInvalidOperationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafInvalidOperationException {
    /// Creates a new builder-style object to manufacture [`WafInvalidOperationException`](crate::error::WafInvalidOperationException).
    pub fn builder() -> crate::error::waf_invalid_operation_exception::Builder {
        crate::error::waf_invalid_operation_exception::Builder::default()
    }
}
/// See [`WafInvalidOperationException`](crate::error::WafInvalidOperationException).
pub mod waf_invalid_operation_exception {

    /// A builder for [`WafInvalidOperationException`](crate::error::WafInvalidOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafInvalidOperationException`](crate::error::WafInvalidOperationException).
        pub fn build(self) -> crate::error::WafInvalidOperationException {
            crate::error::WafInvalidOperationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafInvalidOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafInvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafInvalidOperationException [WAFInvalidOperationException]"
        )?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafInvalidOperationException {}
impl aws_http::request_id::RequestId for crate::error::WafInvalidOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafInvalidOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafInvalidAccountException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafInvalidAccountException {
    /// Creates a new builder-style object to manufacture [`WafInvalidAccountException`](crate::error::WafInvalidAccountException).
    pub fn builder() -> crate::error::waf_invalid_account_exception::Builder {
        crate::error::waf_invalid_account_exception::Builder::default()
    }
}
/// See [`WafInvalidAccountException`](crate::error::WafInvalidAccountException).
pub mod waf_invalid_account_exception {

    /// A builder for [`WafInvalidAccountException`](crate::error::WafInvalidAccountException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafInvalidAccountException`](crate::error::WafInvalidAccountException).
        pub fn build(self) -> crate::error::WafInvalidAccountException {
            crate::error::WafInvalidAccountException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafInvalidAccountException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafInvalidAccountException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafInvalidAccountException [WAFInvalidAccountException]")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafInvalidAccountException {}
impl aws_http::request_id::RequestId for crate::error::WafInvalidAccountException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafInvalidAccountException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafInternalErrorException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafInternalErrorException {
    /// Creates a new builder-style object to manufacture [`WafInternalErrorException`](crate::error::WafInternalErrorException).
    pub fn builder() -> crate::error::waf_internal_error_exception::Builder {
        crate::error::waf_internal_error_exception::Builder::default()
    }
}
/// See [`WafInternalErrorException`](crate::error::WafInternalErrorException).
pub mod waf_internal_error_exception {

    /// A builder for [`WafInternalErrorException`](crate::error::WafInternalErrorException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafInternalErrorException`](crate::error::WafInternalErrorException).
        pub fn build(self) -> crate::error::WafInternalErrorException {
            crate::error::WafInternalErrorException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafInternalErrorException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafInternalErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafInternalErrorException [WAFInternalErrorException]")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafInternalErrorException {}
impl aws_http::request_id::RequestId for crate::error::WafInternalErrorException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafInternalErrorException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateWebACLErrorKind = UpdateWebACLError;
/// Error type for the `UpdateWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWebACLError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p>The specified subscription does not exist.</p>
    WafSubscriptionNotFoundException(crate::error::WafSubscriptionNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafSubscriptionNotFoundException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafSubscriptionNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWebACLError {
    /// Creates the `UpdateWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafSubscriptionNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `UpdateWebACLError::WafSubscriptionNotFoundException`.
    pub fn is_waf_subscription_not_found_exception(&self) -> bool {
        matches!(self, Self::WafSubscriptionNotFoundException(_))
    }
}
impl std::error::Error for UpdateWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafSubscriptionNotFoundException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified subscription does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafSubscriptionNotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafSubscriptionNotFoundException {
    /// Creates a new builder-style object to manufacture [`WafSubscriptionNotFoundException`](crate::error::WafSubscriptionNotFoundException).
    pub fn builder() -> crate::error::waf_subscription_not_found_exception::Builder {
        crate::error::waf_subscription_not_found_exception::Builder::default()
    }
}
/// See [`WafSubscriptionNotFoundException`](crate::error::WafSubscriptionNotFoundException).
pub mod waf_subscription_not_found_exception {

    /// A builder for [`WafSubscriptionNotFoundException`](crate::error::WafSubscriptionNotFoundException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafSubscriptionNotFoundException`](crate::error::WafSubscriptionNotFoundException).
        pub fn build(self) -> crate::error::WafSubscriptionNotFoundException {
            crate::error::WafSubscriptionNotFoundException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafSubscriptionNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafSubscriptionNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafSubscriptionNotFoundException [WAFSubscriptionNotFoundException]"
        )?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafSubscriptionNotFoundException {}
impl aws_http::request_id::RequestId for crate::error::WafSubscriptionNotFoundException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafSubscriptionNotFoundException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
/// <ul>
/// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
/// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafReferencedItemException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafReferencedItemException {
    /// Creates a new builder-style object to manufacture [`WafReferencedItemException`](crate::error::WafReferencedItemException).
    pub fn builder() -> crate::error::waf_referenced_item_exception::Builder {
        crate::error::waf_referenced_item_exception::Builder::default()
    }
}
/// See [`WafReferencedItemException`](crate::error::WafReferencedItemException).
pub mod waf_referenced_item_exception {

    /// A builder for [`WafReferencedItemException`](crate::error::WafReferencedItemException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafReferencedItemException`](crate::error::WafReferencedItemException).
        pub fn build(self) -> crate::error::WafReferencedItemException {
            crate::error::WafReferencedItemException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafReferencedItemException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafReferencedItemException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafReferencedItemException [WAFReferencedItemException]")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafReferencedItemException {}
impl aws_http::request_id::RequestId for crate::error::WafReferencedItemException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafReferencedItemException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateSqlInjectionMatchSetErrorKind = UpdateSqlInjectionMatchSetError;
/// Error type for the `UpdateSqlInjectionMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSqlInjectionMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSqlInjectionMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateSqlInjectionMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateSqlInjectionMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateSqlInjectionMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSqlInjectionMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSqlInjectionMatchSetError {
    /// Creates the `UpdateSqlInjectionMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateSqlInjectionMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateSqlInjectionMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateSqlInjectionMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateSizeConstraintSetErrorKind = UpdateSizeConstraintSetError;
/// Error type for the `UpdateSizeConstraintSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSizeConstraintSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSizeConstraintSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateSizeConstraintSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateSizeConstraintSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateSizeConstraintSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSizeConstraintSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSizeConstraintSetError {
    /// Creates the `UpdateSizeConstraintSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateSizeConstraintSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateSizeConstraintSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateSizeConstraintSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRuleGroupErrorKind = UpdateRuleGroupError;
/// Error type for the `UpdateRuleGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRuleGroupError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRuleGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRuleGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRuleGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRuleGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRuleGroupError {
    /// Creates the `UpdateRuleGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRuleGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleGroupError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRuleErrorKind = UpdateRuleError;
/// Error type for the `UpdateRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRuleError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRuleError {
    /// Creates the `UpdateRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRuleError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRegexPatternSetErrorKind = UpdateRegexPatternSetError;
/// Error type for the `UpdateRegexPatternSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRegexPatternSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The regular expression (regex) you specified in <code>RegexPatternString</code> is invalid.</p>
    WafInvalidRegexPatternException(crate::error::WafInvalidRegexPatternException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRegexPatternSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRegexPatternSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidRegexPatternException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRegexPatternSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidRegexPatternException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRegexPatternSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRegexPatternSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRegexPatternSetError {
    /// Creates the `UpdateRegexPatternSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRegexPatternSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidRegexPatternException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafInvalidRegexPatternException`.
    pub fn is_waf_invalid_regex_pattern_exception(&self) -> bool {
        matches!(self, Self::WafInvalidRegexPatternException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexPatternSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateRegexPatternSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidRegexPatternException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The regular expression (regex) you specified in <code>RegexPatternString</code> is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafInvalidRegexPatternException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafInvalidRegexPatternException {
    /// Creates a new builder-style object to manufacture [`WafInvalidRegexPatternException`](crate::error::WafInvalidRegexPatternException).
    pub fn builder() -> crate::error::waf_invalid_regex_pattern_exception::Builder {
        crate::error::waf_invalid_regex_pattern_exception::Builder::default()
    }
}
/// See [`WafInvalidRegexPatternException`](crate::error::WafInvalidRegexPatternException).
pub mod waf_invalid_regex_pattern_exception {

    /// A builder for [`WafInvalidRegexPatternException`](crate::error::WafInvalidRegexPatternException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafInvalidRegexPatternException`](crate::error::WafInvalidRegexPatternException).
        pub fn build(self) -> crate::error::WafInvalidRegexPatternException {
            crate::error::WafInvalidRegexPatternException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafInvalidRegexPatternException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafInvalidRegexPatternException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafInvalidRegexPatternException [WAFInvalidRegexPatternException]"
        )?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafInvalidRegexPatternException {}
impl aws_http::request_id::RequestId for crate::error::WafInvalidRegexPatternException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafInvalidRegexPatternException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRegexMatchSetErrorKind = UpdateRegexMatchSetError;
/// Error type for the `UpdateRegexMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRegexMatchSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRegexMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRegexMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRegexMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRegexMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRegexMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRegexMatchSetError {
    /// Creates the `UpdateRegexMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRegexMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRegexMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateRegexMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The name specified is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafDisallowedNameException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafDisallowedNameException {
    /// Creates a new builder-style object to manufacture [`WafDisallowedNameException`](crate::error::WafDisallowedNameException).
    pub fn builder() -> crate::error::waf_disallowed_name_exception::Builder {
        crate::error::waf_disallowed_name_exception::Builder::default()
    }
}
/// See [`WafDisallowedNameException`](crate::error::WafDisallowedNameException).
pub mod waf_disallowed_name_exception {

    /// A builder for [`WafDisallowedNameException`](crate::error::WafDisallowedNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafDisallowedNameException`](crate::error::WafDisallowedNameException).
        pub fn build(self) -> crate::error::WafDisallowedNameException {
            crate::error::WafDisallowedNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafDisallowedNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafDisallowedNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafDisallowedNameException [WAFDisallowedNameException]")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafDisallowedNameException {}
impl aws_http::request_id::RequestId for crate::error::WafDisallowedNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafDisallowedNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRateBasedRuleErrorKind = UpdateRateBasedRuleError;
/// Error type for the `UpdateRateBasedRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRateBasedRuleError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRateBasedRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRateBasedRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRateBasedRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRateBasedRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRateBasedRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRateBasedRuleError {
    /// Creates the `UpdateRateBasedRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRateBasedRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateRateBasedRuleError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateRateBasedRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateIPSetErrorKind = UpdateIPSetError;
/// Error type for the `UpdateIPSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIPSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateIPSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateIPSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateIPSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateIPSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateIPSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIPSetError {
    /// Creates the `UpdateIPSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateIPSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateIPSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateIPSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateGeoMatchSetErrorKind = UpdateGeoMatchSetError;
/// Error type for the `UpdateGeoMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGeoMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateGeoMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateGeoMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateGeoMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateGeoMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGeoMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGeoMatchSetError {
    /// Creates the `UpdateGeoMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateGeoMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateGeoMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateGeoMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateByteMatchSetErrorKind = UpdateByteMatchSetError;
/// Error type for the `UpdateByteMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateByteMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
    /// <ul>
    /// <li> <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code> that doesn't exist.</p> </li>
    /// </ul>
    WafNonexistentContainerException(crate::error::WafNonexistentContainerException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateByteMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateByteMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentContainerException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateByteMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentContainerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateByteMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateByteMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateByteMatchSetError {
    /// Creates the `UpdateByteMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateByteMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentContainerException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafNonexistentContainerException`.
    pub fn is_waf_nonexistent_container_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentContainerException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UpdateByteMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for UpdateByteMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentContainerException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafTagOperationInternalErrorException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafTagOperationInternalErrorException {
    /// Creates a new builder-style object to manufacture [`WafTagOperationInternalErrorException`](crate::error::WafTagOperationInternalErrorException).
    pub fn builder() -> crate::error::waf_tag_operation_internal_error_exception::Builder {
        crate::error::waf_tag_operation_internal_error_exception::Builder::default()
    }
}
/// See [`WafTagOperationInternalErrorException`](crate::error::WafTagOperationInternalErrorException).
pub mod waf_tag_operation_internal_error_exception {

    /// A builder for [`WafTagOperationInternalErrorException`](crate::error::WafTagOperationInternalErrorException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafTagOperationInternalErrorException`](crate::error::WafTagOperationInternalErrorException).
        pub fn build(self) -> crate::error::WafTagOperationInternalErrorException {
            crate::error::WafTagOperationInternalErrorException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafTagOperationInternalErrorException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafTagOperationInternalErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafTagOperationInternalErrorException [WAFTagOperationInternalErrorException]"
        )?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafTagOperationInternalErrorException {}
impl aws_http::request_id::RequestId for crate::error::WafTagOperationInternalErrorException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for WafTagOperationInternalErrorException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafTagOperationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafTagOperationException {
    /// Creates a new builder-style object to manufacture [`WafTagOperationException`](crate::error::WafTagOperationException).
    pub fn builder() -> crate::error::waf_tag_operation_exception::Builder {
        crate::error::waf_tag_operation_exception::Builder::default()
    }
}
/// See [`WafTagOperationException`](crate::error::WafTagOperationException).
pub mod waf_tag_operation_exception {

    /// A builder for [`WafTagOperationException`](crate::error::WafTagOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafTagOperationException`](crate::error::WafTagOperationException).
        pub fn build(self) -> crate::error::WafTagOperationException {
            crate::error::WafTagOperationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafTagOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafTagOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafTagOperationException [WAFTagOperationException]")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafTagOperationException {}
impl aws_http::request_id::RequestId for crate::error::WafTagOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafTagOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafBadRequestException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafBadRequestException {
    /// Creates a new builder-style object to manufacture [`WafBadRequestException`](crate::error::WafBadRequestException).
    pub fn builder() -> crate::error::waf_bad_request_exception::Builder {
        crate::error::waf_bad_request_exception::Builder::default()
    }
}
/// See [`WafBadRequestException`](crate::error::WafBadRequestException).
pub mod waf_bad_request_exception {

    /// A builder for [`WafBadRequestException`](crate::error::WafBadRequestException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafBadRequestException`](crate::error::WafBadRequestException).
        pub fn build(self) -> crate::error::WafBadRequestException {
            crate::error::WafBadRequestException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafBadRequestException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafBadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafBadRequestException [WAFBadRequestException]")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafBadRequestException {}
impl aws_http::request_id::RequestId for crate::error::WafBadRequestException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafBadRequestException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutPermissionPolicyErrorKind = PutPermissionPolicyError;
/// Error type for the `PutPermissionPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPermissionPolicyError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the specified policy is not in the proper format. </p>
    /// <p>The policy is subject to the following restrictions:</p>
    /// <ul>
    /// <li> <p>You can attach only one policy with each <code>PutPermissionPolicy</code> request.</p> </li>
    /// <li> <p>The policy must include an <code>Effect</code>, <code>Action</code> and <code>Principal</code>. </p> </li>
    /// <li> <p> <code>Effect</code> must specify <code>Allow</code>.</p> </li>
    /// <li> <p>The <code>Action</code> in the policy must be <code>waf:UpdateWebACL</code>, <code>waf-regional:UpdateWebACL</code>, <code>waf:GetRuleGroup</code> and <code>waf-regional:GetRuleGroup</code> . Any extra or wildcard actions in the policy will be rejected.</p> </li>
    /// <li> <p>The policy cannot include a <code>Resource</code> parameter.</p> </li>
    /// <li> <p>The ARN in the request must be a valid WAF RuleGroup ARN and the RuleGroup must exist in the same region.</p> </li>
    /// <li> <p>The user making the request must be the owner of the RuleGroup.</p> </li>
    /// <li> <p>Your policy must be composed using IAM Policy version 2012-10-17.</p> </li>
    /// </ul>
    WafInvalidPermissionPolicyException(crate::error::WafInvalidPermissionPolicyException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutPermissionPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutPermissionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidPermissionPolicyException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutPermissionPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidPermissionPolicyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutPermissionPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutPermissionPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPermissionPolicyError {
    /// Creates the `PutPermissionPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutPermissionPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidPermissionPolicyException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutPermissionPolicyError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionPolicyError::WafInvalidPermissionPolicyException`.
    pub fn is_waf_invalid_permission_policy_exception(&self) -> bool {
        matches!(self, Self::WafInvalidPermissionPolicyException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionPolicyError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionPolicyError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for PutPermissionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidPermissionPolicyException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation failed because the specified policy is not in the proper format. </p>
/// <p>The policy is subject to the following restrictions:</p>
/// <ul>
/// <li> <p>You can attach only one policy with each <code>PutPermissionPolicy</code> request.</p> </li>
/// <li> <p>The policy must include an <code>Effect</code>, <code>Action</code> and <code>Principal</code>. </p> </li>
/// <li> <p> <code>Effect</code> must specify <code>Allow</code>.</p> </li>
/// <li> <p>The <code>Action</code> in the policy must be <code>waf:UpdateWebACL</code>, <code>waf-regional:UpdateWebACL</code>, <code>waf:GetRuleGroup</code> and <code>waf-regional:GetRuleGroup</code> . Any extra or wildcard actions in the policy will be rejected.</p> </li>
/// <li> <p>The policy cannot include a <code>Resource</code> parameter.</p> </li>
/// <li> <p>The ARN in the request must be a valid WAF RuleGroup ARN and the RuleGroup must exist in the same region.</p> </li>
/// <li> <p>The user making the request must be the owner of the RuleGroup.</p> </li>
/// <li> <p>Your policy must be composed using IAM Policy version 2012-10-17.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafInvalidPermissionPolicyException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafInvalidPermissionPolicyException {
    /// Creates a new builder-style object to manufacture [`WafInvalidPermissionPolicyException`](crate::error::WafInvalidPermissionPolicyException).
    pub fn builder() -> crate::error::waf_invalid_permission_policy_exception::Builder {
        crate::error::waf_invalid_permission_policy_exception::Builder::default()
    }
}
/// See [`WafInvalidPermissionPolicyException`](crate::error::WafInvalidPermissionPolicyException).
pub mod waf_invalid_permission_policy_exception {

    /// A builder for [`WafInvalidPermissionPolicyException`](crate::error::WafInvalidPermissionPolicyException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafInvalidPermissionPolicyException`](crate::error::WafInvalidPermissionPolicyException).
        pub fn build(self) -> crate::error::WafInvalidPermissionPolicyException {
            crate::error::WafInvalidPermissionPolicyException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafInvalidPermissionPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafInvalidPermissionPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafInvalidPermissionPolicyException [WAFInvalidPermissionPolicyException]"
        )?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafInvalidPermissionPolicyException {}
impl aws_http::request_id::RequestId for crate::error::WafInvalidPermissionPolicyException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for WafInvalidPermissionPolicyException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutLoggingConfigurationErrorKind = PutLoggingConfigurationError;
/// Error type for the `PutLoggingConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutLoggingConfigurationError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>AWS WAF is not able to access the service linked role. This can be caused by a previous <code>PutLoggingConfiguration</code> request, which can lock the service linked role for about 20 seconds. Please try your request again. The service linked role can also be locked by a previous <code>DeleteServiceLinkedRole</code> request, which can lock the role for 15 minutes or more. If you recently made a <code>DeleteServiceLinkedRole</code>, wait at least 15 minutes and try the request again. If you receive this same exception again, you will have to wait additional time until the role is unlocked.</p>
    WafServiceLinkedRoleErrorException(crate::error::WafServiceLinkedRoleErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutLoggingConfigurationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafServiceLinkedRoleErrorException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutLoggingConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafServiceLinkedRoleErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutLoggingConfigurationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutLoggingConfigurationError {
    /// Creates the `PutLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafServiceLinkedRoleErrorException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutLoggingConfigurationError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `PutLoggingConfigurationError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `PutLoggingConfigurationError::WafServiceLinkedRoleErrorException`.
    pub fn is_waf_service_linked_role_error_exception(&self) -> bool {
        matches!(self, Self::WafServiceLinkedRoleErrorException(_))
    }
    /// Returns `true` if the error kind is `PutLoggingConfigurationError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for PutLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafServiceLinkedRoleErrorException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>AWS WAF is not able to access the service linked role. This can be caused by a previous <code>PutLoggingConfiguration</code> request, which can lock the service linked role for about 20 seconds. Please try your request again. The service linked role can also be locked by a previous <code>DeleteServiceLinkedRole</code> request, which can lock the role for 15 minutes or more. If you recently made a <code>DeleteServiceLinkedRole</code>, wait at least 15 minutes and try the request again. If you receive this same exception again, you will have to wait additional time until the role is unlocked.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafServiceLinkedRoleErrorException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafServiceLinkedRoleErrorException {
    /// Creates a new builder-style object to manufacture [`WafServiceLinkedRoleErrorException`](crate::error::WafServiceLinkedRoleErrorException).
    pub fn builder() -> crate::error::waf_service_linked_role_error_exception::Builder {
        crate::error::waf_service_linked_role_error_exception::Builder::default()
    }
}
/// See [`WafServiceLinkedRoleErrorException`](crate::error::WafServiceLinkedRoleErrorException).
pub mod waf_service_linked_role_error_exception {

    /// A builder for [`WafServiceLinkedRoleErrorException`](crate::error::WafServiceLinkedRoleErrorException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafServiceLinkedRoleErrorException`](crate::error::WafServiceLinkedRoleErrorException).
        pub fn build(self) -> crate::error::WafServiceLinkedRoleErrorException {
            crate::error::WafServiceLinkedRoleErrorException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafServiceLinkedRoleErrorException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafServiceLinkedRoleErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafServiceLinkedRoleErrorException [WAFServiceLinkedRoleErrorException]"
        )?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafServiceLinkedRoleErrorException {}
impl aws_http::request_id::RequestId for crate::error::WafServiceLinkedRoleErrorException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for WafServiceLinkedRoleErrorException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListXssMatchSetsErrorKind = ListXssMatchSetsError;
/// Error type for the `ListXssMatchSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListXssMatchSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListXssMatchSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListXssMatchSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListXssMatchSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListXssMatchSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListXssMatchSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListXssMatchSetsError {
    /// Creates the `ListXssMatchSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListXssMatchSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListXssMatchSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListXssMatchSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListXssMatchSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListWebACLsErrorKind = ListWebACLsError;
/// Error type for the `ListWebACLsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWebACLsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListWebACLsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListWebACLsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListWebACLsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListWebACLsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListWebACLsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWebACLsError {
    /// Creates the `ListWebACLsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListWebACLsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListWebACLsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListWebACLsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListWebACLsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListSubscribedRuleGroupsErrorKind = ListSubscribedRuleGroupsError;
/// Error type for the `ListSubscribedRuleGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSubscribedRuleGroupsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListSubscribedRuleGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListSubscribedRuleGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListSubscribedRuleGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListSubscribedRuleGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSubscribedRuleGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSubscribedRuleGroupsError {
    /// Creates the `ListSubscribedRuleGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListSubscribedRuleGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListSubscribedRuleGroupsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListSubscribedRuleGroupsError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for ListSubscribedRuleGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListSqlInjectionMatchSetsErrorKind = ListSqlInjectionMatchSetsError;
/// Error type for the `ListSqlInjectionMatchSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSqlInjectionMatchSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListSqlInjectionMatchSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListSqlInjectionMatchSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListSqlInjectionMatchSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListSqlInjectionMatchSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSqlInjectionMatchSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSqlInjectionMatchSetsError {
    /// Creates the `ListSqlInjectionMatchSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListSqlInjectionMatchSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListSqlInjectionMatchSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListSqlInjectionMatchSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListSqlInjectionMatchSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListSizeConstraintSetsErrorKind = ListSizeConstraintSetsError;
/// Error type for the `ListSizeConstraintSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSizeConstraintSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListSizeConstraintSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListSizeConstraintSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListSizeConstraintSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListSizeConstraintSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSizeConstraintSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSizeConstraintSetsError {
    /// Creates the `ListSizeConstraintSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListSizeConstraintSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListSizeConstraintSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListSizeConstraintSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListSizeConstraintSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRulesErrorKind = ListRulesError;
/// Error type for the `ListRulesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRulesError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRulesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRulesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRulesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRulesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRulesError {
    /// Creates the `ListRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRulesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRulesError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListRulesError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRuleGroupsErrorKind = ListRuleGroupsError;
/// Error type for the `ListRuleGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRuleGroupsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRuleGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRuleGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRuleGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRuleGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRuleGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRuleGroupsError {
    /// Creates the `ListRuleGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRuleGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRuleGroupsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
}
impl std::error::Error for ListRuleGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListResourcesForWebACLErrorKind = ListResourcesForWebACLError;
/// Error type for the `ListResourcesForWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourcesForWebACLError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListResourcesForWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListResourcesForWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListResourcesForWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListResourcesForWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListResourcesForWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourcesForWebACLError {
    /// Creates the `ListResourcesForWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListResourcesForWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListResourcesForWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListResourcesForWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `ListResourcesForWebACLError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListResourcesForWebACLError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for ListResourcesForWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRegexPatternSetsErrorKind = ListRegexPatternSetsError;
/// Error type for the `ListRegexPatternSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRegexPatternSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRegexPatternSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRegexPatternSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRegexPatternSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRegexPatternSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRegexPatternSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRegexPatternSetsError {
    /// Creates the `ListRegexPatternSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRegexPatternSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRegexPatternSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListRegexPatternSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListRegexPatternSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRegexMatchSetsErrorKind = ListRegexMatchSetsError;
/// Error type for the `ListRegexMatchSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRegexMatchSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRegexMatchSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRegexMatchSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRegexMatchSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRegexMatchSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRegexMatchSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRegexMatchSetsError {
    /// Creates the `ListRegexMatchSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRegexMatchSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRegexMatchSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListRegexMatchSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListRegexMatchSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRateBasedRulesErrorKind = ListRateBasedRulesError;
/// Error type for the `ListRateBasedRulesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRateBasedRulesError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRateBasedRulesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRateBasedRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRateBasedRulesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRateBasedRulesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRateBasedRulesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRateBasedRulesError {
    /// Creates the `ListRateBasedRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRateBasedRulesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRateBasedRulesError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListRateBasedRulesError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListRateBasedRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListLoggingConfigurationsErrorKind = ListLoggingConfigurationsError;
/// Error type for the `ListLoggingConfigurationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLoggingConfigurationsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListLoggingConfigurationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListLoggingConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListLoggingConfigurationsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListLoggingConfigurationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListLoggingConfigurationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLoggingConfigurationsError {
    /// Creates the `ListLoggingConfigurationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListLoggingConfigurationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListLoggingConfigurationsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListLoggingConfigurationsError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListLoggingConfigurationsError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for ListLoggingConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListIPSetsErrorKind = ListIPSetsError;
/// Error type for the `ListIPSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIPSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListIPSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListIPSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListIPSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListIPSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListIPSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIPSetsError {
    /// Creates the `ListIPSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListIPSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListIPSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListIPSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListIPSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListGeoMatchSetsErrorKind = ListGeoMatchSetsError;
/// Error type for the `ListGeoMatchSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGeoMatchSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListGeoMatchSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListGeoMatchSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListGeoMatchSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListGeoMatchSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGeoMatchSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGeoMatchSetsError {
    /// Creates the `ListGeoMatchSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListGeoMatchSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListGeoMatchSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListGeoMatchSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListGeoMatchSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListByteMatchSetsErrorKind = ListByteMatchSetsError;
/// Error type for the `ListByteMatchSetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListByteMatchSetsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListByteMatchSetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListByteMatchSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListByteMatchSetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListByteMatchSetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListByteMatchSetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListByteMatchSetsError {
    /// Creates the `ListByteMatchSetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListByteMatchSetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListByteMatchSetsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListByteMatchSetsError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
}
impl std::error::Error for ListByteMatchSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListActivatedRulesInRuleGroupErrorKind = ListActivatedRulesInRuleGroupError;
/// Error type for the `ListActivatedRulesInRuleGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListActivatedRulesInRuleGroupError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListActivatedRulesInRuleGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListActivatedRulesInRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListActivatedRulesInRuleGroupError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListActivatedRulesInRuleGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListActivatedRulesInRuleGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListActivatedRulesInRuleGroupError {
    /// Creates the `ListActivatedRulesInRuleGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListActivatedRulesInRuleGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListActivatedRulesInRuleGroupError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `ListActivatedRulesInRuleGroupError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListActivatedRulesInRuleGroupError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for ListActivatedRulesInRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetXssMatchSetErrorKind = GetXssMatchSetError;
/// Error type for the `GetXssMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetXssMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetXssMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetXssMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetXssMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetXssMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetXssMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetXssMatchSetError {
    /// Creates the `GetXssMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetXssMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetXssMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetXssMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetXssMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetXssMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetWebACLForResourceErrorKind = GetWebACLForResourceError;
/// Error type for the `GetWebACLForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWebACLForResourceError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because the entity referenced is temporarily unavailable. Retry your request.</p>
    WafUnavailableEntityException(crate::error::WafUnavailableEntityException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetWebACLForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetWebACLForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafUnavailableEntityException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetWebACLForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafUnavailableEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetWebACLForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetWebACLForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWebACLForResourceError {
    /// Creates the `GetWebACLForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetWebACLForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafUnavailableEntityException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetWebACLForResourceError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetWebACLForResourceError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetWebACLForResourceError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `GetWebACLForResourceError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `GetWebACLForResourceError::WafUnavailableEntityException`.
    pub fn is_waf_unavailable_entity_exception(&self) -> bool {
        matches!(self, Self::WafUnavailableEntityException(_))
    }
}
impl std::error::Error for GetWebACLForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafUnavailableEntityException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation failed because the entity referenced is temporarily unavailable. Retry your request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafUnavailableEntityException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafUnavailableEntityException {
    /// Creates a new builder-style object to manufacture [`WafUnavailableEntityException`](crate::error::WafUnavailableEntityException).
    pub fn builder() -> crate::error::waf_unavailable_entity_exception::Builder {
        crate::error::waf_unavailable_entity_exception::Builder::default()
    }
}
/// See [`WafUnavailableEntityException`](crate::error::WafUnavailableEntityException).
pub mod waf_unavailable_entity_exception {

    /// A builder for [`WafUnavailableEntityException`](crate::error::WafUnavailableEntityException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafUnavailableEntityException`](crate::error::WafUnavailableEntityException).
        pub fn build(self) -> crate::error::WafUnavailableEntityException {
            crate::error::WafUnavailableEntityException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafUnavailableEntityException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafUnavailableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafUnavailableEntityException [WAFUnavailableEntityException]"
        )?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafUnavailableEntityException {}
impl aws_http::request_id::RequestId for crate::error::WafUnavailableEntityException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafUnavailableEntityException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetWebACLErrorKind = GetWebACLError;
/// Error type for the `GetWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWebACLError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWebACLError {
    /// Creates the `GetWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetWebACLError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetSqlInjectionMatchSetErrorKind = GetSqlInjectionMatchSetError;
/// Error type for the `GetSqlInjectionMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSqlInjectionMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetSqlInjectionMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetSqlInjectionMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetSqlInjectionMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetSqlInjectionMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSqlInjectionMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSqlInjectionMatchSetError {
    /// Creates the `GetSqlInjectionMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetSqlInjectionMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetSqlInjectionMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetSqlInjectionMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetSqlInjectionMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetSqlInjectionMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetSizeConstraintSetErrorKind = GetSizeConstraintSetError;
/// Error type for the `GetSizeConstraintSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSizeConstraintSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetSizeConstraintSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetSizeConstraintSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetSizeConstraintSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetSizeConstraintSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSizeConstraintSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSizeConstraintSetError {
    /// Creates the `GetSizeConstraintSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetSizeConstraintSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetSizeConstraintSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetSizeConstraintSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetSizeConstraintSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetSizeConstraintSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetSampledRequestsErrorKind = GetSampledRequestsError;
/// Error type for the `GetSampledRequestsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSampledRequestsError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetSampledRequestsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetSampledRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetSampledRequestsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetSampledRequestsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSampledRequestsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSampledRequestsError {
    /// Creates the `GetSampledRequestsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetSampledRequestsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetSampledRequestsError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetSampledRequestsError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetSampledRequestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRuleGroupErrorKind = GetRuleGroupError;
/// Error type for the `GetRuleGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRuleGroupError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRuleGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRuleGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRuleGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRuleGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRuleGroupError {
    /// Creates the `GetRuleGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRuleGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRuleGroupError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetRuleGroupError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRuleErrorKind = GetRuleError;
/// Error type for the `GetRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRuleError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRuleError {
    /// Creates the `GetRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetRuleError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetRuleError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRegexPatternSetErrorKind = GetRegexPatternSetError;
/// Error type for the `GetRegexPatternSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegexPatternSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRegexPatternSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRegexPatternSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRegexPatternSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRegexPatternSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRegexPatternSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRegexPatternSetError {
    /// Creates the `GetRegexPatternSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRegexPatternSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRegexPatternSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetRegexPatternSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetRegexPatternSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetRegexPatternSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRegexMatchSetErrorKind = GetRegexMatchSetError;
/// Error type for the `GetRegexMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegexMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRegexMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRegexMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRegexMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRegexMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRegexMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRegexMatchSetError {
    /// Creates the `GetRegexMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRegexMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRegexMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetRegexMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetRegexMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetRegexMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRateBasedRuleManagedKeysErrorKind = GetRateBasedRuleManagedKeysError;
/// Error type for the `GetRateBasedRuleManagedKeysError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRateBasedRuleManagedKeysError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRateBasedRuleManagedKeysError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRateBasedRuleManagedKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRateBasedRuleManagedKeysError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRateBasedRuleManagedKeysError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRateBasedRuleManagedKeysError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRateBasedRuleManagedKeysError {
    /// Creates the `GetRateBasedRuleManagedKeysError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRateBasedRuleManagedKeysError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleManagedKeysError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleManagedKeysError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleManagedKeysError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleManagedKeysError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetRateBasedRuleManagedKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRateBasedRuleErrorKind = GetRateBasedRuleError;
/// Error type for the `GetRateBasedRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRateBasedRuleError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRateBasedRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRateBasedRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRateBasedRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRateBasedRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRateBasedRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRateBasedRuleError {
    /// Creates the `GetRateBasedRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRateBasedRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetRateBasedRuleError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetRateBasedRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetPermissionPolicyErrorKind = GetPermissionPolicyError;
/// Error type for the `GetPermissionPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPermissionPolicyError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPermissionPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetPermissionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPermissionPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPermissionPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPermissionPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPermissionPolicyError {
    /// Creates the `GetPermissionPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetPermissionPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPermissionPolicyError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetPermissionPolicyError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetPermissionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetLoggingConfigurationErrorKind = GetLoggingConfigurationError;
/// Error type for the `GetLoggingConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoggingConfigurationError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetLoggingConfigurationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetLoggingConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetLoggingConfigurationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoggingConfigurationError {
    /// Creates the `GetLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetLoggingConfigurationError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetLoggingConfigurationError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetIPSetErrorKind = GetIPSetError;
/// Error type for the `GetIPSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIPSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetIPSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetIPSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetIPSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetIPSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetIPSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIPSetError {
    /// Creates the `GetIPSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetIPSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetIPSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetIPSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetIPSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetIPSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetGeoMatchSetErrorKind = GetGeoMatchSetError;
/// Error type for the `GetGeoMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGeoMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetGeoMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetGeoMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetGeoMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetGeoMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGeoMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGeoMatchSetError {
    /// Creates the `GetGeoMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetGeoMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetGeoMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetGeoMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetGeoMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetGeoMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetChangeTokenStatusErrorKind = GetChangeTokenStatusError;
/// Error type for the `GetChangeTokenStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetChangeTokenStatusError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetChangeTokenStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetChangeTokenStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetChangeTokenStatusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetChangeTokenStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetChangeTokenStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetChangeTokenStatusError {
    /// Creates the `GetChangeTokenStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetChangeTokenStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetChangeTokenStatusError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetChangeTokenStatusError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetChangeTokenStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetChangeTokenErrorKind = GetChangeTokenError;
/// Error type for the `GetChangeTokenError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetChangeTokenError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetChangeTokenError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetChangeTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetChangeTokenError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetChangeTokenError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetChangeTokenError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetChangeTokenError {
    /// Creates the `GetChangeTokenError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetChangeTokenError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetChangeTokenError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
}
impl std::error::Error for GetChangeTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetByteMatchSetErrorKind = GetByteMatchSetError;
/// Error type for the `GetByteMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetByteMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetByteMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetByteMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetByteMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetByteMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetByteMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetByteMatchSetError {
    /// Creates the `GetByteMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetByteMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetByteMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `GetByteMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `GetByteMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for GetByteMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisassociateWebACLErrorKind = DisassociateWebACLError;
/// Error type for the `DisassociateWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateWebACLError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociateWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisassociateWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisassociateWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisassociateWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociateWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateWebACLError {
    /// Creates the `DisassociateWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisassociateWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisassociateWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DisassociateWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DisassociateWebACLError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DisassociateWebACLError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for DisassociateWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteXssMatchSetErrorKind = DeleteXssMatchSetError;
/// Error type for the `DeleteXssMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteXssMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteXssMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteXssMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteXssMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteXssMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteXssMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteXssMatchSetError {
    /// Creates the `DeleteXssMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteXssMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteXssMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteXssMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteXssMatchSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteXssMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteXssMatchSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteXssMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteXssMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
/// <ul>
/// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
/// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
/// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
/// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafNonEmptyEntityException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafNonEmptyEntityException {
    /// Creates a new builder-style object to manufacture [`WafNonEmptyEntityException`](crate::error::WafNonEmptyEntityException).
    pub fn builder() -> crate::error::waf_non_empty_entity_exception::Builder {
        crate::error::waf_non_empty_entity_exception::Builder::default()
    }
}
/// See [`WafNonEmptyEntityException`](crate::error::WafNonEmptyEntityException).
pub mod waf_non_empty_entity_exception {

    /// A builder for [`WafNonEmptyEntityException`](crate::error::WafNonEmptyEntityException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafNonEmptyEntityException`](crate::error::WafNonEmptyEntityException).
        pub fn build(self) -> crate::error::WafNonEmptyEntityException {
            crate::error::WafNonEmptyEntityException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafNonEmptyEntityException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafNonEmptyEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WafNonEmptyEntityException [WAFNonEmptyEntityException]")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafNonEmptyEntityException {}
impl aws_http::request_id::RequestId for crate::error::WafNonEmptyEntityException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafNonEmptyEntityException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteWebACLErrorKind = DeleteWebACLError;
/// Error type for the `DeleteWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWebACLError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWebACLError {
    /// Creates the `DeleteWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteWebACLError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for DeleteWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSqlInjectionMatchSetErrorKind = DeleteSqlInjectionMatchSetError;
/// Error type for the `DeleteSqlInjectionMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSqlInjectionMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSqlInjectionMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSqlInjectionMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSqlInjectionMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSqlInjectionMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSqlInjectionMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSqlInjectionMatchSetError {
    /// Creates the `DeleteSqlInjectionMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSqlInjectionMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSqlInjectionMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteSqlInjectionMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteSqlInjectionMatchSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteSqlInjectionMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteSqlInjectionMatchSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteSqlInjectionMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteSqlInjectionMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSizeConstraintSetErrorKind = DeleteSizeConstraintSetError;
/// Error type for the `DeleteSizeConstraintSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSizeConstraintSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSizeConstraintSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSizeConstraintSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSizeConstraintSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSizeConstraintSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSizeConstraintSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSizeConstraintSetError {
    /// Creates the `DeleteSizeConstraintSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSizeConstraintSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSizeConstraintSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteSizeConstraintSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteSizeConstraintSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteSizeConstraintSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteSizeConstraintSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteSizeConstraintSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteSizeConstraintSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRuleGroupErrorKind = DeleteRuleGroupError;
/// Error type for the `DeleteRuleGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRuleGroupError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRuleGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRuleGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRuleGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRuleGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRuleGroupError {
    /// Creates the `DeleteRuleGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRuleGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleGroupError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for DeleteRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRuleErrorKind = DeleteRuleError;
/// Error type for the `DeleteRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRuleError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRuleError {
    /// Creates the `DeleteRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteRuleError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for DeleteRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRegexPatternSetErrorKind = DeleteRegexPatternSetError;
/// Error type for the `DeleteRegexPatternSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRegexPatternSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRegexPatternSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRegexPatternSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRegexPatternSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRegexPatternSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRegexPatternSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRegexPatternSetError {
    /// Creates the `DeleteRegexPatternSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRegexPatternSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRegexPatternSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexPatternSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexPatternSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexPatternSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexPatternSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexPatternSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteRegexPatternSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRegexMatchSetErrorKind = DeleteRegexMatchSetError;
/// Error type for the `DeleteRegexMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRegexMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRegexMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRegexMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRegexMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRegexMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRegexMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRegexMatchSetError {
    /// Creates the `DeleteRegexMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRegexMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRegexMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexMatchSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexMatchSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRegexMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteRegexMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRateBasedRuleErrorKind = DeleteRateBasedRuleError;
/// Error type for the `DeleteRateBasedRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRateBasedRuleError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRateBasedRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRateBasedRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRateBasedRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRateBasedRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRateBasedRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRateBasedRuleError {
    /// Creates the `DeleteRateBasedRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRateBasedRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteRateBasedRuleError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for DeleteRateBasedRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeletePermissionPolicyErrorKind = DeletePermissionPolicyError;
/// Error type for the `DeletePermissionPolicyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePermissionPolicyError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePermissionPolicyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeletePermissionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeletePermissionPolicyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeletePermissionPolicyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePermissionPolicyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePermissionPolicyError {
    /// Creates the `DeletePermissionPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeletePermissionPolicyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeletePermissionPolicyError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionPolicyError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionPolicyError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeletePermissionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteLoggingConfigurationErrorKind = DeleteLoggingConfigurationError;
/// Error type for the `DeleteLoggingConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLoggingConfigurationError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteLoggingConfigurationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteLoggingConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteLoggingConfigurationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLoggingConfigurationError {
    /// Creates the `DeleteLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteLoggingConfigurationError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteLoggingConfigurationError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteLoggingConfigurationError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteIPSetErrorKind = DeleteIPSetError;
/// Error type for the `DeleteIPSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIPSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteIPSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteIPSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteIPSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteIPSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteIPSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIPSetError {
    /// Creates the `DeleteIPSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteIPSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteIPSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteIPSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteIPSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteIPSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteIPSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteIPSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteIPSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteGeoMatchSetErrorKind = DeleteGeoMatchSetError;
/// Error type for the `DeleteGeoMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGeoMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteGeoMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteGeoMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteGeoMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteGeoMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteGeoMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGeoMatchSetError {
    /// Creates the `DeleteGeoMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteGeoMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteGeoMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteGeoMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteGeoMatchSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteGeoMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteGeoMatchSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteGeoMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteGeoMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteByteMatchSetErrorKind = DeleteByteMatchSetError;
/// Error type for the `DeleteByteMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteByteMatchSetError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects or other predicates.</p> </li>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p> </li>
    /// <li> <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p> </li>
    /// </ul>
    WafNonEmptyEntityException(crate::error::WafNonEmptyEntityException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
    /// <ul>
    /// <li> <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p> </li>
    /// <li> <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p> </li>
    /// </ul>
    WafReferencedItemException(crate::error::WafReferencedItemException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteByteMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteByteMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafNonEmptyEntityException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafReferencedItemException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteByteMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonEmptyEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafReferencedItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteByteMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteByteMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteByteMatchSetError {
    /// Creates the `DeleteByteMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteByteMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafNonEmptyEntityException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafReferencedItemException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteByteMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `DeleteByteMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `DeleteByteMatchSetError::WafNonEmptyEntityException`.
    pub fn is_waf_non_empty_entity_exception(&self) -> bool {
        matches!(self, Self::WafNonEmptyEntityException(_))
    }
    /// Returns `true` if the error kind is `DeleteByteMatchSetError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteByteMatchSetError::WafReferencedItemException`.
    pub fn is_waf_referenced_item_exception(&self) -> bool {
        matches!(self, Self::WafReferencedItemException(_))
    }
    /// Returns `true` if the error kind is `DeleteByteMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for DeleteByteMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafNonEmptyEntityException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafReferencedItemException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateXssMatchSetErrorKind = CreateXssMatchSetError;
/// Error type for the `CreateXssMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateXssMatchSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateXssMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateXssMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateXssMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateXssMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateXssMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateXssMatchSetError {
    /// Creates the `CreateXssMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateXssMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateXssMatchSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateXssMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateXssMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateXssMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateXssMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateXssMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateXssMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateWebACLMigrationStackErrorKind = CreateWebACLMigrationStackError;
/// Error type for the `CreateWebACLMigrationStackError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWebACLMigrationStackError {
    /// <p>The operation failed due to a problem with the migration. The failure cause is provided in the exception, in the <code>MigrationErrorType</code>: </p>
    /// <ul>
    /// <li> <p> <code>ENTITY_NOT_SUPPORTED</code> - The web ACL has an unsupported entity but the <code>IgnoreUnsupportedType</code> is not set to true.</p> </li>
    /// <li> <p> <code>ENTITY_NOT_FOUND</code> - The web ACL doesn't exist. </p> </li>
    /// <li> <p> <code>S3_BUCKET_NO_PERMISSION</code> - You don't have permission to perform the <code>PutObject</code> action to the specified Amazon S3 bucket.</p> </li>
    /// <li> <p> <code>S3_BUCKET_NOT_ACCESSIBLE</code> - The bucket policy doesn't allow AWS WAF to perform the <code>PutObject</code> action in the bucket.</p> </li>
    /// <li> <p> <code>S3_BUCKET_NOT_FOUND</code> - The S3 bucket doesn't exist. </p> </li>
    /// <li> <p> <code>S3_BUCKET_INVALID_REGION</code> - The S3 bucket is not in the same Region as the web ACL.</p> </li>
    /// <li> <p> <code>S3_INTERNAL_ERROR</code> - AWS WAF failed to create the template in the S3 bucket for another reason.</p> </li>
    /// </ul>
    WafEntityMigrationException(crate::error::WafEntityMigrationException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because there was nothing to do. For example:</p>
    /// <ul>
    /// <li> <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p> </li>
    /// <li> <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> isn't in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// <li> <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code> already exists in the specified <code>WebACL</code>.</p> </li>
    /// </ul>
    WafInvalidOperationException(crate::error::WafInvalidOperationException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateWebACLMigrationStackError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateWebACLMigrationStackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafEntityMigrationException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidOperationException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateWebACLMigrationStackError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafEntityMigrationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateWebACLMigrationStackError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateWebACLMigrationStackError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWebACLMigrationStackError {
    /// Creates the `CreateWebACLMigrationStackError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateWebACLMigrationStackError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafEntityMigrationException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidOperationException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateWebACLMigrationStackError::WafEntityMigrationException`.
    pub fn is_waf_entity_migration_exception(&self) -> bool {
        matches!(self, Self::WafEntityMigrationException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLMigrationStackError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLMigrationStackError::WafInvalidOperationException`.
    pub fn is_waf_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::WafInvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLMigrationStackError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLMigrationStackError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
}
impl std::error::Error for CreateWebACLMigrationStackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafEntityMigrationException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidOperationException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation failed due to a problem with the migration. The failure cause is provided in the exception, in the <code>MigrationErrorType</code>: </p>
/// <ul>
/// <li> <p> <code>ENTITY_NOT_SUPPORTED</code> - The web ACL has an unsupported entity but the <code>IgnoreUnsupportedType</code> is not set to true.</p> </li>
/// <li> <p> <code>ENTITY_NOT_FOUND</code> - The web ACL doesn't exist. </p> </li>
/// <li> <p> <code>S3_BUCKET_NO_PERMISSION</code> - You don't have permission to perform the <code>PutObject</code> action to the specified Amazon S3 bucket.</p> </li>
/// <li> <p> <code>S3_BUCKET_NOT_ACCESSIBLE</code> - The bucket policy doesn't allow AWS WAF to perform the <code>PutObject</code> action in the bucket.</p> </li>
/// <li> <p> <code>S3_BUCKET_NOT_FOUND</code> - The S3 bucket doesn't exist. </p> </li>
/// <li> <p> <code>S3_BUCKET_INVALID_REGION</code> - The S3 bucket is not in the same Region as the web ACL.</p> </li>
/// <li> <p> <code>S3_INTERNAL_ERROR</code> - AWS WAF failed to create the template in the S3 bucket for another reason.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WafEntityMigrationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub migration_error_type: std::option::Option<crate::model::MigrationErrorType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub migration_error_reason: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WafEntityMigrationException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn migration_error_type(&self) -> std::option::Option<&crate::model::MigrationErrorType> {
        self.migration_error_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn migration_error_reason(&self) -> std::option::Option<&str> {
        self.migration_error_reason.as_deref()
    }
}
impl WafEntityMigrationException {
    /// Creates a new builder-style object to manufacture [`WafEntityMigrationException`](crate::error::WafEntityMigrationException).
    pub fn builder() -> crate::error::waf_entity_migration_exception::Builder {
        crate::error::waf_entity_migration_exception::Builder::default()
    }
}
/// See [`WafEntityMigrationException`](crate::error::WafEntityMigrationException).
pub mod waf_entity_migration_exception {

    /// A builder for [`WafEntityMigrationException`](crate::error::WafEntityMigrationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) migration_error_type: std::option::Option<crate::model::MigrationErrorType>,
        pub(crate) migration_error_reason: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn migration_error_type(mut self, input: crate::model::MigrationErrorType) -> Self {
            self.migration_error_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_migration_error_type(
            mut self,
            input: std::option::Option<crate::model::MigrationErrorType>,
        ) -> Self {
            self.migration_error_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn migration_error_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.migration_error_reason = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_migration_error_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.migration_error_reason = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`WafEntityMigrationException`](crate::error::WafEntityMigrationException).
        pub fn build(self) -> crate::error::WafEntityMigrationException {
            crate::error::WafEntityMigrationException {
                message: self.message,
                migration_error_type: self.migration_error_type,
                migration_error_reason: self.migration_error_reason,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl WafEntityMigrationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WafEntityMigrationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WafEntityMigrationException [WAFEntityMigrationException]"
        )?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WafEntityMigrationException {}
impl aws_http::request_id::RequestId for crate::error::WafEntityMigrationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WafEntityMigrationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateWebACLErrorKind = CreateWebACLError;
/// Error type for the `CreateWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWebACLError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWebACLError {
    /// Creates the `CreateWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateWebACLError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for CreateWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSqlInjectionMatchSetErrorKind = CreateSqlInjectionMatchSetError;
/// Error type for the `CreateSqlInjectionMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSqlInjectionMatchSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSqlInjectionMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSqlInjectionMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSqlInjectionMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSqlInjectionMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSqlInjectionMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSqlInjectionMatchSetError {
    /// Creates the `CreateSqlInjectionMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSqlInjectionMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSqlInjectionMatchSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateSqlInjectionMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateSqlInjectionMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateSqlInjectionMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateSqlInjectionMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateSqlInjectionMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateSqlInjectionMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSizeConstraintSetErrorKind = CreateSizeConstraintSetError;
/// Error type for the `CreateSizeConstraintSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSizeConstraintSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSizeConstraintSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSizeConstraintSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSizeConstraintSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSizeConstraintSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSizeConstraintSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSizeConstraintSetError {
    /// Creates the `CreateSizeConstraintSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSizeConstraintSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSizeConstraintSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateSizeConstraintSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateSizeConstraintSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateSizeConstraintSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateSizeConstraintSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateSizeConstraintSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateSizeConstraintSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRuleGroupErrorKind = CreateRuleGroupError;
/// Error type for the `CreateRuleGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRuleGroupError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRuleGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRuleGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRuleGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRuleGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRuleGroupError {
    /// Creates the `CreateRuleGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRuleGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleGroupError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for CreateRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRuleErrorKind = CreateRuleError;
/// Error type for the `CreateRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRuleError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRuleError {
    /// Creates the `CreateRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateRuleError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for CreateRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRegexPatternSetErrorKind = CreateRegexPatternSetError;
/// Error type for the `CreateRegexPatternSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRegexPatternSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRegexPatternSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRegexPatternSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRegexPatternSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRegexPatternSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRegexPatternSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRegexPatternSetError {
    /// Creates the `CreateRegexPatternSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRegexPatternSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRegexPatternSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateRegexPatternSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateRegexPatternSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRegexPatternSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateRegexPatternSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRegexMatchSetErrorKind = CreateRegexMatchSetError;
/// Error type for the `CreateRegexMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRegexMatchSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRegexMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRegexMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRegexMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRegexMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRegexMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRegexMatchSetError {
    /// Creates the `CreateRegexMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRegexMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRegexMatchSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateRegexMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateRegexMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRegexMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateRegexMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRateBasedRuleErrorKind = CreateRateBasedRuleError;
/// Error type for the `CreateRateBasedRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRateBasedRuleError {
    /// <p></p>
    WafBadRequestException(crate::error::WafBadRequestException),
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// <p></p>
    WafTagOperationException(crate::error::WafTagOperationException),
    /// <p></p>
    WafTagOperationInternalErrorException(crate::error::WafTagOperationInternalErrorException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRateBasedRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRateBasedRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafBadRequestException(_inner) => _inner.fmt(f),
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::WafTagOperationException(_inner) => _inner.fmt(f),
            Self::WafTagOperationInternalErrorException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRateBasedRuleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafBadRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafTagOperationInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRateBasedRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRateBasedRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRateBasedRuleError {
    /// Creates the `CreateRateBasedRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRateBasedRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafBadRequestException(e) => e.meta(),
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::WafTagOperationException(e) => e.meta(),
            Self::WafTagOperationInternalErrorException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafBadRequestException`.
    pub fn is_waf_bad_request_exception(&self) -> bool {
        matches!(self, Self::WafBadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafTagOperationException`.
    pub fn is_waf_tag_operation_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateRateBasedRuleError::WafTagOperationInternalErrorException`.
    pub fn is_waf_tag_operation_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafTagOperationInternalErrorException(_))
    }
}
impl std::error::Error for CreateRateBasedRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafBadRequestException(_inner) => Some(_inner),
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::WafTagOperationException(_inner) => Some(_inner),
            Self::WafTagOperationInternalErrorException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateIPSetErrorKind = CreateIPSetError;
/// Error type for the `CreateIPSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIPSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateIPSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateIPSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateIPSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateIPSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateIPSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIPSetError {
    /// Creates the `CreateIPSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateIPSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateIPSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateIPSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateIPSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateIPSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateIPSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateIPSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateIPSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateGeoMatchSetErrorKind = CreateGeoMatchSetError;
/// Error type for the `CreateGeoMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGeoMatchSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateGeoMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateGeoMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateGeoMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateGeoMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGeoMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGeoMatchSetError {
    /// Creates the `CreateGeoMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateGeoMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateGeoMatchSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateGeoMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateGeoMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateGeoMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateGeoMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateGeoMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateGeoMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateByteMatchSetErrorKind = CreateByteMatchSetError;
/// Error type for the `CreateByteMatchSetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateByteMatchSetError {
    /// <p>The name specified is invalid.</p>
    WafDisallowedNameException(crate::error::WafDisallowedNameException),
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create for an AWS account. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
    WafLimitsExceededException(crate::error::WafLimitsExceededException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
    WafStaleDataException(crate::error::WafStaleDataException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateByteMatchSetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateByteMatchSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafDisallowedNameException(_inner) => _inner.fmt(f),
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafLimitsExceededException(_inner) => _inner.fmt(f),
            Self::WafStaleDataException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateByteMatchSetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafDisallowedNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafLimitsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafStaleDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateByteMatchSetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateByteMatchSetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateByteMatchSetError {
    /// Creates the `CreateByteMatchSetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateByteMatchSetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafDisallowedNameException(e) => e.meta(),
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafLimitsExceededException(e) => e.meta(),
            Self::WafStaleDataException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateByteMatchSetError::WafDisallowedNameException`.
    pub fn is_waf_disallowed_name_exception(&self) -> bool {
        matches!(self, Self::WafDisallowedNameException(_))
    }
    /// Returns `true` if the error kind is `CreateByteMatchSetError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `CreateByteMatchSetError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateByteMatchSetError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateByteMatchSetError::WafLimitsExceededException`.
    pub fn is_waf_limits_exceeded_exception(&self) -> bool {
        matches!(self, Self::WafLimitsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateByteMatchSetError::WafStaleDataException`.
    pub fn is_waf_stale_data_exception(&self) -> bool {
        matches!(self, Self::WafStaleDataException(_))
    }
}
impl std::error::Error for CreateByteMatchSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafDisallowedNameException(_inner) => Some(_inner),
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafLimitsExceededException(_inner) => Some(_inner),
            Self::WafStaleDataException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AssociateWebACLErrorKind = AssociateWebACLError;
/// Error type for the `AssociateWebACLError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateWebACLError {
    /// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
    WafInternalErrorException(crate::error::WafInternalErrorException),
    /// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
    WafInvalidAccountException(crate::error::WafInvalidAccountException),
    /// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
    /// <ul>
    /// <li> <p>You specified an invalid parameter name.</p> </li>
    /// <li> <p>You specified an invalid value.</p> </li>
    /// <li> <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>) using an action other than <code>INSERT</code> or <code>DELETE</code>.</p> </li>
    /// <li> <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p> </li>
    /// <li> <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code> <code>Type</code> other than <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code> <code>Type</code> other than HEADER, METHOD, QUERY_STRING, URI, or BODY.</p> </li>
    /// <li> <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code> but no value for <code>Data</code>.</p> </li>
    /// <li> <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p> </li>
    /// </ul>
    WafInvalidParameterException(crate::error::WafInvalidParameterException),
    /// <p>The operation failed because the referenced object doesn't exist.</p>
    WafNonexistentItemException(crate::error::WafNonexistentItemException),
    /// <p>The operation failed because the entity referenced is temporarily unavailable. Retry your request.</p>
    WafUnavailableEntityException(crate::error::WafUnavailableEntityException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateWebACLError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AssociateWebACLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::WafInternalErrorException(_inner) => _inner.fmt(f),
            Self::WafInvalidAccountException(_inner) => _inner.fmt(f),
            Self::WafInvalidParameterException(_inner) => _inner.fmt(f),
            Self::WafNonexistentItemException(_inner) => _inner.fmt(f),
            Self::WafUnavailableEntityException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AssociateWebACLError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::WafInternalErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidAccountException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafInvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafNonexistentItemException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::WafUnavailableEntityException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AssociateWebACLError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateWebACLError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateWebACLError {
    /// Creates the `AssociateWebACLError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AssociateWebACLError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::WafInternalErrorException(e) => e.meta(),
            Self::WafInvalidAccountException(e) => e.meta(),
            Self::WafInvalidParameterException(e) => e.meta(),
            Self::WafNonexistentItemException(e) => e.meta(),
            Self::WafUnavailableEntityException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociateWebACLError::WafInternalErrorException`.
    pub fn is_waf_internal_error_exception(&self) -> bool {
        matches!(self, Self::WafInternalErrorException(_))
    }
    /// Returns `true` if the error kind is `AssociateWebACLError::WafInvalidAccountException`.
    pub fn is_waf_invalid_account_exception(&self) -> bool {
        matches!(self, Self::WafInvalidAccountException(_))
    }
    /// Returns `true` if the error kind is `AssociateWebACLError::WafInvalidParameterException`.
    pub fn is_waf_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::WafInvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `AssociateWebACLError::WafNonexistentItemException`.
    pub fn is_waf_nonexistent_item_exception(&self) -> bool {
        matches!(self, Self::WafNonexistentItemException(_))
    }
    /// Returns `true` if the error kind is `AssociateWebACLError::WafUnavailableEntityException`.
    pub fn is_waf_unavailable_entity_exception(&self) -> bool {
        matches!(self, Self::WafUnavailableEntityException(_))
    }
}
impl std::error::Error for AssociateWebACLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::WafInternalErrorException(_inner) => Some(_inner),
            Self::WafInvalidAccountException(_inner) => Some(_inner),
            Self::WafInvalidParameterException(_inner) => Some(_inner),
            Self::WafNonexistentItemException(_inner) => Some(_inner),
            Self::WafUnavailableEntityException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
