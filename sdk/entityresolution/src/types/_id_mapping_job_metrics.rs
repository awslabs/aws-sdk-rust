// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object that contains metrics about an ID mapping job, including counts of input records, processed records, and mapped records between source and target identifiers.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IdMappingJobMetrics {
    /// <p>The total number of records that were input for processing.</p>
    pub input_records: ::std::option::Option<i32>,
    /// <p>The total number of records that were processed.</p>
    pub total_records_processed: ::std::option::Option<i32>,
    /// <p>The total number of records that did not get processed.</p>
    pub records_not_processed: ::std::option::Option<i32>,
    /// <p>The number of records processed that were marked for deletion in the input file using the DELETE schema mapping field. These are the records to be removed from the ID mapping table.</p>
    pub delete_records_processed: ::std::option::Option<i32>,
    /// <p>The total number of records that were mapped.</p>
    pub total_mapped_records: ::std::option::Option<i32>,
    /// <p>The total number of mapped source records.</p>
    pub total_mapped_source_records: ::std::option::Option<i32>,
    /// <p>The total number of distinct mapped target records.</p>
    pub total_mapped_target_records: ::std::option::Option<i32>,
    /// <p>The number of de-duplicated processed records across all runs, excluding deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if you specified "customer_id" as a UNIQUE_ID field and had three records with the same customer_id value, they would count as one unique record in this metric.</p>
    pub unique_records_loaded: ::std::option::Option<i32>,
    /// <p>The number of new mapped records.</p>
    pub new_mapped_records: ::std::option::Option<i32>,
    /// <p>The number of new source records mapped.</p>
    pub new_mapped_source_records: ::std::option::Option<i32>,
    /// <p>The number of new mapped target records.</p>
    pub new_mapped_target_records: ::std::option::Option<i32>,
    /// <p>The number of new unique records processed in the current job run, after removing duplicates. This metric excludes deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if your current run processes five new records with the same UNIQUE_ID value, they would count as one new unique record in this metric.</p>
    pub new_unique_records_loaded: ::std::option::Option<i32>,
    /// <p>The number of mapped records removed.</p>
    pub mapped_records_removed: ::std::option::Option<i32>,
    /// <p>The number of source records removed due to ID mapping.</p>
    pub mapped_source_records_removed: ::std::option::Option<i32>,
    /// <p>The number of mapped target records removed.</p>
    pub mapped_target_records_removed: ::std::option::Option<i32>,
}
impl IdMappingJobMetrics {
    /// <p>The total number of records that were input for processing.</p>
    pub fn input_records(&self) -> ::std::option::Option<i32> {
        self.input_records
    }
    /// <p>The total number of records that were processed.</p>
    pub fn total_records_processed(&self) -> ::std::option::Option<i32> {
        self.total_records_processed
    }
    /// <p>The total number of records that did not get processed.</p>
    pub fn records_not_processed(&self) -> ::std::option::Option<i32> {
        self.records_not_processed
    }
    /// <p>The number of records processed that were marked for deletion in the input file using the DELETE schema mapping field. These are the records to be removed from the ID mapping table.</p>
    pub fn delete_records_processed(&self) -> ::std::option::Option<i32> {
        self.delete_records_processed
    }
    /// <p>The total number of records that were mapped.</p>
    pub fn total_mapped_records(&self) -> ::std::option::Option<i32> {
        self.total_mapped_records
    }
    /// <p>The total number of mapped source records.</p>
    pub fn total_mapped_source_records(&self) -> ::std::option::Option<i32> {
        self.total_mapped_source_records
    }
    /// <p>The total number of distinct mapped target records.</p>
    pub fn total_mapped_target_records(&self) -> ::std::option::Option<i32> {
        self.total_mapped_target_records
    }
    /// <p>The number of de-duplicated processed records across all runs, excluding deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if you specified "customer_id" as a UNIQUE_ID field and had three records with the same customer_id value, they would count as one unique record in this metric.</p>
    pub fn unique_records_loaded(&self) -> ::std::option::Option<i32> {
        self.unique_records_loaded
    }
    /// <p>The number of new mapped records.</p>
    pub fn new_mapped_records(&self) -> ::std::option::Option<i32> {
        self.new_mapped_records
    }
    /// <p>The number of new source records mapped.</p>
    pub fn new_mapped_source_records(&self) -> ::std::option::Option<i32> {
        self.new_mapped_source_records
    }
    /// <p>The number of new mapped target records.</p>
    pub fn new_mapped_target_records(&self) -> ::std::option::Option<i32> {
        self.new_mapped_target_records
    }
    /// <p>The number of new unique records processed in the current job run, after removing duplicates. This metric excludes deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if your current run processes five new records with the same UNIQUE_ID value, they would count as one new unique record in this metric.</p>
    pub fn new_unique_records_loaded(&self) -> ::std::option::Option<i32> {
        self.new_unique_records_loaded
    }
    /// <p>The number of mapped records removed.</p>
    pub fn mapped_records_removed(&self) -> ::std::option::Option<i32> {
        self.mapped_records_removed
    }
    /// <p>The number of source records removed due to ID mapping.</p>
    pub fn mapped_source_records_removed(&self) -> ::std::option::Option<i32> {
        self.mapped_source_records_removed
    }
    /// <p>The number of mapped target records removed.</p>
    pub fn mapped_target_records_removed(&self) -> ::std::option::Option<i32> {
        self.mapped_target_records_removed
    }
}
impl IdMappingJobMetrics {
    /// Creates a new builder-style object to manufacture [`IdMappingJobMetrics`](crate::types::IdMappingJobMetrics).
    pub fn builder() -> crate::types::builders::IdMappingJobMetricsBuilder {
        crate::types::builders::IdMappingJobMetricsBuilder::default()
    }
}

/// A builder for [`IdMappingJobMetrics`](crate::types::IdMappingJobMetrics).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct IdMappingJobMetricsBuilder {
    pub(crate) input_records: ::std::option::Option<i32>,
    pub(crate) total_records_processed: ::std::option::Option<i32>,
    pub(crate) records_not_processed: ::std::option::Option<i32>,
    pub(crate) delete_records_processed: ::std::option::Option<i32>,
    pub(crate) total_mapped_records: ::std::option::Option<i32>,
    pub(crate) total_mapped_source_records: ::std::option::Option<i32>,
    pub(crate) total_mapped_target_records: ::std::option::Option<i32>,
    pub(crate) unique_records_loaded: ::std::option::Option<i32>,
    pub(crate) new_mapped_records: ::std::option::Option<i32>,
    pub(crate) new_mapped_source_records: ::std::option::Option<i32>,
    pub(crate) new_mapped_target_records: ::std::option::Option<i32>,
    pub(crate) new_unique_records_loaded: ::std::option::Option<i32>,
    pub(crate) mapped_records_removed: ::std::option::Option<i32>,
    pub(crate) mapped_source_records_removed: ::std::option::Option<i32>,
    pub(crate) mapped_target_records_removed: ::std::option::Option<i32>,
}
impl IdMappingJobMetricsBuilder {
    /// <p>The total number of records that were input for processing.</p>
    pub fn input_records(mut self, input: i32) -> Self {
        self.input_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of records that were input for processing.</p>
    pub fn set_input_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.input_records = input;
        self
    }
    /// <p>The total number of records that were input for processing.</p>
    pub fn get_input_records(&self) -> &::std::option::Option<i32> {
        &self.input_records
    }
    /// <p>The total number of records that were processed.</p>
    pub fn total_records_processed(mut self, input: i32) -> Self {
        self.total_records_processed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of records that were processed.</p>
    pub fn set_total_records_processed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_records_processed = input;
        self
    }
    /// <p>The total number of records that were processed.</p>
    pub fn get_total_records_processed(&self) -> &::std::option::Option<i32> {
        &self.total_records_processed
    }
    /// <p>The total number of records that did not get processed.</p>
    pub fn records_not_processed(mut self, input: i32) -> Self {
        self.records_not_processed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of records that did not get processed.</p>
    pub fn set_records_not_processed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.records_not_processed = input;
        self
    }
    /// <p>The total number of records that did not get processed.</p>
    pub fn get_records_not_processed(&self) -> &::std::option::Option<i32> {
        &self.records_not_processed
    }
    /// <p>The number of records processed that were marked for deletion in the input file using the DELETE schema mapping field. These are the records to be removed from the ID mapping table.</p>
    pub fn delete_records_processed(mut self, input: i32) -> Self {
        self.delete_records_processed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of records processed that were marked for deletion in the input file using the DELETE schema mapping field. These are the records to be removed from the ID mapping table.</p>
    pub fn set_delete_records_processed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.delete_records_processed = input;
        self
    }
    /// <p>The number of records processed that were marked for deletion in the input file using the DELETE schema mapping field. These are the records to be removed from the ID mapping table.</p>
    pub fn get_delete_records_processed(&self) -> &::std::option::Option<i32> {
        &self.delete_records_processed
    }
    /// <p>The total number of records that were mapped.</p>
    pub fn total_mapped_records(mut self, input: i32) -> Self {
        self.total_mapped_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of records that were mapped.</p>
    pub fn set_total_mapped_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_mapped_records = input;
        self
    }
    /// <p>The total number of records that were mapped.</p>
    pub fn get_total_mapped_records(&self) -> &::std::option::Option<i32> {
        &self.total_mapped_records
    }
    /// <p>The total number of mapped source records.</p>
    pub fn total_mapped_source_records(mut self, input: i32) -> Self {
        self.total_mapped_source_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of mapped source records.</p>
    pub fn set_total_mapped_source_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_mapped_source_records = input;
        self
    }
    /// <p>The total number of mapped source records.</p>
    pub fn get_total_mapped_source_records(&self) -> &::std::option::Option<i32> {
        &self.total_mapped_source_records
    }
    /// <p>The total number of distinct mapped target records.</p>
    pub fn total_mapped_target_records(mut self, input: i32) -> Self {
        self.total_mapped_target_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of distinct mapped target records.</p>
    pub fn set_total_mapped_target_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_mapped_target_records = input;
        self
    }
    /// <p>The total number of distinct mapped target records.</p>
    pub fn get_total_mapped_target_records(&self) -> &::std::option::Option<i32> {
        &self.total_mapped_target_records
    }
    /// <p>The number of de-duplicated processed records across all runs, excluding deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if you specified "customer_id" as a UNIQUE_ID field and had three records with the same customer_id value, they would count as one unique record in this metric.</p>
    pub fn unique_records_loaded(mut self, input: i32) -> Self {
        self.unique_records_loaded = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of de-duplicated processed records across all runs, excluding deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if you specified "customer_id" as a UNIQUE_ID field and had three records with the same customer_id value, they would count as one unique record in this metric.</p>
    pub fn set_unique_records_loaded(mut self, input: ::std::option::Option<i32>) -> Self {
        self.unique_records_loaded = input;
        self
    }
    /// <p>The number of de-duplicated processed records across all runs, excluding deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if you specified "customer_id" as a UNIQUE_ID field and had three records with the same customer_id value, they would count as one unique record in this metric.</p>
    pub fn get_unique_records_loaded(&self) -> &::std::option::Option<i32> {
        &self.unique_records_loaded
    }
    /// <p>The number of new mapped records.</p>
    pub fn new_mapped_records(mut self, input: i32) -> Self {
        self.new_mapped_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of new mapped records.</p>
    pub fn set_new_mapped_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.new_mapped_records = input;
        self
    }
    /// <p>The number of new mapped records.</p>
    pub fn get_new_mapped_records(&self) -> &::std::option::Option<i32> {
        &self.new_mapped_records
    }
    /// <p>The number of new source records mapped.</p>
    pub fn new_mapped_source_records(mut self, input: i32) -> Self {
        self.new_mapped_source_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of new source records mapped.</p>
    pub fn set_new_mapped_source_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.new_mapped_source_records = input;
        self
    }
    /// <p>The number of new source records mapped.</p>
    pub fn get_new_mapped_source_records(&self) -> &::std::option::Option<i32> {
        &self.new_mapped_source_records
    }
    /// <p>The number of new mapped target records.</p>
    pub fn new_mapped_target_records(mut self, input: i32) -> Self {
        self.new_mapped_target_records = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of new mapped target records.</p>
    pub fn set_new_mapped_target_records(mut self, input: ::std::option::Option<i32>) -> Self {
        self.new_mapped_target_records = input;
        self
    }
    /// <p>The number of new mapped target records.</p>
    pub fn get_new_mapped_target_records(&self) -> &::std::option::Option<i32> {
        &self.new_mapped_target_records
    }
    /// <p>The number of new unique records processed in the current job run, after removing duplicates. This metric excludes deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if your current run processes five new records with the same UNIQUE_ID value, they would count as one new unique record in this metric.</p>
    pub fn new_unique_records_loaded(mut self, input: i32) -> Self {
        self.new_unique_records_loaded = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of new unique records processed in the current job run, after removing duplicates. This metric excludes deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if your current run processes five new records with the same UNIQUE_ID value, they would count as one new unique record in this metric.</p>
    pub fn set_new_unique_records_loaded(mut self, input: ::std::option::Option<i32>) -> Self {
        self.new_unique_records_loaded = input;
        self
    }
    /// <p>The number of new unique records processed in the current job run, after removing duplicates. This metric excludes deletion-related records. Duplicates are determined by the field marked as UNIQUE_ID in your schema mapping. Records sharing the same value in this field are considered duplicates. For example, if your current run processes five new records with the same UNIQUE_ID value, they would count as one new unique record in this metric.</p>
    pub fn get_new_unique_records_loaded(&self) -> &::std::option::Option<i32> {
        &self.new_unique_records_loaded
    }
    /// <p>The number of mapped records removed.</p>
    pub fn mapped_records_removed(mut self, input: i32) -> Self {
        self.mapped_records_removed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of mapped records removed.</p>
    pub fn set_mapped_records_removed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.mapped_records_removed = input;
        self
    }
    /// <p>The number of mapped records removed.</p>
    pub fn get_mapped_records_removed(&self) -> &::std::option::Option<i32> {
        &self.mapped_records_removed
    }
    /// <p>The number of source records removed due to ID mapping.</p>
    pub fn mapped_source_records_removed(mut self, input: i32) -> Self {
        self.mapped_source_records_removed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of source records removed due to ID mapping.</p>
    pub fn set_mapped_source_records_removed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.mapped_source_records_removed = input;
        self
    }
    /// <p>The number of source records removed due to ID mapping.</p>
    pub fn get_mapped_source_records_removed(&self) -> &::std::option::Option<i32> {
        &self.mapped_source_records_removed
    }
    /// <p>The number of mapped target records removed.</p>
    pub fn mapped_target_records_removed(mut self, input: i32) -> Self {
        self.mapped_target_records_removed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of mapped target records removed.</p>
    pub fn set_mapped_target_records_removed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.mapped_target_records_removed = input;
        self
    }
    /// <p>The number of mapped target records removed.</p>
    pub fn get_mapped_target_records_removed(&self) -> &::std::option::Option<i32> {
        &self.mapped_target_records_removed
    }
    /// Consumes the builder and constructs a [`IdMappingJobMetrics`](crate::types::IdMappingJobMetrics).
    pub fn build(self) -> crate::types::IdMappingJobMetrics {
        crate::types::IdMappingJobMetrics {
            input_records: self.input_records,
            total_records_processed: self.total_records_processed,
            records_not_processed: self.records_not_processed,
            delete_records_processed: self.delete_records_processed,
            total_mapped_records: self.total_mapped_records,
            total_mapped_source_records: self.total_mapped_source_records,
            total_mapped_target_records: self.total_mapped_target_records,
            unique_records_loaded: self.unique_records_loaded,
            new_mapped_records: self.new_mapped_records,
            new_mapped_source_records: self.new_mapped_source_records,
            new_mapped_target_records: self.new_mapped_target_records,
            new_unique_records_loaded: self.new_unique_records_loaded,
            mapped_records_removed: self.mapped_records_removed,
            mapped_source_records_removed: self.mapped_source_records_removed,
            mapped_target_records_removed: self.mapped_target_records_removed,
        }
    }
}
