// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Answering Machine Detection config
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnswerMachineDetectionConfig {
    /// Enable or disable answering machine detection
    #[doc(hidden)]
    pub enable_answer_machine_detection: std::option::Option<bool>,
}
impl AnswerMachineDetectionConfig {
    /// Enable or disable answering machine detection
    pub fn enable_answer_machine_detection(&self) -> std::option::Option<bool> {
        self.enable_answer_machine_detection
    }
}
/// See [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
pub mod answer_machine_detection_config {

    /// A builder for [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_answer_machine_detection: std::option::Option<bool>,
    }
    impl Builder {
        /// Enable or disable answering machine detection
        pub fn enable_answer_machine_detection(mut self, input: bool) -> Self {
            self.enable_answer_machine_detection = Some(input);
            self
        }
        /// Enable or disable answering machine detection
        pub fn set_enable_answer_machine_detection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_answer_machine_detection = input;
            self
        }
        /// Consumes the builder and constructs a [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
        pub fn build(self) -> crate::model::AnswerMachineDetectionConfig {
            crate::model::AnswerMachineDetectionConfig {
                enable_answer_machine_detection: self.enable_answer_machine_detection,
            }
        }
    }
}
impl AnswerMachineDetectionConfig {
    /// Creates a new builder-style object to manufacture [`AnswerMachineDetectionConfig`](crate::model::AnswerMachineDetectionConfig).
    pub fn builder() -> crate::model::answer_machine_detection_config::Builder {
        crate::model::answer_machine_detection_config::Builder::default()
    }
}

/// The possible types of dialer config parameters
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DialerConfig {
    /// Predictive Dialer config
    PredictiveDialerConfig(crate::model::PredictiveDialerConfig),
    /// Progressive Dialer config
    ProgressiveDialerConfig(crate::model::ProgressiveDialerConfig),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DialerConfig {
    /// Tries to convert the enum instance into [`PredictiveDialerConfig`](crate::model::DialerConfig::PredictiveDialerConfig), extracting the inner [`PredictiveDialerConfig`](crate::model::PredictiveDialerConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_predictive_dialer_config(
        &self,
    ) -> std::result::Result<&crate::model::PredictiveDialerConfig, &Self> {
        if let DialerConfig::PredictiveDialerConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`PredictiveDialerConfig`](crate::model::DialerConfig::PredictiveDialerConfig).
    pub fn is_predictive_dialer_config(&self) -> bool {
        self.as_predictive_dialer_config().is_ok()
    }
    /// Tries to convert the enum instance into [`ProgressiveDialerConfig`](crate::model::DialerConfig::ProgressiveDialerConfig), extracting the inner [`ProgressiveDialerConfig`](crate::model::ProgressiveDialerConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_progressive_dialer_config(
        &self,
    ) -> std::result::Result<&crate::model::ProgressiveDialerConfig, &Self> {
        if let DialerConfig::ProgressiveDialerConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ProgressiveDialerConfig`](crate::model::DialerConfig::ProgressiveDialerConfig).
    pub fn is_progressive_dialer_config(&self) -> bool {
        self.as_progressive_dialer_config().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// Predictive Dialer config
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictiveDialerConfig {
    /// The bandwidth allocation of a queue resource.
    #[doc(hidden)]
    pub bandwidth_allocation: std::option::Option<f64>,
}
impl PredictiveDialerConfig {
    /// The bandwidth allocation of a queue resource.
    pub fn bandwidth_allocation(&self) -> std::option::Option<f64> {
        self.bandwidth_allocation
    }
}
/// See [`PredictiveDialerConfig`](crate::model::PredictiveDialerConfig).
pub mod predictive_dialer_config {

    /// A builder for [`PredictiveDialerConfig`](crate::model::PredictiveDialerConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bandwidth_allocation: std::option::Option<f64>,
    }
    impl Builder {
        /// The bandwidth allocation of a queue resource.
        pub fn bandwidth_allocation(mut self, input: f64) -> Self {
            self.bandwidth_allocation = Some(input);
            self
        }
        /// The bandwidth allocation of a queue resource.
        pub fn set_bandwidth_allocation(mut self, input: std::option::Option<f64>) -> Self {
            self.bandwidth_allocation = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictiveDialerConfig`](crate::model::PredictiveDialerConfig).
        pub fn build(self) -> crate::model::PredictiveDialerConfig {
            crate::model::PredictiveDialerConfig {
                bandwidth_allocation: self.bandwidth_allocation,
            }
        }
    }
}
impl PredictiveDialerConfig {
    /// Creates a new builder-style object to manufacture [`PredictiveDialerConfig`](crate::model::PredictiveDialerConfig).
    pub fn builder() -> crate::model::predictive_dialer_config::Builder {
        crate::model::predictive_dialer_config::Builder::default()
    }
}

/// Progressive Dialer config
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProgressiveDialerConfig {
    /// The bandwidth allocation of a queue resource.
    #[doc(hidden)]
    pub bandwidth_allocation: std::option::Option<f64>,
}
impl ProgressiveDialerConfig {
    /// The bandwidth allocation of a queue resource.
    pub fn bandwidth_allocation(&self) -> std::option::Option<f64> {
        self.bandwidth_allocation
    }
}
/// See [`ProgressiveDialerConfig`](crate::model::ProgressiveDialerConfig).
pub mod progressive_dialer_config {

    /// A builder for [`ProgressiveDialerConfig`](crate::model::ProgressiveDialerConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bandwidth_allocation: std::option::Option<f64>,
    }
    impl Builder {
        /// The bandwidth allocation of a queue resource.
        pub fn bandwidth_allocation(mut self, input: f64) -> Self {
            self.bandwidth_allocation = Some(input);
            self
        }
        /// The bandwidth allocation of a queue resource.
        pub fn set_bandwidth_allocation(mut self, input: std::option::Option<f64>) -> Self {
            self.bandwidth_allocation = input;
            self
        }
        /// Consumes the builder and constructs a [`ProgressiveDialerConfig`](crate::model::ProgressiveDialerConfig).
        pub fn build(self) -> crate::model::ProgressiveDialerConfig {
            crate::model::ProgressiveDialerConfig {
                bandwidth_allocation: self.bandwidth_allocation,
            }
        }
    }
}
impl ProgressiveDialerConfig {
    /// Creates a new builder-style object to manufacture [`ProgressiveDialerConfig`](crate::model::ProgressiveDialerConfig).
    pub fn builder() -> crate::model::progressive_dialer_config::Builder {
        crate::model::progressive_dialer_config::Builder::default()
    }
}

/// When writing a match expression against `CampaignState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let campaignstate = unimplemented!();
/// match campaignstate {
///     CampaignState::Failed => { /* ... */ },
///     CampaignState::Initialized => { /* ... */ },
///     CampaignState::Paused => { /* ... */ },
///     CampaignState::Running => { /* ... */ },
///     CampaignState::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `campaignstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CampaignState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CampaignState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CampaignState::NewFeature` is defined.
/// Specifically, when `campaignstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CampaignState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// State of a campaign
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CampaignState {
    /// Campaign is in failed state
    Failed,
    /// Campaign is in initialized state
    Initialized,
    /// Campaign is in paused state
    Paused,
    /// Campaign is in running state
    Running,
    /// Campaign is in stopped state
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CampaignState {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => CampaignState::Failed,
            "Initialized" => CampaignState::Initialized,
            "Paused" => CampaignState::Paused,
            "Running" => CampaignState::Running,
            "Stopped" => CampaignState::Stopped,
            other => CampaignState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CampaignState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CampaignState::from(s))
    }
}
impl CampaignState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CampaignState::Failed => "Failed",
            CampaignState::Initialized => "Initialized",
            CampaignState::Paused => "Paused",
            CampaignState::Running => "Running",
            CampaignState::Stopped => "Stopped",
            CampaignState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failed", "Initialized", "Paused", "Running", "Stopped"]
    }
}
impl AsRef<str> for CampaignState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// Instance onboarding job status object
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceOnboardingJobStatus {
    /// Amazon Connect Instance Id
    #[doc(hidden)]
    pub connect_instance_id: std::option::Option<std::string::String>,
    /// Enumeration of the possible states for instance onboarding job
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::InstanceOnboardingJobStatusCode>,
    /// Enumeration of the possible failure codes for instance onboarding job
    #[doc(hidden)]
    pub failure_code: std::option::Option<crate::model::InstanceOnboardingJobFailureCode>,
}
impl InstanceOnboardingJobStatus {
    /// Amazon Connect Instance Id
    pub fn connect_instance_id(&self) -> std::option::Option<&str> {
        self.connect_instance_id.as_deref()
    }
    /// Enumeration of the possible states for instance onboarding job
    pub fn status(&self) -> std::option::Option<&crate::model::InstanceOnboardingJobStatusCode> {
        self.status.as_ref()
    }
    /// Enumeration of the possible failure codes for instance onboarding job
    pub fn failure_code(
        &self,
    ) -> std::option::Option<&crate::model::InstanceOnboardingJobFailureCode> {
        self.failure_code.as_ref()
    }
}
/// See [`InstanceOnboardingJobStatus`](crate::model::InstanceOnboardingJobStatus).
pub mod instance_onboarding_job_status {

    /// A builder for [`InstanceOnboardingJobStatus`](crate::model::InstanceOnboardingJobStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_instance_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::InstanceOnboardingJobStatusCode>,
        pub(crate) failure_code:
            std::option::Option<crate::model::InstanceOnboardingJobFailureCode>,
    }
    impl Builder {
        /// Amazon Connect Instance Id
        pub fn connect_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_instance_id = Some(input.into());
            self
        }
        /// Amazon Connect Instance Id
        pub fn set_connect_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_instance_id = input;
            self
        }
        /// Enumeration of the possible states for instance onboarding job
        pub fn status(mut self, input: crate::model::InstanceOnboardingJobStatusCode) -> Self {
            self.status = Some(input);
            self
        }
        /// Enumeration of the possible states for instance onboarding job
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::InstanceOnboardingJobStatusCode>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Enumeration of the possible failure codes for instance onboarding job
        pub fn failure_code(
            mut self,
            input: crate::model::InstanceOnboardingJobFailureCode,
        ) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// Enumeration of the possible failure codes for instance onboarding job
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::InstanceOnboardingJobFailureCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceOnboardingJobStatus`](crate::model::InstanceOnboardingJobStatus).
        pub fn build(self) -> crate::model::InstanceOnboardingJobStatus {
            crate::model::InstanceOnboardingJobStatus {
                connect_instance_id: self.connect_instance_id,
                status: self.status,
                failure_code: self.failure_code,
            }
        }
    }
}
impl InstanceOnboardingJobStatus {
    /// Creates a new builder-style object to manufacture [`InstanceOnboardingJobStatus`](crate::model::InstanceOnboardingJobStatus).
    pub fn builder() -> crate::model::instance_onboarding_job_status::Builder {
        crate::model::instance_onboarding_job_status::Builder::default()
    }
}

/// When writing a match expression against `InstanceOnboardingJobFailureCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let instanceonboardingjobfailurecode = unimplemented!();
/// match instanceonboardingjobfailurecode {
///     InstanceOnboardingJobFailureCode::EventBridgeAccessDenied => { /* ... */ },
///     InstanceOnboardingJobFailureCode::EventBridgeManagedRuleLimitExceeded => { /* ... */ },
///     InstanceOnboardingJobFailureCode::IamAccessDenied => { /* ... */ },
///     InstanceOnboardingJobFailureCode::InternalFailure => { /* ... */ },
///     InstanceOnboardingJobFailureCode::KmsAccessDenied => { /* ... */ },
///     InstanceOnboardingJobFailureCode::KmsKeyNotFound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instanceonboardingjobfailurecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceOnboardingJobFailureCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceOnboardingJobFailureCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceOnboardingJobFailureCode::NewFeature` is defined.
/// Specifically, when `instanceonboardingjobfailurecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceOnboardingJobFailureCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Enumeration of the possible failure codes for instance onboarding job
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceOnboardingJobFailureCode {
    #[allow(missing_docs)] // documentation missing in model
    EventBridgeAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EventBridgeManagedRuleLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    IamAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    KmsAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    KmsKeyNotFound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InstanceOnboardingJobFailureCode {
    fn from(s: &str) -> Self {
        match s {
            "EVENT_BRIDGE_ACCESS_DENIED" => {
                InstanceOnboardingJobFailureCode::EventBridgeAccessDenied
            }
            "EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED" => {
                InstanceOnboardingJobFailureCode::EventBridgeManagedRuleLimitExceeded
            }
            "IAM_ACCESS_DENIED" => InstanceOnboardingJobFailureCode::IamAccessDenied,
            "INTERNAL_FAILURE" => InstanceOnboardingJobFailureCode::InternalFailure,
            "KMS_ACCESS_DENIED" => InstanceOnboardingJobFailureCode::KmsAccessDenied,
            "KMS_KEY_NOT_FOUND" => InstanceOnboardingJobFailureCode::KmsKeyNotFound,
            other => InstanceOnboardingJobFailureCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InstanceOnboardingJobFailureCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceOnboardingJobFailureCode::from(s))
    }
}
impl InstanceOnboardingJobFailureCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceOnboardingJobFailureCode::EventBridgeAccessDenied => {
                "EVENT_BRIDGE_ACCESS_DENIED"
            }
            InstanceOnboardingJobFailureCode::EventBridgeManagedRuleLimitExceeded => {
                "EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED"
            }
            InstanceOnboardingJobFailureCode::IamAccessDenied => "IAM_ACCESS_DENIED",
            InstanceOnboardingJobFailureCode::InternalFailure => "INTERNAL_FAILURE",
            InstanceOnboardingJobFailureCode::KmsAccessDenied => "KMS_ACCESS_DENIED",
            InstanceOnboardingJobFailureCode::KmsKeyNotFound => "KMS_KEY_NOT_FOUND",
            InstanceOnboardingJobFailureCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EVENT_BRIDGE_ACCESS_DENIED",
            "EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED",
            "IAM_ACCESS_DENIED",
            "INTERNAL_FAILURE",
            "KMS_ACCESS_DENIED",
            "KMS_KEY_NOT_FOUND",
        ]
    }
}
impl AsRef<str> for InstanceOnboardingJobFailureCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InstanceOnboardingJobStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let instanceonboardingjobstatuscode = unimplemented!();
/// match instanceonboardingjobstatuscode {
///     InstanceOnboardingJobStatusCode::Failed => { /* ... */ },
///     InstanceOnboardingJobStatusCode::InProgress => { /* ... */ },
///     InstanceOnboardingJobStatusCode::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instanceonboardingjobstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceOnboardingJobStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceOnboardingJobStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceOnboardingJobStatusCode::NewFeature` is defined.
/// Specifically, when `instanceonboardingjobstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceOnboardingJobStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Enumeration of the possible states for instance onboarding job
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceOnboardingJobStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InstanceOnboardingJobStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => InstanceOnboardingJobStatusCode::Failed,
            "IN_PROGRESS" => InstanceOnboardingJobStatusCode::InProgress,
            "SUCCEEDED" => InstanceOnboardingJobStatusCode::Succeeded,
            other => InstanceOnboardingJobStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InstanceOnboardingJobStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceOnboardingJobStatusCode::from(s))
    }
}
impl InstanceOnboardingJobStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceOnboardingJobStatusCode::Failed => "FAILED",
            InstanceOnboardingJobStatusCode::InProgress => "IN_PROGRESS",
            InstanceOnboardingJobStatusCode::Succeeded => "SUCCEEDED",
            InstanceOnboardingJobStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCEEDED"]
    }
}
impl AsRef<str> for InstanceOnboardingJobStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionConfig {
    /// Boolean to indicate if custom encryption has been enabled.
    #[doc(hidden)]
    pub enabled: bool,
    /// Server-side encryption type.
    #[doc(hidden)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// KMS key id/arn for encryption config.
    #[doc(hidden)]
    pub key_arn: std::option::Option<std::string::String>,
}
impl EncryptionConfig {
    /// Boolean to indicate if custom encryption has been enabled.
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// Server-side encryption type.
    pub fn encryption_type(&self) -> std::option::Option<&crate::model::EncryptionType> {
        self.encryption_type.as_ref()
    }
    /// KMS key id/arn for encryption config.
    pub fn key_arn(&self) -> std::option::Option<&str> {
        self.key_arn.as_deref()
    }
}
/// See [`EncryptionConfig`](crate::model::EncryptionConfig).
pub mod encryption_config {

    /// A builder for [`EncryptionConfig`](crate::model::EncryptionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) encryption_type: std::option::Option<crate::model::EncryptionType>,
        pub(crate) key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Boolean to indicate if custom encryption has been enabled.
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// Boolean to indicate if custom encryption has been enabled.
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Server-side encryption type.
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(input);
            self
        }
        /// Server-side encryption type.
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// KMS key id/arn for encryption config.
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        /// KMS key id/arn for encryption config.
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfig`](crate::model::EncryptionConfig).
        pub fn build(self) -> crate::model::EncryptionConfig {
            crate::model::EncryptionConfig {
                enabled: self.enabled.unwrap_or_default(),
                encryption_type: self.encryption_type,
                key_arn: self.key_arn,
            }
        }
    }
}
impl EncryptionConfig {
    /// Creates a new builder-style object to manufacture [`EncryptionConfig`](crate::model::EncryptionConfig).
    pub fn builder() -> crate::model::encryption_config::Builder {
        crate::model::encryption_config::Builder::default()
    }
}

/// When writing a match expression against `EncryptionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let encryptiontype = unimplemented!();
/// match encryptiontype {
///     EncryptionType::Kms => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `encryptiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EncryptionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EncryptionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EncryptionType::NewFeature` is defined.
/// Specifically, when `encryptiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EncryptionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Server-side encryption type.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    #[allow(missing_docs)] // documentation missing in model
    Kms,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "KMS" => EncryptionType::Kms,
            other => EncryptionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}
impl EncryptionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::Kms => "KMS",
            EncryptionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KMS"]
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// A failed request identified by the unique client token.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedRequest {
    /// Client provided parameter used for idempotency. Its value must be unique for each request.
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// Identifier representing a Dial request
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// A predefined code indicating the error that caused the failure.
    #[doc(hidden)]
    pub failure_code: std::option::Option<crate::model::FailureCode>,
}
impl FailedRequest {
    /// Client provided parameter used for idempotency. Its value must be unique for each request.
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// Identifier representing a Dial request
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// A predefined code indicating the error that caused the failure.
    pub fn failure_code(&self) -> std::option::Option<&crate::model::FailureCode> {
        self.failure_code.as_ref()
    }
}
/// See [`FailedRequest`](crate::model::FailedRequest).
pub mod failed_request {

    /// A builder for [`FailedRequest`](crate::model::FailedRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<crate::model::FailureCode>,
    }
    impl Builder {
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Identifier representing a Dial request
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// Identifier representing a Dial request
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// A predefined code indicating the error that caused the failure.
        pub fn failure_code(mut self, input: crate::model::FailureCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// A predefined code indicating the error that caused the failure.
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::FailureCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedRequest`](crate::model::FailedRequest).
        pub fn build(self) -> crate::model::FailedRequest {
            crate::model::FailedRequest {
                client_token: self.client_token,
                id: self.id,
                failure_code: self.failure_code,
            }
        }
    }
}
impl FailedRequest {
    /// Creates a new builder-style object to manufacture [`FailedRequest`](crate::model::FailedRequest).
    pub fn builder() -> crate::model::failed_request::Builder {
        crate::model::failed_request::Builder::default()
    }
}

/// When writing a match expression against `FailureCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let failurecode = unimplemented!();
/// match failurecode {
///     FailureCode::InvalidInput => { /* ... */ },
///     FailureCode::RequestThrottled => { /* ... */ },
///     FailureCode::UnknownError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `failurecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FailureCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FailureCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FailureCode::NewFeature` is defined.
/// Specifically, when `failurecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FailureCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// A predefined code indicating the error that caused the failure.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailureCode {
    /// The request failed to satisfy the constraints specified by the service
    InvalidInput,
    /// Request throttled due to large number of pending dial requests
    RequestThrottled,
    /// Unexpected error during processing of request
    UnknownError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FailureCode {
    fn from(s: &str) -> Self {
        match s {
            "InvalidInput" => FailureCode::InvalidInput,
            "RequestThrottled" => FailureCode::RequestThrottled,
            "UnknownError" => FailureCode::UnknownError,
            other => FailureCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FailureCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailureCode::from(s))
    }
}
impl FailureCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailureCode::InvalidInput => "InvalidInput",
            FailureCode::RequestThrottled => "RequestThrottled",
            FailureCode::UnknownError => "UnknownError",
            FailureCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["InvalidInput", "RequestThrottled", "UnknownError"]
    }
}
impl AsRef<str> for FailureCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// A successful request identified by the unique client token.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuccessfulRequest {
    /// Client provided parameter used for idempotency. Its value must be unique for each request.
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// Identifier representing a Dial request
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl SuccessfulRequest {
    /// Client provided parameter used for idempotency. Its value must be unique for each request.
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// Identifier representing a Dial request
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`SuccessfulRequest`](crate::model::SuccessfulRequest).
pub mod successful_request {

    /// A builder for [`SuccessfulRequest`](crate::model::SuccessfulRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Identifier representing a Dial request
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// Identifier representing a Dial request
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`SuccessfulRequest`](crate::model::SuccessfulRequest).
        pub fn build(self) -> crate::model::SuccessfulRequest {
            crate::model::SuccessfulRequest {
                client_token: self.client_token,
                id: self.id,
            }
        }
    }
}
impl SuccessfulRequest {
    /// Creates a new builder-style object to manufacture [`SuccessfulRequest`](crate::model::SuccessfulRequest).
    pub fn builder() -> crate::model::successful_request::Builder {
        crate::model::successful_request::Builder::default()
    }
}

/// A dial request for a campaign.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DialRequest {
    /// Client provided parameter used for idempotency. Its value must be unique for each request.
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// The phone number of the customer, in E.164 format.
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// Timestamp with no UTC offset or timezone
    #[doc(hidden)]
    pub expiration_time: std::option::Option<aws_smithy_types::DateTime>,
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes.
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DialRequest {
    /// Client provided parameter used for idempotency. Its value must be unique for each request.
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// The phone number of the customer, in E.164 format.
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// Timestamp with no UTC offset or timezone
    pub fn expiration_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiration_time.as_ref()
    }
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes.
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
}
impl std::fmt::Debug for DialRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DialRequest");
        formatter.field("client_token", &self.client_token);
        formatter.field("phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("expiration_time", &self.expiration_time);
        formatter.field("attributes", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DialRequest`](crate::model::DialRequest).
pub mod dial_request {

    /// A builder for [`DialRequest`](crate::model::DialRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) expiration_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// The phone number of the customer, in E.164 format.
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// The phone number of the customer, in E.164 format.
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// Timestamp with no UTC offset or timezone
        pub fn expiration_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiration_time = Some(input);
            self
        }
        /// Timestamp with no UTC offset or timezone
        pub fn set_expiration_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiration_time = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes.
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes.
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`DialRequest`](crate::model::DialRequest).
        pub fn build(self) -> crate::model::DialRequest {
            crate::model::DialRequest {
                client_token: self.client_token,
                phone_number: self.phone_number,
                expiration_time: self.expiration_time,
                attributes: self.attributes,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("client_token", &self.client_token);
            formatter.field("phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("expiration_time", &self.expiration_time);
            formatter.field("attributes", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl DialRequest {
    /// Creates a new builder-style object to manufacture [`DialRequest`](crate::model::DialRequest).
    pub fn builder() -> crate::model::dial_request::Builder {
        crate::model::dial_request::Builder::default()
    }
}

/// An Amazon Connect campaign summary.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CampaignSummary {
    /// Identifier representing a Campaign
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// The resource name of an Amazon Connect campaign.
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// The name of an Amazon Connect Campaign name.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Amazon Connect Instance Id
    #[doc(hidden)]
    pub connect_instance_id: std::option::Option<std::string::String>,
}
impl CampaignSummary {
    /// Identifier representing a Campaign
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// The resource name of an Amazon Connect campaign.
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// The name of an Amazon Connect Campaign name.
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// Amazon Connect Instance Id
    pub fn connect_instance_id(&self) -> std::option::Option<&str> {
        self.connect_instance_id.as_deref()
    }
}
/// See [`CampaignSummary`](crate::model::CampaignSummary).
pub mod campaign_summary {

    /// A builder for [`CampaignSummary`](crate::model::CampaignSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) connect_instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Identifier representing a Campaign
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// Identifier representing a Campaign
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// The resource name of an Amazon Connect campaign.
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// The resource name of an Amazon Connect campaign.
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// The name of an Amazon Connect Campaign name.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of an Amazon Connect Campaign name.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Amazon Connect Instance Id
        pub fn connect_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_instance_id = Some(input.into());
            self
        }
        /// Amazon Connect Instance Id
        pub fn set_connect_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignSummary`](crate::model::CampaignSummary).
        pub fn build(self) -> crate::model::CampaignSummary {
            crate::model::CampaignSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                connect_instance_id: self.connect_instance_id,
            }
        }
    }
}
impl CampaignSummary {
    /// Creates a new builder-style object to manufacture [`CampaignSummary`](crate::model::CampaignSummary).
    pub fn builder() -> crate::model::campaign_summary::Builder {
        crate::model::campaign_summary::Builder::default()
    }
}

/// Filter model by type
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CampaignFilters {
    /// Connect instance identifier filter
    #[doc(hidden)]
    pub instance_id_filter: std::option::Option<crate::model::InstanceIdFilter>,
}
impl CampaignFilters {
    /// Connect instance identifier filter
    pub fn instance_id_filter(&self) -> std::option::Option<&crate::model::InstanceIdFilter> {
        self.instance_id_filter.as_ref()
    }
}
/// See [`CampaignFilters`](crate::model::CampaignFilters).
pub mod campaign_filters {

    /// A builder for [`CampaignFilters`](crate::model::CampaignFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id_filter: std::option::Option<crate::model::InstanceIdFilter>,
    }
    impl Builder {
        /// Connect instance identifier filter
        pub fn instance_id_filter(mut self, input: crate::model::InstanceIdFilter) -> Self {
            self.instance_id_filter = Some(input);
            self
        }
        /// Connect instance identifier filter
        pub fn set_instance_id_filter(
            mut self,
            input: std::option::Option<crate::model::InstanceIdFilter>,
        ) -> Self {
            self.instance_id_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignFilters`](crate::model::CampaignFilters).
        pub fn build(self) -> crate::model::CampaignFilters {
            crate::model::CampaignFilters {
                instance_id_filter: self.instance_id_filter,
            }
        }
    }
}
impl CampaignFilters {
    /// Creates a new builder-style object to manufacture [`CampaignFilters`](crate::model::CampaignFilters).
    pub fn builder() -> crate::model::campaign_filters::Builder {
        crate::model::campaign_filters::Builder::default()
    }
}

/// Connect instance identifier filter
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceIdFilter {
    /// Amazon Connect Instance Id
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// Operators for Connect instance identifier filter
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::InstanceIdFilterOperator>,
}
impl InstanceIdFilter {
    /// Amazon Connect Instance Id
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// Operators for Connect instance identifier filter
    pub fn operator(&self) -> std::option::Option<&crate::model::InstanceIdFilterOperator> {
        self.operator.as_ref()
    }
}
/// See [`InstanceIdFilter`](crate::model::InstanceIdFilter).
pub mod instance_id_filter {

    /// A builder for [`InstanceIdFilter`](crate::model::InstanceIdFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<crate::model::InstanceIdFilterOperator>,
    }
    impl Builder {
        /// Amazon Connect Instance Id
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// Amazon Connect Instance Id
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Operators for Connect instance identifier filter
        pub fn operator(mut self, input: crate::model::InstanceIdFilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// Operators for Connect instance identifier filter
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::InstanceIdFilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceIdFilter`](crate::model::InstanceIdFilter).
        pub fn build(self) -> crate::model::InstanceIdFilter {
            crate::model::InstanceIdFilter {
                value: self.value,
                operator: self.operator,
            }
        }
    }
}
impl InstanceIdFilter {
    /// Creates a new builder-style object to manufacture [`InstanceIdFilter`](crate::model::InstanceIdFilter).
    pub fn builder() -> crate::model::instance_id_filter::Builder {
        crate::model::instance_id_filter::Builder::default()
    }
}

/// When writing a match expression against `InstanceIdFilterOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let instanceidfilteroperator = unimplemented!();
/// match instanceidfilteroperator {
///     InstanceIdFilterOperator::Eq => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instanceidfilteroperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceIdFilterOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceIdFilterOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceIdFilterOperator::NewFeature` is defined.
/// Specifically, when `instanceidfilteroperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceIdFilterOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Operators for Connect instance identifier filter
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceIdFilterOperator {
    /// Equals operator
    Eq,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InstanceIdFilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "Eq" => InstanceIdFilterOperator::Eq,
            other => InstanceIdFilterOperator::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InstanceIdFilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceIdFilterOperator::from(s))
    }
}
impl InstanceIdFilterOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceIdFilterOperator::Eq => "Eq",
            InstanceIdFilterOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Eq"]
    }
}
impl AsRef<str> for InstanceIdFilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// Instance config object
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceConfig {
    /// Amazon Connect Instance Id
    #[doc(hidden)]
    pub connect_instance_id: std::option::Option<std::string::String>,
    /// Service linked role arn
    #[doc(hidden)]
    pub service_linked_role_arn: std::option::Option<std::string::String>,
    /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
    #[doc(hidden)]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,
}
impl InstanceConfig {
    /// Amazon Connect Instance Id
    pub fn connect_instance_id(&self) -> std::option::Option<&str> {
        self.connect_instance_id.as_deref()
    }
    /// Service linked role arn
    pub fn service_linked_role_arn(&self) -> std::option::Option<&str> {
        self.service_linked_role_arn.as_deref()
    }
    /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
    pub fn encryption_config(&self) -> std::option::Option<&crate::model::EncryptionConfig> {
        self.encryption_config.as_ref()
    }
}
/// See [`InstanceConfig`](crate::model::InstanceConfig).
pub mod instance_config {

    /// A builder for [`InstanceConfig`](crate::model::InstanceConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_instance_id: std::option::Option<std::string::String>,
        pub(crate) service_linked_role_arn: std::option::Option<std::string::String>,
        pub(crate) encryption_config: std::option::Option<crate::model::EncryptionConfig>,
    }
    impl Builder {
        /// Amazon Connect Instance Id
        pub fn connect_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_instance_id = Some(input.into());
            self
        }
        /// Amazon Connect Instance Id
        pub fn set_connect_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_instance_id = input;
            self
        }
        /// Service linked role arn
        pub fn service_linked_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_linked_role_arn = Some(input.into());
            self
        }
        /// Service linked role arn
        pub fn set_service_linked_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_linked_role_arn = input;
            self
        }
        /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
        pub fn encryption_config(mut self, input: crate::model::EncryptionConfig) -> Self {
            self.encryption_config = Some(input);
            self
        }
        /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfig>,
        ) -> Self {
            self.encryption_config = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceConfig`](crate::model::InstanceConfig).
        pub fn build(self) -> crate::model::InstanceConfig {
            crate::model::InstanceConfig {
                connect_instance_id: self.connect_instance_id,
                service_linked_role_arn: self.service_linked_role_arn,
                encryption_config: self.encryption_config,
            }
        }
    }
}
impl InstanceConfig {
    /// Creates a new builder-style object to manufacture [`InstanceConfig`](crate::model::InstanceConfig).
    pub fn builder() -> crate::model::instance_config::Builder {
        crate::model::instance_config::Builder::default()
    }
}

/// Failed response of campaign state
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedCampaignStateResponse {
    /// Identifier representing a Campaign
    #[doc(hidden)]
    pub campaign_id: std::option::Option<std::string::String>,
    /// A predefined code indicating the error that caused the failure in getting state of campaigns
    #[doc(hidden)]
    pub failure_code: std::option::Option<crate::model::GetCampaignStateBatchFailureCode>,
}
impl FailedCampaignStateResponse {
    /// Identifier representing a Campaign
    pub fn campaign_id(&self) -> std::option::Option<&str> {
        self.campaign_id.as_deref()
    }
    /// A predefined code indicating the error that caused the failure in getting state of campaigns
    pub fn failure_code(
        &self,
    ) -> std::option::Option<&crate::model::GetCampaignStateBatchFailureCode> {
        self.failure_code.as_ref()
    }
}
/// See [`FailedCampaignStateResponse`](crate::model::FailedCampaignStateResponse).
pub mod failed_campaign_state_response {

    /// A builder for [`FailedCampaignStateResponse`](crate::model::FailedCampaignStateResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) failure_code:
            std::option::Option<crate::model::GetCampaignStateBatchFailureCode>,
    }
    impl Builder {
        /// Identifier representing a Campaign
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        /// Identifier representing a Campaign
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// A predefined code indicating the error that caused the failure in getting state of campaigns
        pub fn failure_code(
            mut self,
            input: crate::model::GetCampaignStateBatchFailureCode,
        ) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// A predefined code indicating the error that caused the failure in getting state of campaigns
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::GetCampaignStateBatchFailureCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedCampaignStateResponse`](crate::model::FailedCampaignStateResponse).
        pub fn build(self) -> crate::model::FailedCampaignStateResponse {
            crate::model::FailedCampaignStateResponse {
                campaign_id: self.campaign_id,
                failure_code: self.failure_code,
            }
        }
    }
}
impl FailedCampaignStateResponse {
    /// Creates a new builder-style object to manufacture [`FailedCampaignStateResponse`](crate::model::FailedCampaignStateResponse).
    pub fn builder() -> crate::model::failed_campaign_state_response::Builder {
        crate::model::failed_campaign_state_response::Builder::default()
    }
}

/// When writing a match expression against `GetCampaignStateBatchFailureCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let getcampaignstatebatchfailurecode = unimplemented!();
/// match getcampaignstatebatchfailurecode {
///     GetCampaignStateBatchFailureCode::ResourceNotFound => { /* ... */ },
///     GetCampaignStateBatchFailureCode::UnknownError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `getcampaignstatebatchfailurecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GetCampaignStateBatchFailureCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GetCampaignStateBatchFailureCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GetCampaignStateBatchFailureCode::NewFeature` is defined.
/// Specifically, when `getcampaignstatebatchfailurecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GetCampaignStateBatchFailureCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// A predefined code indicating the error that caused the failure in getting state of campaigns
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GetCampaignStateBatchFailureCode {
    /// The specified resource was not found
    ResourceNotFound,
    /// Unexpected error during processing of request
    UnknownError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GetCampaignStateBatchFailureCode {
    fn from(s: &str) -> Self {
        match s {
            "ResourceNotFound" => GetCampaignStateBatchFailureCode::ResourceNotFound,
            "UnknownError" => GetCampaignStateBatchFailureCode::UnknownError,
            other => GetCampaignStateBatchFailureCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for GetCampaignStateBatchFailureCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GetCampaignStateBatchFailureCode::from(s))
    }
}
impl GetCampaignStateBatchFailureCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GetCampaignStateBatchFailureCode::ResourceNotFound => "ResourceNotFound",
            GetCampaignStateBatchFailureCode::UnknownError => "UnknownError",
            GetCampaignStateBatchFailureCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ResourceNotFound", "UnknownError"]
    }
}
impl AsRef<str> for GetCampaignStateBatchFailureCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// Successful response of campaign state
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuccessfulCampaignStateResponse {
    /// Identifier representing a Campaign
    #[doc(hidden)]
    pub campaign_id: std::option::Option<std::string::String>,
    /// State of a campaign
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CampaignState>,
}
impl SuccessfulCampaignStateResponse {
    /// Identifier representing a Campaign
    pub fn campaign_id(&self) -> std::option::Option<&str> {
        self.campaign_id.as_deref()
    }
    /// State of a campaign
    pub fn state(&self) -> std::option::Option<&crate::model::CampaignState> {
        self.state.as_ref()
    }
}
/// See [`SuccessfulCampaignStateResponse`](crate::model::SuccessfulCampaignStateResponse).
pub mod successful_campaign_state_response {

    /// A builder for [`SuccessfulCampaignStateResponse`](crate::model::SuccessfulCampaignStateResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::CampaignState>,
    }
    impl Builder {
        /// Identifier representing a Campaign
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        /// Identifier representing a Campaign
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// State of a campaign
        pub fn state(mut self, input: crate::model::CampaignState) -> Self {
            self.state = Some(input);
            self
        }
        /// State of a campaign
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CampaignState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`SuccessfulCampaignStateResponse`](crate::model::SuccessfulCampaignStateResponse).
        pub fn build(self) -> crate::model::SuccessfulCampaignStateResponse {
            crate::model::SuccessfulCampaignStateResponse {
                campaign_id: self.campaign_id,
                state: self.state,
            }
        }
    }
}
impl SuccessfulCampaignStateResponse {
    /// Creates a new builder-style object to manufacture [`SuccessfulCampaignStateResponse`](crate::model::SuccessfulCampaignStateResponse).
    pub fn builder() -> crate::model::successful_campaign_state_response::Builder {
        crate::model::successful_campaign_state_response::Builder::default()
    }
}

/// An Amazon Connect campaign.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Campaign {
    /// Identifier representing a Campaign
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// The resource name of an Amazon Connect campaign.
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// The name of an Amazon Connect Campaign name.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Amazon Connect Instance Id
    #[doc(hidden)]
    pub connect_instance_id: std::option::Option<std::string::String>,
    /// The possible types of dialer config parameters
    #[doc(hidden)]
    pub dialer_config: std::option::Option<crate::model::DialerConfig>,
    /// The configuration used for outbound calls.
    #[doc(hidden)]
    pub outbound_call_config: std::option::Option<crate::model::OutboundCallConfig>,
    /// Tag map with key and value.
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Campaign {
    /// Identifier representing a Campaign
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// The resource name of an Amazon Connect campaign.
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// The name of an Amazon Connect Campaign name.
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// Amazon Connect Instance Id
    pub fn connect_instance_id(&self) -> std::option::Option<&str> {
        self.connect_instance_id.as_deref()
    }
    /// The possible types of dialer config parameters
    pub fn dialer_config(&self) -> std::option::Option<&crate::model::DialerConfig> {
        self.dialer_config.as_ref()
    }
    /// The configuration used for outbound calls.
    pub fn outbound_call_config(&self) -> std::option::Option<&crate::model::OutboundCallConfig> {
        self.outbound_call_config.as_ref()
    }
    /// Tag map with key and value.
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`Campaign`](crate::model::Campaign).
pub mod campaign {

    /// A builder for [`Campaign`](crate::model::Campaign).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) connect_instance_id: std::option::Option<std::string::String>,
        pub(crate) dialer_config: std::option::Option<crate::model::DialerConfig>,
        pub(crate) outbound_call_config: std::option::Option<crate::model::OutboundCallConfig>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Identifier representing a Campaign
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// Identifier representing a Campaign
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// The resource name of an Amazon Connect campaign.
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// The resource name of an Amazon Connect campaign.
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// The name of an Amazon Connect Campaign name.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of an Amazon Connect Campaign name.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Amazon Connect Instance Id
        pub fn connect_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_instance_id = Some(input.into());
            self
        }
        /// Amazon Connect Instance Id
        pub fn set_connect_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_instance_id = input;
            self
        }
        /// The possible types of dialer config parameters
        pub fn dialer_config(mut self, input: crate::model::DialerConfig) -> Self {
            self.dialer_config = Some(input);
            self
        }
        /// The possible types of dialer config parameters
        pub fn set_dialer_config(
            mut self,
            input: std::option::Option<crate::model::DialerConfig>,
        ) -> Self {
            self.dialer_config = input;
            self
        }
        /// The configuration used for outbound calls.
        pub fn outbound_call_config(mut self, input: crate::model::OutboundCallConfig) -> Self {
            self.outbound_call_config = Some(input);
            self
        }
        /// The configuration used for outbound calls.
        pub fn set_outbound_call_config(
            mut self,
            input: std::option::Option<crate::model::OutboundCallConfig>,
        ) -> Self {
            self.outbound_call_config = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag map with key and value.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// Tag map with key and value.
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Campaign`](crate::model::Campaign).
        pub fn build(self) -> crate::model::Campaign {
            crate::model::Campaign {
                id: self.id,
                arn: self.arn,
                name: self.name,
                connect_instance_id: self.connect_instance_id,
                dialer_config: self.dialer_config,
                outbound_call_config: self.outbound_call_config,
                tags: self.tags,
            }
        }
    }
}
impl Campaign {
    /// Creates a new builder-style object to manufacture [`Campaign`](crate::model::Campaign).
    pub fn builder() -> crate::model::campaign::Builder {
        crate::model::campaign::Builder::default()
    }
}

/// The configuration used for outbound calls.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutboundCallConfig {
    /// The identifier of the contact flow for the outbound call.
    #[doc(hidden)]
    pub connect_contact_flow_id: std::option::Option<std::string::String>,
    /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
    #[doc(hidden)]
    pub connect_source_phone_number: std::option::Option<std::string::String>,
    /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
    #[doc(hidden)]
    pub connect_queue_id: std::option::Option<std::string::String>,
    /// Answering Machine Detection config
    #[doc(hidden)]
    pub answer_machine_detection_config:
        std::option::Option<crate::model::AnswerMachineDetectionConfig>,
}
impl OutboundCallConfig {
    /// The identifier of the contact flow for the outbound call.
    pub fn connect_contact_flow_id(&self) -> std::option::Option<&str> {
        self.connect_contact_flow_id.as_deref()
    }
    /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
    pub fn connect_source_phone_number(&self) -> std::option::Option<&str> {
        self.connect_source_phone_number.as_deref()
    }
    /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
    pub fn connect_queue_id(&self) -> std::option::Option<&str> {
        self.connect_queue_id.as_deref()
    }
    /// Answering Machine Detection config
    pub fn answer_machine_detection_config(
        &self,
    ) -> std::option::Option<&crate::model::AnswerMachineDetectionConfig> {
        self.answer_machine_detection_config.as_ref()
    }
}
/// See [`OutboundCallConfig`](crate::model::OutboundCallConfig).
pub mod outbound_call_config {

    /// A builder for [`OutboundCallConfig`](crate::model::OutboundCallConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_contact_flow_id: std::option::Option<std::string::String>,
        pub(crate) connect_source_phone_number: std::option::Option<std::string::String>,
        pub(crate) connect_queue_id: std::option::Option<std::string::String>,
        pub(crate) answer_machine_detection_config:
            std::option::Option<crate::model::AnswerMachineDetectionConfig>,
    }
    impl Builder {
        /// The identifier of the contact flow for the outbound call.
        pub fn connect_contact_flow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_contact_flow_id = Some(input.into());
            self
        }
        /// The identifier of the contact flow for the outbound call.
        pub fn set_connect_contact_flow_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_contact_flow_id = input;
            self
        }
        /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
        pub fn connect_source_phone_number(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.connect_source_phone_number = Some(input.into());
            self
        }
        /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
        pub fn set_connect_source_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_source_phone_number = input;
            self
        }
        /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
        pub fn connect_queue_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_queue_id = Some(input.into());
            self
        }
        /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
        pub fn set_connect_queue_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_queue_id = input;
            self
        }
        /// Answering Machine Detection config
        pub fn answer_machine_detection_config(
            mut self,
            input: crate::model::AnswerMachineDetectionConfig,
        ) -> Self {
            self.answer_machine_detection_config = Some(input);
            self
        }
        /// Answering Machine Detection config
        pub fn set_answer_machine_detection_config(
            mut self,
            input: std::option::Option<crate::model::AnswerMachineDetectionConfig>,
        ) -> Self {
            self.answer_machine_detection_config = input;
            self
        }
        /// Consumes the builder and constructs a [`OutboundCallConfig`](crate::model::OutboundCallConfig).
        pub fn build(self) -> crate::model::OutboundCallConfig {
            crate::model::OutboundCallConfig {
                connect_contact_flow_id: self.connect_contact_flow_id,
                connect_source_phone_number: self.connect_source_phone_number,
                connect_queue_id: self.connect_queue_id,
                answer_machine_detection_config: self.answer_machine_detection_config,
            }
        }
    }
}
impl OutboundCallConfig {
    /// Creates a new builder-style object to manufacture [`OutboundCallConfig`](crate::model::OutboundCallConfig).
    pub fn builder() -> crate::model::outbound_call_config::Builder {
        crate::model::outbound_call_config::Builder::default()
    }
}
