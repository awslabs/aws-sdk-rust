// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_network::_create_network_output::CreateNetworkOutputBuilder;

pub use crate::operation::create_network::_create_network_input::CreateNetworkInputBuilder;

impl crate::operation::create_network::builders::CreateNetworkInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_network::CreateNetworkOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_network::CreateNetworkError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_network();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateNetwork`.
///
/// Create as many Networks as you need. You will associate one or more Clusters with each Network.Each Network provides MediaLive Anywhere with required information about the network in your organization that you are using for video encoding using MediaLive.
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateNetworkFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_network::builders::CreateNetworkInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_network::CreateNetworkOutput,
        crate::operation::create_network::CreateNetworkError,
    > for CreateNetworkFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_network::CreateNetworkOutput,
            crate::operation::create_network::CreateNetworkError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateNetworkFluentBuilder {
    /// Creates a new `CreateNetworkFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateNetwork as a reference.
    pub fn as_input(&self) -> &crate::operation::create_network::builders::CreateNetworkInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_network::CreateNetworkOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_network::CreateNetworkError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_network::CreateNetwork::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_network::CreateNetwork::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_network::CreateNetworkOutput,
        crate::operation::create_network::CreateNetworkError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    ///
    /// Appends an item to `IpPools`.
    ///
    /// To override the contents of this collection use [`set_ip_pools`](Self::set_ip_pools).
    ///
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub fn ip_pools(mut self, input: crate::types::IpPoolCreateRequest) -> Self {
        self.inner = self.inner.ip_pools(input);
        self
    }
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub fn set_ip_pools(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::IpPoolCreateRequest>>) -> Self {
        self.inner = self.inner.set_ip_pools(input);
        self
    }
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub fn get_ip_pools(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::IpPoolCreateRequest>> {
        self.inner.get_ip_pools()
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn request_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.request_id(input.into());
        self
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn set_request_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_request_id(input);
        self
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn get_request_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_request_id()
    }
    ///
    /// Appends an item to `Routes`.
    ///
    /// To override the contents of this collection use [`set_routes`](Self::set_routes).
    ///
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub fn routes(mut self, input: crate::types::RouteCreateRequest) -> Self {
        self.inner = self.inner.routes(input);
        self
    }
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub fn set_routes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteCreateRequest>>) -> Self {
        self.inner = self.inner.set_routes(input);
        self
    }
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub fn get_routes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteCreateRequest>> {
        self.inner.get_routes()
    }
    ///
    /// Adds a key-value pair to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// A collection of key-value pairs.
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// A collection of key-value pairs.
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// A collection of key-value pairs.
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
}
