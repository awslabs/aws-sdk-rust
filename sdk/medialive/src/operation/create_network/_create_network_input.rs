// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// A request to create a Network.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateNetworkInput {
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub ip_pools: ::std::option::Option<::std::vec::Vec<crate::types::IpPoolCreateRequest>>,
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub name: ::std::option::Option<::std::string::String>,
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub request_id: ::std::option::Option<::std::string::String>,
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub routes: ::std::option::Option<::std::vec::Vec<crate::types::RouteCreateRequest>>,
    /// A collection of key-value pairs.
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateNetworkInput {
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.ip_pools.is_none()`.
    pub fn ip_pools(&self) -> &[crate::types::IpPoolCreateRequest] {
        self.ip_pools.as_deref().unwrap_or_default()
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn request_id(&self) -> ::std::option::Option<&str> {
        self.request_id.as_deref()
    }
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.routes.is_none()`.
    pub fn routes(&self) -> &[crate::types::RouteCreateRequest] {
        self.routes.as_deref().unwrap_or_default()
    }
    /// A collection of key-value pairs.
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl CreateNetworkInput {
    /// Creates a new builder-style object to manufacture [`CreateNetworkInput`](crate::operation::create_network::CreateNetworkInput).
    pub fn builder() -> crate::operation::create_network::builders::CreateNetworkInputBuilder {
        crate::operation::create_network::builders::CreateNetworkInputBuilder::default()
    }
}

/// A builder for [`CreateNetworkInput`](crate::operation::create_network::CreateNetworkInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateNetworkInputBuilder {
    pub(crate) ip_pools: ::std::option::Option<::std::vec::Vec<crate::types::IpPoolCreateRequest>>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) request_id: ::std::option::Option<::std::string::String>,
    pub(crate) routes: ::std::option::Option<::std::vec::Vec<crate::types::RouteCreateRequest>>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateNetworkInputBuilder {
    /// Appends an item to `ip_pools`.
    ///
    /// To override the contents of this collection use [`set_ip_pools`](Self::set_ip_pools).
    ///
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub fn ip_pools(mut self, input: crate::types::IpPoolCreateRequest) -> Self {
        let mut v = self.ip_pools.unwrap_or_default();
        v.push(input);
        self.ip_pools = ::std::option::Option::Some(v);
        self
    }
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub fn set_ip_pools(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::IpPoolCreateRequest>>) -> Self {
        self.ip_pools = input;
        self
    }
    /// An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    pub fn get_ip_pools(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::IpPoolCreateRequest>> {
        &self.ip_pools
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn request_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.request_id = ::std::option::Option::Some(input.into());
        self
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn set_request_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.request_id = input;
        self
    }
    /// An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    pub fn get_request_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.request_id
    }
    /// Appends an item to `routes`.
    ///
    /// To override the contents of this collection use [`set_routes`](Self::set_routes).
    ///
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub fn routes(mut self, input: crate::types::RouteCreateRequest) -> Self {
        let mut v = self.routes.unwrap_or_default();
        v.push(input);
        self.routes = ::std::option::Option::Some(v);
        self
    }
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub fn set_routes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteCreateRequest>>) -> Self {
        self.routes = input;
        self
    }
    /// An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    pub fn get_routes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteCreateRequest>> {
        &self.routes
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// A collection of key-value pairs.
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// A collection of key-value pairs.
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// A collection of key-value pairs.
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateNetworkInput`](crate::operation::create_network::CreateNetworkInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_network::CreateNetworkInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_network::CreateNetworkInput {
            ip_pools: self.ip_pools,
            name: self.name,
            request_id: self.request_id,
            routes: self.routes,
            tags: self.tags,
        })
    }
}
