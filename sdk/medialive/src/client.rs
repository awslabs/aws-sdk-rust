// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_input_device_transfer(&self) -> fluent_builders::AcceptInputDeviceTransfer<C> {
        fluent_builders::AcceptInputDeviceTransfer::new(self.handle.clone())
    }
    pub fn batch_delete(&self) -> fluent_builders::BatchDelete<C> {
        fluent_builders::BatchDelete::new(self.handle.clone())
    }
    pub fn batch_start(&self) -> fluent_builders::BatchStart<C> {
        fluent_builders::BatchStart::new(self.handle.clone())
    }
    pub fn batch_stop(&self) -> fluent_builders::BatchStop<C> {
        fluent_builders::BatchStop::new(self.handle.clone())
    }
    pub fn batch_update_schedule(&self) -> fluent_builders::BatchUpdateSchedule<C> {
        fluent_builders::BatchUpdateSchedule::new(self.handle.clone())
    }
    pub fn cancel_input_device_transfer(&self) -> fluent_builders::CancelInputDeviceTransfer<C> {
        fluent_builders::CancelInputDeviceTransfer::new(self.handle.clone())
    }
    pub fn create_channel(&self) -> fluent_builders::CreateChannel<C> {
        fluent_builders::CreateChannel::new(self.handle.clone())
    }
    pub fn create_input(&self) -> fluent_builders::CreateInput<C> {
        fluent_builders::CreateInput::new(self.handle.clone())
    }
    pub fn create_input_security_group(&self) -> fluent_builders::CreateInputSecurityGroup<C> {
        fluent_builders::CreateInputSecurityGroup::new(self.handle.clone())
    }
    pub fn create_multiplex(&self) -> fluent_builders::CreateMultiplex<C> {
        fluent_builders::CreateMultiplex::new(self.handle.clone())
    }
    pub fn create_multiplex_program(&self) -> fluent_builders::CreateMultiplexProgram<C> {
        fluent_builders::CreateMultiplexProgram::new(self.handle.clone())
    }
    pub fn create_partner_input(&self) -> fluent_builders::CreatePartnerInput<C> {
        fluent_builders::CreatePartnerInput::new(self.handle.clone())
    }
    pub fn create_tags(&self) -> fluent_builders::CreateTags<C> {
        fluent_builders::CreateTags::new(self.handle.clone())
    }
    pub fn delete_channel(&self) -> fluent_builders::DeleteChannel<C> {
        fluent_builders::DeleteChannel::new(self.handle.clone())
    }
    pub fn delete_input(&self) -> fluent_builders::DeleteInput<C> {
        fluent_builders::DeleteInput::new(self.handle.clone())
    }
    pub fn delete_input_security_group(&self) -> fluent_builders::DeleteInputSecurityGroup<C> {
        fluent_builders::DeleteInputSecurityGroup::new(self.handle.clone())
    }
    pub fn delete_multiplex(&self) -> fluent_builders::DeleteMultiplex<C> {
        fluent_builders::DeleteMultiplex::new(self.handle.clone())
    }
    pub fn delete_multiplex_program(&self) -> fluent_builders::DeleteMultiplexProgram<C> {
        fluent_builders::DeleteMultiplexProgram::new(self.handle.clone())
    }
    pub fn delete_reservation(&self) -> fluent_builders::DeleteReservation<C> {
        fluent_builders::DeleteReservation::new(self.handle.clone())
    }
    pub fn delete_schedule(&self) -> fluent_builders::DeleteSchedule<C> {
        fluent_builders::DeleteSchedule::new(self.handle.clone())
    }
    pub fn delete_tags(&self) -> fluent_builders::DeleteTags<C> {
        fluent_builders::DeleteTags::new(self.handle.clone())
    }
    pub fn describe_channel(&self) -> fluent_builders::DescribeChannel<C> {
        fluent_builders::DescribeChannel::new(self.handle.clone())
    }
    pub fn describe_input(&self) -> fluent_builders::DescribeInput<C> {
        fluent_builders::DescribeInput::new(self.handle.clone())
    }
    pub fn describe_input_device(&self) -> fluent_builders::DescribeInputDevice<C> {
        fluent_builders::DescribeInputDevice::new(self.handle.clone())
    }
    pub fn describe_input_device_thumbnail(
        &self,
    ) -> fluent_builders::DescribeInputDeviceThumbnail<C> {
        fluent_builders::DescribeInputDeviceThumbnail::new(self.handle.clone())
    }
    pub fn describe_input_security_group(&self) -> fluent_builders::DescribeInputSecurityGroup<C> {
        fluent_builders::DescribeInputSecurityGroup::new(self.handle.clone())
    }
    pub fn describe_multiplex(&self) -> fluent_builders::DescribeMultiplex<C> {
        fluent_builders::DescribeMultiplex::new(self.handle.clone())
    }
    pub fn describe_multiplex_program(&self) -> fluent_builders::DescribeMultiplexProgram<C> {
        fluent_builders::DescribeMultiplexProgram::new(self.handle.clone())
    }
    pub fn describe_offering(&self) -> fluent_builders::DescribeOffering<C> {
        fluent_builders::DescribeOffering::new(self.handle.clone())
    }
    pub fn describe_reservation(&self) -> fluent_builders::DescribeReservation<C> {
        fluent_builders::DescribeReservation::new(self.handle.clone())
    }
    pub fn describe_schedule(&self) -> fluent_builders::DescribeSchedule<C> {
        fluent_builders::DescribeSchedule::new(self.handle.clone())
    }
    pub fn list_channels(&self) -> fluent_builders::ListChannels<C> {
        fluent_builders::ListChannels::new(self.handle.clone())
    }
    pub fn list_input_devices(&self) -> fluent_builders::ListInputDevices<C> {
        fluent_builders::ListInputDevices::new(self.handle.clone())
    }
    pub fn list_input_device_transfers(&self) -> fluent_builders::ListInputDeviceTransfers<C> {
        fluent_builders::ListInputDeviceTransfers::new(self.handle.clone())
    }
    pub fn list_inputs(&self) -> fluent_builders::ListInputs<C> {
        fluent_builders::ListInputs::new(self.handle.clone())
    }
    pub fn list_input_security_groups(&self) -> fluent_builders::ListInputSecurityGroups<C> {
        fluent_builders::ListInputSecurityGroups::new(self.handle.clone())
    }
    pub fn list_multiplexes(&self) -> fluent_builders::ListMultiplexes<C> {
        fluent_builders::ListMultiplexes::new(self.handle.clone())
    }
    pub fn list_multiplex_programs(&self) -> fluent_builders::ListMultiplexPrograms<C> {
        fluent_builders::ListMultiplexPrograms::new(self.handle.clone())
    }
    pub fn list_offerings(&self) -> fluent_builders::ListOfferings<C> {
        fluent_builders::ListOfferings::new(self.handle.clone())
    }
    pub fn list_reservations(&self) -> fluent_builders::ListReservations<C> {
        fluent_builders::ListReservations::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn purchase_offering(&self) -> fluent_builders::PurchaseOffering<C> {
        fluent_builders::PurchaseOffering::new(self.handle.clone())
    }
    pub fn reject_input_device_transfer(&self) -> fluent_builders::RejectInputDeviceTransfer<C> {
        fluent_builders::RejectInputDeviceTransfer::new(self.handle.clone())
    }
    pub fn start_channel(&self) -> fluent_builders::StartChannel<C> {
        fluent_builders::StartChannel::new(self.handle.clone())
    }
    pub fn start_multiplex(&self) -> fluent_builders::StartMultiplex<C> {
        fluent_builders::StartMultiplex::new(self.handle.clone())
    }
    pub fn stop_channel(&self) -> fluent_builders::StopChannel<C> {
        fluent_builders::StopChannel::new(self.handle.clone())
    }
    pub fn stop_multiplex(&self) -> fluent_builders::StopMultiplex<C> {
        fluent_builders::StopMultiplex::new(self.handle.clone())
    }
    pub fn transfer_input_device(&self) -> fluent_builders::TransferInputDevice<C> {
        fluent_builders::TransferInputDevice::new(self.handle.clone())
    }
    pub fn update_channel(&self) -> fluent_builders::UpdateChannel<C> {
        fluent_builders::UpdateChannel::new(self.handle.clone())
    }
    pub fn update_channel_class(&self) -> fluent_builders::UpdateChannelClass<C> {
        fluent_builders::UpdateChannelClass::new(self.handle.clone())
    }
    pub fn update_input(&self) -> fluent_builders::UpdateInput<C> {
        fluent_builders::UpdateInput::new(self.handle.clone())
    }
    pub fn update_input_device(&self) -> fluent_builders::UpdateInputDevice<C> {
        fluent_builders::UpdateInputDevice::new(self.handle.clone())
    }
    pub fn update_input_security_group(&self) -> fluent_builders::UpdateInputSecurityGroup<C> {
        fluent_builders::UpdateInputSecurityGroup::new(self.handle.clone())
    }
    pub fn update_multiplex(&self) -> fluent_builders::UpdateMultiplex<C> {
        fluent_builders::UpdateMultiplex::new(self.handle.clone())
    }
    pub fn update_multiplex_program(&self) -> fluent_builders::UpdateMultiplexProgram<C> {
        fluent_builders::UpdateMultiplexProgram::new(self.handle.clone())
    }
    pub fn update_reservation(&self) -> fluent_builders::UpdateReservation<C> {
        fluent_builders::UpdateReservation::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptInputDeviceTransfer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_input_device_transfer_input::Builder,
    }
    impl<C> AcceptInputDeviceTransfer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AcceptInputDeviceTransferOutput,
            smithy_http::result::SdkError<crate::error::AcceptInputDeviceTransferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID of the input device to accept. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDelete<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_input::Builder,
    }
    impl<C> BatchDelete<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::BatchDeleteOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// List of channel IDs
        pub fn channel_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_ids(inp);
            self
        }
        pub fn set_channel_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_channel_ids(inp);
            self
        }
        /// List of input IDs
        pub fn input_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_ids(inp);
            self
        }
        pub fn set_input_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_input_ids(inp);
            self
        }
        /// List of input security group IDs
        pub fn input_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_security_group_ids(inp);
            self
        }
        pub fn set_input_security_group_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_input_security_group_ids(inp);
            self
        }
        /// List of multiplex IDs
        pub fn multiplex_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_ids(inp);
            self
        }
        pub fn set_multiplex_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_ids(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchStart<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_start_input::Builder,
    }
    impl<C> BatchStart<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::BatchStartOutput,
            smithy_http::result::SdkError<crate::error::BatchStartError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// List of channel IDs
        pub fn channel_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_ids(inp);
            self
        }
        pub fn set_channel_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_channel_ids(inp);
            self
        }
        /// List of multiplex IDs
        pub fn multiplex_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_ids(inp);
            self
        }
        pub fn set_multiplex_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_ids(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchStop<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_stop_input::Builder,
    }
    impl<C> BatchStop<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::BatchStopOutput,
            smithy_http::result::SdkError<crate::error::BatchStopError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// List of channel IDs
        pub fn channel_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_ids(inp);
            self
        }
        pub fn set_channel_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_channel_ids(inp);
            self
        }
        /// List of multiplex IDs
        pub fn multiplex_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_ids(inp);
            self
        }
        pub fn set_multiplex_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_ids(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchUpdateSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_update_schedule_input::Builder,
    }
    impl<C> BatchUpdateSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::BatchUpdateScheduleOutput,
            smithy_http::result::SdkError<crate::error::BatchUpdateScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Id of the channel whose schedule is being updated.
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
        /// Schedule actions to create in the schedule.
        pub fn creates(mut self, inp: crate::model::BatchScheduleActionCreateRequest) -> Self {
            self.inner = self.inner.creates(inp);
            self
        }
        pub fn set_creates(
            mut self,
            inp: std::option::Option<crate::model::BatchScheduleActionCreateRequest>,
        ) -> Self {
            self.inner = self.inner.set_creates(inp);
            self
        }
        /// Schedule actions to delete from the schedule.
        pub fn deletes(mut self, inp: crate::model::BatchScheduleActionDeleteRequest) -> Self {
            self.inner = self.inner.deletes(inp);
            self
        }
        pub fn set_deletes(
            mut self,
            inp: std::option::Option<crate::model::BatchScheduleActionDeleteRequest>,
        ) -> Self {
            self.inner = self.inner.set_deletes(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelInputDeviceTransfer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_input_device_transfer_input::Builder,
    }
    impl<C> CancelInputDeviceTransfer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CancelInputDeviceTransferOutput,
            smithy_http::result::SdkError<crate::error::CancelInputDeviceTransferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID of the input device to cancel. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_channel_input::Builder,
    }
    impl<C> CreateChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateChannelOutput,
            smithy_http::result::SdkError<crate::error::CreateChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Specification of CDI inputs for this channel
        pub fn cdi_input_specification(mut self, inp: crate::model::CdiInputSpecification) -> Self {
            self.inner = self.inner.cdi_input_specification(inp);
            self
        }
        pub fn set_cdi_input_specification(
            mut self,
            inp: std::option::Option<crate::model::CdiInputSpecification>,
        ) -> Self {
            self.inner = self.inner.set_cdi_input_specification(inp);
            self
        }
        /// The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
        pub fn channel_class(mut self, inp: crate::model::ChannelClass) -> Self {
            self.inner = self.inner.channel_class(inp);
            self
        }
        pub fn set_channel_class(
            mut self,
            inp: std::option::Option<crate::model::ChannelClass>,
        ) -> Self {
            self.inner = self.inner.set_channel_class(inp);
            self
        }
        /// Placeholder documentation for __listOfOutputDestination
        pub fn destinations(mut self, inp: impl Into<crate::model::OutputDestination>) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(inp);
            self
        }
        /// Encoder Settings
        pub fn encoder_settings(mut self, inp: crate::model::EncoderSettings) -> Self {
            self.inner = self.inner.encoder_settings(inp);
            self
        }
        pub fn set_encoder_settings(
            mut self,
            inp: std::option::Option<crate::model::EncoderSettings>,
        ) -> Self {
            self.inner = self.inner.set_encoder_settings(inp);
            self
        }
        /// List of input attachments for channel.
        pub fn input_attachments(mut self, inp: impl Into<crate::model::InputAttachment>) -> Self {
            self.inner = self.inner.input_attachments(inp);
            self
        }
        pub fn set_input_attachments(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
        ) -> Self {
            self.inner = self.inner.set_input_attachments(inp);
            self
        }
        /// Specification of network and file inputs for this channel
        pub fn input_specification(mut self, inp: crate::model::InputSpecification) -> Self {
            self.inner = self.inner.input_specification(inp);
            self
        }
        pub fn set_input_specification(
            mut self,
            inp: std::option::Option<crate::model::InputSpecification>,
        ) -> Self {
            self.inner = self.inner.set_input_specification(inp);
            self
        }
        /// The log level to write to CloudWatch Logs.
        pub fn log_level(mut self, inp: crate::model::LogLevel) -> Self {
            self.inner = self.inner.log_level(inp);
            self
        }
        pub fn set_log_level(mut self, inp: std::option::Option<crate::model::LogLevel>) -> Self {
            self.inner = self.inner.set_log_level(inp);
            self
        }
        /// Name of channel.
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// Unique request ID to be specified. This is needed to prevent retries from
        /// creating multiple resources.
        pub fn request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_id(inp);
            self
        }
        pub fn set_request_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_id(inp);
            self
        }
        /// Deprecated field that's only usable by whitelisted customers.
        pub fn reserved(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved(inp);
            self
        }
        pub fn set_reserved(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reserved(inp);
            self
        }
        /// An optional Amazon Resource Name (ARN) of the role to assume when running the Channel.
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// A collection of key-value pairs.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// Settings for VPC output
        pub fn vpc(mut self, inp: crate::model::VpcOutputSettings) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(
            mut self,
            inp: std::option::Option<crate::model::VpcOutputSettings>,
        ) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_input_input::Builder,
    }
    impl<C> CreateInput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateInputOutput,
            smithy_http::result::SdkError<crate::error::CreateInputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Destination settings for PUSH type inputs.
        pub fn destinations(
            mut self,
            inp: impl Into<crate::model::InputDestinationRequest>,
        ) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputDestinationRequest>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(inp);
            self
        }
        /// Settings for the devices.
        pub fn input_devices(mut self, inp: impl Into<crate::model::InputDeviceSettings>) -> Self {
            self.inner = self.inner.input_devices(inp);
            self
        }
        pub fn set_input_devices(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputDeviceSettings>>,
        ) -> Self {
            self.inner = self.inner.set_input_devices(inp);
            self
        }
        /// A list of security groups referenced by IDs to attach to the input.
        pub fn input_security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_security_groups(inp);
            self
        }
        pub fn set_input_security_groups(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_input_security_groups(inp);
            self
        }
        /// A list of the MediaConnect Flows that you want to use in this input. You can specify as few as one
        /// Flow and presently, as many as two. The only requirement is when you have more than one is that each Flow is in a
        /// separate Availability Zone as this ensures your EML input is redundant to AZ issues.
        pub fn media_connect_flows(
            mut self,
            inp: impl Into<crate::model::MediaConnectFlowRequest>,
        ) -> Self {
            self.inner = self.inner.media_connect_flows(inp);
            self
        }
        pub fn set_media_connect_flows(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MediaConnectFlowRequest>>,
        ) -> Self {
            self.inner = self.inner.set_media_connect_flows(inp);
            self
        }
        /// Name of the input.
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// Unique identifier of the request to ensure the request is handled
        /// exactly once in case of retries.
        pub fn request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_id(inp);
            self
        }
        pub fn set_request_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_id(inp);
            self
        }
        /// The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// The source URLs for a PULL-type input. Every PULL type input needs
        /// exactly two source URLs for redundancy.
        /// Only specify sources for PULL type Inputs. Leave Destinations empty.
        pub fn sources(mut self, inp: impl Into<crate::model::InputSourceRequest>) -> Self {
            self.inner = self.inner.sources(inp);
            self
        }
        pub fn set_sources(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputSourceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_sources(inp);
            self
        }
        /// A collection of key-value pairs.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// Placeholder documentation for InputType
        pub fn r#type(mut self, inp: crate::model::InputType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::InputType>) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
        /// Settings for a private VPC Input.
        /// When this property is specified, the input destination addresses will be created in a VPC rather than with public Internet addresses.
        /// This property requires setting the roleArn property on Input creation.
        /// Not compatible with the inputSecurityGroups property.
        pub fn vpc(mut self, inp: crate::model::InputVpcRequest) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, inp: std::option::Option<crate::model::InputVpcRequest>) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInputSecurityGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_input_security_group_input::Builder,
    }
    impl<C> CreateInputSecurityGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateInputSecurityGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateInputSecurityGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// A collection of key-value pairs.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// List of IPv4 CIDR addresses to whitelist
        pub fn whitelist_rules(
            mut self,
            inp: impl Into<crate::model::InputWhitelistRuleCidr>,
        ) -> Self {
            self.inner = self.inner.whitelist_rules(inp);
            self
        }
        pub fn set_whitelist_rules(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputWhitelistRuleCidr>>,
        ) -> Self {
            self.inner = self.inner.set_whitelist_rules(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMultiplex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_multiplex_input::Builder,
    }
    impl<C> CreateMultiplex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateMultiplexOutput,
            smithy_http::result::SdkError<crate::error::CreateMultiplexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// A list of availability zones for the multiplex. You must specify exactly two.
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(inp);
            self
        }
        /// Configuration for a multiplex event.
        pub fn multiplex_settings(mut self, inp: crate::model::MultiplexSettings) -> Self {
            self.inner = self.inner.multiplex_settings(inp);
            self
        }
        pub fn set_multiplex_settings(
            mut self,
            inp: std::option::Option<crate::model::MultiplexSettings>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_settings(inp);
            self
        }
        /// Name of multiplex.
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// Unique request ID. This prevents retries from creating multiple
        /// resources.
        pub fn request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_id(inp);
            self
        }
        pub fn set_request_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_id(inp);
            self
        }
        /// A collection of key-value pairs.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMultiplexProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_multiplex_program_input::Builder,
    }
    impl<C> CreateMultiplexProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateMultiplexProgramOutput,
            smithy_http::result::SdkError<crate::error::CreateMultiplexProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// ID of the multiplex where the program is to be created.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
        /// The settings for this multiplex program.
        pub fn multiplex_program_settings(
            mut self,
            inp: crate::model::MultiplexProgramSettings,
        ) -> Self {
            self.inner = self.inner.multiplex_program_settings(inp);
            self
        }
        pub fn set_multiplex_program_settings(
            mut self,
            inp: std::option::Option<crate::model::MultiplexProgramSettings>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_program_settings(inp);
            self
        }
        /// Name of multiplex program.
        pub fn program_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(inp);
            self
        }
        pub fn set_program_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_program_name(inp);
            self
        }
        /// Unique request ID. This prevents retries from creating multiple
        /// resources.
        pub fn request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_id(inp);
            self
        }
        pub fn set_request_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePartnerInput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_partner_input_input::Builder,
    }
    impl<C> CreatePartnerInput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreatePartnerInputOutput,
            smithy_http::result::SdkError<crate::error::CreatePartnerInputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique ID of the input.
        pub fn input_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_id(inp);
            self
        }
        pub fn set_input_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_id(inp);
            self
        }
        /// Unique identifier of the request to ensure the request is handled
        /// exactly once in case of retries.
        pub fn request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_id(inp);
            self
        }
        pub fn set_request_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_id(inp);
            self
        }
        /// A collection of key-value pairs.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tags_input::Builder,
    }
    impl<C> CreateTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for __string
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
        /// Placeholder documentation for Tags
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_channel_input::Builder,
    }
    impl<C> DeleteChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteChannelOutput,
            smithy_http::result::SdkError<crate::error::DeleteChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique ID of the channel.
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_input_input::Builder,
    }
    impl<C> DeleteInput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteInputOutput,
            smithy_http::result::SdkError<crate::error::DeleteInputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique ID of the input
        pub fn input_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_id(inp);
            self
        }
        pub fn set_input_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInputSecurityGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_input_security_group_input::Builder,
    }
    impl<C> DeleteInputSecurityGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteInputSecurityGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteInputSecurityGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Input Security Group to delete
        pub fn input_security_group_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_security_group_id(inp);
            self
        }
        pub fn set_input_security_group_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_security_group_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMultiplex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_multiplex_input::Builder,
    }
    impl<C> DeleteMultiplex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteMultiplexOutput,
            smithy_http::result::SdkError<crate::error::DeleteMultiplexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMultiplexProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_multiplex_program_input::Builder,
    }
    impl<C> DeleteMultiplexProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteMultiplexProgramOutput,
            smithy_http::result::SdkError<crate::error::DeleteMultiplexProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex that the program belongs to.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
        /// The multiplex program name.
        pub fn program_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(inp);
            self
        }
        pub fn set_program_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_program_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_reservation_input::Builder,
    }
    impl<C> DeleteReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteReservationOutput,
            smithy_http::result::SdkError<crate::error::DeleteReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique reservation ID, e.g. '1234567'
        pub fn reservation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reservation_id(inp);
            self
        }
        pub fn set_reservation_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_reservation_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_schedule_input::Builder,
    }
    impl<C> DeleteSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteScheduleOutput,
            smithy_http::result::SdkError<crate::error::DeleteScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Id of the channel whose schedule is being deleted.
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tags_input::Builder,
    }
    impl<C> DeleteTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteTagsOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for __string
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
        /// An array of tag keys to delete
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_channel_input::Builder,
    }
    impl<C> DescribeChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeChannelOutput,
            smithy_http::result::SdkError<crate::error::DescribeChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// channel ID
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_input_input::Builder,
    }
    impl<C> DescribeInput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInputOutput,
            smithy_http::result::SdkError<crate::error::DescribeInputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique ID of the input
        pub fn input_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_id(inp);
            self
        }
        pub fn set_input_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInputDevice<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_input_device_input::Builder,
    }
    impl<C> DescribeInputDevice<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInputDeviceOutput,
            smithy_http::result::SdkError<crate::error::DescribeInputDeviceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID of this input device. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInputDeviceThumbnail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_input_device_thumbnail_input::Builder,
    }
    impl<C> DescribeInputDeviceThumbnail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInputDeviceThumbnailOutput,
            smithy_http::result::SdkError<crate::error::DescribeInputDeviceThumbnailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID of this input device. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
        /// The HTTP Accept header. Indicates the requested type for the thumbnail.
        pub fn accept(mut self, inp: crate::model::AcceptHeader) -> Self {
            self.inner = self.inner.accept(inp);
            self
        }
        pub fn set_accept(mut self, inp: std::option::Option<crate::model::AcceptHeader>) -> Self {
            self.inner = self.inner.set_accept(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInputSecurityGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_input_security_group_input::Builder,
    }
    impl<C> DescribeInputSecurityGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeInputSecurityGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeInputSecurityGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The id of the Input Security Group to describe
        pub fn input_security_group_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_security_group_id(inp);
            self
        }
        pub fn set_input_security_group_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_security_group_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMultiplex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_multiplex_input::Builder,
    }
    impl<C> DescribeMultiplex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMultiplexOutput,
            smithy_http::result::SdkError<crate::error::DescribeMultiplexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMultiplexProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_multiplex_program_input::Builder,
    }
    impl<C> DescribeMultiplexProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeMultiplexProgramOutput,
            smithy_http::result::SdkError<crate::error::DescribeMultiplexProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex that the program belongs to.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
        /// The name of the program.
        pub fn program_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(inp);
            self
        }
        pub fn set_program_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_program_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_offering_input::Builder,
    }
    impl<C> DescribeOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeOfferingOutput,
            smithy_http::result::SdkError<crate::error::DescribeOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique offering ID, e.g. '87654321'
        pub fn offering_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(inp);
            self
        }
        pub fn set_offering_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_offering_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_reservation_input::Builder,
    }
    impl<C> DescribeReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeReservationOutput,
            smithy_http::result::SdkError<crate::error::DescribeReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Unique reservation ID, e.g. '1234567'
        pub fn reservation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reservation_id(inp);
            self
        }
        pub fn set_reservation_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_reservation_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_schedule_input::Builder,
    }
    impl<C> DescribeSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeScheduleOutput,
            smithy_http::result::SdkError<crate::error::DescribeScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Id of the channel whose schedule is being updated.
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListChannels<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_channels_input::Builder,
    }
    impl<C> ListChannels<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListChannelsOutput,
            smithy_http::result::SdkError<crate::error::ListChannelsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInputDevices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_input_devices_input::Builder,
    }
    impl<C> ListInputDevices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInputDevicesOutput,
            smithy_http::result::SdkError<crate::error::ListInputDevicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInputDeviceTransfers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_input_device_transfers_input::Builder,
    }
    impl<C> ListInputDeviceTransfers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInputDeviceTransfersOutput,
            smithy_http::result::SdkError<crate::error::ListInputDeviceTransfersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn transfer_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transfer_type(inp);
            self
        }
        pub fn set_transfer_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_transfer_type(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInputs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_inputs_input::Builder,
    }
    impl<C> ListInputs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInputsOutput,
            smithy_http::result::SdkError<crate::error::ListInputsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInputSecurityGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_input_security_groups_input::Builder,
    }
    impl<C> ListInputSecurityGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInputSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListInputSecurityGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMultiplexes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_multiplexes_input::Builder,
    }
    impl<C> ListMultiplexes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListMultiplexesOutput,
            smithy_http::result::SdkError<crate::error::ListMultiplexesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of items to return.
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// The token to retrieve the next page of results.
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMultiplexPrograms<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_multiplex_programs_input::Builder,
    }
    impl<C> ListMultiplexPrograms<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListMultiplexProgramsOutput,
            smithy_http::result::SdkError<crate::error::ListMultiplexProgramsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of items to return.
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// The ID of the multiplex that the programs belong to.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
        /// The token to retrieve the next page of results.
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOfferings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_offerings_input::Builder,
    }
    impl<C> ListOfferings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListOfferingsOutput,
            smithy_http::result::SdkError<crate::error::ListOfferingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
        pub fn channel_class(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_class(inp);
            self
        }
        pub fn set_channel_class(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_class(inp);
            self
        }
        /// Filter to offerings that match the configuration of an existing channel, e.g. '2345678' (a channel ID)
        pub fn channel_configuration(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_configuration(inp);
            self
        }
        pub fn set_channel_configuration(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_channel_configuration(inp);
            self
        }
        /// Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', or 'LINK'
        pub fn codec(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.codec(inp);
            self
        }
        pub fn set_codec(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_codec(inp);
            self
        }
        /// Filter by offering duration, e.g. '12'
        pub fn duration(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.duration(inp);
            self
        }
        pub fn set_duration(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_duration(inp);
            self
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
        pub fn maximum_bitrate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.maximum_bitrate(inp);
            self
        }
        pub fn set_maximum_bitrate(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_maximum_bitrate(inp);
            self
        }
        /// Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
        pub fn maximum_framerate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.maximum_framerate(inp);
            self
        }
        pub fn set_maximum_framerate(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_maximum_framerate(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
        pub fn resolution(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolution(inp);
            self
        }
        pub fn set_resolution(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resolution(inp);
            self
        }
        /// Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
        pub fn special_feature(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.special_feature(inp);
            self
        }
        pub fn set_special_feature(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_special_feature(inp);
            self
        }
        /// Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
        pub fn video_quality(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.video_quality(inp);
            self
        }
        pub fn set_video_quality(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_video_quality(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReservations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_reservations_input::Builder,
    }
    impl<C> ListReservations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListReservationsOutput,
            smithy_http::result::SdkError<crate::error::ListReservationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
        pub fn channel_class(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_class(inp);
            self
        }
        pub fn set_channel_class(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_class(inp);
            self
        }
        /// Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', or 'LINK'
        pub fn codec(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.codec(inp);
            self
        }
        pub fn set_codec(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_codec(inp);
            self
        }
        /// Placeholder documentation for MaxResults
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
        pub fn maximum_bitrate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.maximum_bitrate(inp);
            self
        }
        pub fn set_maximum_bitrate(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_maximum_bitrate(inp);
            self
        }
        /// Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
        pub fn maximum_framerate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.maximum_framerate(inp);
            self
        }
        pub fn set_maximum_framerate(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_maximum_framerate(inp);
            self
        }
        /// Placeholder documentation for __string
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
        pub fn resolution(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolution(inp);
            self
        }
        pub fn set_resolution(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resolution(inp);
            self
        }
        /// Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
        pub fn special_feature(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.special_feature(inp);
            self
        }
        pub fn set_special_feature(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_special_feature(inp);
            self
        }
        /// Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
        pub fn video_quality(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.video_quality(inp);
            self
        }
        pub fn set_video_quality(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_video_quality(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Placeholder documentation for __string
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PurchaseOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::purchase_offering_input::Builder,
    }
    impl<C> PurchaseOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PurchaseOfferingOutput,
            smithy_http::result::SdkError<crate::error::PurchaseOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Number of resources
        pub fn count(mut self, inp: i32) -> Self {
            self.inner = self.inner.count(inp);
            self
        }
        pub fn set_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_count(inp);
            self
        }
        /// Name for the new reservation
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// Offering to purchase, e.g. '87654321'
        pub fn offering_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(inp);
            self
        }
        pub fn set_offering_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_offering_id(inp);
            self
        }
        /// Unique request ID to be specified. This is needed to prevent retries from creating multiple resources.
        pub fn request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_id(inp);
            self
        }
        pub fn set_request_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_id(inp);
            self
        }
        /// Requested reservation start time (UTC) in ISO-8601 format. The specified time must be between the first day of the current month and one year from now. If no value is given, the default is now.
        pub fn start(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start(inp);
            self
        }
        pub fn set_start(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_start(inp);
            self
        }
        /// A collection of key-value pairs
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectInputDeviceTransfer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_input_device_transfer_input::Builder,
    }
    impl<C> RejectInputDeviceTransfer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RejectInputDeviceTransferOutput,
            smithy_http::result::SdkError<crate::error::RejectInputDeviceTransferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID of the input device to reject. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_channel_input::Builder,
    }
    impl<C> StartChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartChannelOutput,
            smithy_http::result::SdkError<crate::error::StartChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// A request to start a channel
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMultiplex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_multiplex_input::Builder,
    }
    impl<C> StartMultiplex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartMultiplexOutput,
            smithy_http::result::SdkError<crate::error::StartMultiplexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_channel_input::Builder,
    }
    impl<C> StopChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StopChannelOutput,
            smithy_http::result::SdkError<crate::error::StopChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// A request to stop a running channel
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopMultiplex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_multiplex_input::Builder,
    }
    impl<C> StopMultiplex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StopMultiplexOutput,
            smithy_http::result::SdkError<crate::error::StopMultiplexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TransferInputDevice<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::transfer_input_device_input::Builder,
    }
    impl<C> TransferInputDevice<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TransferInputDeviceOutput,
            smithy_http::result::SdkError<crate::error::TransferInputDeviceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID of this input device. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
        /// The AWS account ID (12 digits) for the recipient of the device transfer.
        pub fn target_customer_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_customer_id(inp);
            self
        }
        pub fn set_target_customer_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_customer_id(inp);
            self
        }
        /// The target AWS region to transfer the device.
        pub fn target_region(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_region(inp);
            self
        }
        pub fn set_target_region(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_region(inp);
            self
        }
        /// An optional message for the recipient. Maximum 280 characters.
        pub fn transfer_message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transfer_message(inp);
            self
        }
        pub fn set_transfer_message(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transfer_message(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_channel_input::Builder,
    }
    impl<C> UpdateChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateChannelOutput,
            smithy_http::result::SdkError<crate::error::UpdateChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Specification of CDI inputs for this channel
        pub fn cdi_input_specification(mut self, inp: crate::model::CdiInputSpecification) -> Self {
            self.inner = self.inner.cdi_input_specification(inp);
            self
        }
        pub fn set_cdi_input_specification(
            mut self,
            inp: std::option::Option<crate::model::CdiInputSpecification>,
        ) -> Self {
            self.inner = self.inner.set_cdi_input_specification(inp);
            self
        }
        /// channel ID
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
        /// A list of output destinations for this channel.
        pub fn destinations(mut self, inp: impl Into<crate::model::OutputDestination>) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(inp);
            self
        }
        /// The encoder settings for this channel.
        pub fn encoder_settings(mut self, inp: crate::model::EncoderSettings) -> Self {
            self.inner = self.inner.encoder_settings(inp);
            self
        }
        pub fn set_encoder_settings(
            mut self,
            inp: std::option::Option<crate::model::EncoderSettings>,
        ) -> Self {
            self.inner = self.inner.set_encoder_settings(inp);
            self
        }
        /// Placeholder documentation for __listOfInputAttachment
        pub fn input_attachments(mut self, inp: impl Into<crate::model::InputAttachment>) -> Self {
            self.inner = self.inner.input_attachments(inp);
            self
        }
        pub fn set_input_attachments(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
        ) -> Self {
            self.inner = self.inner.set_input_attachments(inp);
            self
        }
        /// Specification of network and file inputs for this channel
        pub fn input_specification(mut self, inp: crate::model::InputSpecification) -> Self {
            self.inner = self.inner.input_specification(inp);
            self
        }
        pub fn set_input_specification(
            mut self,
            inp: std::option::Option<crate::model::InputSpecification>,
        ) -> Self {
            self.inner = self.inner.set_input_specification(inp);
            self
        }
        /// The log level to write to CloudWatch Logs.
        pub fn log_level(mut self, inp: crate::model::LogLevel) -> Self {
            self.inner = self.inner.log_level(inp);
            self
        }
        pub fn set_log_level(mut self, inp: std::option::Option<crate::model::LogLevel>) -> Self {
            self.inner = self.inner.set_log_level(inp);
            self
        }
        /// The name of the channel.
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// An optional Amazon Resource Name (ARN) of the role to assume when running the Channel. If you do not specify this on an update call but the role was previously set that role will be removed.
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateChannelClass<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_channel_class_input::Builder,
    }
    impl<C> UpdateChannelClass<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateChannelClassOutput,
            smithy_http::result::SdkError<crate::error::UpdateChannelClassError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The channel class that you wish to update this channel to use.
        pub fn channel_class(mut self, inp: crate::model::ChannelClass) -> Self {
            self.inner = self.inner.channel_class(inp);
            self
        }
        pub fn set_channel_class(
            mut self,
            inp: std::option::Option<crate::model::ChannelClass>,
        ) -> Self {
            self.inner = self.inner.set_channel_class(inp);
            self
        }
        /// Channel Id of the channel whose class should be updated.
        pub fn channel_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(inp);
            self
        }
        pub fn set_channel_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_channel_id(inp);
            self
        }
        /// A list of output destinations for this channel.
        pub fn destinations(mut self, inp: impl Into<crate::model::OutputDestination>) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateInput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_input_input::Builder,
    }
    impl<C> UpdateInput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateInputOutput,
            smithy_http::result::SdkError<crate::error::UpdateInputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Destination settings for PUSH type inputs.
        pub fn destinations(
            mut self,
            inp: impl Into<crate::model::InputDestinationRequest>,
        ) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputDestinationRequest>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(inp);
            self
        }
        /// Settings for the devices.
        pub fn input_devices(mut self, inp: impl Into<crate::model::InputDeviceRequest>) -> Self {
            self.inner = self.inner.input_devices(inp);
            self
        }
        pub fn set_input_devices(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputDeviceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_input_devices(inp);
            self
        }
        /// Unique ID of the input.
        pub fn input_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_id(inp);
            self
        }
        pub fn set_input_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_id(inp);
            self
        }
        /// A list of security groups referenced by IDs to attach to the input.
        pub fn input_security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_security_groups(inp);
            self
        }
        pub fn set_input_security_groups(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_input_security_groups(inp);
            self
        }
        /// A list of the MediaConnect Flow ARNs that you want to use as the source of the input. You can specify as few as one
        /// Flow and presently, as many as two. The only requirement is when you have more than one is that each Flow is in a
        /// separate Availability Zone as this ensures your EML input is redundant to AZ issues.
        pub fn media_connect_flows(
            mut self,
            inp: impl Into<crate::model::MediaConnectFlowRequest>,
        ) -> Self {
            self.inner = self.inner.media_connect_flows(inp);
            self
        }
        pub fn set_media_connect_flows(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MediaConnectFlowRequest>>,
        ) -> Self {
            self.inner = self.inner.set_media_connect_flows(inp);
            self
        }
        /// Name of the input.
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// The source URLs for a PULL-type input. Every PULL type input needs
        /// exactly two source URLs for redundancy.
        /// Only specify sources for PULL type Inputs. Leave Destinations empty.
        pub fn sources(mut self, inp: impl Into<crate::model::InputSourceRequest>) -> Self {
            self.inner = self.inner.sources(inp);
            self
        }
        pub fn set_sources(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputSourceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_sources(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateInputDevice<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_input_device_input::Builder,
    }
    impl<C> UpdateInputDevice<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateInputDeviceOutput,
            smithy_http::result::SdkError<crate::error::UpdateInputDeviceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The settings that you want to apply to the HD input device.
        pub fn hd_device_settings(
            mut self,
            inp: crate::model::InputDeviceConfigurableSettings,
        ) -> Self {
            self.inner = self.inner.hd_device_settings(inp);
            self
        }
        pub fn set_hd_device_settings(
            mut self,
            inp: std::option::Option<crate::model::InputDeviceConfigurableSettings>,
        ) -> Self {
            self.inner = self.inner.set_hd_device_settings(inp);
            self
        }
        /// The unique ID of the input device. For example, hd-123456789abcdef.
        pub fn input_device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_device_id(inp);
            self
        }
        pub fn set_input_device_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_device_id(inp);
            self
        }
        /// The name that you assigned to this input device (not the unique ID).
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// The settings that you want to apply to the UHD input device.
        pub fn uhd_device_settings(
            mut self,
            inp: crate::model::InputDeviceConfigurableSettings,
        ) -> Self {
            self.inner = self.inner.uhd_device_settings(inp);
            self
        }
        pub fn set_uhd_device_settings(
            mut self,
            inp: std::option::Option<crate::model::InputDeviceConfigurableSettings>,
        ) -> Self {
            self.inner = self.inner.set_uhd_device_settings(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateInputSecurityGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_input_security_group_input::Builder,
    }
    impl<C> UpdateInputSecurityGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateInputSecurityGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateInputSecurityGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The id of the Input Security Group to update.
        pub fn input_security_group_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_security_group_id(inp);
            self
        }
        pub fn set_input_security_group_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_input_security_group_id(inp);
            self
        }
        /// A collection of key-value pairs.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// List of IPv4 CIDR addresses to whitelist
        pub fn whitelist_rules(
            mut self,
            inp: impl Into<crate::model::InputWhitelistRuleCidr>,
        ) -> Self {
            self.inner = self.inner.whitelist_rules(inp);
            self
        }
        pub fn set_whitelist_rules(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::InputWhitelistRuleCidr>>,
        ) -> Self {
            self.inner = self.inner.set_whitelist_rules(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMultiplex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_multiplex_input::Builder,
    }
    impl<C> UpdateMultiplex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateMultiplexOutput,
            smithy_http::result::SdkError<crate::error::UpdateMultiplexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// ID of the multiplex to update.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
        /// The new settings for a multiplex.
        pub fn multiplex_settings(mut self, inp: crate::model::MultiplexSettings) -> Self {
            self.inner = self.inner.multiplex_settings(inp);
            self
        }
        pub fn set_multiplex_settings(
            mut self,
            inp: std::option::Option<crate::model::MultiplexSettings>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_settings(inp);
            self
        }
        /// Name of the multiplex.
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMultiplexProgram<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_multiplex_program_input::Builder,
    }
    impl<C> UpdateMultiplexProgram<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateMultiplexProgramOutput,
            smithy_http::result::SdkError<crate::error::UpdateMultiplexProgramError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ID of the multiplex of the program to update.
        pub fn multiplex_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multiplex_id(inp);
            self
        }
        pub fn set_multiplex_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_multiplex_id(inp);
            self
        }
        /// The new settings for a multiplex program.
        pub fn multiplex_program_settings(
            mut self,
            inp: crate::model::MultiplexProgramSettings,
        ) -> Self {
            self.inner = self.inner.multiplex_program_settings(inp);
            self
        }
        pub fn set_multiplex_program_settings(
            mut self,
            inp: std::option::Option<crate::model::MultiplexProgramSettings>,
        ) -> Self {
            self.inner = self.inner.set_multiplex_program_settings(inp);
            self
        }
        /// The name of the program to update.
        pub fn program_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.program_name(inp);
            self
        }
        pub fn set_program_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_program_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_reservation_input::Builder,
    }
    impl<C> UpdateReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateReservationOutput,
            smithy_http::result::SdkError<crate::error::UpdateReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Name of the reservation
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// Unique reservation ID, e.g. '1234567'
        pub fn reservation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reservation_id(inp);
            self
        }
        pub fn set_reservation_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_reservation_id(inp);
            self
        }
    }
}
