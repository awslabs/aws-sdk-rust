// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptInputDeviceTransferError {
    pub kind: AcceptInputDeviceTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptInputDeviceTransferErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptInputDeviceTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptInputDeviceTransferErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            AcceptInputDeviceTransferErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::UnprocessableEntityException(_inner) => {
                _inner.fmt(f)
            }
            AcceptInputDeviceTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptInputDeviceTransferError {
    fn code(&self) -> Option<&str> {
        AcceptInputDeviceTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptInputDeviceTransferError {
    pub fn new(kind: AcceptInputDeviceTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptInputDeviceTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptInputDeviceTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for AcceptInputDeviceTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptInputDeviceTransferErrorKind::BadGatewayException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::BadRequestException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::ConflictException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::ForbiddenException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            AcceptInputDeviceTransferErrorKind::NotFoundException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::UnprocessableEntityException(_inner) => {
                Some(_inner)
            }
            AcceptInputDeviceTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteError {
    pub kind: BatchDeleteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteError {
    fn code(&self) -> Option<&str> {
        BatchDeleteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteError {
    pub fn new(kind: BatchDeleteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for BatchDeleteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteErrorKind::BadGatewayException(_inner) => Some(_inner),
            BatchDeleteErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchDeleteErrorKind::ConflictException(_inner) => Some(_inner),
            BatchDeleteErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchDeleteErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            BatchDeleteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            BatchDeleteErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchDeleteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            BatchDeleteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchStartError {
    pub kind: BatchStartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchStartErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchStartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchStartErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            BatchStartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchStartError {
    fn code(&self) -> Option<&str> {
        BatchStartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchStartError {
    pub fn new(kind: BatchStartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchStartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchStartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchStartErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for BatchStartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchStartErrorKind::BadGatewayException(_inner) => Some(_inner),
            BatchStartErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchStartErrorKind::ConflictException(_inner) => Some(_inner),
            BatchStartErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchStartErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            BatchStartErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            BatchStartErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchStartErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            BatchStartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchStopError {
    pub kind: BatchStopErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchStopErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchStopError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchStopErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            BatchStopErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchStopError {
    fn code(&self) -> Option<&str> {
        BatchStopError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchStopError {
    pub fn new(kind: BatchStopErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchStopErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchStopErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchStopErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for BatchStopError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchStopErrorKind::BadGatewayException(_inner) => Some(_inner),
            BatchStopErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchStopErrorKind::ConflictException(_inner) => Some(_inner),
            BatchStopErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchStopErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            BatchStopErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            BatchStopErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchStopErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            BatchStopErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdateScheduleError {
    pub kind: BatchUpdateScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdateScheduleErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUpdateScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdateScheduleErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUpdateScheduleError {
    fn code(&self) -> Option<&str> {
        BatchUpdateScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdateScheduleError {
    pub fn new(kind: BatchUpdateScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdateScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdateScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for BatchUpdateScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdateScheduleErrorKind::BadGatewayException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelInputDeviceTransferError {
    pub kind: CancelInputDeviceTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelInputDeviceTransferErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelInputDeviceTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelInputDeviceTransferErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            CancelInputDeviceTransferErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::UnprocessableEntityException(_inner) => {
                _inner.fmt(f)
            }
            CancelInputDeviceTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelInputDeviceTransferError {
    fn code(&self) -> Option<&str> {
        CancelInputDeviceTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelInputDeviceTransferError {
    pub fn new(kind: CancelInputDeviceTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelInputDeviceTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelInputDeviceTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for CancelInputDeviceTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelInputDeviceTransferErrorKind::BadGatewayException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::BadRequestException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::ConflictException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::ForbiddenException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            CancelInputDeviceTransferErrorKind::NotFoundException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::UnprocessableEntityException(_inner) => {
                Some(_inner)
            }
            CancelInputDeviceTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelError {
    pub kind: CreateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelError {
    fn code(&self) -> Option<&str> {
        CreateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelError {
    pub fn new(kind: CreateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for CreateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelErrorKind::BadGatewayException(_inner) => Some(_inner),
            CreateChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CreateChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateChannelErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            CreateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInputError {
    pub kind: CreateInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInputErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInputErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CreateInputErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateInputErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateInputErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreateInputErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateInputErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInputError {
    fn code(&self) -> Option<&str> {
        CreateInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInputError {
    pub fn new(kind: CreateInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInputErrorKind::BadGatewayException(_inner) => Some(_inner),
            CreateInputErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateInputErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateInputErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CreateInputErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateInputErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInputSecurityGroupError {
    pub kind: CreateInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInputSecurityGroupErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInputSecurityGroupErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            CreateInputSecurityGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        CreateInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInputSecurityGroupError {
    pub fn new(kind: CreateInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInputSecurityGroupErrorKind::BadGatewayException(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMultiplexError {
    pub kind: CreateMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMultiplexErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMultiplexErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMultiplexError {
    fn code(&self) -> Option<&str> {
        CreateMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMultiplexError {
    pub fn new(kind: CreateMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for CreateMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMultiplexErrorKind::BadGatewayException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::ConflictException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            CreateMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMultiplexProgramError {
    pub kind: CreateMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMultiplexProgramErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMultiplexProgramErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        CreateMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMultiplexProgramError {
    pub fn new(kind: CreateMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for CreateMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMultiplexProgramErrorKind::BadGatewayException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::ConflictException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePartnerInputError {
    pub kind: CreatePartnerInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePartnerInputErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePartnerInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePartnerInputErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePartnerInputError {
    fn code(&self) -> Option<&str> {
        CreatePartnerInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePartnerInputError {
    pub fn new(kind: CreatePartnerInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePartnerInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePartnerInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreatePartnerInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePartnerInputErrorKind::BadGatewayException(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::BadRequestException(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTagsError {
    pub kind: CreateTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTagsError {
    fn code(&self) -> Option<&str> {
        CreateTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTagsError {
    pub fn new(kind: CreateTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTagsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CreateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateTagsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelError {
    pub kind: DeleteChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelError {
    fn code(&self) -> Option<&str> {
        DeleteChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelError {
    pub fn new(kind: DeleteChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInputError {
    pub kind: DeleteInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInputErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInputErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInputError {
    fn code(&self) -> Option<&str> {
        DeleteInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInputError {
    pub fn new(kind: DeleteInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInputErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteInputErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteInputErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteInputErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteInputErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteInputErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteInputErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteInputErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInputSecurityGroupError {
    pub kind: DeleteInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInputSecurityGroupErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInputSecurityGroupErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteInputSecurityGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DeleteInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInputSecurityGroupError {
    pub fn new(kind: DeleteInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInputSecurityGroupErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMultiplexError {
    pub kind: DeleteMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMultiplexErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMultiplexErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMultiplexError {
    fn code(&self) -> Option<&str> {
        DeleteMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMultiplexError {
    pub fn new(kind: DeleteMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMultiplexErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMultiplexProgramError {
    pub kind: DeleteMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMultiplexProgramErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMultiplexProgramErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        DeleteMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMultiplexProgramError {
    pub fn new(kind: DeleteMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMultiplexProgramErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteReservationError {
    pub kind: DeleteReservationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteReservationErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteReservationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteReservationErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteReservationError {
    fn code(&self) -> Option<&str> {
        DeleteReservationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteReservationError {
    pub fn new(kind: DeleteReservationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteReservationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteReservationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteReservationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteReservationErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteReservationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteReservationErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteReservationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteReservationErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteReservationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteReservationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteReservationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteReservationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteScheduleError {
    pub kind: DeleteScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteScheduleErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteScheduleErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteScheduleError {
    fn code(&self) -> Option<&str> {
        DeleteScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteScheduleError {
    pub fn new(kind: DeleteScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduleErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduleErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduleErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteScheduleErrorKind::BadGatewayException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTagsError {
    pub kind: DeleteTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTagsError {
    fn code(&self) -> Option<&str> {
        DeleteTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTagsError {
    pub fn new(kind: DeleteTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTagsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteTagsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelError {
    pub kind: DescribeChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelError {
    fn code(&self) -> Option<&str> {
        DescribeChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelError {
    pub fn new(kind: DescribeChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputError {
    pub kind: DescribeInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputError {
    fn code(&self) -> Option<&str> {
        DescribeInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputError {
    pub fn new(kind: DescribeInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeInputErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeInputErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeInputErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeInputErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeInputErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeInputErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputDeviceError {
    pub kind: DescribeInputDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputDeviceErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputDeviceErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputDeviceError {
    fn code(&self) -> Option<&str> {
        DescribeInputDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputDeviceError {
    pub fn new(kind: DescribeInputDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeInputDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputDeviceErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputDeviceThumbnailError {
    pub kind: DescribeInputDeviceThumbnailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputDeviceThumbnailErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputDeviceThumbnailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputDeviceThumbnailErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInputDeviceThumbnailErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInputDeviceThumbnailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputDeviceThumbnailError {
    fn code(&self) -> Option<&str> {
        DescribeInputDeviceThumbnailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputDeviceThumbnailError {
    pub fn new(kind: DescribeInputDeviceThumbnailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputDeviceThumbnailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputDeviceThumbnailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeInputDeviceThumbnailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputDeviceThumbnailErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeInputDeviceThumbnailErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputSecurityGroupError {
    pub kind: DescribeInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputSecurityGroupErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputSecurityGroupErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeInputSecurityGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DescribeInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputSecurityGroupError {
    pub fn new(kind: DescribeInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputSecurityGroupErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeInputSecurityGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMultiplexError {
    pub kind: DescribeMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMultiplexErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMultiplexErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMultiplexError {
    fn code(&self) -> Option<&str> {
        DescribeMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMultiplexError {
    pub fn new(kind: DescribeMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeMultiplexErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMultiplexErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMultiplexProgramError {
    pub kind: DescribeMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMultiplexProgramErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMultiplexProgramErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMultiplexProgramErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        DescribeMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMultiplexProgramError {
    pub fn new(kind: DescribeMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMultiplexProgramErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOfferingError {
    pub kind: DescribeOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOfferingErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOfferingErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOfferingError {
    fn code(&self) -> Option<&str> {
        DescribeOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOfferingError {
    pub fn new(kind: DescribeOfferingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeOfferingErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeOfferingErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOfferingErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeOfferingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservationError {
    pub kind: DescribeReservationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservationErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservationErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservationError {
    fn code(&self) -> Option<&str> {
        DescribeReservationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservationError {
    pub fn new(kind: DescribeReservationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeReservationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservationErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeReservationErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeReservationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeReservationErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeReservationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeReservationErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeReservationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeReservationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeScheduleError {
    pub kind: DescribeScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeScheduleErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeScheduleErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeScheduleError {
    fn code(&self) -> Option<&str> {
        DescribeScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeScheduleError {
    pub fn new(kind: DescribeScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeScheduleErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeScheduleErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeScheduleErrorKind::BadGatewayException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsError {
    pub kind: ListChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsError {
    fn code(&self) -> Option<&str> {
        ListChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsError {
    pub fn new(kind: ListChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListChannelsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelsErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListChannelsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListChannelsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputDevicesError {
    pub kind: ListInputDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputDevicesErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputDevicesErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputDevicesError {
    fn code(&self) -> Option<&str> {
        ListInputDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputDevicesError {
    pub fn new(kind: ListInputDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListInputDevicesErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListInputDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputDevicesErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListInputDevicesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListInputDevicesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListInputDevicesErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListInputDevicesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListInputDevicesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListInputDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputDeviceTransfersError {
    pub kind: ListInputDeviceTransfersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputDeviceTransfersErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputDeviceTransfersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputDeviceTransfersErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListInputDeviceTransfersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::UnprocessableEntityException(_inner) => {
                _inner.fmt(f)
            }
            ListInputDeviceTransfersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputDeviceTransfersError {
    fn code(&self) -> Option<&str> {
        ListInputDeviceTransfersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputDeviceTransfersError {
    pub fn new(kind: ListInputDeviceTransfersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputDeviceTransfersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputDeviceTransfersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for ListInputDeviceTransfersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputDeviceTransfersErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputsError {
    pub kind: ListInputsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputsErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputsErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListInputsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListInputsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListInputsErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListInputsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListInputsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListInputsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputsError {
    fn code(&self) -> Option<&str> {
        ListInputsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputsError {
    pub fn new(kind: ListInputsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListInputsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputsErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListInputsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListInputsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListInputsErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListInputsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListInputsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListInputsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputSecurityGroupsError {
    pub kind: ListInputSecurityGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputSecurityGroupsErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputSecurityGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputSecurityGroupsErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputSecurityGroupsError {
    fn code(&self) -> Option<&str> {
        ListInputSecurityGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputSecurityGroupsError {
    pub fn new(kind: ListInputSecurityGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputSecurityGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputSecurityGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListInputSecurityGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputSecurityGroupsErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMultiplexesError {
    pub kind: ListMultiplexesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMultiplexesErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMultiplexesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMultiplexesErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMultiplexesError {
    fn code(&self) -> Option<&str> {
        ListMultiplexesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMultiplexesError {
    pub fn new(kind: ListMultiplexesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMultiplexesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMultiplexesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexesErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListMultiplexesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMultiplexesErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListMultiplexesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMultiplexesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListMultiplexesErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListMultiplexesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListMultiplexesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListMultiplexesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMultiplexProgramsError {
    pub kind: ListMultiplexProgramsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMultiplexProgramsErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMultiplexProgramsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMultiplexProgramsErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMultiplexProgramsError {
    fn code(&self) -> Option<&str> {
        ListMultiplexProgramsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMultiplexProgramsError {
    pub fn new(kind: ListMultiplexProgramsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMultiplexProgramsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMultiplexProgramsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListMultiplexProgramsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMultiplexProgramsErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOfferingsError {
    pub kind: ListOfferingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOfferingsErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOfferingsErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOfferingsError {
    fn code(&self) -> Option<&str> {
        ListOfferingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOfferingsError {
    pub fn new(kind: ListOfferingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOfferingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOfferingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingsErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOfferingsErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListOfferingsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListOfferingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListOfferingsErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListOfferingsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListOfferingsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListOfferingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReservationsError {
    pub kind: ListReservationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReservationsErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReservationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReservationsErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReservationsError {
    fn code(&self) -> Option<&str> {
        ListReservationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReservationsError {
    pub fn new(kind: ListReservationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReservationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReservationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListReservationsErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListReservationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReservationsErrorKind::BadGatewayException(_inner) => Some(_inner),
            ListReservationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListReservationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListReservationsErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            ListReservationsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListReservationsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListReservationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PurchaseOfferingError {
    pub kind: PurchaseOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseOfferingErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PurchaseOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PurchaseOfferingErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PurchaseOfferingError {
    fn code(&self) -> Option<&str> {
        PurchaseOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseOfferingError {
    pub fn new(kind: PurchaseOfferingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PurchaseOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PurchaseOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PurchaseOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PurchaseOfferingErrorKind::BadGatewayException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::BadRequestException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::ConflictException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::ForbiddenException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::NotFoundException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectInputDeviceTransferError {
    pub kind: RejectInputDeviceTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectInputDeviceTransferErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectInputDeviceTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectInputDeviceTransferErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::ConflictException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            RejectInputDeviceTransferErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::UnprocessableEntityException(_inner) => {
                _inner.fmt(f)
            }
            RejectInputDeviceTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectInputDeviceTransferError {
    fn code(&self) -> Option<&str> {
        RejectInputDeviceTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectInputDeviceTransferError {
    pub fn new(kind: RejectInputDeviceTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectInputDeviceTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectInputDeviceTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for RejectInputDeviceTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectInputDeviceTransferErrorKind::BadGatewayException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::BadRequestException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::ConflictException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::ForbiddenException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            RejectInputDeviceTransferErrorKind::NotFoundException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::UnprocessableEntityException(_inner) => {
                Some(_inner)
            }
            RejectInputDeviceTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartChannelError {
    pub kind: StartChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartChannelErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartChannelErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            StartChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartChannelError {
    fn code(&self) -> Option<&str> {
        StartChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartChannelError {
    pub fn new(kind: StartChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChannelErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for StartChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartChannelErrorKind::BadGatewayException(_inner) => Some(_inner),
            StartChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            StartChannelErrorKind::ConflictException(_inner) => Some(_inner),
            StartChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            StartChannelErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            StartChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            StartChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            StartChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            StartChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMultiplexError {
    pub kind: StartMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMultiplexErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMultiplexErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMultiplexError {
    fn code(&self) -> Option<&str> {
        StartMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMultiplexError {
    pub fn new(kind: StartMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMultiplexErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMultiplexErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMultiplexErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for StartMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMultiplexErrorKind::BadGatewayException(_inner) => Some(_inner),
            StartMultiplexErrorKind::BadRequestException(_inner) => Some(_inner),
            StartMultiplexErrorKind::ConflictException(_inner) => Some(_inner),
            StartMultiplexErrorKind::ForbiddenException(_inner) => Some(_inner),
            StartMultiplexErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            StartMultiplexErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            StartMultiplexErrorKind::NotFoundException(_inner) => Some(_inner),
            StartMultiplexErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            StartMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopChannelError {
    pub kind: StopChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopChannelErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopChannelErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            StopChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopChannelError {
    fn code(&self) -> Option<&str> {
        StopChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopChannelError {
    pub fn new(kind: StopChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for StopChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopChannelErrorKind::BadGatewayException(_inner) => Some(_inner),
            StopChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            StopChannelErrorKind::ConflictException(_inner) => Some(_inner),
            StopChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            StopChannelErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            StopChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            StopChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            StopChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            StopChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopMultiplexError {
    pub kind: StopMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopMultiplexErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopMultiplexErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopMultiplexError {
    fn code(&self) -> Option<&str> {
        StopMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopMultiplexError {
    pub fn new(kind: StopMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMultiplexErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMultiplexErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMultiplexErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for StopMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopMultiplexErrorKind::BadGatewayException(_inner) => Some(_inner),
            StopMultiplexErrorKind::BadRequestException(_inner) => Some(_inner),
            StopMultiplexErrorKind::ConflictException(_inner) => Some(_inner),
            StopMultiplexErrorKind::ForbiddenException(_inner) => Some(_inner),
            StopMultiplexErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            StopMultiplexErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            StopMultiplexErrorKind::NotFoundException(_inner) => Some(_inner),
            StopMultiplexErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            StopMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransferInputDeviceError {
    pub kind: TransferInputDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransferInputDeviceErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransferInputDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransferInputDeviceErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransferInputDeviceError {
    fn code(&self) -> Option<&str> {
        TransferInputDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransferInputDeviceError {
    pub fn new(kind: TransferInputDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransferInputDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransferInputDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for TransferInputDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransferInputDeviceErrorKind::BadGatewayException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::BadRequestException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::ConflictException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::ForbiddenException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::NotFoundException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelError {
    pub kind: UpdateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelError {
    fn code(&self) -> Option<&str> {
        UpdateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelError {
    pub fn new(kind: UpdateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateChannelErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            UpdateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelClassError {
    pub kind: UpdateChannelClassErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelClassErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelClassError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelClassErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelClassError {
    fn code(&self) -> Option<&str> {
        UpdateChannelClassError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelClassError {
    pub fn new(kind: UpdateChannelClassErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelClassErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelClassErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateChannelClassError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelClassErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInputError {
    pub kind: UpdateInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInputErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInputErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInputError {
    fn code(&self) -> Option<&str> {
        UpdateInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInputError {
    pub fn new(kind: UpdateInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::GatewayTimeoutException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UpdateInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInputErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateInputErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateInputErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateInputErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateInputErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateInputErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateInputErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInputDeviceError {
    pub kind: UpdateInputDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInputDeviceErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInputDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInputDeviceErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInputDeviceError {
    fn code(&self) -> Option<&str> {
        UpdateInputDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInputDeviceError {
    pub fn new(kind: UpdateInputDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInputDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInputDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateInputDeviceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateInputDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInputDeviceErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInputSecurityGroupError {
    pub kind: UpdateInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInputSecurityGroupErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInputSecurityGroupErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateInputSecurityGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        UpdateInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInputSecurityGroupError {
    pub fn new(kind: UpdateInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInputSecurityGroupErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMultiplexError {
    pub kind: UpdateMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMultiplexErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMultiplexErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMultiplexError {
    fn code(&self) -> Option<&str> {
        UpdateMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMultiplexError {
    pub fn new(kind: UpdateMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::BadGatewayException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::ForbiddenException(_))
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::NotFoundException(_))
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMultiplexErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMultiplexProgramError {
    pub kind: UpdateMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMultiplexProgramErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMultiplexProgramErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        UpdateMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMultiplexProgramError {
    pub fn new(kind: UpdateMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMultiplexProgramErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateReservationError {
    pub kind: UpdateReservationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateReservationErrorKind {
    BadGatewayException(crate::error::BadGatewayException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateReservationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateReservationErrorKind::BadGatewayException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::GatewayTimeoutException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateReservationError {
    fn code(&self) -> Option<&str> {
        UpdateReservationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateReservationError {
    pub fn new(kind: UpdateReservationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateReservationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateReservationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::BadGatewayException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::GatewayTimeoutException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateReservationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateReservationErrorKind::BadGatewayException(_inner) => Some(_inner),
            UpdateReservationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateReservationErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateReservationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateReservationErrorKind::GatewayTimeoutException(_inner) => Some(_inner),
            UpdateReservationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateReservationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateReservationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateReservationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Placeholder documentation for TooManyRequestsException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// Placeholder documentation for NotFoundException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// Placeholder documentation for InternalServerErrorException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// Placeholder documentation for GatewayTimeoutException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GatewayTimeoutException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GatewayTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GatewayTimeoutException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GatewayTimeoutException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GatewayTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GatewayTimeoutException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for GatewayTimeoutException {}
/// See [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
pub mod gateway_timeout_exception {
    /// A builder for [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
        pub fn build(self) -> crate::error::GatewayTimeoutException {
            crate::error::GatewayTimeoutException {
                message: self.message,
            }
        }
    }
}
impl GatewayTimeoutException {
    /// Creates a new builder-style object to manufacture [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
    pub fn builder() -> crate::error::gateway_timeout_exception::Builder {
        crate::error::gateway_timeout_exception::Builder::default()
    }
}

/// Placeholder documentation for ForbiddenException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// Placeholder documentation for ConflictException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Placeholder documentation for BadRequestException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// Placeholder documentation for BadGatewayException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadGatewayException {
    /// Placeholder documentation for __string
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadGatewayException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadGatewayException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadGatewayException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadGatewayException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadGatewayException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadGatewayException {}
/// See [`BadGatewayException`](crate::error::BadGatewayException)
pub mod bad_gateway_exception {
    /// A builder for [`BadGatewayException`](crate::error::BadGatewayException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadGatewayException`](crate::error::BadGatewayException)
        pub fn build(self) -> crate::error::BadGatewayException {
            crate::error::BadGatewayException {
                message: self.message,
            }
        }
    }
}
impl BadGatewayException {
    /// Creates a new builder-style object to manufacture [`BadGatewayException`](crate::error::BadGatewayException)
    pub fn builder() -> crate::error::bad_gateway_exception::Builder {
        crate::error::bad_gateway_exception::Builder::default()
    }
}

/// Placeholder documentation for UnprocessableEntityException
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessableEntityException {
    /// The error message.
    pub message: std::option::Option<std::string::String>,
    /// A collection of validation error responses.
    pub validation_errors: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
}
impl std::fmt::Debug for UnprocessableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessableEntityException");
        formatter.field("message", &self.message);
        formatter.field("validation_errors", &self.validation_errors);
        formatter.finish()
    }
}
impl UnprocessableEntityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnprocessableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnprocessableEntityException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnprocessableEntityException {}
/// See [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
pub mod unprocessable_entity_exception {
    /// A builder for [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) validation_errors:
            std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
    }
    impl Builder {
        /// The error message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn validation_errors(
            mut self,
            input: impl Into<crate::model::ValidationError>,
        ) -> Self {
            let mut v = self.validation_errors.unwrap_or_default();
            v.push(input.into());
            self.validation_errors = Some(v);
            self
        }
        pub fn set_validation_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
        ) -> Self {
            self.validation_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
        pub fn build(self) -> crate::error::UnprocessableEntityException {
            crate::error::UnprocessableEntityException {
                message: self.message,
                validation_errors: self.validation_errors,
            }
        }
    }
}
impl UnprocessableEntityException {
    /// Creates a new builder-style object to manufacture [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
    pub fn builder() -> crate::error::unprocessable_entity_exception::Builder {
        crate::error::unprocessable_entity_exception::Builder::default()
    }
}
