// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptInputDeviceTransferError {
    pub kind: AcceptInputDeviceTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptInputDeviceTransferErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptInputDeviceTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptInputDeviceTransferErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::ConflictError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            AcceptInputDeviceTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptInputDeviceTransferError {
    fn code(&self) -> Option<&str> {
        AcceptInputDeviceTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptInputDeviceTransferError {
    pub fn new(kind: AcceptInputDeviceTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptInputDeviceTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptInputDeviceTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptInputDeviceTransferErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for AcceptInputDeviceTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptInputDeviceTransferErrorKind::BadGatewayError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::BadRequestError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::ConflictError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::ForbiddenError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::NotFoundError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            AcceptInputDeviceTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteError {
    pub kind: BatchDeleteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::ConflictError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            BatchDeleteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteError {
    fn code(&self) -> Option<&str> {
        BatchDeleteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteError {
    pub fn new(kind: BatchDeleteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, BatchDeleteErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for BatchDeleteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteErrorKind::BadGatewayError(_inner) => Some(_inner),
            BatchDeleteErrorKind::BadRequestError(_inner) => Some(_inner),
            BatchDeleteErrorKind::ConflictError(_inner) => Some(_inner),
            BatchDeleteErrorKind::ForbiddenError(_inner) => Some(_inner),
            BatchDeleteErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            BatchDeleteErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            BatchDeleteErrorKind::NotFoundError(_inner) => Some(_inner),
            BatchDeleteErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            BatchDeleteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchStartError {
    pub kind: BatchStartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchStartErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchStartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchStartErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::ConflictError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            BatchStartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchStartError {
    fn code(&self) -> Option<&str> {
        BatchStartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchStartError {
    pub fn new(kind: BatchStartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchStartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchStartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::InternalServerErrorError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, BatchStartErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for BatchStartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchStartErrorKind::BadGatewayError(_inner) => Some(_inner),
            BatchStartErrorKind::BadRequestError(_inner) => Some(_inner),
            BatchStartErrorKind::ConflictError(_inner) => Some(_inner),
            BatchStartErrorKind::ForbiddenError(_inner) => Some(_inner),
            BatchStartErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            BatchStartErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            BatchStartErrorKind::NotFoundError(_inner) => Some(_inner),
            BatchStartErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            BatchStartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchStopError {
    pub kind: BatchStopErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchStopErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchStopError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchStopErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::ConflictError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            BatchStopErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchStopError {
    fn code(&self) -> Option<&str> {
        BatchStopError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchStopError {
    pub fn new(kind: BatchStopErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchStopErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchStopErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::InternalServerErrorError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, BatchStopErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for BatchStopError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchStopErrorKind::BadGatewayError(_inner) => Some(_inner),
            BatchStopErrorKind::BadRequestError(_inner) => Some(_inner),
            BatchStopErrorKind::ConflictError(_inner) => Some(_inner),
            BatchStopErrorKind::ForbiddenError(_inner) => Some(_inner),
            BatchStopErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            BatchStopErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            BatchStopErrorKind::NotFoundError(_inner) => Some(_inner),
            BatchStopErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            BatchStopErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdateScheduleError {
    pub kind: BatchUpdateScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdateScheduleErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUpdateScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdateScheduleErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            BatchUpdateScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUpdateScheduleError {
    fn code(&self) -> Option<&str> {
        BatchUpdateScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdateScheduleError {
    pub fn new(kind: BatchUpdateScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdateScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdateScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, BatchUpdateScheduleErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, BatchUpdateScheduleErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, BatchUpdateScheduleErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, BatchUpdateScheduleErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateScheduleErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for BatchUpdateScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdateScheduleErrorKind::BadGatewayError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::BadRequestError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::ForbiddenError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::NotFoundError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            BatchUpdateScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelInputDeviceTransferError {
    pub kind: CancelInputDeviceTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelInputDeviceTransferErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelInputDeviceTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelInputDeviceTransferErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CancelInputDeviceTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelInputDeviceTransferError {
    fn code(&self) -> Option<&str> {
        CancelInputDeviceTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelInputDeviceTransferError {
    pub fn new(kind: CancelInputDeviceTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelInputDeviceTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelInputDeviceTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelInputDeviceTransferErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CancelInputDeviceTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelInputDeviceTransferErrorKind::BadGatewayError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::BadRequestError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::ConflictError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::ForbiddenError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::NotFoundError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CancelInputDeviceTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelError {
    pub kind: CreateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelError {
    fn code(&self) -> Option<&str> {
        CreateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelError {
    pub fn new(kind: CreateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::TooManyRequestsError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CreateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelErrorKind::BadGatewayError(_inner) => Some(_inner),
            CreateChannelErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateChannelErrorKind::ConflictError(_inner) => Some(_inner),
            CreateChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateChannelErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CreateChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateChannelErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CreateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInputError {
    pub kind: CreateInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInputErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInputErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CreateInputErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateInputErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateInputErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CreateInputErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateInputErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInputError {
    fn code(&self) -> Option<&str> {
        CreateInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInputError {
    pub fn new(kind: CreateInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, CreateInputErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for CreateInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInputErrorKind::BadGatewayError(_inner) => Some(_inner),
            CreateInputErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateInputErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateInputErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CreateInputErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateInputErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInputSecurityGroupError {
    pub kind: CreateInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInputSecurityGroupErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInputSecurityGroupErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        CreateInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInputSecurityGroupError {
    pub fn new(kind: CreateInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInputSecurityGroupErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInputSecurityGroupErrorKind::BadGatewayError(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMultiplexError {
    pub kind: CreateMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMultiplexErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMultiplexErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CreateMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMultiplexError {
    fn code(&self) -> Option<&str> {
        CreateMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMultiplexError {
    pub fn new(kind: CreateMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, CreateMultiplexErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CreateMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMultiplexErrorKind::BadGatewayError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::ConflictError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CreateMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMultiplexProgramError {
    pub kind: CreateMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMultiplexProgramErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMultiplexProgramErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CreateMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        CreateMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMultiplexProgramError {
    pub fn new(kind: CreateMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateMultiplexProgramErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CreateMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMultiplexProgramErrorKind::BadGatewayError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::ConflictError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CreateMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePartnerInputError {
    pub kind: CreatePartnerInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePartnerInputErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePartnerInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePartnerInputErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreatePartnerInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePartnerInputError {
    fn code(&self) -> Option<&str> {
        CreatePartnerInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePartnerInputError {
    pub fn new(kind: CreatePartnerInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePartnerInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePartnerInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, CreatePartnerInputErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreatePartnerInputErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreatePartnerInputErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerInputErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreatePartnerInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePartnerInputErrorKind::BadGatewayError(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::BadRequestError(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreatePartnerInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTagsError {
    pub kind: CreateTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTagsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTagsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTagsError {
    fn code(&self) -> Option<&str> {
        CreateTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTagsError {
    pub fn new(kind: CreateTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::InternalServerErrorError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::NotFoundError(_))
    }
}
impl std::error::Error for CreateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTagsErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateTagsErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateTagsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateTagsErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelError {
    pub kind: DeleteChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelError {
    fn code(&self) -> Option<&str> {
        DeleteChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelError {
    pub fn new(kind: DeleteChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for DeleteChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteChannelErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteChannelErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteChannelErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInputError {
    pub kind: DeleteInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInputErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInputErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInputError {
    fn code(&self) -> Option<&str> {
        DeleteInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInputError {
    pub fn new(kind: DeleteInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, DeleteInputErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for DeleteInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInputErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteInputErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteInputErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteInputErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteInputErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteInputErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteInputErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteInputErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInputSecurityGroupError {
    pub kind: DeleteInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInputSecurityGroupErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInputSecurityGroupErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DeleteInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInputSecurityGroupError {
    pub fn new(kind: DeleteInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInputSecurityGroupErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInputSecurityGroupErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMultiplexError {
    pub kind: DeleteMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMultiplexErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMultiplexErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMultiplexError {
    fn code(&self) -> Option<&str> {
        DeleteMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMultiplexError {
    pub fn new(kind: DeleteMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteMultiplexErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMultiplexErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMultiplexProgramError {
    pub kind: DeleteMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMultiplexProgramErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMultiplexProgramErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        DeleteMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMultiplexProgramError {
    pub fn new(kind: DeleteMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMultiplexProgramErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMultiplexProgramErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteReservationError {
    pub kind: DeleteReservationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteReservationErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteReservationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteReservationErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteReservationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteReservationError {
    fn code(&self) -> Option<&str> {
        DeleteReservationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteReservationError {
    pub fn new(kind: DeleteReservationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteReservationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteReservationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteReservationErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReservationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteReservationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteReservationErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteReservationErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteReservationErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteReservationErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteReservationErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteReservationErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteReservationErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteReservationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteReservationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteScheduleError {
    pub kind: DeleteScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteScheduleErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteScheduleErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteScheduleError {
    fn code(&self) -> Option<&str> {
        DeleteScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteScheduleError {
    pub fn new(kind: DeleteScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduleErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, DeleteScheduleErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for DeleteScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteScheduleErrorKind::BadGatewayError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTagsError {
    pub kind: DeleteTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTagsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTagsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTagsError {
    fn code(&self) -> Option<&str> {
        DeleteTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTagsError {
    pub fn new(kind: DeleteTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::InternalServerErrorError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::NotFoundError(_))
    }
}
impl std::error::Error for DeleteTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTagsErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteTagsErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteTagsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteTagsErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelError {
    pub kind: DescribeChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelError {
    fn code(&self) -> Option<&str> {
        DescribeChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelError {
    pub fn new(kind: DescribeChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeChannelErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeChannelErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputError {
    pub kind: DescribeInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputError {
    fn code(&self) -> Option<&str> {
        DescribeInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputError {
    pub fn new(kind: DescribeInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, DescribeInputErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for DescribeInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeInputErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeInputErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeInputErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeInputErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeInputErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeInputErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputDeviceError {
    pub kind: DescribeInputDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputDeviceErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputDeviceErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeInputDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputDeviceError {
    fn code(&self) -> Option<&str> {
        DescribeInputDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputDeviceError {
    pub fn new(kind: DescribeInputDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeInputDeviceErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeInputDeviceErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeInputDeviceErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeInputDeviceErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeInputDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputDeviceErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeInputDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputDeviceThumbnailError {
    pub kind: DescribeInputDeviceThumbnailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputDeviceThumbnailErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputDeviceThumbnailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputDeviceThumbnailErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::InternalServerErrorError(_inner) => {
                _inner.fmt(f)
            }
            DescribeInputDeviceThumbnailErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeInputDeviceThumbnailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputDeviceThumbnailError {
    fn code(&self) -> Option<&str> {
        DescribeInputDeviceThumbnailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputDeviceThumbnailError {
    pub fn new(kind: DescribeInputDeviceThumbnailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputDeviceThumbnailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputDeviceThumbnailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputDeviceThumbnailErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeInputDeviceThumbnailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputDeviceThumbnailErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeInputDeviceThumbnailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInputSecurityGroupError {
    pub kind: DescribeInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInputSecurityGroupErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInputSecurityGroupErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DescribeInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInputSecurityGroupError {
    pub fn new(kind: DescribeInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInputSecurityGroupErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInputSecurityGroupErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMultiplexError {
    pub kind: DescribeMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMultiplexErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMultiplexErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMultiplexError {
    fn code(&self) -> Option<&str> {
        DescribeMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMultiplexError {
    pub fn new(kind: DescribeMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeMultiplexErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeMultiplexErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeMultiplexErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeMultiplexErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMultiplexErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMultiplexProgramError {
    pub kind: DescribeMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMultiplexProgramErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMultiplexProgramErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        DescribeMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMultiplexProgramError {
    pub fn new(kind: DescribeMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMultiplexProgramErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMultiplexProgramErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOfferingError {
    pub kind: DescribeOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOfferingErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOfferingErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeOfferingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOfferingError {
    fn code(&self) -> Option<&str> {
        DescribeOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOfferingError {
    pub fn new(kind: DescribeOfferingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeOfferingErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeOfferingErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeOfferingErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeOfferingErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOfferingErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOfferingErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeOfferingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservationError {
    pub kind: DescribeReservationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservationErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservationErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeReservationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservationError {
    fn code(&self) -> Option<&str> {
        DescribeReservationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservationError {
    pub fn new(kind: DescribeReservationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeReservationErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeReservationErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeReservationErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeReservationErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeReservationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservationErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeReservationErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeReservationErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeReservationErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeReservationErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeReservationErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeReservationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeReservationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeScheduleError {
    pub kind: DescribeScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeScheduleErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeScheduleErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeScheduleError {
    fn code(&self) -> Option<&str> {
        DescribeScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeScheduleError {
    pub fn new(kind: DescribeScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, DescribeScheduleErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DescribeScheduleErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeScheduleErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeScheduleErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduleErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DescribeScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeScheduleErrorKind::BadGatewayError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::BadRequestError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsError {
    pub kind: ListChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsError {
    fn code(&self) -> Option<&str> {
        ListChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsError {
    pub fn new(kind: ListChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for ListChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListChannelsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListChannelsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListChannelsErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListChannelsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListChannelsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputDevicesError {
    pub kind: ListInputDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputDevicesErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputDevicesErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListInputDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputDevicesError {
    fn code(&self) -> Option<&str> {
        ListInputDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputDevicesError {
    pub fn new(kind: ListInputDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, ListInputDevicesErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListInputDevicesErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListInputDevicesErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDevicesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListInputDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputDevicesErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListInputDevicesErrorKind::BadRequestError(_inner) => Some(_inner),
            ListInputDevicesErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListInputDevicesErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListInputDevicesErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListInputDevicesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListInputDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputDeviceTransfersError {
    pub kind: ListInputDeviceTransfersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputDeviceTransfersErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputDeviceTransfersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputDeviceTransfersErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            ListInputDeviceTransfersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputDeviceTransfersError {
    fn code(&self) -> Option<&str> {
        ListInputDeviceTransfersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputDeviceTransfersError {
    pub fn new(kind: ListInputDeviceTransfersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputDeviceTransfersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputDeviceTransfersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputDeviceTransfersErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for ListInputDeviceTransfersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputDeviceTransfersErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::BadRequestError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            ListInputDeviceTransfersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputsError {
    pub kind: ListInputsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputsErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputsErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListInputsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListInputsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListInputsErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListInputsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListInputsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListInputsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputsError {
    fn code(&self) -> Option<&str> {
        ListInputsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputsError {
    pub fn new(kind: ListInputsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::InternalServerErrorError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ListInputsErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for ListInputsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputsErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListInputsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListInputsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListInputsErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListInputsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListInputsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListInputsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInputSecurityGroupsError {
    pub kind: ListInputSecurityGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInputSecurityGroupsErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInputSecurityGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInputSecurityGroupsErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListInputSecurityGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInputSecurityGroupsError {
    fn code(&self) -> Option<&str> {
        ListInputSecurityGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInputSecurityGroupsError {
    pub fn new(kind: ListInputSecurityGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInputSecurityGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInputSecurityGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInputSecurityGroupsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListInputSecurityGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInputSecurityGroupsErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListInputSecurityGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMultiplexesError {
    pub kind: ListMultiplexesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMultiplexesErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMultiplexesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMultiplexesErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListMultiplexesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMultiplexesError {
    fn code(&self) -> Option<&str> {
        ListMultiplexesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMultiplexesError {
    pub fn new(kind: ListMultiplexesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMultiplexesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMultiplexesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, ListMultiplexesErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexesErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListMultiplexesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMultiplexesErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListMultiplexesErrorKind::BadRequestError(_inner) => Some(_inner),
            ListMultiplexesErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListMultiplexesErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListMultiplexesErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListMultiplexesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListMultiplexesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMultiplexProgramsError {
    pub kind: ListMultiplexProgramsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMultiplexProgramsErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMultiplexProgramsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMultiplexProgramsErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListMultiplexProgramsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMultiplexProgramsError {
    fn code(&self) -> Option<&str> {
        ListMultiplexProgramsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMultiplexProgramsError {
    pub fn new(kind: ListMultiplexProgramsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMultiplexProgramsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMultiplexProgramsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListMultiplexProgramsErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMultiplexProgramsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListMultiplexProgramsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMultiplexProgramsErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListMultiplexProgramsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOfferingsError {
    pub kind: ListOfferingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOfferingsErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOfferingsErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOfferingsError {
    fn code(&self) -> Option<&str> {
        ListOfferingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOfferingsError {
    pub fn new(kind: ListOfferingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOfferingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOfferingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for ListOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOfferingsErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListOfferingsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListOfferingsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListOfferingsErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListOfferingsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListOfferingsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListOfferingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReservationsError {
    pub kind: ListReservationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReservationsErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReservationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReservationsErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListReservationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReservationsError {
    fn code(&self) -> Option<&str> {
        ListReservationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReservationsError {
    pub fn new(kind: ListReservationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReservationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReservationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, ListReservationsErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListReservationsErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListReservationsErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListReservationsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListReservationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReservationsErrorKind::BadGatewayError(_inner) => Some(_inner),
            ListReservationsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListReservationsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListReservationsErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            ListReservationsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListReservationsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListReservationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::NotFoundError(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PurchaseOfferingError {
    pub kind: PurchaseOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseOfferingErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PurchaseOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PurchaseOfferingErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PurchaseOfferingError {
    fn code(&self) -> Option<&str> {
        PurchaseOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseOfferingError {
    pub fn new(kind: PurchaseOfferingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PurchaseOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PurchaseOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PurchaseOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PurchaseOfferingErrorKind::BadGatewayError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::BadRequestError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::ConflictError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::ForbiddenError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::NotFoundError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectInputDeviceTransferError {
    pub kind: RejectInputDeviceTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectInputDeviceTransferErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectInputDeviceTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectInputDeviceTransferErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::ConflictError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            RejectInputDeviceTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectInputDeviceTransferError {
    fn code(&self) -> Option<&str> {
        RejectInputDeviceTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectInputDeviceTransferError {
    pub fn new(kind: RejectInputDeviceTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectInputDeviceTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectInputDeviceTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectInputDeviceTransferErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for RejectInputDeviceTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectInputDeviceTransferErrorKind::BadGatewayError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::BadRequestError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::ConflictError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::ForbiddenError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::NotFoundError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            RejectInputDeviceTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartChannelError {
    pub kind: StartChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartChannelErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartChannelErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            StartChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartChannelError {
    fn code(&self) -> Option<&str> {
        StartChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartChannelError {
    pub fn new(kind: StartChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            StartChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, StartChannelErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for StartChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartChannelErrorKind::BadGatewayError(_inner) => Some(_inner),
            StartChannelErrorKind::BadRequestError(_inner) => Some(_inner),
            StartChannelErrorKind::ConflictError(_inner) => Some(_inner),
            StartChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            StartChannelErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            StartChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            StartChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            StartChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            StartChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMultiplexError {
    pub kind: StartMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMultiplexErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMultiplexErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::ConflictError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            StartMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMultiplexError {
    fn code(&self) -> Option<&str> {
        StartMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMultiplexError {
    pub fn new(kind: StartMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            StartMultiplexErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, StartMultiplexErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for StartMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMultiplexErrorKind::BadGatewayError(_inner) => Some(_inner),
            StartMultiplexErrorKind::BadRequestError(_inner) => Some(_inner),
            StartMultiplexErrorKind::ConflictError(_inner) => Some(_inner),
            StartMultiplexErrorKind::ForbiddenError(_inner) => Some(_inner),
            StartMultiplexErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            StartMultiplexErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            StartMultiplexErrorKind::NotFoundError(_inner) => Some(_inner),
            StartMultiplexErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            StartMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopChannelError {
    pub kind: StopChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopChannelErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopChannelErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            StopChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopChannelError {
    fn code(&self) -> Option<&str> {
        StopChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopChannelError {
    pub fn new(kind: StopChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            StopChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, StopChannelErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for StopChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopChannelErrorKind::BadGatewayError(_inner) => Some(_inner),
            StopChannelErrorKind::BadRequestError(_inner) => Some(_inner),
            StopChannelErrorKind::ConflictError(_inner) => Some(_inner),
            StopChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            StopChannelErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            StopChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            StopChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            StopChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            StopChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopMultiplexError {
    pub kind: StopMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopMultiplexErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopMultiplexErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::ConflictError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            StopMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopMultiplexError {
    fn code(&self) -> Option<&str> {
        StopMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopMultiplexError {
    pub fn new(kind: StopMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            StopMultiplexErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, StopMultiplexErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for StopMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopMultiplexErrorKind::BadGatewayError(_inner) => Some(_inner),
            StopMultiplexErrorKind::BadRequestError(_inner) => Some(_inner),
            StopMultiplexErrorKind::ConflictError(_inner) => Some(_inner),
            StopMultiplexErrorKind::ForbiddenError(_inner) => Some(_inner),
            StopMultiplexErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            StopMultiplexErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            StopMultiplexErrorKind::NotFoundError(_inner) => Some(_inner),
            StopMultiplexErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            StopMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransferInputDeviceError {
    pub kind: TransferInputDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransferInputDeviceErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransferInputDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransferInputDeviceErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::ConflictError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            TransferInputDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransferInputDeviceError {
    fn code(&self) -> Option<&str> {
        TransferInputDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransferInputDeviceError {
    pub fn new(kind: TransferInputDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransferInputDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransferInputDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, TransferInputDeviceErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, TransferInputDeviceErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, TransferInputDeviceErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, TransferInputDeviceErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, TransferInputDeviceErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            TransferInputDeviceErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for TransferInputDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransferInputDeviceErrorKind::BadGatewayError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::BadRequestError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::ConflictError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::ForbiddenError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::NotFoundError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            TransferInputDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelError {
    pub kind: UpdateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelError {
    fn code(&self) -> Option<&str> {
        UpdateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelError {
    pub fn new(kind: UpdateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateChannelErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateChannelErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateChannelErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateChannelErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelClassError {
    pub kind: UpdateChannelClassErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelClassErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelClassError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelClassErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateChannelClassErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelClassError {
    fn code(&self) -> Option<&str> {
        UpdateChannelClassError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelClassError {
    pub fn new(kind: UpdateChannelClassErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelClassErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelClassErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelClassErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelClassErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelClassErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelClassErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelClassErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelClassErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateChannelClassError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelClassErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateChannelClassErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInputError {
    pub kind: UpdateInputErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInputErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInputErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateInputErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInputError {
    fn code(&self) -> Option<&str> {
        UpdateInputError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInputError {
    pub fn new(kind: UpdateInputErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInputErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInputErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateInputErrorKind::NotFoundError(_))
    }
}
impl std::error::Error for UpdateInputError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInputErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateInputErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateInputErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateInputErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateInputErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateInputErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateInputErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateInputErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInputDeviceError {
    pub kind: UpdateInputDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInputDeviceErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInputDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInputDeviceErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateInputDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInputDeviceError {
    fn code(&self) -> Option<&str> {
        UpdateInputDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInputDeviceError {
    pub fn new(kind: UpdateInputDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInputDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInputDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, UpdateInputDeviceErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateInputDeviceErrorKind::BadRequestError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateInputDeviceErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateInputDeviceErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputDeviceErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateInputDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInputDeviceErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateInputDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInputSecurityGroupError {
    pub kind: UpdateInputSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInputSecurityGroupErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInputSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInputSecurityGroupErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateInputSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInputSecurityGroupError {
    fn code(&self) -> Option<&str> {
        UpdateInputSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInputSecurityGroupError {
    pub fn new(kind: UpdateInputSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInputSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInputSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInputSecurityGroupErrorKind::NotFoundError(_)
        )
    }
}
impl std::error::Error for UpdateInputSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInputSecurityGroupErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateInputSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMultiplexError {
    pub kind: UpdateMultiplexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMultiplexErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMultiplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMultiplexErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateMultiplexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMultiplexError {
    fn code(&self) -> Option<&str> {
        UpdateMultiplexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMultiplexError {
    pub fn new(kind: UpdateMultiplexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMultiplexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMultiplexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::GatewayTimeoutError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateMultiplexErrorKind::NotFoundError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateMultiplexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMultiplexErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateMultiplexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMultiplexProgramError {
    pub kind: UpdateMultiplexProgramErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMultiplexProgramErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMultiplexProgramError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMultiplexProgramErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateMultiplexProgramErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMultiplexProgramError {
    fn code(&self) -> Option<&str> {
        UpdateMultiplexProgramError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMultiplexProgramError {
    pub fn new(kind: UpdateMultiplexProgramErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMultiplexProgramErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMultiplexProgramErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::BadGatewayError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::BadRequestError(_)
        )
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::ConflictError(_)
        )
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::NotFoundError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMultiplexProgramErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateMultiplexProgramError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMultiplexProgramErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateMultiplexProgramErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateReservationError {
    pub kind: UpdateReservationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateReservationErrorKind {
    BadGatewayError(crate::error::BadGatewayError),
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    ForbiddenError(crate::error::ForbiddenError),
    GatewayTimeoutError(crate::error::GatewayTimeoutError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateReservationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateReservationErrorKind::BadGatewayError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::GatewayTimeoutError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateReservationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateReservationError {
    fn code(&self) -> Option<&str> {
        UpdateReservationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateReservationError {
    pub fn new(kind: UpdateReservationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateReservationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateReservationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_gateway_error(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::BadGatewayError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::ConflictError(_))
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::ForbiddenError(_))
    }
    pub fn is_gateway_timeout_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::GatewayTimeoutError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateReservationErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReservationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for UpdateReservationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateReservationErrorKind::BadGatewayError(_inner) => Some(_inner),
            UpdateReservationErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateReservationErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateReservationErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateReservationErrorKind::GatewayTimeoutError(_inner) => Some(_inner),
            UpdateReservationErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateReservationErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateReservationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateReservationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Placeholder documentation for TooManyRequestsException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsError [TooManyRequestsException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsError {}
/// See [`TooManyRequestsError`](crate::error::TooManyRequestsError)
pub mod too_many_requests_error {
    /// A builder for [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsError`](crate::error::TooManyRequestsError)
        pub fn build(self) -> crate::error::TooManyRequestsError {
            crate::error::TooManyRequestsError {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsError {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    pub fn builder() -> crate::error::too_many_requests_error::Builder {
        crate::error::too_many_requests_error::Builder::default()
    }
}

/// Placeholder documentation for NotFoundException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError [NotFoundException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// Placeholder documentation for InternalServerErrorException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorError [InternalServerErrorException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorError {}
/// See [`InternalServerErrorError`](crate::error::InternalServerErrorError)
pub mod internal_server_error_error {
    /// A builder for [`InternalServerErrorError`](crate::error::InternalServerErrorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorError`](crate::error::InternalServerErrorError)
        pub fn build(self) -> crate::error::InternalServerErrorError {
            crate::error::InternalServerErrorError {
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorError {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorError`](crate::error::InternalServerErrorError)
    pub fn builder() -> crate::error::internal_server_error_error::Builder {
        crate::error::internal_server_error_error::Builder::default()
    }
}

/// Placeholder documentation for GatewayTimeoutException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GatewayTimeoutError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GatewayTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GatewayTimeoutError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GatewayTimeoutError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GatewayTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GatewayTimeoutError [GatewayTimeoutException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for GatewayTimeoutError {}
/// See [`GatewayTimeoutError`](crate::error::GatewayTimeoutError)
pub mod gateway_timeout_error {
    /// A builder for [`GatewayTimeoutError`](crate::error::GatewayTimeoutError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewayTimeoutError`](crate::error::GatewayTimeoutError)
        pub fn build(self) -> crate::error::GatewayTimeoutError {
            crate::error::GatewayTimeoutError {
                message: self.message,
            }
        }
    }
}
impl GatewayTimeoutError {
    /// Creates a new builder-style object to manufacture [`GatewayTimeoutError`](crate::error::GatewayTimeoutError)
    pub fn builder() -> crate::error::gateway_timeout_error::Builder {
        crate::error::gateway_timeout_error::Builder::default()
    }
}

/// Placeholder documentation for ForbiddenException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenError [ForbiddenException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
    /// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
        pub fn build(self) -> crate::error::ForbiddenError {
            crate::error::ForbiddenError {
                message: self.message,
            }
        }
    }
}
impl ForbiddenError {
    /// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
    pub fn builder() -> crate::error::forbidden_error::Builder {
        crate::error::forbidden_error::Builder::default()
    }
}

/// Placeholder documentation for ConflictException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictError [ConflictException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictError {}
/// See [`ConflictError`](crate::error::ConflictError)
pub mod conflict_error {
    /// A builder for [`ConflictError`](crate::error::ConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictError`](crate::error::ConflictError)
        pub fn build(self) -> crate::error::ConflictError {
            crate::error::ConflictError {
                message: self.message,
            }
        }
    }
}
impl ConflictError {
    /// Creates a new builder-style object to manufacture [`ConflictError`](crate::error::ConflictError)
    pub fn builder() -> crate::error::conflict_error::Builder {
        crate::error::conflict_error::Builder::default()
    }
}

/// Placeholder documentation for BadRequestException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestError [BadRequestException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
    /// A builder for [`BadRequestError`](crate::error::BadRequestError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
        pub fn build(self) -> crate::error::BadRequestError {
            crate::error::BadRequestError {
                message: self.message,
            }
        }
    }
}
impl BadRequestError {
    /// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
    pub fn builder() -> crate::error::bad_request_error::Builder {
        crate::error::bad_request_error::Builder::default()
    }
}

/// Placeholder documentation for BadGatewayException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BadGatewayError {
    /// Placeholder documentation for __string
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadGatewayError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadGatewayError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadGatewayError [BadGatewayException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadGatewayError {}
/// See [`BadGatewayError`](crate::error::BadGatewayError)
pub mod bad_gateway_error {
    /// A builder for [`BadGatewayError`](crate::error::BadGatewayError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Placeholder documentation for __string
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadGatewayError`](crate::error::BadGatewayError)
        pub fn build(self) -> crate::error::BadGatewayError {
            crate::error::BadGatewayError {
                message: self.message,
            }
        }
    }
}
impl BadGatewayError {
    /// Creates a new builder-style object to manufacture [`BadGatewayError`](crate::error::BadGatewayError)
    pub fn builder() -> crate::error::bad_gateway_error::Builder {
        crate::error::bad_gateway_error::Builder::default()
    }
}

/// Placeholder documentation for UnprocessableEntityException
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessableEntityError {
    /// The error message.
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    /// A collection of validation error responses.
    #[serde(rename = "validationErrors")]
    #[serde(default)]
    pub validation_errors: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
}
impl std::fmt::Debug for UnprocessableEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessableEntityError");
        formatter.field("message", &self.message);
        formatter.field("validation_errors", &self.validation_errors);
        formatter.finish()
    }
}
impl UnprocessableEntityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnprocessableEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnprocessableEntityError [UnprocessableEntityException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnprocessableEntityError {}
/// See [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
pub mod unprocessable_entity_error {
    /// A builder for [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) validation_errors:
            std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
    }
    impl Builder {
        /// The error message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn validation_errors(
            mut self,
            input: impl Into<crate::model::ValidationError>,
        ) -> Self {
            let mut v = self.validation_errors.unwrap_or_default();
            v.push(input.into());
            self.validation_errors = Some(v);
            self
        }
        pub fn set_validation_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
        ) -> Self {
            self.validation_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
        pub fn build(self) -> crate::error::UnprocessableEntityError {
            crate::error::UnprocessableEntityError {
                message: self.message,
                validation_errors: self.validation_errors,
            }
        }
    }
}
impl UnprocessableEntityError {
    /// Creates a new builder-style object to manufacture [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
    pub fn builder() -> crate::error::unprocessable_entity_error::Builder {
        crate::error::unprocessable_entity_error::Builder::default()
    }
}
