// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// H264 Settings
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct H264Settings {
    /// Enables or disables adaptive quantization, which is a technique MediaLive can apply to video on a frame-by-frame basis to produce more compression without losing quality. There are three types of adaptive quantization: flicker, spatial, and temporal. Set the field in one of these ways: Set to Auto. Recommended. For each type of AQ, MediaLive will determine if AQ is needed, and if so, the appropriate strength. Set a strength (a value other than Auto or Disable). This strength will apply to any of the AQ fields that you choose to enable. Set to Disabled to disable all types of adaptive quantization.
    #[doc(hidden)]
    pub adaptive_quantization: std::option::Option<crate::types::H264AdaptiveQuantization>,
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    #[doc(hidden)]
    pub afd_signaling: std::option::Option<crate::types::AfdSignaling>,
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    #[doc(hidden)]
    pub bitrate: i32,
    /// Percentage of the buffer that should initially be filled (HRD buffer model).
    #[doc(hidden)]
    pub buf_fill_pct: i32,
    /// Size of buffer (HRD buffer model) in bits.
    #[doc(hidden)]
    pub buf_size: i32,
    /// Includes colorspace metadata in the output.
    #[doc(hidden)]
    pub color_metadata: std::option::Option<crate::types::H264ColorMetadata>,
    /// Color Space settings
    #[doc(hidden)]
    pub color_space_settings: std::option::Option<crate::types::H264ColorSpaceSettings>,
    /// Entropy encoding mode. Use cabac (must be in Main or High profile) or cavlc.
    #[doc(hidden)]
    pub entropy_encoding: std::option::Option<crate::types::H264EntropyEncoding>,
    /// Optional filters that you can apply to an encode.
    #[doc(hidden)]
    pub filter_settings: std::option::Option<crate::types::H264FilterSettings>,
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    #[doc(hidden)]
    pub fixed_afd: std::option::Option<crate::types::FixedAfd>,
    /// Flicker AQ makes adjustments within each frame to reduce flicker or 'pop' on I-frames. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if flicker AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply flicker AQ using the specified strength. Disabled: MediaLive won't apply flicker AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply flicker AQ.
    #[doc(hidden)]
    pub flicker_aq: std::option::Option<crate::types::H264FlickerAq>,
    /// This setting applies only when scan type is "interlaced." It controls whether coding is performed on a field basis or on a frame basis. (When the video is progressive, the coding is always performed on a frame basis.) enabled: Force MediaLive to code on a field basis, so that odd and even sets of fields are coded separately. disabled: Code the two sets of fields separately (on a field basis) or together (on a frame basis using PAFF), depending on what is most appropriate for the content.
    #[doc(hidden)]
    pub force_field_pictures: std::option::Option<crate::types::H264ForceFieldPictures>,
    /// This field indicates how the output video frame rate is specified. If "specified" is selected then the output video frame rate is determined by framerateNumerator and framerateDenominator, else if "initializeFromSource" is selected then the output video frame rate will be set equal to the input video frame rate of the first input.
    #[doc(hidden)]
    pub framerate_control: std::option::Option<crate::types::H264FramerateControl>,
    /// Framerate denominator.
    #[doc(hidden)]
    pub framerate_denominator: i32,
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    #[doc(hidden)]
    pub framerate_numerator: i32,
    /// Documentation update needed
    #[doc(hidden)]
    pub gop_b_reference: std::option::Option<crate::types::H264GopBReference>,
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    #[doc(hidden)]
    pub gop_closed_cadence: i32,
    /// Number of B-frames between reference frames.
    #[doc(hidden)]
    pub gop_num_b_frames: i32,
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    #[doc(hidden)]
    pub gop_size: f64,
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    #[doc(hidden)]
    pub gop_size_units: std::option::Option<crate::types::H264GopSizeUnits>,
    /// H.264 Level.
    #[doc(hidden)]
    pub level: std::option::Option<crate::types::H264Level>,
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    #[doc(hidden)]
    pub look_ahead_rate_control: std::option::Option<crate::types::H264LookAheadRateControl>,
    /// For QVBR: See the tooltip for Quality level For VBR: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
    #[doc(hidden)]
    pub max_bitrate: i32,
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    #[doc(hidden)]
    pub min_i_interval: i32,
    /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
    #[doc(hidden)]
    pub num_ref_frames: i32,
    /// This field indicates how the output pixel aspect ratio is specified. If "specified" is selected then the output video pixel aspect ratio is determined by parNumerator and parDenominator, else if "initializeFromSource" is selected then the output pixsel aspect ratio will be set equal to the input video pixel aspect ratio of the first input.
    #[doc(hidden)]
    pub par_control: std::option::Option<crate::types::H264ParControl>,
    /// Pixel Aspect Ratio denominator.
    #[doc(hidden)]
    pub par_denominator: i32,
    /// Pixel Aspect Ratio numerator.
    #[doc(hidden)]
    pub par_numerator: i32,
    /// H.264 Profile.
    #[doc(hidden)]
    pub profile: std::option::Option<crate::types::H264Profile>,
    /// Leave as STANDARD_QUALITY or choose a different value (which might result in additional costs to run the channel). - ENHANCED_QUALITY: Produces a slightly better video quality without an increase in the bitrate. Has an effect only when the Rate control mode is QVBR or CBR. If this channel is in a MediaLive multiplex, the value must be ENHANCED_QUALITY. - STANDARD_QUALITY: Valid for any Rate control mode.
    #[doc(hidden)]
    pub quality_level: std::option::Option<crate::types::H264QualityLevel>,
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. You can set a target quality or you can let MediaLive determine the best quality. To set a target quality, enter values in the QVBR quality level field and the Max bitrate field. Enter values that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M To let MediaLive decide, leave the QVBR quality level field empty, and in Max bitrate enter the maximum rate you want in the video. For more information, see the section called "Video - rate control mode" in the MediaLive user guide
    #[doc(hidden)]
    pub qvbr_quality_level: i32,
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. VBR: Quality and bitrate vary, depending on the video complexity. Recommended instead of QVBR if you want to maintain a specific average bitrate over the duration of the channel. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    #[doc(hidden)]
    pub rate_control_mode: std::option::Option<crate::types::H264RateControlMode>,
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    #[doc(hidden)]
    pub scan_type: std::option::Option<crate::types::H264ScanType>,
    /// Scene change detection. - On: inserts I-frames when scene change is detected. - Off: does not force an I-frame when scene change is detected.
    #[doc(hidden)]
    pub scene_change_detect: std::option::Option<crate::types::H264SceneChangeDetect>,
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    #[doc(hidden)]
    pub slices: i32,
    /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image. If not set to zero, must be greater than 15.
    #[doc(hidden)]
    pub softness: i32,
    /// Spatial AQ makes adjustments within each frame based on spatial variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if spatial AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply spatial AQ using the specified strength. Disabled: MediaLive won't apply spatial AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply spatial AQ.
    #[doc(hidden)]
    pub spatial_aq: std::option::Option<crate::types::H264SpatialAq>,
    /// If set to fixed, use gopNumBFrames B-frames per sub-GOP. If set to dynamic, optimize the number of B-frames used for each sub-GOP to improve visual quality.
    #[doc(hidden)]
    pub subgop_length: std::option::Option<crate::types::H264SubGopLength>,
    /// Produces a bitstream compliant with SMPTE RP-2027.
    #[doc(hidden)]
    pub syntax: std::option::Option<crate::types::H264Syntax>,
    /// Temporal makes adjustments within each frame based on temporal variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if temporal AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply temporal AQ using the specified strength. Disabled: MediaLive won't apply temporal AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply temporal AQ.
    #[doc(hidden)]
    pub temporal_aq: std::option::Option<crate::types::H264TemporalAq>,
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    #[doc(hidden)]
    pub timecode_insertion: std::option::Option<crate::types::H264TimecodeInsertionBehavior>,
    /// Timecode burn-in settings
    #[doc(hidden)]
    pub timecode_burnin_settings: std::option::Option<crate::types::TimecodeBurninSettings>,
}
impl H264Settings {
    /// Enables or disables adaptive quantization, which is a technique MediaLive can apply to video on a frame-by-frame basis to produce more compression without losing quality. There are three types of adaptive quantization: flicker, spatial, and temporal. Set the field in one of these ways: Set to Auto. Recommended. For each type of AQ, MediaLive will determine if AQ is needed, and if so, the appropriate strength. Set a strength (a value other than Auto or Disable). This strength will apply to any of the AQ fields that you choose to enable. Set to Disabled to disable all types of adaptive quantization.
    pub fn adaptive_quantization(
        &self,
    ) -> std::option::Option<&crate::types::H264AdaptiveQuantization> {
        self.adaptive_quantization.as_ref()
    }
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    pub fn afd_signaling(&self) -> std::option::Option<&crate::types::AfdSignaling> {
        self.afd_signaling.as_ref()
    }
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    pub fn bitrate(&self) -> i32 {
        self.bitrate
    }
    /// Percentage of the buffer that should initially be filled (HRD buffer model).
    pub fn buf_fill_pct(&self) -> i32 {
        self.buf_fill_pct
    }
    /// Size of buffer (HRD buffer model) in bits.
    pub fn buf_size(&self) -> i32 {
        self.buf_size
    }
    /// Includes colorspace metadata in the output.
    pub fn color_metadata(&self) -> std::option::Option<&crate::types::H264ColorMetadata> {
        self.color_metadata.as_ref()
    }
    /// Color Space settings
    pub fn color_space_settings(
        &self,
    ) -> std::option::Option<&crate::types::H264ColorSpaceSettings> {
        self.color_space_settings.as_ref()
    }
    /// Entropy encoding mode. Use cabac (must be in Main or High profile) or cavlc.
    pub fn entropy_encoding(&self) -> std::option::Option<&crate::types::H264EntropyEncoding> {
        self.entropy_encoding.as_ref()
    }
    /// Optional filters that you can apply to an encode.
    pub fn filter_settings(&self) -> std::option::Option<&crate::types::H264FilterSettings> {
        self.filter_settings.as_ref()
    }
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    pub fn fixed_afd(&self) -> std::option::Option<&crate::types::FixedAfd> {
        self.fixed_afd.as_ref()
    }
    /// Flicker AQ makes adjustments within each frame to reduce flicker or 'pop' on I-frames. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if flicker AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply flicker AQ using the specified strength. Disabled: MediaLive won't apply flicker AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply flicker AQ.
    pub fn flicker_aq(&self) -> std::option::Option<&crate::types::H264FlickerAq> {
        self.flicker_aq.as_ref()
    }
    /// This setting applies only when scan type is "interlaced." It controls whether coding is performed on a field basis or on a frame basis. (When the video is progressive, the coding is always performed on a frame basis.) enabled: Force MediaLive to code on a field basis, so that odd and even sets of fields are coded separately. disabled: Code the two sets of fields separately (on a field basis) or together (on a frame basis using PAFF), depending on what is most appropriate for the content.
    pub fn force_field_pictures(
        &self,
    ) -> std::option::Option<&crate::types::H264ForceFieldPictures> {
        self.force_field_pictures.as_ref()
    }
    /// This field indicates how the output video frame rate is specified. If "specified" is selected then the output video frame rate is determined by framerateNumerator and framerateDenominator, else if "initializeFromSource" is selected then the output video frame rate will be set equal to the input video frame rate of the first input.
    pub fn framerate_control(&self) -> std::option::Option<&crate::types::H264FramerateControl> {
        self.framerate_control.as_ref()
    }
    /// Framerate denominator.
    pub fn framerate_denominator(&self) -> i32 {
        self.framerate_denominator
    }
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    pub fn framerate_numerator(&self) -> i32 {
        self.framerate_numerator
    }
    /// Documentation update needed
    pub fn gop_b_reference(&self) -> std::option::Option<&crate::types::H264GopBReference> {
        self.gop_b_reference.as_ref()
    }
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    pub fn gop_closed_cadence(&self) -> i32 {
        self.gop_closed_cadence
    }
    /// Number of B-frames between reference frames.
    pub fn gop_num_b_frames(&self) -> i32 {
        self.gop_num_b_frames
    }
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    pub fn gop_size(&self) -> f64 {
        self.gop_size
    }
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    pub fn gop_size_units(&self) -> std::option::Option<&crate::types::H264GopSizeUnits> {
        self.gop_size_units.as_ref()
    }
    /// H.264 Level.
    pub fn level(&self) -> std::option::Option<&crate::types::H264Level> {
        self.level.as_ref()
    }
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    pub fn look_ahead_rate_control(
        &self,
    ) -> std::option::Option<&crate::types::H264LookAheadRateControl> {
        self.look_ahead_rate_control.as_ref()
    }
    /// For QVBR: See the tooltip for Quality level For VBR: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
    pub fn max_bitrate(&self) -> i32 {
        self.max_bitrate
    }
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    pub fn min_i_interval(&self) -> i32 {
        self.min_i_interval
    }
    /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
    pub fn num_ref_frames(&self) -> i32 {
        self.num_ref_frames
    }
    /// This field indicates how the output pixel aspect ratio is specified. If "specified" is selected then the output video pixel aspect ratio is determined by parNumerator and parDenominator, else if "initializeFromSource" is selected then the output pixsel aspect ratio will be set equal to the input video pixel aspect ratio of the first input.
    pub fn par_control(&self) -> std::option::Option<&crate::types::H264ParControl> {
        self.par_control.as_ref()
    }
    /// Pixel Aspect Ratio denominator.
    pub fn par_denominator(&self) -> i32 {
        self.par_denominator
    }
    /// Pixel Aspect Ratio numerator.
    pub fn par_numerator(&self) -> i32 {
        self.par_numerator
    }
    /// H.264 Profile.
    pub fn profile(&self) -> std::option::Option<&crate::types::H264Profile> {
        self.profile.as_ref()
    }
    /// Leave as STANDARD_QUALITY or choose a different value (which might result in additional costs to run the channel). - ENHANCED_QUALITY: Produces a slightly better video quality without an increase in the bitrate. Has an effect only when the Rate control mode is QVBR or CBR. If this channel is in a MediaLive multiplex, the value must be ENHANCED_QUALITY. - STANDARD_QUALITY: Valid for any Rate control mode.
    pub fn quality_level(&self) -> std::option::Option<&crate::types::H264QualityLevel> {
        self.quality_level.as_ref()
    }
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. You can set a target quality or you can let MediaLive determine the best quality. To set a target quality, enter values in the QVBR quality level field and the Max bitrate field. Enter values that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M To let MediaLive decide, leave the QVBR quality level field empty, and in Max bitrate enter the maximum rate you want in the video. For more information, see the section called "Video - rate control mode" in the MediaLive user guide
    pub fn qvbr_quality_level(&self) -> i32 {
        self.qvbr_quality_level
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. VBR: Quality and bitrate vary, depending on the video complexity. Recommended instead of QVBR if you want to maintain a specific average bitrate over the duration of the channel. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    pub fn rate_control_mode(&self) -> std::option::Option<&crate::types::H264RateControlMode> {
        self.rate_control_mode.as_ref()
    }
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    pub fn scan_type(&self) -> std::option::Option<&crate::types::H264ScanType> {
        self.scan_type.as_ref()
    }
    /// Scene change detection. - On: inserts I-frames when scene change is detected. - Off: does not force an I-frame when scene change is detected.
    pub fn scene_change_detect(&self) -> std::option::Option<&crate::types::H264SceneChangeDetect> {
        self.scene_change_detect.as_ref()
    }
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    pub fn slices(&self) -> i32 {
        self.slices
    }
    /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image. If not set to zero, must be greater than 15.
    pub fn softness(&self) -> i32 {
        self.softness
    }
    /// Spatial AQ makes adjustments within each frame based on spatial variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if spatial AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply spatial AQ using the specified strength. Disabled: MediaLive won't apply spatial AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply spatial AQ.
    pub fn spatial_aq(&self) -> std::option::Option<&crate::types::H264SpatialAq> {
        self.spatial_aq.as_ref()
    }
    /// If set to fixed, use gopNumBFrames B-frames per sub-GOP. If set to dynamic, optimize the number of B-frames used for each sub-GOP to improve visual quality.
    pub fn subgop_length(&self) -> std::option::Option<&crate::types::H264SubGopLength> {
        self.subgop_length.as_ref()
    }
    /// Produces a bitstream compliant with SMPTE RP-2027.
    pub fn syntax(&self) -> std::option::Option<&crate::types::H264Syntax> {
        self.syntax.as_ref()
    }
    /// Temporal makes adjustments within each frame based on temporal variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if temporal AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply temporal AQ using the specified strength. Disabled: MediaLive won't apply temporal AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply temporal AQ.
    pub fn temporal_aq(&self) -> std::option::Option<&crate::types::H264TemporalAq> {
        self.temporal_aq.as_ref()
    }
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    pub fn timecode_insertion(
        &self,
    ) -> std::option::Option<&crate::types::H264TimecodeInsertionBehavior> {
        self.timecode_insertion.as_ref()
    }
    /// Timecode burn-in settings
    pub fn timecode_burnin_settings(
        &self,
    ) -> std::option::Option<&crate::types::TimecodeBurninSettings> {
        self.timecode_burnin_settings.as_ref()
    }
}
impl H264Settings {
    /// Creates a new builder-style object to manufacture [`H264Settings`](crate::types::H264Settings).
    pub fn builder() -> crate::types::builders::H264SettingsBuilder {
        crate::types::builders::H264SettingsBuilder::default()
    }
}

/// A builder for [`H264Settings`](crate::types::H264Settings).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct H264SettingsBuilder {
    pub(crate) adaptive_quantization: std::option::Option<crate::types::H264AdaptiveQuantization>,
    pub(crate) afd_signaling: std::option::Option<crate::types::AfdSignaling>,
    pub(crate) bitrate: std::option::Option<i32>,
    pub(crate) buf_fill_pct: std::option::Option<i32>,
    pub(crate) buf_size: std::option::Option<i32>,
    pub(crate) color_metadata: std::option::Option<crate::types::H264ColorMetadata>,
    pub(crate) color_space_settings: std::option::Option<crate::types::H264ColorSpaceSettings>,
    pub(crate) entropy_encoding: std::option::Option<crate::types::H264EntropyEncoding>,
    pub(crate) filter_settings: std::option::Option<crate::types::H264FilterSettings>,
    pub(crate) fixed_afd: std::option::Option<crate::types::FixedAfd>,
    pub(crate) flicker_aq: std::option::Option<crate::types::H264FlickerAq>,
    pub(crate) force_field_pictures: std::option::Option<crate::types::H264ForceFieldPictures>,
    pub(crate) framerate_control: std::option::Option<crate::types::H264FramerateControl>,
    pub(crate) framerate_denominator: std::option::Option<i32>,
    pub(crate) framerate_numerator: std::option::Option<i32>,
    pub(crate) gop_b_reference: std::option::Option<crate::types::H264GopBReference>,
    pub(crate) gop_closed_cadence: std::option::Option<i32>,
    pub(crate) gop_num_b_frames: std::option::Option<i32>,
    pub(crate) gop_size: std::option::Option<f64>,
    pub(crate) gop_size_units: std::option::Option<crate::types::H264GopSizeUnits>,
    pub(crate) level: std::option::Option<crate::types::H264Level>,
    pub(crate) look_ahead_rate_control: std::option::Option<crate::types::H264LookAheadRateControl>,
    pub(crate) max_bitrate: std::option::Option<i32>,
    pub(crate) min_i_interval: std::option::Option<i32>,
    pub(crate) num_ref_frames: std::option::Option<i32>,
    pub(crate) par_control: std::option::Option<crate::types::H264ParControl>,
    pub(crate) par_denominator: std::option::Option<i32>,
    pub(crate) par_numerator: std::option::Option<i32>,
    pub(crate) profile: std::option::Option<crate::types::H264Profile>,
    pub(crate) quality_level: std::option::Option<crate::types::H264QualityLevel>,
    pub(crate) qvbr_quality_level: std::option::Option<i32>,
    pub(crate) rate_control_mode: std::option::Option<crate::types::H264RateControlMode>,
    pub(crate) scan_type: std::option::Option<crate::types::H264ScanType>,
    pub(crate) scene_change_detect: std::option::Option<crate::types::H264SceneChangeDetect>,
    pub(crate) slices: std::option::Option<i32>,
    pub(crate) softness: std::option::Option<i32>,
    pub(crate) spatial_aq: std::option::Option<crate::types::H264SpatialAq>,
    pub(crate) subgop_length: std::option::Option<crate::types::H264SubGopLength>,
    pub(crate) syntax: std::option::Option<crate::types::H264Syntax>,
    pub(crate) temporal_aq: std::option::Option<crate::types::H264TemporalAq>,
    pub(crate) timecode_insertion: std::option::Option<crate::types::H264TimecodeInsertionBehavior>,
    pub(crate) timecode_burnin_settings: std::option::Option<crate::types::TimecodeBurninSettings>,
}
impl H264SettingsBuilder {
    /// Enables or disables adaptive quantization, which is a technique MediaLive can apply to video on a frame-by-frame basis to produce more compression without losing quality. There are three types of adaptive quantization: flicker, spatial, and temporal. Set the field in one of these ways: Set to Auto. Recommended. For each type of AQ, MediaLive will determine if AQ is needed, and if so, the appropriate strength. Set a strength (a value other than Auto or Disable). This strength will apply to any of the AQ fields that you choose to enable. Set to Disabled to disable all types of adaptive quantization.
    pub fn adaptive_quantization(mut self, input: crate::types::H264AdaptiveQuantization) -> Self {
        self.adaptive_quantization = Some(input);
        self
    }
    /// Enables or disables adaptive quantization, which is a technique MediaLive can apply to video on a frame-by-frame basis to produce more compression without losing quality. There are three types of adaptive quantization: flicker, spatial, and temporal. Set the field in one of these ways: Set to Auto. Recommended. For each type of AQ, MediaLive will determine if AQ is needed, and if so, the appropriate strength. Set a strength (a value other than Auto or Disable). This strength will apply to any of the AQ fields that you choose to enable. Set to Disabled to disable all types of adaptive quantization.
    pub fn set_adaptive_quantization(
        mut self,
        input: std::option::Option<crate::types::H264AdaptiveQuantization>,
    ) -> Self {
        self.adaptive_quantization = input;
        self
    }
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    pub fn afd_signaling(mut self, input: crate::types::AfdSignaling) -> Self {
        self.afd_signaling = Some(input);
        self
    }
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    pub fn set_afd_signaling(
        mut self,
        input: std::option::Option<crate::types::AfdSignaling>,
    ) -> Self {
        self.afd_signaling = input;
        self
    }
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    pub fn bitrate(mut self, input: i32) -> Self {
        self.bitrate = Some(input);
        self
    }
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    pub fn set_bitrate(mut self, input: std::option::Option<i32>) -> Self {
        self.bitrate = input;
        self
    }
    /// Percentage of the buffer that should initially be filled (HRD buffer model).
    pub fn buf_fill_pct(mut self, input: i32) -> Self {
        self.buf_fill_pct = Some(input);
        self
    }
    /// Percentage of the buffer that should initially be filled (HRD buffer model).
    pub fn set_buf_fill_pct(mut self, input: std::option::Option<i32>) -> Self {
        self.buf_fill_pct = input;
        self
    }
    /// Size of buffer (HRD buffer model) in bits.
    pub fn buf_size(mut self, input: i32) -> Self {
        self.buf_size = Some(input);
        self
    }
    /// Size of buffer (HRD buffer model) in bits.
    pub fn set_buf_size(mut self, input: std::option::Option<i32>) -> Self {
        self.buf_size = input;
        self
    }
    /// Includes colorspace metadata in the output.
    pub fn color_metadata(mut self, input: crate::types::H264ColorMetadata) -> Self {
        self.color_metadata = Some(input);
        self
    }
    /// Includes colorspace metadata in the output.
    pub fn set_color_metadata(
        mut self,
        input: std::option::Option<crate::types::H264ColorMetadata>,
    ) -> Self {
        self.color_metadata = input;
        self
    }
    /// Color Space settings
    pub fn color_space_settings(mut self, input: crate::types::H264ColorSpaceSettings) -> Self {
        self.color_space_settings = Some(input);
        self
    }
    /// Color Space settings
    pub fn set_color_space_settings(
        mut self,
        input: std::option::Option<crate::types::H264ColorSpaceSettings>,
    ) -> Self {
        self.color_space_settings = input;
        self
    }
    /// Entropy encoding mode. Use cabac (must be in Main or High profile) or cavlc.
    pub fn entropy_encoding(mut self, input: crate::types::H264EntropyEncoding) -> Self {
        self.entropy_encoding = Some(input);
        self
    }
    /// Entropy encoding mode. Use cabac (must be in Main or High profile) or cavlc.
    pub fn set_entropy_encoding(
        mut self,
        input: std::option::Option<crate::types::H264EntropyEncoding>,
    ) -> Self {
        self.entropy_encoding = input;
        self
    }
    /// Optional filters that you can apply to an encode.
    pub fn filter_settings(mut self, input: crate::types::H264FilterSettings) -> Self {
        self.filter_settings = Some(input);
        self
    }
    /// Optional filters that you can apply to an encode.
    pub fn set_filter_settings(
        mut self,
        input: std::option::Option<crate::types::H264FilterSettings>,
    ) -> Self {
        self.filter_settings = input;
        self
    }
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    pub fn fixed_afd(mut self, input: crate::types::FixedAfd) -> Self {
        self.fixed_afd = Some(input);
        self
    }
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    pub fn set_fixed_afd(mut self, input: std::option::Option<crate::types::FixedAfd>) -> Self {
        self.fixed_afd = input;
        self
    }
    /// Flicker AQ makes adjustments within each frame to reduce flicker or 'pop' on I-frames. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if flicker AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply flicker AQ using the specified strength. Disabled: MediaLive won't apply flicker AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply flicker AQ.
    pub fn flicker_aq(mut self, input: crate::types::H264FlickerAq) -> Self {
        self.flicker_aq = Some(input);
        self
    }
    /// Flicker AQ makes adjustments within each frame to reduce flicker or 'pop' on I-frames. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if flicker AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply flicker AQ using the specified strength. Disabled: MediaLive won't apply flicker AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply flicker AQ.
    pub fn set_flicker_aq(
        mut self,
        input: std::option::Option<crate::types::H264FlickerAq>,
    ) -> Self {
        self.flicker_aq = input;
        self
    }
    /// This setting applies only when scan type is "interlaced." It controls whether coding is performed on a field basis or on a frame basis. (When the video is progressive, the coding is always performed on a frame basis.) enabled: Force MediaLive to code on a field basis, so that odd and even sets of fields are coded separately. disabled: Code the two sets of fields separately (on a field basis) or together (on a frame basis using PAFF), depending on what is most appropriate for the content.
    pub fn force_field_pictures(mut self, input: crate::types::H264ForceFieldPictures) -> Self {
        self.force_field_pictures = Some(input);
        self
    }
    /// This setting applies only when scan type is "interlaced." It controls whether coding is performed on a field basis or on a frame basis. (When the video is progressive, the coding is always performed on a frame basis.) enabled: Force MediaLive to code on a field basis, so that odd and even sets of fields are coded separately. disabled: Code the two sets of fields separately (on a field basis) or together (on a frame basis using PAFF), depending on what is most appropriate for the content.
    pub fn set_force_field_pictures(
        mut self,
        input: std::option::Option<crate::types::H264ForceFieldPictures>,
    ) -> Self {
        self.force_field_pictures = input;
        self
    }
    /// This field indicates how the output video frame rate is specified. If "specified" is selected then the output video frame rate is determined by framerateNumerator and framerateDenominator, else if "initializeFromSource" is selected then the output video frame rate will be set equal to the input video frame rate of the first input.
    pub fn framerate_control(mut self, input: crate::types::H264FramerateControl) -> Self {
        self.framerate_control = Some(input);
        self
    }
    /// This field indicates how the output video frame rate is specified. If "specified" is selected then the output video frame rate is determined by framerateNumerator and framerateDenominator, else if "initializeFromSource" is selected then the output video frame rate will be set equal to the input video frame rate of the first input.
    pub fn set_framerate_control(
        mut self,
        input: std::option::Option<crate::types::H264FramerateControl>,
    ) -> Self {
        self.framerate_control = input;
        self
    }
    /// Framerate denominator.
    pub fn framerate_denominator(mut self, input: i32) -> Self {
        self.framerate_denominator = Some(input);
        self
    }
    /// Framerate denominator.
    pub fn set_framerate_denominator(mut self, input: std::option::Option<i32>) -> Self {
        self.framerate_denominator = input;
        self
    }
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    pub fn framerate_numerator(mut self, input: i32) -> Self {
        self.framerate_numerator = Some(input);
        self
    }
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    pub fn set_framerate_numerator(mut self, input: std::option::Option<i32>) -> Self {
        self.framerate_numerator = input;
        self
    }
    /// Documentation update needed
    pub fn gop_b_reference(mut self, input: crate::types::H264GopBReference) -> Self {
        self.gop_b_reference = Some(input);
        self
    }
    /// Documentation update needed
    pub fn set_gop_b_reference(
        mut self,
        input: std::option::Option<crate::types::H264GopBReference>,
    ) -> Self {
        self.gop_b_reference = input;
        self
    }
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    pub fn gop_closed_cadence(mut self, input: i32) -> Self {
        self.gop_closed_cadence = Some(input);
        self
    }
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    pub fn set_gop_closed_cadence(mut self, input: std::option::Option<i32>) -> Self {
        self.gop_closed_cadence = input;
        self
    }
    /// Number of B-frames between reference frames.
    pub fn gop_num_b_frames(mut self, input: i32) -> Self {
        self.gop_num_b_frames = Some(input);
        self
    }
    /// Number of B-frames between reference frames.
    pub fn set_gop_num_b_frames(mut self, input: std::option::Option<i32>) -> Self {
        self.gop_num_b_frames = input;
        self
    }
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    pub fn gop_size(mut self, input: f64) -> Self {
        self.gop_size = Some(input);
        self
    }
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    pub fn set_gop_size(mut self, input: std::option::Option<f64>) -> Self {
        self.gop_size = input;
        self
    }
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    pub fn gop_size_units(mut self, input: crate::types::H264GopSizeUnits) -> Self {
        self.gop_size_units = Some(input);
        self
    }
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    pub fn set_gop_size_units(
        mut self,
        input: std::option::Option<crate::types::H264GopSizeUnits>,
    ) -> Self {
        self.gop_size_units = input;
        self
    }
    /// H.264 Level.
    pub fn level(mut self, input: crate::types::H264Level) -> Self {
        self.level = Some(input);
        self
    }
    /// H.264 Level.
    pub fn set_level(mut self, input: std::option::Option<crate::types::H264Level>) -> Self {
        self.level = input;
        self
    }
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    pub fn look_ahead_rate_control(
        mut self,
        input: crate::types::H264LookAheadRateControl,
    ) -> Self {
        self.look_ahead_rate_control = Some(input);
        self
    }
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    pub fn set_look_ahead_rate_control(
        mut self,
        input: std::option::Option<crate::types::H264LookAheadRateControl>,
    ) -> Self {
        self.look_ahead_rate_control = input;
        self
    }
    /// For QVBR: See the tooltip for Quality level For VBR: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
    pub fn max_bitrate(mut self, input: i32) -> Self {
        self.max_bitrate = Some(input);
        self
    }
    /// For QVBR: See the tooltip for Quality level For VBR: Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
    pub fn set_max_bitrate(mut self, input: std::option::Option<i32>) -> Self {
        self.max_bitrate = input;
        self
    }
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    pub fn min_i_interval(mut self, input: i32) -> Self {
        self.min_i_interval = Some(input);
        self
    }
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    pub fn set_min_i_interval(mut self, input: std::option::Option<i32>) -> Self {
        self.min_i_interval = input;
        self
    }
    /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
    pub fn num_ref_frames(mut self, input: i32) -> Self {
        self.num_ref_frames = Some(input);
        self
    }
    /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
    pub fn set_num_ref_frames(mut self, input: std::option::Option<i32>) -> Self {
        self.num_ref_frames = input;
        self
    }
    /// This field indicates how the output pixel aspect ratio is specified. If "specified" is selected then the output video pixel aspect ratio is determined by parNumerator and parDenominator, else if "initializeFromSource" is selected then the output pixsel aspect ratio will be set equal to the input video pixel aspect ratio of the first input.
    pub fn par_control(mut self, input: crate::types::H264ParControl) -> Self {
        self.par_control = Some(input);
        self
    }
    /// This field indicates how the output pixel aspect ratio is specified. If "specified" is selected then the output video pixel aspect ratio is determined by parNumerator and parDenominator, else if "initializeFromSource" is selected then the output pixsel aspect ratio will be set equal to the input video pixel aspect ratio of the first input.
    pub fn set_par_control(
        mut self,
        input: std::option::Option<crate::types::H264ParControl>,
    ) -> Self {
        self.par_control = input;
        self
    }
    /// Pixel Aspect Ratio denominator.
    pub fn par_denominator(mut self, input: i32) -> Self {
        self.par_denominator = Some(input);
        self
    }
    /// Pixel Aspect Ratio denominator.
    pub fn set_par_denominator(mut self, input: std::option::Option<i32>) -> Self {
        self.par_denominator = input;
        self
    }
    /// Pixel Aspect Ratio numerator.
    pub fn par_numerator(mut self, input: i32) -> Self {
        self.par_numerator = Some(input);
        self
    }
    /// Pixel Aspect Ratio numerator.
    pub fn set_par_numerator(mut self, input: std::option::Option<i32>) -> Self {
        self.par_numerator = input;
        self
    }
    /// H.264 Profile.
    pub fn profile(mut self, input: crate::types::H264Profile) -> Self {
        self.profile = Some(input);
        self
    }
    /// H.264 Profile.
    pub fn set_profile(mut self, input: std::option::Option<crate::types::H264Profile>) -> Self {
        self.profile = input;
        self
    }
    /// Leave as STANDARD_QUALITY or choose a different value (which might result in additional costs to run the channel). - ENHANCED_QUALITY: Produces a slightly better video quality without an increase in the bitrate. Has an effect only when the Rate control mode is QVBR or CBR. If this channel is in a MediaLive multiplex, the value must be ENHANCED_QUALITY. - STANDARD_QUALITY: Valid for any Rate control mode.
    pub fn quality_level(mut self, input: crate::types::H264QualityLevel) -> Self {
        self.quality_level = Some(input);
        self
    }
    /// Leave as STANDARD_QUALITY or choose a different value (which might result in additional costs to run the channel). - ENHANCED_QUALITY: Produces a slightly better video quality without an increase in the bitrate. Has an effect only when the Rate control mode is QVBR or CBR. If this channel is in a MediaLive multiplex, the value must be ENHANCED_QUALITY. - STANDARD_QUALITY: Valid for any Rate control mode.
    pub fn set_quality_level(
        mut self,
        input: std::option::Option<crate::types::H264QualityLevel>,
    ) -> Self {
        self.quality_level = input;
        self
    }
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. You can set a target quality or you can let MediaLive determine the best quality. To set a target quality, enter values in the QVBR quality level field and the Max bitrate field. Enter values that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M To let MediaLive decide, leave the QVBR quality level field empty, and in Max bitrate enter the maximum rate you want in the video. For more information, see the section called "Video - rate control mode" in the MediaLive user guide
    pub fn qvbr_quality_level(mut self, input: i32) -> Self {
        self.qvbr_quality_level = Some(input);
        self
    }
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. You can set a target quality or you can let MediaLive determine the best quality. To set a target quality, enter values in the QVBR quality level field and the Max bitrate field. Enter values that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M To let MediaLive decide, leave the QVBR quality level field empty, and in Max bitrate enter the maximum rate you want in the video. For more information, see the section called "Video - rate control mode" in the MediaLive user guide
    pub fn set_qvbr_quality_level(mut self, input: std::option::Option<i32>) -> Self {
        self.qvbr_quality_level = input;
        self
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. VBR: Quality and bitrate vary, depending on the video complexity. Recommended instead of QVBR if you want to maintain a specific average bitrate over the duration of the channel. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    pub fn rate_control_mode(mut self, input: crate::types::H264RateControlMode) -> Self {
        self.rate_control_mode = Some(input);
        self
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. VBR: Quality and bitrate vary, depending on the video complexity. Recommended instead of QVBR if you want to maintain a specific average bitrate over the duration of the channel. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    pub fn set_rate_control_mode(
        mut self,
        input: std::option::Option<crate::types::H264RateControlMode>,
    ) -> Self {
        self.rate_control_mode = input;
        self
    }
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    pub fn scan_type(mut self, input: crate::types::H264ScanType) -> Self {
        self.scan_type = Some(input);
        self
    }
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    pub fn set_scan_type(mut self, input: std::option::Option<crate::types::H264ScanType>) -> Self {
        self.scan_type = input;
        self
    }
    /// Scene change detection. - On: inserts I-frames when scene change is detected. - Off: does not force an I-frame when scene change is detected.
    pub fn scene_change_detect(mut self, input: crate::types::H264SceneChangeDetect) -> Self {
        self.scene_change_detect = Some(input);
        self
    }
    /// Scene change detection. - On: inserts I-frames when scene change is detected. - Off: does not force an I-frame when scene change is detected.
    pub fn set_scene_change_detect(
        mut self,
        input: std::option::Option<crate::types::H264SceneChangeDetect>,
    ) -> Self {
        self.scene_change_detect = input;
        self
    }
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    pub fn slices(mut self, input: i32) -> Self {
        self.slices = Some(input);
        self
    }
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    pub fn set_slices(mut self, input: std::option::Option<i32>) -> Self {
        self.slices = input;
        self
    }
    /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image. If not set to zero, must be greater than 15.
    pub fn softness(mut self, input: i32) -> Self {
        self.softness = Some(input);
        self
    }
    /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image. If not set to zero, must be greater than 15.
    pub fn set_softness(mut self, input: std::option::Option<i32>) -> Self {
        self.softness = input;
        self
    }
    /// Spatial AQ makes adjustments within each frame based on spatial variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if spatial AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply spatial AQ using the specified strength. Disabled: MediaLive won't apply spatial AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply spatial AQ.
    pub fn spatial_aq(mut self, input: crate::types::H264SpatialAq) -> Self {
        self.spatial_aq = Some(input);
        self
    }
    /// Spatial AQ makes adjustments within each frame based on spatial variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if spatial AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply spatial AQ using the specified strength. Disabled: MediaLive won't apply spatial AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply spatial AQ.
    pub fn set_spatial_aq(
        mut self,
        input: std::option::Option<crate::types::H264SpatialAq>,
    ) -> Self {
        self.spatial_aq = input;
        self
    }
    /// If set to fixed, use gopNumBFrames B-frames per sub-GOP. If set to dynamic, optimize the number of B-frames used for each sub-GOP to improve visual quality.
    pub fn subgop_length(mut self, input: crate::types::H264SubGopLength) -> Self {
        self.subgop_length = Some(input);
        self
    }
    /// If set to fixed, use gopNumBFrames B-frames per sub-GOP. If set to dynamic, optimize the number of B-frames used for each sub-GOP to improve visual quality.
    pub fn set_subgop_length(
        mut self,
        input: std::option::Option<crate::types::H264SubGopLength>,
    ) -> Self {
        self.subgop_length = input;
        self
    }
    /// Produces a bitstream compliant with SMPTE RP-2027.
    pub fn syntax(mut self, input: crate::types::H264Syntax) -> Self {
        self.syntax = Some(input);
        self
    }
    /// Produces a bitstream compliant with SMPTE RP-2027.
    pub fn set_syntax(mut self, input: std::option::Option<crate::types::H264Syntax>) -> Self {
        self.syntax = input;
        self
    }
    /// Temporal makes adjustments within each frame based on temporal variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if temporal AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply temporal AQ using the specified strength. Disabled: MediaLive won't apply temporal AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply temporal AQ.
    pub fn temporal_aq(mut self, input: crate::types::H264TemporalAq) -> Self {
        self.temporal_aq = Some(input);
        self
    }
    /// Temporal makes adjustments within each frame based on temporal variation of content complexity. The value to enter in this field depends on the value in the Adaptive quantization field: If you have set the Adaptive quantization field to Auto, MediaLive ignores any value in this field. MediaLive will determine if temporal AQ is appropriate and will apply the appropriate strength. If you have set the Adaptive quantization field to a strength, you can set this field to Enabled or Disabled. Enabled: MediaLive will apply temporal AQ using the specified strength. Disabled: MediaLive won't apply temporal AQ. If you have set the Adaptive quantization to Disabled, MediaLive ignores any value in this field and doesn't apply temporal AQ.
    pub fn set_temporal_aq(
        mut self,
        input: std::option::Option<crate::types::H264TemporalAq>,
    ) -> Self {
        self.temporal_aq = input;
        self
    }
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    pub fn timecode_insertion(
        mut self,
        input: crate::types::H264TimecodeInsertionBehavior,
    ) -> Self {
        self.timecode_insertion = Some(input);
        self
    }
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    pub fn set_timecode_insertion(
        mut self,
        input: std::option::Option<crate::types::H264TimecodeInsertionBehavior>,
    ) -> Self {
        self.timecode_insertion = input;
        self
    }
    /// Timecode burn-in settings
    pub fn timecode_burnin_settings(mut self, input: crate::types::TimecodeBurninSettings) -> Self {
        self.timecode_burnin_settings = Some(input);
        self
    }
    /// Timecode burn-in settings
    pub fn set_timecode_burnin_settings(
        mut self,
        input: std::option::Option<crate::types::TimecodeBurninSettings>,
    ) -> Self {
        self.timecode_burnin_settings = input;
        self
    }
    /// Consumes the builder and constructs a [`H264Settings`](crate::types::H264Settings).
    pub fn build(self) -> crate::types::H264Settings {
        crate::types::H264Settings {
            adaptive_quantization: self.adaptive_quantization,
            afd_signaling: self.afd_signaling,
            bitrate: self.bitrate.unwrap_or_default(),
            buf_fill_pct: self.buf_fill_pct.unwrap_or_default(),
            buf_size: self.buf_size.unwrap_or_default(),
            color_metadata: self.color_metadata,
            color_space_settings: self.color_space_settings,
            entropy_encoding: self.entropy_encoding,
            filter_settings: self.filter_settings,
            fixed_afd: self.fixed_afd,
            flicker_aq: self.flicker_aq,
            force_field_pictures: self.force_field_pictures,
            framerate_control: self.framerate_control,
            framerate_denominator: self.framerate_denominator.unwrap_or_default(),
            framerate_numerator: self.framerate_numerator.unwrap_or_default(),
            gop_b_reference: self.gop_b_reference,
            gop_closed_cadence: self.gop_closed_cadence.unwrap_or_default(),
            gop_num_b_frames: self.gop_num_b_frames.unwrap_or_default(),
            gop_size: self.gop_size.unwrap_or_default(),
            gop_size_units: self.gop_size_units,
            level: self.level,
            look_ahead_rate_control: self.look_ahead_rate_control,
            max_bitrate: self.max_bitrate.unwrap_or_default(),
            min_i_interval: self.min_i_interval.unwrap_or_default(),
            num_ref_frames: self.num_ref_frames.unwrap_or_default(),
            par_control: self.par_control,
            par_denominator: self.par_denominator.unwrap_or_default(),
            par_numerator: self.par_numerator.unwrap_or_default(),
            profile: self.profile,
            quality_level: self.quality_level,
            qvbr_quality_level: self.qvbr_quality_level.unwrap_or_default(),
            rate_control_mode: self.rate_control_mode,
            scan_type: self.scan_type,
            scene_change_detect: self.scene_change_detect,
            slices: self.slices.unwrap_or_default(),
            softness: self.softness.unwrap_or_default(),
            spatial_aq: self.spatial_aq,
            subgop_length: self.subgop_length,
            syntax: self.syntax,
            temporal_aq: self.temporal_aq,
            timecode_insertion: self.timecode_insertion,
            timecode_burnin_settings: self.timecode_burnin_settings,
        }
    }
}
