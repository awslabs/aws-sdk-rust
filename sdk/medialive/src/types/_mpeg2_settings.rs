// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Mpeg2 Settings
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Mpeg2Settings {
    /// Choose Off to disable adaptive quantization. Or choose another value to enable the quantizer and set its strength. The strengths are: Auto, Off, Low, Medium, High. When you enable this field, MediaLive allows intra-frame quantizers to vary, which might improve visual quality.
    #[doc(hidden)]
    pub adaptive_quantization: std::option::Option<crate::types::Mpeg2AdaptiveQuantization>,
    /// Indicates the AFD values that MediaLive will write into the video encode. If you do not know what AFD signaling is, or if your downstream system has not given you guidance, choose AUTO. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: MediaLive will use the value you specify in fixedAFD.
    #[doc(hidden)]
    pub afd_signaling: std::option::Option<crate::types::AfdSignaling>,
    /// Specifies whether to include the color space metadata. The metadata describes the color space that applies to the video (the colorSpace field). We recommend that you insert the metadata.
    #[doc(hidden)]
    pub color_metadata: std::option::Option<crate::types::Mpeg2ColorMetadata>,
    /// Choose the type of color space conversion to apply to the output. For detailed information on setting up both the input and the output to obtain the desired color space in the output, see the section on \"MediaLive Features - Video - color space\" in the MediaLive User Guide. PASSTHROUGH: Keep the color space of the input content - do not convert it. AUTO:Convert all content that is SD to rec 601, and convert all content that is HD to rec 709.
    #[doc(hidden)]
    pub color_space: std::option::Option<crate::types::Mpeg2ColorSpace>,
    /// Sets the pixel aspect ratio for the encode.
    #[doc(hidden)]
    pub display_aspect_ratio: std::option::Option<crate::types::Mpeg2DisplayRatio>,
    /// Optionally specify a noise reduction filter, which can improve quality of compressed content. If you do not choose a filter, no filter will be applied. TEMPORAL: This filter is useful for both source content that is noisy (when it has excessive digital artifacts) and source content that is clean. When the content is noisy, the filter cleans up the source content before the encoding phase, with these two effects: First, it improves the output video quality because the content has been cleaned up. Secondly, it decreases the bandwidth because MediaLive does not waste bits on encoding noise. When the content is reasonably clean, the filter tends to decrease the bitrate.
    #[doc(hidden)]
    pub filter_settings: std::option::Option<crate::types::Mpeg2FilterSettings>,
    /// Complete this field only when afdSignaling is set to FIXED. Enter the AFD value (4 bits) to write on all frames of the video encode.
    #[doc(hidden)]
    pub fixed_afd: std::option::Option<crate::types::FixedAfd>,
    /// description": "The framerate denominator. For example, 1001. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    #[doc(hidden)]
    pub framerate_denominator: i32,
    /// The framerate numerator. For example, 24000. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    #[doc(hidden)]
    pub framerate_numerator: i32,
    /// MPEG2: default is open GOP.
    #[doc(hidden)]
    pub gop_closed_cadence: i32,
    /// Relates to the GOP structure. The number of B-frames between reference frames. If you do not know what a B-frame is, use the default.
    #[doc(hidden)]
    pub gop_num_b_frames: i32,
    /// Relates to the GOP structure. The GOP size (keyframe interval) in the units specified in gopSizeUnits. If you do not know what GOP is, use the default. If gopSizeUnits is frames, then the gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, the gopSize must be greater than 0, but does not need to be an integer.
    #[doc(hidden)]
    pub gop_size: f64,
    /// Relates to the GOP structure. Specifies whether the gopSize is specified in frames or seconds. If you do not plan to change the default gopSize, leave the default. If you specify SECONDS, MediaLive will internally convert the gop size to a frame count.
    #[doc(hidden)]
    pub gop_size_units: std::option::Option<crate::types::Mpeg2GopSizeUnits>,
    /// Set the scan type of the output to PROGRESSIVE or INTERLACED (top field first).
    #[doc(hidden)]
    pub scan_type: std::option::Option<crate::types::Mpeg2ScanType>,
    /// Relates to the GOP structure. If you do not know what GOP is, use the default. FIXED: Set the number of B-frames in each sub-GOP to the value in gopNumBFrames. DYNAMIC: Let MediaLive optimize the number of B-frames in each sub-GOP, to improve visual quality.
    #[doc(hidden)]
    pub subgop_length: std::option::Option<crate::types::Mpeg2SubGopLength>,
    /// Determines how MediaLive inserts timecodes in the output video. For detailed information about setting up the input and the output for a timecode, see the section on \"MediaLive Features - Timecode configuration\" in the MediaLive User Guide. DISABLED: do not include timecodes. GOP_TIMECODE: Include timecode metadata in the GOP header.
    #[doc(hidden)]
    pub timecode_insertion: std::option::Option<crate::types::Mpeg2TimecodeInsertionBehavior>,
    /// Timecode burn-in settings
    #[doc(hidden)]
    pub timecode_burnin_settings: std::option::Option<crate::types::TimecodeBurninSettings>,
}
impl Mpeg2Settings {
    /// Choose Off to disable adaptive quantization. Or choose another value to enable the quantizer and set its strength. The strengths are: Auto, Off, Low, Medium, High. When you enable this field, MediaLive allows intra-frame quantizers to vary, which might improve visual quality.
    pub fn adaptive_quantization(
        &self,
    ) -> std::option::Option<&crate::types::Mpeg2AdaptiveQuantization> {
        self.adaptive_quantization.as_ref()
    }
    /// Indicates the AFD values that MediaLive will write into the video encode. If you do not know what AFD signaling is, or if your downstream system has not given you guidance, choose AUTO. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: MediaLive will use the value you specify in fixedAFD.
    pub fn afd_signaling(&self) -> std::option::Option<&crate::types::AfdSignaling> {
        self.afd_signaling.as_ref()
    }
    /// Specifies whether to include the color space metadata. The metadata describes the color space that applies to the video (the colorSpace field). We recommend that you insert the metadata.
    pub fn color_metadata(&self) -> std::option::Option<&crate::types::Mpeg2ColorMetadata> {
        self.color_metadata.as_ref()
    }
    /// Choose the type of color space conversion to apply to the output. For detailed information on setting up both the input and the output to obtain the desired color space in the output, see the section on \"MediaLive Features - Video - color space\" in the MediaLive User Guide. PASSTHROUGH: Keep the color space of the input content - do not convert it. AUTO:Convert all content that is SD to rec 601, and convert all content that is HD to rec 709.
    pub fn color_space(&self) -> std::option::Option<&crate::types::Mpeg2ColorSpace> {
        self.color_space.as_ref()
    }
    /// Sets the pixel aspect ratio for the encode.
    pub fn display_aspect_ratio(&self) -> std::option::Option<&crate::types::Mpeg2DisplayRatio> {
        self.display_aspect_ratio.as_ref()
    }
    /// Optionally specify a noise reduction filter, which can improve quality of compressed content. If you do not choose a filter, no filter will be applied. TEMPORAL: This filter is useful for both source content that is noisy (when it has excessive digital artifacts) and source content that is clean. When the content is noisy, the filter cleans up the source content before the encoding phase, with these two effects: First, it improves the output video quality because the content has been cleaned up. Secondly, it decreases the bandwidth because MediaLive does not waste bits on encoding noise. When the content is reasonably clean, the filter tends to decrease the bitrate.
    pub fn filter_settings(&self) -> std::option::Option<&crate::types::Mpeg2FilterSettings> {
        self.filter_settings.as_ref()
    }
    /// Complete this field only when afdSignaling is set to FIXED. Enter the AFD value (4 bits) to write on all frames of the video encode.
    pub fn fixed_afd(&self) -> std::option::Option<&crate::types::FixedAfd> {
        self.fixed_afd.as_ref()
    }
    /// description": "The framerate denominator. For example, 1001. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    pub fn framerate_denominator(&self) -> i32 {
        self.framerate_denominator
    }
    /// The framerate numerator. For example, 24000. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    pub fn framerate_numerator(&self) -> i32 {
        self.framerate_numerator
    }
    /// MPEG2: default is open GOP.
    pub fn gop_closed_cadence(&self) -> i32 {
        self.gop_closed_cadence
    }
    /// Relates to the GOP structure. The number of B-frames between reference frames. If you do not know what a B-frame is, use the default.
    pub fn gop_num_b_frames(&self) -> i32 {
        self.gop_num_b_frames
    }
    /// Relates to the GOP structure. The GOP size (keyframe interval) in the units specified in gopSizeUnits. If you do not know what GOP is, use the default. If gopSizeUnits is frames, then the gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, the gopSize must be greater than 0, but does not need to be an integer.
    pub fn gop_size(&self) -> f64 {
        self.gop_size
    }
    /// Relates to the GOP structure. Specifies whether the gopSize is specified in frames or seconds. If you do not plan to change the default gopSize, leave the default. If you specify SECONDS, MediaLive will internally convert the gop size to a frame count.
    pub fn gop_size_units(&self) -> std::option::Option<&crate::types::Mpeg2GopSizeUnits> {
        self.gop_size_units.as_ref()
    }
    /// Set the scan type of the output to PROGRESSIVE or INTERLACED (top field first).
    pub fn scan_type(&self) -> std::option::Option<&crate::types::Mpeg2ScanType> {
        self.scan_type.as_ref()
    }
    /// Relates to the GOP structure. If you do not know what GOP is, use the default. FIXED: Set the number of B-frames in each sub-GOP to the value in gopNumBFrames. DYNAMIC: Let MediaLive optimize the number of B-frames in each sub-GOP, to improve visual quality.
    pub fn subgop_length(&self) -> std::option::Option<&crate::types::Mpeg2SubGopLength> {
        self.subgop_length.as_ref()
    }
    /// Determines how MediaLive inserts timecodes in the output video. For detailed information about setting up the input and the output for a timecode, see the section on \"MediaLive Features - Timecode configuration\" in the MediaLive User Guide. DISABLED: do not include timecodes. GOP_TIMECODE: Include timecode metadata in the GOP header.
    pub fn timecode_insertion(
        &self,
    ) -> std::option::Option<&crate::types::Mpeg2TimecodeInsertionBehavior> {
        self.timecode_insertion.as_ref()
    }
    /// Timecode burn-in settings
    pub fn timecode_burnin_settings(
        &self,
    ) -> std::option::Option<&crate::types::TimecodeBurninSettings> {
        self.timecode_burnin_settings.as_ref()
    }
}
impl Mpeg2Settings {
    /// Creates a new builder-style object to manufacture [`Mpeg2Settings`](crate::types::Mpeg2Settings).
    pub fn builder() -> crate::types::builders::Mpeg2SettingsBuilder {
        crate::types::builders::Mpeg2SettingsBuilder::default()
    }
}

/// A builder for [`Mpeg2Settings`](crate::types::Mpeg2Settings).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct Mpeg2SettingsBuilder {
    pub(crate) adaptive_quantization: std::option::Option<crate::types::Mpeg2AdaptiveQuantization>,
    pub(crate) afd_signaling: std::option::Option<crate::types::AfdSignaling>,
    pub(crate) color_metadata: std::option::Option<crate::types::Mpeg2ColorMetadata>,
    pub(crate) color_space: std::option::Option<crate::types::Mpeg2ColorSpace>,
    pub(crate) display_aspect_ratio: std::option::Option<crate::types::Mpeg2DisplayRatio>,
    pub(crate) filter_settings: std::option::Option<crate::types::Mpeg2FilterSettings>,
    pub(crate) fixed_afd: std::option::Option<crate::types::FixedAfd>,
    pub(crate) framerate_denominator: std::option::Option<i32>,
    pub(crate) framerate_numerator: std::option::Option<i32>,
    pub(crate) gop_closed_cadence: std::option::Option<i32>,
    pub(crate) gop_num_b_frames: std::option::Option<i32>,
    pub(crate) gop_size: std::option::Option<f64>,
    pub(crate) gop_size_units: std::option::Option<crate::types::Mpeg2GopSizeUnits>,
    pub(crate) scan_type: std::option::Option<crate::types::Mpeg2ScanType>,
    pub(crate) subgop_length: std::option::Option<crate::types::Mpeg2SubGopLength>,
    pub(crate) timecode_insertion:
        std::option::Option<crate::types::Mpeg2TimecodeInsertionBehavior>,
    pub(crate) timecode_burnin_settings: std::option::Option<crate::types::TimecodeBurninSettings>,
}
impl Mpeg2SettingsBuilder {
    /// Choose Off to disable adaptive quantization. Or choose another value to enable the quantizer and set its strength. The strengths are: Auto, Off, Low, Medium, High. When you enable this field, MediaLive allows intra-frame quantizers to vary, which might improve visual quality.
    pub fn adaptive_quantization(mut self, input: crate::types::Mpeg2AdaptiveQuantization) -> Self {
        self.adaptive_quantization = Some(input);
        self
    }
    /// Choose Off to disable adaptive quantization. Or choose another value to enable the quantizer and set its strength. The strengths are: Auto, Off, Low, Medium, High. When you enable this field, MediaLive allows intra-frame quantizers to vary, which might improve visual quality.
    pub fn set_adaptive_quantization(
        mut self,
        input: std::option::Option<crate::types::Mpeg2AdaptiveQuantization>,
    ) -> Self {
        self.adaptive_quantization = input;
        self
    }
    /// Indicates the AFD values that MediaLive will write into the video encode. If you do not know what AFD signaling is, or if your downstream system has not given you guidance, choose AUTO. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: MediaLive will use the value you specify in fixedAFD.
    pub fn afd_signaling(mut self, input: crate::types::AfdSignaling) -> Self {
        self.afd_signaling = Some(input);
        self
    }
    /// Indicates the AFD values that MediaLive will write into the video encode. If you do not know what AFD signaling is, or if your downstream system has not given you guidance, choose AUTO. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: MediaLive will use the value you specify in fixedAFD.
    pub fn set_afd_signaling(
        mut self,
        input: std::option::Option<crate::types::AfdSignaling>,
    ) -> Self {
        self.afd_signaling = input;
        self
    }
    /// Specifies whether to include the color space metadata. The metadata describes the color space that applies to the video (the colorSpace field). We recommend that you insert the metadata.
    pub fn color_metadata(mut self, input: crate::types::Mpeg2ColorMetadata) -> Self {
        self.color_metadata = Some(input);
        self
    }
    /// Specifies whether to include the color space metadata. The metadata describes the color space that applies to the video (the colorSpace field). We recommend that you insert the metadata.
    pub fn set_color_metadata(
        mut self,
        input: std::option::Option<crate::types::Mpeg2ColorMetadata>,
    ) -> Self {
        self.color_metadata = input;
        self
    }
    /// Choose the type of color space conversion to apply to the output. For detailed information on setting up both the input and the output to obtain the desired color space in the output, see the section on \"MediaLive Features - Video - color space\" in the MediaLive User Guide. PASSTHROUGH: Keep the color space of the input content - do not convert it. AUTO:Convert all content that is SD to rec 601, and convert all content that is HD to rec 709.
    pub fn color_space(mut self, input: crate::types::Mpeg2ColorSpace) -> Self {
        self.color_space = Some(input);
        self
    }
    /// Choose the type of color space conversion to apply to the output. For detailed information on setting up both the input and the output to obtain the desired color space in the output, see the section on \"MediaLive Features - Video - color space\" in the MediaLive User Guide. PASSTHROUGH: Keep the color space of the input content - do not convert it. AUTO:Convert all content that is SD to rec 601, and convert all content that is HD to rec 709.
    pub fn set_color_space(
        mut self,
        input: std::option::Option<crate::types::Mpeg2ColorSpace>,
    ) -> Self {
        self.color_space = input;
        self
    }
    /// Sets the pixel aspect ratio for the encode.
    pub fn display_aspect_ratio(mut self, input: crate::types::Mpeg2DisplayRatio) -> Self {
        self.display_aspect_ratio = Some(input);
        self
    }
    /// Sets the pixel aspect ratio for the encode.
    pub fn set_display_aspect_ratio(
        mut self,
        input: std::option::Option<crate::types::Mpeg2DisplayRatio>,
    ) -> Self {
        self.display_aspect_ratio = input;
        self
    }
    /// Optionally specify a noise reduction filter, which can improve quality of compressed content. If you do not choose a filter, no filter will be applied. TEMPORAL: This filter is useful for both source content that is noisy (when it has excessive digital artifacts) and source content that is clean. When the content is noisy, the filter cleans up the source content before the encoding phase, with these two effects: First, it improves the output video quality because the content has been cleaned up. Secondly, it decreases the bandwidth because MediaLive does not waste bits on encoding noise. When the content is reasonably clean, the filter tends to decrease the bitrate.
    pub fn filter_settings(mut self, input: crate::types::Mpeg2FilterSettings) -> Self {
        self.filter_settings = Some(input);
        self
    }
    /// Optionally specify a noise reduction filter, which can improve quality of compressed content. If you do not choose a filter, no filter will be applied. TEMPORAL: This filter is useful for both source content that is noisy (when it has excessive digital artifacts) and source content that is clean. When the content is noisy, the filter cleans up the source content before the encoding phase, with these two effects: First, it improves the output video quality because the content has been cleaned up. Secondly, it decreases the bandwidth because MediaLive does not waste bits on encoding noise. When the content is reasonably clean, the filter tends to decrease the bitrate.
    pub fn set_filter_settings(
        mut self,
        input: std::option::Option<crate::types::Mpeg2FilterSettings>,
    ) -> Self {
        self.filter_settings = input;
        self
    }
    /// Complete this field only when afdSignaling is set to FIXED. Enter the AFD value (4 bits) to write on all frames of the video encode.
    pub fn fixed_afd(mut self, input: crate::types::FixedAfd) -> Self {
        self.fixed_afd = Some(input);
        self
    }
    /// Complete this field only when afdSignaling is set to FIXED. Enter the AFD value (4 bits) to write on all frames of the video encode.
    pub fn set_fixed_afd(mut self, input: std::option::Option<crate::types::FixedAfd>) -> Self {
        self.fixed_afd = input;
        self
    }
    /// description": "The framerate denominator. For example, 1001. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    pub fn framerate_denominator(mut self, input: i32) -> Self {
        self.framerate_denominator = Some(input);
        self
    }
    /// description": "The framerate denominator. For example, 1001. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    pub fn set_framerate_denominator(mut self, input: std::option::Option<i32>) -> Self {
        self.framerate_denominator = input;
        self
    }
    /// The framerate numerator. For example, 24000. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    pub fn framerate_numerator(mut self, input: i32) -> Self {
        self.framerate_numerator = Some(input);
        self
    }
    /// The framerate numerator. For example, 24000. The framerate is the numerator divided by the denominator. For example, 24000 / 1001 = 23.976 FPS.
    pub fn set_framerate_numerator(mut self, input: std::option::Option<i32>) -> Self {
        self.framerate_numerator = input;
        self
    }
    /// MPEG2: default is open GOP.
    pub fn gop_closed_cadence(mut self, input: i32) -> Self {
        self.gop_closed_cadence = Some(input);
        self
    }
    /// MPEG2: default is open GOP.
    pub fn set_gop_closed_cadence(mut self, input: std::option::Option<i32>) -> Self {
        self.gop_closed_cadence = input;
        self
    }
    /// Relates to the GOP structure. The number of B-frames between reference frames. If you do not know what a B-frame is, use the default.
    pub fn gop_num_b_frames(mut self, input: i32) -> Self {
        self.gop_num_b_frames = Some(input);
        self
    }
    /// Relates to the GOP structure. The number of B-frames between reference frames. If you do not know what a B-frame is, use the default.
    pub fn set_gop_num_b_frames(mut self, input: std::option::Option<i32>) -> Self {
        self.gop_num_b_frames = input;
        self
    }
    /// Relates to the GOP structure. The GOP size (keyframe interval) in the units specified in gopSizeUnits. If you do not know what GOP is, use the default. If gopSizeUnits is frames, then the gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, the gopSize must be greater than 0, but does not need to be an integer.
    pub fn gop_size(mut self, input: f64) -> Self {
        self.gop_size = Some(input);
        self
    }
    /// Relates to the GOP structure. The GOP size (keyframe interval) in the units specified in gopSizeUnits. If you do not know what GOP is, use the default. If gopSizeUnits is frames, then the gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, the gopSize must be greater than 0, but does not need to be an integer.
    pub fn set_gop_size(mut self, input: std::option::Option<f64>) -> Self {
        self.gop_size = input;
        self
    }
    /// Relates to the GOP structure. Specifies whether the gopSize is specified in frames or seconds. If you do not plan to change the default gopSize, leave the default. If you specify SECONDS, MediaLive will internally convert the gop size to a frame count.
    pub fn gop_size_units(mut self, input: crate::types::Mpeg2GopSizeUnits) -> Self {
        self.gop_size_units = Some(input);
        self
    }
    /// Relates to the GOP structure. Specifies whether the gopSize is specified in frames or seconds. If you do not plan to change the default gopSize, leave the default. If you specify SECONDS, MediaLive will internally convert the gop size to a frame count.
    pub fn set_gop_size_units(
        mut self,
        input: std::option::Option<crate::types::Mpeg2GopSizeUnits>,
    ) -> Self {
        self.gop_size_units = input;
        self
    }
    /// Set the scan type of the output to PROGRESSIVE or INTERLACED (top field first).
    pub fn scan_type(mut self, input: crate::types::Mpeg2ScanType) -> Self {
        self.scan_type = Some(input);
        self
    }
    /// Set the scan type of the output to PROGRESSIVE or INTERLACED (top field first).
    pub fn set_scan_type(
        mut self,
        input: std::option::Option<crate::types::Mpeg2ScanType>,
    ) -> Self {
        self.scan_type = input;
        self
    }
    /// Relates to the GOP structure. If you do not know what GOP is, use the default. FIXED: Set the number of B-frames in each sub-GOP to the value in gopNumBFrames. DYNAMIC: Let MediaLive optimize the number of B-frames in each sub-GOP, to improve visual quality.
    pub fn subgop_length(mut self, input: crate::types::Mpeg2SubGopLength) -> Self {
        self.subgop_length = Some(input);
        self
    }
    /// Relates to the GOP structure. If you do not know what GOP is, use the default. FIXED: Set the number of B-frames in each sub-GOP to the value in gopNumBFrames. DYNAMIC: Let MediaLive optimize the number of B-frames in each sub-GOP, to improve visual quality.
    pub fn set_subgop_length(
        mut self,
        input: std::option::Option<crate::types::Mpeg2SubGopLength>,
    ) -> Self {
        self.subgop_length = input;
        self
    }
    /// Determines how MediaLive inserts timecodes in the output video. For detailed information about setting up the input and the output for a timecode, see the section on \"MediaLive Features - Timecode configuration\" in the MediaLive User Guide. DISABLED: do not include timecodes. GOP_TIMECODE: Include timecode metadata in the GOP header.
    pub fn timecode_insertion(
        mut self,
        input: crate::types::Mpeg2TimecodeInsertionBehavior,
    ) -> Self {
        self.timecode_insertion = Some(input);
        self
    }
    /// Determines how MediaLive inserts timecodes in the output video. For detailed information about setting up the input and the output for a timecode, see the section on \"MediaLive Features - Timecode configuration\" in the MediaLive User Guide. DISABLED: do not include timecodes. GOP_TIMECODE: Include timecode metadata in the GOP header.
    pub fn set_timecode_insertion(
        mut self,
        input: std::option::Option<crate::types::Mpeg2TimecodeInsertionBehavior>,
    ) -> Self {
        self.timecode_insertion = input;
        self
    }
    /// Timecode burn-in settings
    pub fn timecode_burnin_settings(mut self, input: crate::types::TimecodeBurninSettings) -> Self {
        self.timecode_burnin_settings = Some(input);
        self
    }
    /// Timecode burn-in settings
    pub fn set_timecode_burnin_settings(
        mut self,
        input: std::option::Option<crate::types::TimecodeBurninSettings>,
    ) -> Self {
        self.timecode_burnin_settings = input;
        self
    }
    /// Consumes the builder and constructs a [`Mpeg2Settings`](crate::types::Mpeg2Settings).
    pub fn build(self) -> crate::types::Mpeg2Settings {
        crate::types::Mpeg2Settings {
            adaptive_quantization: self.adaptive_quantization,
            afd_signaling: self.afd_signaling,
            color_metadata: self.color_metadata,
            color_space: self.color_space,
            display_aspect_ratio: self.display_aspect_ratio,
            filter_settings: self.filter_settings,
            fixed_afd: self.fixed_afd,
            framerate_denominator: self.framerate_denominator.unwrap_or_default(),
            framerate_numerator: self.framerate_numerator.unwrap_or_default(),
            gop_closed_cadence: self.gop_closed_cadence.unwrap_or_default(),
            gop_num_b_frames: self.gop_num_b_frames.unwrap_or_default(),
            gop_size: self.gop_size.unwrap_or_default(),
            gop_size_units: self.gop_size_units,
            scan_type: self.scan_type,
            subgop_length: self.subgop_length,
            timecode_insertion: self.timecode_insertion,
            timecode_burnin_settings: self.timecode_burnin_settings,
        }
    }
}
