// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Placeholder documentation for VideoBlackFailoverSettings
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VideoBlackFailoverSettings {
    /// A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (1023*0.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (255*0.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
    #[doc(hidden)]
    pub black_detect_threshold: f64,
    /// The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
    #[doc(hidden)]
    pub video_black_threshold_msec: i32,
}
impl VideoBlackFailoverSettings {
    /// A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (1023*0.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (255*0.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
    pub fn black_detect_threshold(&self) -> f64 {
        self.black_detect_threshold
    }
    /// The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
    pub fn video_black_threshold_msec(&self) -> i32 {
        self.video_black_threshold_msec
    }
}
impl VideoBlackFailoverSettings {
    /// Creates a new builder-style object to manufacture [`VideoBlackFailoverSettings`](crate::types::VideoBlackFailoverSettings).
    pub fn builder() -> crate::types::builders::VideoBlackFailoverSettingsBuilder {
        crate::types::builders::VideoBlackFailoverSettingsBuilder::default()
    }
}

/// A builder for [`VideoBlackFailoverSettings`](crate::types::VideoBlackFailoverSettings).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct VideoBlackFailoverSettingsBuilder {
    pub(crate) black_detect_threshold: std::option::Option<f64>,
    pub(crate) video_black_threshold_msec: std::option::Option<i32>,
}
impl VideoBlackFailoverSettingsBuilder {
    /// A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (1023*0.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (255*0.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
    pub fn black_detect_threshold(mut self, input: f64) -> Self {
        self.black_detect_threshold = Some(input);
        self
    }
    /// A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (1023*0.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (255*0.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.
    pub fn set_black_detect_threshold(mut self, input: std::option::Option<f64>) -> Self {
        self.black_detect_threshold = input;
        self
    }
    /// The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
    pub fn video_black_threshold_msec(mut self, input: i32) -> Self {
        self.video_black_threshold_msec = Some(input);
        self
    }
    /// The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs.
    pub fn set_video_black_threshold_msec(mut self, input: std::option::Option<i32>) -> Self {
        self.video_black_threshold_msec = input;
        self
    }
    /// Consumes the builder and constructs a [`VideoBlackFailoverSettings`](crate::types::VideoBlackFailoverSettings).
    pub fn build(self) -> crate::types::VideoBlackFailoverSettings {
        crate::types::VideoBlackFailoverSettings {
            black_detect_threshold: self.black_detect_threshold.unwrap_or_default(),
            video_black_threshold_msec: self.video_black_threshold_msec.unwrap_or_default(),
        }
    }
}
