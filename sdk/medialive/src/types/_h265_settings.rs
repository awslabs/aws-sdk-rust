// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// H265 Settings
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct H265Settings  {
    /// Adaptive quantization. Allows intra-frame quantizers to vary to improve visual quality.
    #[doc(hidden)]
    pub adaptive_quantization: std::option::Option<crate::types::H265AdaptiveQuantization>,
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    #[doc(hidden)]
    pub afd_signaling: std::option::Option<crate::types::AfdSignaling>,
    /// Whether or not EML should insert an Alternative Transfer Function SEI message to support backwards compatibility with non-HDR decoders and displays.
    #[doc(hidden)]
    pub alternative_transfer_function: std::option::Option<crate::types::H265AlternativeTransferFunction>,
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    #[doc(hidden)]
    pub bitrate: i32,
    /// Size of buffer (HRD buffer model) in bits.
    #[doc(hidden)]
    pub buf_size: i32,
    /// Includes colorspace metadata in the output.
    #[doc(hidden)]
    pub color_metadata: std::option::Option<crate::types::H265ColorMetadata>,
    /// Color Space settings
    #[doc(hidden)]
    pub color_space_settings: std::option::Option<crate::types::H265ColorSpaceSettings>,
    /// Optional filters that you can apply to an encode.
    #[doc(hidden)]
    pub filter_settings: std::option::Option<crate::types::H265FilterSettings>,
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    #[doc(hidden)]
    pub fixed_afd: std::option::Option<crate::types::FixedAfd>,
    /// If set to enabled, adjust quantization within each frame to reduce flicker or 'pop' on I-frames.
    #[doc(hidden)]
    pub flicker_aq: std::option::Option<crate::types::H265FlickerAq>,
    /// Framerate denominator.
    #[doc(hidden)]
    pub framerate_denominator: i32,
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    #[doc(hidden)]
    pub framerate_numerator: i32,
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    #[doc(hidden)]
    pub gop_closed_cadence: i32,
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    #[doc(hidden)]
    pub gop_size: f64,
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    #[doc(hidden)]
    pub gop_size_units: std::option::Option<crate::types::H265GopSizeUnits>,
    /// H.265 Level.
    #[doc(hidden)]
    pub level: std::option::Option<crate::types::H265Level>,
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    #[doc(hidden)]
    pub look_ahead_rate_control: std::option::Option<crate::types::H265LookAheadRateControl>,
    /// For QVBR: See the tooltip for Quality level
    #[doc(hidden)]
    pub max_bitrate: i32,
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    #[doc(hidden)]
    pub min_i_interval: i32,
    /// Pixel Aspect Ratio denominator.
    #[doc(hidden)]
    pub par_denominator: i32,
    /// Pixel Aspect Ratio numerator.
    #[doc(hidden)]
    pub par_numerator: i32,
    /// H.265 Profile.
    #[doc(hidden)]
    pub profile: std::option::Option<crate::types::H265Profile>,
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. Set values for the QVBR quality level field and Max bitrate field that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M
    #[doc(hidden)]
    pub qvbr_quality_level: i32,
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    #[doc(hidden)]
    pub rate_control_mode: std::option::Option<crate::types::H265RateControlMode>,
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    #[doc(hidden)]
    pub scan_type: std::option::Option<crate::types::H265ScanType>,
    /// Scene change detection.
    #[doc(hidden)]
    pub scene_change_detect: std::option::Option<crate::types::H265SceneChangeDetect>,
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    #[doc(hidden)]
    pub slices: i32,
    /// H.265 Tier.
    #[doc(hidden)]
    pub tier: std::option::Option<crate::types::H265Tier>,
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    #[doc(hidden)]
    pub timecode_insertion: std::option::Option<crate::types::H265TimecodeInsertionBehavior>,
    /// Timecode burn-in settings
    #[doc(hidden)]
    pub timecode_burnin_settings: std::option::Option<crate::types::TimecodeBurninSettings>,
}
impl H265Settings {
    /// Adaptive quantization. Allows intra-frame quantizers to vary to improve visual quality.
    pub fn adaptive_quantization(&self) -> std::option::Option<& crate::types::H265AdaptiveQuantization> {
        self.adaptive_quantization.as_ref()
    }
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    pub fn afd_signaling(&self) -> std::option::Option<& crate::types::AfdSignaling> {
        self.afd_signaling.as_ref()
    }
    /// Whether or not EML should insert an Alternative Transfer Function SEI message to support backwards compatibility with non-HDR decoders and displays.
    pub fn alternative_transfer_function(&self) -> std::option::Option<& crate::types::H265AlternativeTransferFunction> {
        self.alternative_transfer_function.as_ref()
    }
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    pub fn bitrate(&self) -> i32 {
        self.bitrate
    }
    /// Size of buffer (HRD buffer model) in bits.
    pub fn buf_size(&self) -> i32 {
        self.buf_size
    }
    /// Includes colorspace metadata in the output.
    pub fn color_metadata(&self) -> std::option::Option<& crate::types::H265ColorMetadata> {
        self.color_metadata.as_ref()
    }
    /// Color Space settings
    pub fn color_space_settings(&self) -> std::option::Option<& crate::types::H265ColorSpaceSettings> {
        self.color_space_settings.as_ref()
    }
    /// Optional filters that you can apply to an encode.
    pub fn filter_settings(&self) -> std::option::Option<& crate::types::H265FilterSettings> {
        self.filter_settings.as_ref()
    }
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    pub fn fixed_afd(&self) -> std::option::Option<& crate::types::FixedAfd> {
        self.fixed_afd.as_ref()
    }
    /// If set to enabled, adjust quantization within each frame to reduce flicker or 'pop' on I-frames.
    pub fn flicker_aq(&self) -> std::option::Option<& crate::types::H265FlickerAq> {
        self.flicker_aq.as_ref()
    }
    /// Framerate denominator.
    pub fn framerate_denominator(&self) -> i32 {
        self.framerate_denominator
    }
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    pub fn framerate_numerator(&self) -> i32 {
        self.framerate_numerator
    }
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    pub fn gop_closed_cadence(&self) -> i32 {
        self.gop_closed_cadence
    }
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    pub fn gop_size(&self) -> f64 {
        self.gop_size
    }
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    pub fn gop_size_units(&self) -> std::option::Option<& crate::types::H265GopSizeUnits> {
        self.gop_size_units.as_ref()
    }
    /// H.265 Level.
    pub fn level(&self) -> std::option::Option<& crate::types::H265Level> {
        self.level.as_ref()
    }
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    pub fn look_ahead_rate_control(&self) -> std::option::Option<& crate::types::H265LookAheadRateControl> {
        self.look_ahead_rate_control.as_ref()
    }
    /// For QVBR: See the tooltip for Quality level
    pub fn max_bitrate(&self) -> i32 {
        self.max_bitrate
    }
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    pub fn min_i_interval(&self) -> i32 {
        self.min_i_interval
    }
    /// Pixel Aspect Ratio denominator.
    pub fn par_denominator(&self) -> i32 {
        self.par_denominator
    }
    /// Pixel Aspect Ratio numerator.
    pub fn par_numerator(&self) -> i32 {
        self.par_numerator
    }
    /// H.265 Profile.
    pub fn profile(&self) -> std::option::Option<& crate::types::H265Profile> {
        self.profile.as_ref()
    }
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. Set values for the QVBR quality level field and Max bitrate field that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M
    pub fn qvbr_quality_level(&self) -> i32 {
        self.qvbr_quality_level
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    pub fn rate_control_mode(&self) -> std::option::Option<& crate::types::H265RateControlMode> {
        self.rate_control_mode.as_ref()
    }
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    pub fn scan_type(&self) -> std::option::Option<& crate::types::H265ScanType> {
        self.scan_type.as_ref()
    }
    /// Scene change detection.
    pub fn scene_change_detect(&self) -> std::option::Option<& crate::types::H265SceneChangeDetect> {
        self.scene_change_detect.as_ref()
    }
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    pub fn slices(&self) -> i32 {
        self.slices
    }
    /// H.265 Tier.
    pub fn tier(&self) -> std::option::Option<& crate::types::H265Tier> {
        self.tier.as_ref()
    }
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    pub fn timecode_insertion(&self) -> std::option::Option<& crate::types::H265TimecodeInsertionBehavior> {
        self.timecode_insertion.as_ref()
    }
    /// Timecode burn-in settings
    pub fn timecode_burnin_settings(&self) -> std::option::Option<& crate::types::TimecodeBurninSettings> {
        self.timecode_burnin_settings.as_ref()
    }
}
impl H265Settings {
    /// Creates a new builder-style object to manufacture [`H265Settings`](crate::types::H265Settings).
    pub fn builder() -> crate::types::builders::H265SettingsBuilder {
        crate::types::builders::H265SettingsBuilder::default()
    }
}

/// A builder for [`H265Settings`](crate::types::H265Settings).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct H265SettingsBuilder {
    pub(crate) adaptive_quantization: std::option::Option<crate::types::H265AdaptiveQuantization>,
    pub(crate) afd_signaling: std::option::Option<crate::types::AfdSignaling>,
    pub(crate) alternative_transfer_function: std::option::Option<crate::types::H265AlternativeTransferFunction>,
    pub(crate) bitrate: std::option::Option<i32>,
    pub(crate) buf_size: std::option::Option<i32>,
    pub(crate) color_metadata: std::option::Option<crate::types::H265ColorMetadata>,
    pub(crate) color_space_settings: std::option::Option<crate::types::H265ColorSpaceSettings>,
    pub(crate) filter_settings: std::option::Option<crate::types::H265FilterSettings>,
    pub(crate) fixed_afd: std::option::Option<crate::types::FixedAfd>,
    pub(crate) flicker_aq: std::option::Option<crate::types::H265FlickerAq>,
    pub(crate) framerate_denominator: std::option::Option<i32>,
    pub(crate) framerate_numerator: std::option::Option<i32>,
    pub(crate) gop_closed_cadence: std::option::Option<i32>,
    pub(crate) gop_size: std::option::Option<f64>,
    pub(crate) gop_size_units: std::option::Option<crate::types::H265GopSizeUnits>,
    pub(crate) level: std::option::Option<crate::types::H265Level>,
    pub(crate) look_ahead_rate_control: std::option::Option<crate::types::H265LookAheadRateControl>,
    pub(crate) max_bitrate: std::option::Option<i32>,
    pub(crate) min_i_interval: std::option::Option<i32>,
    pub(crate) par_denominator: std::option::Option<i32>,
    pub(crate) par_numerator: std::option::Option<i32>,
    pub(crate) profile: std::option::Option<crate::types::H265Profile>,
    pub(crate) qvbr_quality_level: std::option::Option<i32>,
    pub(crate) rate_control_mode: std::option::Option<crate::types::H265RateControlMode>,
    pub(crate) scan_type: std::option::Option<crate::types::H265ScanType>,
    pub(crate) scene_change_detect: std::option::Option<crate::types::H265SceneChangeDetect>,
    pub(crate) slices: std::option::Option<i32>,
    pub(crate) tier: std::option::Option<crate::types::H265Tier>,
    pub(crate) timecode_insertion: std::option::Option<crate::types::H265TimecodeInsertionBehavior>,
    pub(crate) timecode_burnin_settings: std::option::Option<crate::types::TimecodeBurninSettings>,
}
impl H265SettingsBuilder {
    /// Adaptive quantization. Allows intra-frame quantizers to vary to improve visual quality.
    pub fn adaptive_quantization(mut self, input: crate::types::H265AdaptiveQuantization) -> Self {
        self.adaptive_quantization = Some(input);
        self
    }
    /// Adaptive quantization. Allows intra-frame quantizers to vary to improve visual quality.
    pub fn set_adaptive_quantization(mut self, input: std::option::Option<crate::types::H265AdaptiveQuantization>) -> Self {
        self.adaptive_quantization = input; self
    }
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    pub fn afd_signaling(mut self, input: crate::types::AfdSignaling) -> Self {
        self.afd_signaling = Some(input);
        self
    }
    /// Indicates that AFD values will be written into the output stream. If afdSignaling is "auto", the system will try to preserve the input AFD value (in cases where multiple AFD values are valid). If set to "fixed", the AFD value will be the value configured in the fixedAfd parameter.
    pub fn set_afd_signaling(mut self, input: std::option::Option<crate::types::AfdSignaling>) -> Self {
        self.afd_signaling = input; self
    }
    /// Whether or not EML should insert an Alternative Transfer Function SEI message to support backwards compatibility with non-HDR decoders and displays.
    pub fn alternative_transfer_function(mut self, input: crate::types::H265AlternativeTransferFunction) -> Self {
        self.alternative_transfer_function = Some(input);
        self
    }
    /// Whether or not EML should insert an Alternative Transfer Function SEI message to support backwards compatibility with non-HDR decoders and displays.
    pub fn set_alternative_transfer_function(mut self, input: std::option::Option<crate::types::H265AlternativeTransferFunction>) -> Self {
        self.alternative_transfer_function = input; self
    }
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    pub fn bitrate(mut self, input: i32) -> Self {
        self.bitrate = Some(input);
        self
    }
    /// Average bitrate in bits/second. Required when the rate control mode is VBR or CBR. Not used for QVBR. In an MS Smooth output group, each output must have a unique value when its bitrate is rounded down to the nearest multiple of 1000.
    pub fn set_bitrate(mut self, input: std::option::Option<i32>) -> Self {
        self.bitrate = input; self
    }
    /// Size of buffer (HRD buffer model) in bits.
    pub fn buf_size(mut self, input: i32) -> Self {
        self.buf_size = Some(input);
        self
    }
    /// Size of buffer (HRD buffer model) in bits.
    pub fn set_buf_size(mut self, input: std::option::Option<i32>) -> Self {
        self.buf_size = input; self
    }
    /// Includes colorspace metadata in the output.
    pub fn color_metadata(mut self, input: crate::types::H265ColorMetadata) -> Self {
        self.color_metadata = Some(input);
        self
    }
    /// Includes colorspace metadata in the output.
    pub fn set_color_metadata(mut self, input: std::option::Option<crate::types::H265ColorMetadata>) -> Self {
        self.color_metadata = input; self
    }
    /// Color Space settings
    pub fn color_space_settings(mut self, input: crate::types::H265ColorSpaceSettings) -> Self {
        self.color_space_settings = Some(input);
        self
    }
    /// Color Space settings
    pub fn set_color_space_settings(mut self, input: std::option::Option<crate::types::H265ColorSpaceSettings>) -> Self {
        self.color_space_settings = input; self
    }
    /// Optional filters that you can apply to an encode.
    pub fn filter_settings(mut self, input: crate::types::H265FilterSettings) -> Self {
        self.filter_settings = Some(input);
        self
    }
    /// Optional filters that you can apply to an encode.
    pub fn set_filter_settings(mut self, input: std::option::Option<crate::types::H265FilterSettings>) -> Self {
        self.filter_settings = input; self
    }
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    pub fn fixed_afd(mut self, input: crate::types::FixedAfd) -> Self {
        self.fixed_afd = Some(input);
        self
    }
    /// Four bit AFD value to write on all frames of video in the output stream. Only valid when afdSignaling is set to 'Fixed'.
    pub fn set_fixed_afd(mut self, input: std::option::Option<crate::types::FixedAfd>) -> Self {
        self.fixed_afd = input; self
    }
    /// If set to enabled, adjust quantization within each frame to reduce flicker or 'pop' on I-frames.
    pub fn flicker_aq(mut self, input: crate::types::H265FlickerAq) -> Self {
        self.flicker_aq = Some(input);
        self
    }
    /// If set to enabled, adjust quantization within each frame to reduce flicker or 'pop' on I-frames.
    pub fn set_flicker_aq(mut self, input: std::option::Option<crate::types::H265FlickerAq>) -> Self {
        self.flicker_aq = input; self
    }
    /// Framerate denominator.
    pub fn framerate_denominator(mut self, input: i32) -> Self {
        self.framerate_denominator = Some(input);
        self
    }
    /// Framerate denominator.
    pub fn set_framerate_denominator(mut self, input: std::option::Option<i32>) -> Self {
        self.framerate_denominator = input; self
    }
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    pub fn framerate_numerator(mut self, input: i32) -> Self {
        self.framerate_numerator = Some(input);
        self
    }
    /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
    pub fn set_framerate_numerator(mut self, input: std::option::Option<i32>) -> Self {
        self.framerate_numerator = input; self
    }
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    pub fn gop_closed_cadence(mut self, input: i32) -> Self {
        self.gop_closed_cadence = Some(input);
        self
    }
    /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
    pub fn set_gop_closed_cadence(mut self, input: std::option::Option<i32>) -> Self {
        self.gop_closed_cadence = input; self
    }
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    pub fn gop_size(mut self, input: f64) -> Self {
        self.gop_size = Some(input);
        self
    }
    /// GOP size (keyframe interval) in units of either frames or seconds per gopSizeUnits. If gopSizeUnits is frames, gopSize must be an integer and must be greater than or equal to 1. If gopSizeUnits is seconds, gopSize must be greater than 0, but need not be an integer.
    pub fn set_gop_size(mut self, input: std::option::Option<f64>) -> Self {
        self.gop_size = input; self
    }
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    pub fn gop_size_units(mut self, input: crate::types::H265GopSizeUnits) -> Self {
        self.gop_size_units = Some(input);
        self
    }
    /// Indicates if the gopSize is specified in frames or seconds. If seconds the system will convert the gopSize into a frame count at run time.
    pub fn set_gop_size_units(mut self, input: std::option::Option<crate::types::H265GopSizeUnits>) -> Self {
        self.gop_size_units = input; self
    }
    /// H.265 Level.
    pub fn level(mut self, input: crate::types::H265Level) -> Self {
        self.level = Some(input);
        self
    }
    /// H.265 Level.
    pub fn set_level(mut self, input: std::option::Option<crate::types::H265Level>) -> Self {
        self.level = input; self
    }
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    pub fn look_ahead_rate_control(mut self, input: crate::types::H265LookAheadRateControl) -> Self {
        self.look_ahead_rate_control = Some(input);
        self
    }
    /// Amount of lookahead. A value of low can decrease latency and memory usage, while high can produce better quality for certain content.
    pub fn set_look_ahead_rate_control(mut self, input: std::option::Option<crate::types::H265LookAheadRateControl>) -> Self {
        self.look_ahead_rate_control = input; self
    }
    /// For QVBR: See the tooltip for Quality level
    pub fn max_bitrate(mut self, input: i32) -> Self {
        self.max_bitrate = Some(input);
        self
    }
    /// For QVBR: See the tooltip for Quality level
    pub fn set_max_bitrate(mut self, input: std::option::Option<i32>) -> Self {
        self.max_bitrate = input; self
    }
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    pub fn min_i_interval(mut self, input: i32) -> Self {
        self.min_i_interval = Some(input);
        self
    }
    /// Only meaningful if sceneChangeDetect is set to enabled. Defaults to 5 if multiplex rate control is used. Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
    pub fn set_min_i_interval(mut self, input: std::option::Option<i32>) -> Self {
        self.min_i_interval = input; self
    }
    /// Pixel Aspect Ratio denominator.
    pub fn par_denominator(mut self, input: i32) -> Self {
        self.par_denominator = Some(input);
        self
    }
    /// Pixel Aspect Ratio denominator.
    pub fn set_par_denominator(mut self, input: std::option::Option<i32>) -> Self {
        self.par_denominator = input; self
    }
    /// Pixel Aspect Ratio numerator.
    pub fn par_numerator(mut self, input: i32) -> Self {
        self.par_numerator = Some(input);
        self
    }
    /// Pixel Aspect Ratio numerator.
    pub fn set_par_numerator(mut self, input: std::option::Option<i32>) -> Self {
        self.par_numerator = input; self
    }
    /// H.265 Profile.
    pub fn profile(mut self, input: crate::types::H265Profile) -> Self {
        self.profile = Some(input);
        self
    }
    /// H.265 Profile.
    pub fn set_profile(mut self, input: std::option::Option<crate::types::H265Profile>) -> Self {
        self.profile = input; self
    }
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. Set values for the QVBR quality level field and Max bitrate field that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M
    pub fn qvbr_quality_level(mut self, input: i32) -> Self {
        self.qvbr_quality_level = Some(input);
        self
    }
    /// Controls the target quality for the video encode. Applies only when the rate control mode is QVBR. Set values for the QVBR quality level field and Max bitrate field that suit your most important viewing devices. Recommended values are: - Primary screen: Quality level: 8 to 10. Max bitrate: 4M - PC or tablet: Quality level: 7. Max bitrate: 1.5M to 3M - Smartphone: Quality level: 6. Max bitrate: 1M to 1.5M
    pub fn set_qvbr_quality_level(mut self, input: std::option::Option<i32>) -> Self {
        self.qvbr_quality_level = input; self
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    pub fn rate_control_mode(mut self, input: crate::types::H265RateControlMode) -> Self {
        self.rate_control_mode = Some(input);
        self
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates. Multiplex: This rate control mode is only supported (and is required) when the video is being delivered to a MediaLive Multiplex in which case the rate control configuration is controlled by the properties within the Multiplex Program.
    pub fn set_rate_control_mode(mut self, input: std::option::Option<crate::types::H265RateControlMode>) -> Self {
        self.rate_control_mode = input; self
    }
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    pub fn scan_type(mut self, input: crate::types::H265ScanType) -> Self {
        self.scan_type = Some(input);
        self
    }
    /// Sets the scan type of the output to progressive or top-field-first interlaced.
    pub fn set_scan_type(mut self, input: std::option::Option<crate::types::H265ScanType>) -> Self {
        self.scan_type = input; self
    }
    /// Scene change detection.
    pub fn scene_change_detect(mut self, input: crate::types::H265SceneChangeDetect) -> Self {
        self.scene_change_detect = Some(input);
        self
    }
    /// Scene change detection.
    pub fn set_scene_change_detect(mut self, input: std::option::Option<crate::types::H265SceneChangeDetect>) -> Self {
        self.scene_change_detect = input; self
    }
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    pub fn slices(mut self, input: i32) -> Self {
        self.slices = Some(input);
        self
    }
    /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures. This field is optional; when no value is specified the encoder will choose the number of slices based on encode resolution.
    pub fn set_slices(mut self, input: std::option::Option<i32>) -> Self {
        self.slices = input; self
    }
    /// H.265 Tier.
    pub fn tier(mut self, input: crate::types::H265Tier) -> Self {
        self.tier = Some(input);
        self
    }
    /// H.265 Tier.
    pub fn set_tier(mut self, input: std::option::Option<crate::types::H265Tier>) -> Self {
        self.tier = input; self
    }
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    pub fn timecode_insertion(mut self, input: crate::types::H265TimecodeInsertionBehavior) -> Self {
        self.timecode_insertion = Some(input);
        self
    }
    /// Determines how timecodes should be inserted into the video elementary stream. - 'disabled': Do not include timecodes - 'picTimingSei': Pass through picture timing SEI messages from the source specified in Timecode Config
    pub fn set_timecode_insertion(mut self, input: std::option::Option<crate::types::H265TimecodeInsertionBehavior>) -> Self {
        self.timecode_insertion = input; self
    }
    /// Timecode burn-in settings
    pub fn timecode_burnin_settings(mut self, input: crate::types::TimecodeBurninSettings) -> Self {
        self.timecode_burnin_settings = Some(input);
        self
    }
    /// Timecode burn-in settings
    pub fn set_timecode_burnin_settings(mut self, input: std::option::Option<crate::types::TimecodeBurninSettings>) -> Self {
        self.timecode_burnin_settings = input; self
    }
    /// Consumes the builder and constructs a [`H265Settings`](crate::types::H265Settings).
    pub fn build(self) -> crate::types::H265Settings {
        crate::types::H265Settings {
            adaptive_quantization: self.adaptive_quantization
            ,
            afd_signaling: self.afd_signaling
            ,
            alternative_transfer_function: self.alternative_transfer_function
            ,
            bitrate: self.bitrate
                .unwrap_or_default()
            ,
            buf_size: self.buf_size
                .unwrap_or_default()
            ,
            color_metadata: self.color_metadata
            ,
            color_space_settings: self.color_space_settings
            ,
            filter_settings: self.filter_settings
            ,
            fixed_afd: self.fixed_afd
            ,
            flicker_aq: self.flicker_aq
            ,
            framerate_denominator: self.framerate_denominator
                .unwrap_or_default()
            ,
            framerate_numerator: self.framerate_numerator
                .unwrap_or_default()
            ,
            gop_closed_cadence: self.gop_closed_cadence
                .unwrap_or_default()
            ,
            gop_size: self.gop_size
                .unwrap_or_default()
            ,
            gop_size_units: self.gop_size_units
            ,
            level: self.level
            ,
            look_ahead_rate_control: self.look_ahead_rate_control
            ,
            max_bitrate: self.max_bitrate
                .unwrap_or_default()
            ,
            min_i_interval: self.min_i_interval
                .unwrap_or_default()
            ,
            par_denominator: self.par_denominator
                .unwrap_or_default()
            ,
            par_numerator: self.par_numerator
                .unwrap_or_default()
            ,
            profile: self.profile
            ,
            qvbr_quality_level: self.qvbr_quality_level
                .unwrap_or_default()
            ,
            rate_control_mode: self.rate_control_mode
            ,
            scan_type: self.scan_type
            ,
            scene_change_detect: self.scene_change_detect
            ,
            slices: self.slices
                .unwrap_or_default()
            ,
            tier: self.tier
            ,
            timecode_insertion: self.timecode_insertion
            ,
            timecode_burnin_settings: self.timecode_burnin_settings
            ,
        }
    }
}

