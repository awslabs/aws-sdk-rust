// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Av1 Settings
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Av1Settings {
    /// Configures whether MediaLive will write AFD values into the video. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: the AFD value will be the value configured in the fixedAfd parameter. NONE: MediaLive won't write AFD into the video
    pub afd_signaling: ::std::option::Option<crate::types::AfdSignaling>,
    /// The size of the buffer (HRD buffer model) in bits.
    pub buf_size: ::std::option::Option<i32>,
    /// Color Space settings
    pub color_space_settings: ::std::option::Option<crate::types::Av1ColorSpaceSettings>,
    /// Complete this property only if you set the afdSignaling property to FIXED. Choose the AFD value (4 bits) to write on all frames of the video encode.
    pub fixed_afd: ::std::option::Option<crate::types::FixedAfd>,
    /// The denominator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub framerate_denominator: ::std::option::Option<i32>,
    /// The numerator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub framerate_numerator: ::std::option::Option<i32>,
    /// The GOP size (keyframe interval). If GopSizeUnits is frames, GopSize must be a whole number and must be greater than or equal to 1. If GopSizeUnits is seconds, GopSize must be greater than 0, but it can be a decimal.
    pub gop_size: ::std::option::Option<f64>,
    /// Choose the units for the GOP size: FRAMES or SECONDS. For SECONDS, MediaLive converts the size into a frame count at run time.
    pub gop_size_units: ::std::option::Option<crate::types::Av1GopSizeUnits>,
    /// Sets the level. This parameter is one of the properties of the encoding scheme for AV1.
    pub level: ::std::option::Option<crate::types::Av1Level>,
    /// Sets the amount of lookahead. A value of LOW can decrease latency and memory usage. A value of HIGH can produce better quality for certain content.
    pub look_ahead_rate_control: ::std::option::Option<crate::types::Av1LookAheadRateControl>,
    /// The maximum bitrate to assign. For recommendations, see the description for qvbrQualityLevel.
    pub max_bitrate: ::std::option::Option<i32>,
    /// Applies only if you enable SceneChangeDetect. Sets the interval between frames. This property ensures a minimum separation between repeated (cadence) I-frames and any I-frames inserted by scene change detection (SCD frames). Enter a number for the interval, measured in number of frames. If an SCD frame and a cadence frame are closer than the specified number of frames, MediaLive shrinks or stretches the GOP to include the SCD frame. Then normal cadence resumes in the next GOP. For GOP stretch to succeed, you must enable LookAheadRateControl. Note that the maximum GOP stretch = (GOP size) + (Minimum I-interval) - 1
    pub min_i_interval: ::std::option::Option<i32>,
    /// The denominator for the output pixel aspect ratio (PAR).
    pub par_denominator: ::std::option::Option<i32>,
    /// The numerator for the output pixel aspect ratio (PAR).
    pub par_numerator: ::std::option::Option<i32>,
    /// Controls the target quality for the video encode. With QVBR rate control mode, the final quality is the target quality, constrained by the maxBitrate. Set values for the qvbrQualityLevel property and maxBitrate property that suit your most important viewing devices. To let MediaLive set the quality level (AUTO mode), leave the qvbrQualityLevel field empty. In this case, MediaLive uses the maximum bitrate, and the quality follows from that: more complex content might have a lower quality. Or set a target quality level and a maximum bitrate. With more complex content, MediaLive will try to achieve the target quality, but it won't exceed the maximum bitrate. With less complex content, This option will use only the bitrate needed to reach the target quality. Recommended values are: Primary screen: qvbrQualityLevel: Leave empty. maxBitrate: 4,000,000 PC or tablet: qvbrQualityLevel: Leave empty. maxBitrate: 1,500,000 to 3,000,000 Smartphone: qvbrQualityLevel: Leave empty. maxBitrate: 1,000,000 to 1,500,000
    pub qvbr_quality_level: ::std::option::Option<i32>,
    /// Controls whether MediaLive inserts I-frames when it detects a scene change. ENABLED or DISABLED.
    pub scene_change_detect: ::std::option::Option<crate::types::Av1SceneChangeDetect>,
    /// Configures the timecode burn-in feature. If you enable this feature, the timecode will become part of the video.
    pub timecode_burnin_settings: ::std::option::Option<crate::types::TimecodeBurninSettings>,
    /// Average bitrate in bits/second. Required when the rate control mode is CBR. Not used for QVBR.
    pub bitrate: ::std::option::Option<i32>,
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates.
    pub rate_control_mode: ::std::option::Option<crate::types::Av1RateControlMode>,
    /// Used for QVBR rate control mode only. Optional. Enter a minimum bitrate if you want to keep the output bitrate about a threshold, in order to prevent the downstream system from de-allocating network bandwidth for this output.
    pub min_bitrate: ::std::option::Option<i32>,
}
impl Av1Settings {
    /// Configures whether MediaLive will write AFD values into the video. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: the AFD value will be the value configured in the fixedAfd parameter. NONE: MediaLive won't write AFD into the video
    pub fn afd_signaling(&self) -> ::std::option::Option<&crate::types::AfdSignaling> {
        self.afd_signaling.as_ref()
    }
    /// The size of the buffer (HRD buffer model) in bits.
    pub fn buf_size(&self) -> ::std::option::Option<i32> {
        self.buf_size
    }
    /// Color Space settings
    pub fn color_space_settings(&self) -> ::std::option::Option<&crate::types::Av1ColorSpaceSettings> {
        self.color_space_settings.as_ref()
    }
    /// Complete this property only if you set the afdSignaling property to FIXED. Choose the AFD value (4 bits) to write on all frames of the video encode.
    pub fn fixed_afd(&self) -> ::std::option::Option<&crate::types::FixedAfd> {
        self.fixed_afd.as_ref()
    }
    /// The denominator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub fn framerate_denominator(&self) -> ::std::option::Option<i32> {
        self.framerate_denominator
    }
    /// The numerator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub fn framerate_numerator(&self) -> ::std::option::Option<i32> {
        self.framerate_numerator
    }
    /// The GOP size (keyframe interval). If GopSizeUnits is frames, GopSize must be a whole number and must be greater than or equal to 1. If GopSizeUnits is seconds, GopSize must be greater than 0, but it can be a decimal.
    pub fn gop_size(&self) -> ::std::option::Option<f64> {
        self.gop_size
    }
    /// Choose the units for the GOP size: FRAMES or SECONDS. For SECONDS, MediaLive converts the size into a frame count at run time.
    pub fn gop_size_units(&self) -> ::std::option::Option<&crate::types::Av1GopSizeUnits> {
        self.gop_size_units.as_ref()
    }
    /// Sets the level. This parameter is one of the properties of the encoding scheme for AV1.
    pub fn level(&self) -> ::std::option::Option<&crate::types::Av1Level> {
        self.level.as_ref()
    }
    /// Sets the amount of lookahead. A value of LOW can decrease latency and memory usage. A value of HIGH can produce better quality for certain content.
    pub fn look_ahead_rate_control(&self) -> ::std::option::Option<&crate::types::Av1LookAheadRateControl> {
        self.look_ahead_rate_control.as_ref()
    }
    /// The maximum bitrate to assign. For recommendations, see the description for qvbrQualityLevel.
    pub fn max_bitrate(&self) -> ::std::option::Option<i32> {
        self.max_bitrate
    }
    /// Applies only if you enable SceneChangeDetect. Sets the interval between frames. This property ensures a minimum separation between repeated (cadence) I-frames and any I-frames inserted by scene change detection (SCD frames). Enter a number for the interval, measured in number of frames. If an SCD frame and a cadence frame are closer than the specified number of frames, MediaLive shrinks or stretches the GOP to include the SCD frame. Then normal cadence resumes in the next GOP. For GOP stretch to succeed, you must enable LookAheadRateControl. Note that the maximum GOP stretch = (GOP size) + (Minimum I-interval) - 1
    pub fn min_i_interval(&self) -> ::std::option::Option<i32> {
        self.min_i_interval
    }
    /// The denominator for the output pixel aspect ratio (PAR).
    pub fn par_denominator(&self) -> ::std::option::Option<i32> {
        self.par_denominator
    }
    /// The numerator for the output pixel aspect ratio (PAR).
    pub fn par_numerator(&self) -> ::std::option::Option<i32> {
        self.par_numerator
    }
    /// Controls the target quality for the video encode. With QVBR rate control mode, the final quality is the target quality, constrained by the maxBitrate. Set values for the qvbrQualityLevel property and maxBitrate property that suit your most important viewing devices. To let MediaLive set the quality level (AUTO mode), leave the qvbrQualityLevel field empty. In this case, MediaLive uses the maximum bitrate, and the quality follows from that: more complex content might have a lower quality. Or set a target quality level and a maximum bitrate. With more complex content, MediaLive will try to achieve the target quality, but it won't exceed the maximum bitrate. With less complex content, This option will use only the bitrate needed to reach the target quality. Recommended values are: Primary screen: qvbrQualityLevel: Leave empty. maxBitrate: 4,000,000 PC or tablet: qvbrQualityLevel: Leave empty. maxBitrate: 1,500,000 to 3,000,000 Smartphone: qvbrQualityLevel: Leave empty. maxBitrate: 1,000,000 to 1,500,000
    pub fn qvbr_quality_level(&self) -> ::std::option::Option<i32> {
        self.qvbr_quality_level
    }
    /// Controls whether MediaLive inserts I-frames when it detects a scene change. ENABLED or DISABLED.
    pub fn scene_change_detect(&self) -> ::std::option::Option<&crate::types::Av1SceneChangeDetect> {
        self.scene_change_detect.as_ref()
    }
    /// Configures the timecode burn-in feature. If you enable this feature, the timecode will become part of the video.
    pub fn timecode_burnin_settings(&self) -> ::std::option::Option<&crate::types::TimecodeBurninSettings> {
        self.timecode_burnin_settings.as_ref()
    }
    /// Average bitrate in bits/second. Required when the rate control mode is CBR. Not used for QVBR.
    pub fn bitrate(&self) -> ::std::option::Option<i32> {
        self.bitrate
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates.
    pub fn rate_control_mode(&self) -> ::std::option::Option<&crate::types::Av1RateControlMode> {
        self.rate_control_mode.as_ref()
    }
    /// Used for QVBR rate control mode only. Optional. Enter a minimum bitrate if you want to keep the output bitrate about a threshold, in order to prevent the downstream system from de-allocating network bandwidth for this output.
    pub fn min_bitrate(&self) -> ::std::option::Option<i32> {
        self.min_bitrate
    }
}
impl Av1Settings {
    /// Creates a new builder-style object to manufacture [`Av1Settings`](crate::types::Av1Settings).
    pub fn builder() -> crate::types::builders::Av1SettingsBuilder {
        crate::types::builders::Av1SettingsBuilder::default()
    }
}

/// A builder for [`Av1Settings`](crate::types::Av1Settings).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct Av1SettingsBuilder {
    pub(crate) afd_signaling: ::std::option::Option<crate::types::AfdSignaling>,
    pub(crate) buf_size: ::std::option::Option<i32>,
    pub(crate) color_space_settings: ::std::option::Option<crate::types::Av1ColorSpaceSettings>,
    pub(crate) fixed_afd: ::std::option::Option<crate::types::FixedAfd>,
    pub(crate) framerate_denominator: ::std::option::Option<i32>,
    pub(crate) framerate_numerator: ::std::option::Option<i32>,
    pub(crate) gop_size: ::std::option::Option<f64>,
    pub(crate) gop_size_units: ::std::option::Option<crate::types::Av1GopSizeUnits>,
    pub(crate) level: ::std::option::Option<crate::types::Av1Level>,
    pub(crate) look_ahead_rate_control: ::std::option::Option<crate::types::Av1LookAheadRateControl>,
    pub(crate) max_bitrate: ::std::option::Option<i32>,
    pub(crate) min_i_interval: ::std::option::Option<i32>,
    pub(crate) par_denominator: ::std::option::Option<i32>,
    pub(crate) par_numerator: ::std::option::Option<i32>,
    pub(crate) qvbr_quality_level: ::std::option::Option<i32>,
    pub(crate) scene_change_detect: ::std::option::Option<crate::types::Av1SceneChangeDetect>,
    pub(crate) timecode_burnin_settings: ::std::option::Option<crate::types::TimecodeBurninSettings>,
    pub(crate) bitrate: ::std::option::Option<i32>,
    pub(crate) rate_control_mode: ::std::option::Option<crate::types::Av1RateControlMode>,
    pub(crate) min_bitrate: ::std::option::Option<i32>,
}
impl Av1SettingsBuilder {
    /// Configures whether MediaLive will write AFD values into the video. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: the AFD value will be the value configured in the fixedAfd parameter. NONE: MediaLive won't write AFD into the video
    pub fn afd_signaling(mut self, input: crate::types::AfdSignaling) -> Self {
        self.afd_signaling = ::std::option::Option::Some(input);
        self
    }
    /// Configures whether MediaLive will write AFD values into the video. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: the AFD value will be the value configured in the fixedAfd parameter. NONE: MediaLive won't write AFD into the video
    pub fn set_afd_signaling(mut self, input: ::std::option::Option<crate::types::AfdSignaling>) -> Self {
        self.afd_signaling = input;
        self
    }
    /// Configures whether MediaLive will write AFD values into the video. AUTO: MediaLive will try to preserve the input AFD value (in cases where multiple AFD values are valid). FIXED: the AFD value will be the value configured in the fixedAfd parameter. NONE: MediaLive won't write AFD into the video
    pub fn get_afd_signaling(&self) -> &::std::option::Option<crate::types::AfdSignaling> {
        &self.afd_signaling
    }
    /// The size of the buffer (HRD buffer model) in bits.
    pub fn buf_size(mut self, input: i32) -> Self {
        self.buf_size = ::std::option::Option::Some(input);
        self
    }
    /// The size of the buffer (HRD buffer model) in bits.
    pub fn set_buf_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.buf_size = input;
        self
    }
    /// The size of the buffer (HRD buffer model) in bits.
    pub fn get_buf_size(&self) -> &::std::option::Option<i32> {
        &self.buf_size
    }
    /// Color Space settings
    pub fn color_space_settings(mut self, input: crate::types::Av1ColorSpaceSettings) -> Self {
        self.color_space_settings = ::std::option::Option::Some(input);
        self
    }
    /// Color Space settings
    pub fn set_color_space_settings(mut self, input: ::std::option::Option<crate::types::Av1ColorSpaceSettings>) -> Self {
        self.color_space_settings = input;
        self
    }
    /// Color Space settings
    pub fn get_color_space_settings(&self) -> &::std::option::Option<crate::types::Av1ColorSpaceSettings> {
        &self.color_space_settings
    }
    /// Complete this property only if you set the afdSignaling property to FIXED. Choose the AFD value (4 bits) to write on all frames of the video encode.
    pub fn fixed_afd(mut self, input: crate::types::FixedAfd) -> Self {
        self.fixed_afd = ::std::option::Option::Some(input);
        self
    }
    /// Complete this property only if you set the afdSignaling property to FIXED. Choose the AFD value (4 bits) to write on all frames of the video encode.
    pub fn set_fixed_afd(mut self, input: ::std::option::Option<crate::types::FixedAfd>) -> Self {
        self.fixed_afd = input;
        self
    }
    /// Complete this property only if you set the afdSignaling property to FIXED. Choose the AFD value (4 bits) to write on all frames of the video encode.
    pub fn get_fixed_afd(&self) -> &::std::option::Option<crate::types::FixedAfd> {
        &self.fixed_afd
    }
    /// The denominator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    /// This field is required.
    pub fn framerate_denominator(mut self, input: i32) -> Self {
        self.framerate_denominator = ::std::option::Option::Some(input);
        self
    }
    /// The denominator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub fn set_framerate_denominator(mut self, input: ::std::option::Option<i32>) -> Self {
        self.framerate_denominator = input;
        self
    }
    /// The denominator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub fn get_framerate_denominator(&self) -> &::std::option::Option<i32> {
        &self.framerate_denominator
    }
    /// The numerator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    /// This field is required.
    pub fn framerate_numerator(mut self, input: i32) -> Self {
        self.framerate_numerator = ::std::option::Option::Some(input);
        self
    }
    /// The numerator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub fn set_framerate_numerator(mut self, input: ::std::option::Option<i32>) -> Self {
        self.framerate_numerator = input;
        self
    }
    /// The numerator for the framerate. Framerate is a fraction, for example, 24000 / 1001.
    pub fn get_framerate_numerator(&self) -> &::std::option::Option<i32> {
        &self.framerate_numerator
    }
    /// The GOP size (keyframe interval). If GopSizeUnits is frames, GopSize must be a whole number and must be greater than or equal to 1. If GopSizeUnits is seconds, GopSize must be greater than 0, but it can be a decimal.
    pub fn gop_size(mut self, input: f64) -> Self {
        self.gop_size = ::std::option::Option::Some(input);
        self
    }
    /// The GOP size (keyframe interval). If GopSizeUnits is frames, GopSize must be a whole number and must be greater than or equal to 1. If GopSizeUnits is seconds, GopSize must be greater than 0, but it can be a decimal.
    pub fn set_gop_size(mut self, input: ::std::option::Option<f64>) -> Self {
        self.gop_size = input;
        self
    }
    /// The GOP size (keyframe interval). If GopSizeUnits is frames, GopSize must be a whole number and must be greater than or equal to 1. If GopSizeUnits is seconds, GopSize must be greater than 0, but it can be a decimal.
    pub fn get_gop_size(&self) -> &::std::option::Option<f64> {
        &self.gop_size
    }
    /// Choose the units for the GOP size: FRAMES or SECONDS. For SECONDS, MediaLive converts the size into a frame count at run time.
    pub fn gop_size_units(mut self, input: crate::types::Av1GopSizeUnits) -> Self {
        self.gop_size_units = ::std::option::Option::Some(input);
        self
    }
    /// Choose the units for the GOP size: FRAMES or SECONDS. For SECONDS, MediaLive converts the size into a frame count at run time.
    pub fn set_gop_size_units(mut self, input: ::std::option::Option<crate::types::Av1GopSizeUnits>) -> Self {
        self.gop_size_units = input;
        self
    }
    /// Choose the units for the GOP size: FRAMES or SECONDS. For SECONDS, MediaLive converts the size into a frame count at run time.
    pub fn get_gop_size_units(&self) -> &::std::option::Option<crate::types::Av1GopSizeUnits> {
        &self.gop_size_units
    }
    /// Sets the level. This parameter is one of the properties of the encoding scheme for AV1.
    pub fn level(mut self, input: crate::types::Av1Level) -> Self {
        self.level = ::std::option::Option::Some(input);
        self
    }
    /// Sets the level. This parameter is one of the properties of the encoding scheme for AV1.
    pub fn set_level(mut self, input: ::std::option::Option<crate::types::Av1Level>) -> Self {
        self.level = input;
        self
    }
    /// Sets the level. This parameter is one of the properties of the encoding scheme for AV1.
    pub fn get_level(&self) -> &::std::option::Option<crate::types::Av1Level> {
        &self.level
    }
    /// Sets the amount of lookahead. A value of LOW can decrease latency and memory usage. A value of HIGH can produce better quality for certain content.
    pub fn look_ahead_rate_control(mut self, input: crate::types::Av1LookAheadRateControl) -> Self {
        self.look_ahead_rate_control = ::std::option::Option::Some(input);
        self
    }
    /// Sets the amount of lookahead. A value of LOW can decrease latency and memory usage. A value of HIGH can produce better quality for certain content.
    pub fn set_look_ahead_rate_control(mut self, input: ::std::option::Option<crate::types::Av1LookAheadRateControl>) -> Self {
        self.look_ahead_rate_control = input;
        self
    }
    /// Sets the amount of lookahead. A value of LOW can decrease latency and memory usage. A value of HIGH can produce better quality for certain content.
    pub fn get_look_ahead_rate_control(&self) -> &::std::option::Option<crate::types::Av1LookAheadRateControl> {
        &self.look_ahead_rate_control
    }
    /// The maximum bitrate to assign. For recommendations, see the description for qvbrQualityLevel.
    pub fn max_bitrate(mut self, input: i32) -> Self {
        self.max_bitrate = ::std::option::Option::Some(input);
        self
    }
    /// The maximum bitrate to assign. For recommendations, see the description for qvbrQualityLevel.
    pub fn set_max_bitrate(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_bitrate = input;
        self
    }
    /// The maximum bitrate to assign. For recommendations, see the description for qvbrQualityLevel.
    pub fn get_max_bitrate(&self) -> &::std::option::Option<i32> {
        &self.max_bitrate
    }
    /// Applies only if you enable SceneChangeDetect. Sets the interval between frames. This property ensures a minimum separation between repeated (cadence) I-frames and any I-frames inserted by scene change detection (SCD frames). Enter a number for the interval, measured in number of frames. If an SCD frame and a cadence frame are closer than the specified number of frames, MediaLive shrinks or stretches the GOP to include the SCD frame. Then normal cadence resumes in the next GOP. For GOP stretch to succeed, you must enable LookAheadRateControl. Note that the maximum GOP stretch = (GOP size) + (Minimum I-interval) - 1
    pub fn min_i_interval(mut self, input: i32) -> Self {
        self.min_i_interval = ::std::option::Option::Some(input);
        self
    }
    /// Applies only if you enable SceneChangeDetect. Sets the interval between frames. This property ensures a minimum separation between repeated (cadence) I-frames and any I-frames inserted by scene change detection (SCD frames). Enter a number for the interval, measured in number of frames. If an SCD frame and a cadence frame are closer than the specified number of frames, MediaLive shrinks or stretches the GOP to include the SCD frame. Then normal cadence resumes in the next GOP. For GOP stretch to succeed, you must enable LookAheadRateControl. Note that the maximum GOP stretch = (GOP size) + (Minimum I-interval) - 1
    pub fn set_min_i_interval(mut self, input: ::std::option::Option<i32>) -> Self {
        self.min_i_interval = input;
        self
    }
    /// Applies only if you enable SceneChangeDetect. Sets the interval between frames. This property ensures a minimum separation between repeated (cadence) I-frames and any I-frames inserted by scene change detection (SCD frames). Enter a number for the interval, measured in number of frames. If an SCD frame and a cadence frame are closer than the specified number of frames, MediaLive shrinks or stretches the GOP to include the SCD frame. Then normal cadence resumes in the next GOP. For GOP stretch to succeed, you must enable LookAheadRateControl. Note that the maximum GOP stretch = (GOP size) + (Minimum I-interval) - 1
    pub fn get_min_i_interval(&self) -> &::std::option::Option<i32> {
        &self.min_i_interval
    }
    /// The denominator for the output pixel aspect ratio (PAR).
    pub fn par_denominator(mut self, input: i32) -> Self {
        self.par_denominator = ::std::option::Option::Some(input);
        self
    }
    /// The denominator for the output pixel aspect ratio (PAR).
    pub fn set_par_denominator(mut self, input: ::std::option::Option<i32>) -> Self {
        self.par_denominator = input;
        self
    }
    /// The denominator for the output pixel aspect ratio (PAR).
    pub fn get_par_denominator(&self) -> &::std::option::Option<i32> {
        &self.par_denominator
    }
    /// The numerator for the output pixel aspect ratio (PAR).
    pub fn par_numerator(mut self, input: i32) -> Self {
        self.par_numerator = ::std::option::Option::Some(input);
        self
    }
    /// The numerator for the output pixel aspect ratio (PAR).
    pub fn set_par_numerator(mut self, input: ::std::option::Option<i32>) -> Self {
        self.par_numerator = input;
        self
    }
    /// The numerator for the output pixel aspect ratio (PAR).
    pub fn get_par_numerator(&self) -> &::std::option::Option<i32> {
        &self.par_numerator
    }
    /// Controls the target quality for the video encode. With QVBR rate control mode, the final quality is the target quality, constrained by the maxBitrate. Set values for the qvbrQualityLevel property and maxBitrate property that suit your most important viewing devices. To let MediaLive set the quality level (AUTO mode), leave the qvbrQualityLevel field empty. In this case, MediaLive uses the maximum bitrate, and the quality follows from that: more complex content might have a lower quality. Or set a target quality level and a maximum bitrate. With more complex content, MediaLive will try to achieve the target quality, but it won't exceed the maximum bitrate. With less complex content, This option will use only the bitrate needed to reach the target quality. Recommended values are: Primary screen: qvbrQualityLevel: Leave empty. maxBitrate: 4,000,000 PC or tablet: qvbrQualityLevel: Leave empty. maxBitrate: 1,500,000 to 3,000,000 Smartphone: qvbrQualityLevel: Leave empty. maxBitrate: 1,000,000 to 1,500,000
    pub fn qvbr_quality_level(mut self, input: i32) -> Self {
        self.qvbr_quality_level = ::std::option::Option::Some(input);
        self
    }
    /// Controls the target quality for the video encode. With QVBR rate control mode, the final quality is the target quality, constrained by the maxBitrate. Set values for the qvbrQualityLevel property and maxBitrate property that suit your most important viewing devices. To let MediaLive set the quality level (AUTO mode), leave the qvbrQualityLevel field empty. In this case, MediaLive uses the maximum bitrate, and the quality follows from that: more complex content might have a lower quality. Or set a target quality level and a maximum bitrate. With more complex content, MediaLive will try to achieve the target quality, but it won't exceed the maximum bitrate. With less complex content, This option will use only the bitrate needed to reach the target quality. Recommended values are: Primary screen: qvbrQualityLevel: Leave empty. maxBitrate: 4,000,000 PC or tablet: qvbrQualityLevel: Leave empty. maxBitrate: 1,500,000 to 3,000,000 Smartphone: qvbrQualityLevel: Leave empty. maxBitrate: 1,000,000 to 1,500,000
    pub fn set_qvbr_quality_level(mut self, input: ::std::option::Option<i32>) -> Self {
        self.qvbr_quality_level = input;
        self
    }
    /// Controls the target quality for the video encode. With QVBR rate control mode, the final quality is the target quality, constrained by the maxBitrate. Set values for the qvbrQualityLevel property and maxBitrate property that suit your most important viewing devices. To let MediaLive set the quality level (AUTO mode), leave the qvbrQualityLevel field empty. In this case, MediaLive uses the maximum bitrate, and the quality follows from that: more complex content might have a lower quality. Or set a target quality level and a maximum bitrate. With more complex content, MediaLive will try to achieve the target quality, but it won't exceed the maximum bitrate. With less complex content, This option will use only the bitrate needed to reach the target quality. Recommended values are: Primary screen: qvbrQualityLevel: Leave empty. maxBitrate: 4,000,000 PC or tablet: qvbrQualityLevel: Leave empty. maxBitrate: 1,500,000 to 3,000,000 Smartphone: qvbrQualityLevel: Leave empty. maxBitrate: 1,000,000 to 1,500,000
    pub fn get_qvbr_quality_level(&self) -> &::std::option::Option<i32> {
        &self.qvbr_quality_level
    }
    /// Controls whether MediaLive inserts I-frames when it detects a scene change. ENABLED or DISABLED.
    pub fn scene_change_detect(mut self, input: crate::types::Av1SceneChangeDetect) -> Self {
        self.scene_change_detect = ::std::option::Option::Some(input);
        self
    }
    /// Controls whether MediaLive inserts I-frames when it detects a scene change. ENABLED or DISABLED.
    pub fn set_scene_change_detect(mut self, input: ::std::option::Option<crate::types::Av1SceneChangeDetect>) -> Self {
        self.scene_change_detect = input;
        self
    }
    /// Controls whether MediaLive inserts I-frames when it detects a scene change. ENABLED or DISABLED.
    pub fn get_scene_change_detect(&self) -> &::std::option::Option<crate::types::Av1SceneChangeDetect> {
        &self.scene_change_detect
    }
    /// Configures the timecode burn-in feature. If you enable this feature, the timecode will become part of the video.
    pub fn timecode_burnin_settings(mut self, input: crate::types::TimecodeBurninSettings) -> Self {
        self.timecode_burnin_settings = ::std::option::Option::Some(input);
        self
    }
    /// Configures the timecode burn-in feature. If you enable this feature, the timecode will become part of the video.
    pub fn set_timecode_burnin_settings(mut self, input: ::std::option::Option<crate::types::TimecodeBurninSettings>) -> Self {
        self.timecode_burnin_settings = input;
        self
    }
    /// Configures the timecode burn-in feature. If you enable this feature, the timecode will become part of the video.
    pub fn get_timecode_burnin_settings(&self) -> &::std::option::Option<crate::types::TimecodeBurninSettings> {
        &self.timecode_burnin_settings
    }
    /// Average bitrate in bits/second. Required when the rate control mode is CBR. Not used for QVBR.
    pub fn bitrate(mut self, input: i32) -> Self {
        self.bitrate = ::std::option::Option::Some(input);
        self
    }
    /// Average bitrate in bits/second. Required when the rate control mode is CBR. Not used for QVBR.
    pub fn set_bitrate(mut self, input: ::std::option::Option<i32>) -> Self {
        self.bitrate = input;
        self
    }
    /// Average bitrate in bits/second. Required when the rate control mode is CBR. Not used for QVBR.
    pub fn get_bitrate(&self) -> &::std::option::Option<i32> {
        &self.bitrate
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates.
    pub fn rate_control_mode(mut self, input: crate::types::Av1RateControlMode) -> Self {
        self.rate_control_mode = ::std::option::Option::Some(input);
        self
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates.
    pub fn set_rate_control_mode(mut self, input: ::std::option::Option<crate::types::Av1RateControlMode>) -> Self {
        self.rate_control_mode = input;
        self
    }
    /// Rate control mode. QVBR: Quality will match the specified quality level except when it is constrained by the maximum bitrate. Recommended if you or your viewers pay for bandwidth. CBR: Quality varies, depending on the video complexity. Recommended only if you distribute your assets to devices that cannot handle variable bitrates.
    pub fn get_rate_control_mode(&self) -> &::std::option::Option<crate::types::Av1RateControlMode> {
        &self.rate_control_mode
    }
    /// Used for QVBR rate control mode only. Optional. Enter a minimum bitrate if you want to keep the output bitrate about a threshold, in order to prevent the downstream system from de-allocating network bandwidth for this output.
    pub fn min_bitrate(mut self, input: i32) -> Self {
        self.min_bitrate = ::std::option::Option::Some(input);
        self
    }
    /// Used for QVBR rate control mode only. Optional. Enter a minimum bitrate if you want to keep the output bitrate about a threshold, in order to prevent the downstream system from de-allocating network bandwidth for this output.
    pub fn set_min_bitrate(mut self, input: ::std::option::Option<i32>) -> Self {
        self.min_bitrate = input;
        self
    }
    /// Used for QVBR rate control mode only. Optional. Enter a minimum bitrate if you want to keep the output bitrate about a threshold, in order to prevent the downstream system from de-allocating network bandwidth for this output.
    pub fn get_min_bitrate(&self) -> &::std::option::Option<i32> {
        &self.min_bitrate
    }
    /// Consumes the builder and constructs a [`Av1Settings`](crate::types::Av1Settings).
    pub fn build(self) -> crate::types::Av1Settings {
        crate::types::Av1Settings {
            afd_signaling: self.afd_signaling,
            buf_size: self.buf_size,
            color_space_settings: self.color_space_settings,
            fixed_afd: self.fixed_afd,
            framerate_denominator: self.framerate_denominator,
            framerate_numerator: self.framerate_numerator,
            gop_size: self.gop_size,
            gop_size_units: self.gop_size_units,
            level: self.level,
            look_ahead_rate_control: self.look_ahead_rate_control,
            max_bitrate: self.max_bitrate,
            min_i_interval: self.min_i_interval,
            par_denominator: self.par_denominator,
            par_numerator: self.par_numerator,
            qvbr_quality_level: self.qvbr_quality_level,
            scene_change_detect: self.scene_change_detect,
            timecode_burnin_settings: self.timecode_burnin_settings,
            bitrate: self.bitrate,
            rate_control_mode: self.rate_control_mode,
            min_bitrate: self.min_bitrate,
        }
    }
}
