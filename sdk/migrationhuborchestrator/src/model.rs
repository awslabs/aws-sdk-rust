// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The summary of a step group in a workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowStepGroupSummary {
    /// <p>The ID of the step group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the step group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The owner of the step group.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<crate::model::Owner>,
    /// <p>The status of the step group.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StepGroupStatus>,
    /// <p>The previous step group.</p>
    #[doc(hidden)]
    pub previous: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The next step group.</p>
    #[doc(hidden)]
    pub next: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl WorkflowStepGroupSummary {
    /// <p>The ID of the step group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the step group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The owner of the step group.</p>
    pub fn owner(&self) -> std::option::Option<&crate::model::Owner> {
        self.owner.as_ref()
    }
    /// <p>The status of the step group.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StepGroupStatus> {
        self.status.as_ref()
    }
    /// <p>The previous step group.</p>
    pub fn previous(&self) -> std::option::Option<&[std::string::String]> {
        self.previous.as_deref()
    }
    /// <p>The next step group.</p>
    pub fn next(&self) -> std::option::Option<&[std::string::String]> {
        self.next.as_deref()
    }
}
impl WorkflowStepGroupSummary {
    /// Creates a new builder-style object to manufacture [`WorkflowStepGroupSummary`](crate::model::WorkflowStepGroupSummary).
    pub fn builder() -> crate::model::workflow_step_group_summary::Builder {
        crate::model::workflow_step_group_summary::Builder::default()
    }
}

/// See [`WorkflowStepGroupSummary`](crate::model::WorkflowStepGroupSummary).
pub mod workflow_step_group_summary {

    /// A builder for [`WorkflowStepGroupSummary`](crate::model::WorkflowStepGroupSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<crate::model::Owner>,
        pub(crate) status: std::option::Option<crate::model::StepGroupStatus>,
        pub(crate) previous: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the step group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the step group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the step group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the step group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The owner of the step group.</p>
        pub fn owner(mut self, input: crate::model::Owner) -> Self {
            self.owner = Some(input);
            self
        }
        /// <p>The owner of the step group.</p>
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Owner>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The status of the step group.</p>
        pub fn status(mut self, input: crate::model::StepGroupStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the step group.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::StepGroupStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `previous`.
        ///
        /// To override the contents of this collection use [`set_previous`](Self::set_previous).
        ///
        /// <p>The previous step group.</p>
        pub fn previous(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.previous.unwrap_or_default();
            v.push(input.into());
            self.previous = Some(v);
            self
        }
        /// <p>The previous step group.</p>
        pub fn set_previous(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.previous = input;
            self
        }
        /// Appends an item to `next`.
        ///
        /// To override the contents of this collection use [`set_next`](Self::set_next).
        ///
        /// <p>The next step group.</p>
        pub fn next(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.next.unwrap_or_default();
            v.push(input.into());
            self.next = Some(v);
            self
        }
        /// <p>The next step group.</p>
        pub fn set_next(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.next = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowStepGroupSummary`](crate::model::WorkflowStepGroupSummary).
        pub fn build(self) -> crate::model::WorkflowStepGroupSummary {
            crate::model::WorkflowStepGroupSummary {
                id: self.id,
                name: self.name,
                owner: self.owner,
                status: self.status,
                previous: self.previous,
                next: self.next,
            }
        }
    }
}

/// When writing a match expression against `StepGroupStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stepgroupstatus = unimplemented!();
/// match stepgroupstatus {
///     StepGroupStatus::AwaitingDependencies => { /* ... */ },
///     StepGroupStatus::Completed => { /* ... */ },
///     StepGroupStatus::Failed => { /* ... */ },
///     StepGroupStatus::InProgress => { /* ... */ },
///     StepGroupStatus::Paused => { /* ... */ },
///     StepGroupStatus::Pausing => { /* ... */ },
///     StepGroupStatus::Ready => { /* ... */ },
///     StepGroupStatus::UserAttentionRequired => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stepgroupstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StepGroupStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StepGroupStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StepGroupStatus::NewFeature` is defined.
/// Specifically, when `stepgroupstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StepGroupStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StepGroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    AwaitingDependencies,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    #[allow(missing_docs)] // documentation missing in model
    Pausing,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UserAttentionRequired,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StepGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "AWAITING_DEPENDENCIES" => StepGroupStatus::AwaitingDependencies,
            "COMPLETED" => StepGroupStatus::Completed,
            "FAILED" => StepGroupStatus::Failed,
            "IN_PROGRESS" => StepGroupStatus::InProgress,
            "PAUSED" => StepGroupStatus::Paused,
            "PAUSING" => StepGroupStatus::Pausing,
            "READY" => StepGroupStatus::Ready,
            "USER_ATTENTION_REQUIRED" => StepGroupStatus::UserAttentionRequired,
            other => StepGroupStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StepGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StepGroupStatus::from(s))
    }
}
impl StepGroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StepGroupStatus::AwaitingDependencies => "AWAITING_DEPENDENCIES",
            StepGroupStatus::Completed => "COMPLETED",
            StepGroupStatus::Failed => "FAILED",
            StepGroupStatus::InProgress => "IN_PROGRESS",
            StepGroupStatus::Paused => "PAUSED",
            StepGroupStatus::Pausing => "PAUSING",
            StepGroupStatus::Ready => "READY",
            StepGroupStatus::UserAttentionRequired => "USER_ATTENTION_REQUIRED",
            StepGroupStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWAITING_DEPENDENCIES",
            "COMPLETED",
            "FAILED",
            "IN_PROGRESS",
            "PAUSED",
            "PAUSING",
            "READY",
            "USER_ATTENTION_REQUIRED",
        ]
    }
}
impl AsRef<str> for StepGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Owner`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let owner = unimplemented!();
/// match owner {
///     Owner::AwsManaged => { /* ... */ },
///     Owner::Custom => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `owner` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Owner::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Owner::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Owner::NewFeature` is defined.
/// Specifically, when `owner` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Owner::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Owner {
    #[allow(missing_docs)] // documentation missing in model
    AwsManaged,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Owner {
    fn from(s: &str) -> Self {
        match s {
            "AWS_MANAGED" => Owner::AwsManaged,
            "CUSTOM" => Owner::Custom,
            other => Owner::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Owner {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Owner::from(s))
    }
}
impl Owner {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Owner::AwsManaged => "AWS_MANAGED",
            Owner::Custom => "CUSTOM",
            Owner::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_MANAGED", "CUSTOM"]
    }
}
impl AsRef<str> for Owner {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>List of AWS services utilized in a migration workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tool {
    /// <p>The name of an AWS service. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The URL of an AWS service.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
}
impl Tool {
    /// <p>The name of an AWS service. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The URL of an AWS service.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl Tool {
    /// Creates a new builder-style object to manufacture [`Tool`](crate::model::Tool).
    pub fn builder() -> crate::model::tool::Builder {
        crate::model::tool::Builder::default()
    }
}

/// See [`Tool`](crate::model::Tool).
pub mod tool {

    /// A builder for [`Tool`](crate::model::Tool).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an AWS service. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of an AWS service. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The URL of an AWS service.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL of an AWS service.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`Tool`](crate::model::Tool).
        pub fn build(self) -> crate::model::Tool {
            crate::model::Tool {
                name: self.name,
                url: self.url,
            }
        }
    }
}

/// When writing a match expression against `StepStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stepstatus = unimplemented!();
/// match stepstatus {
///     StepStatus::AwaitingDependencies => { /* ... */ },
///     StepStatus::Completed => { /* ... */ },
///     StepStatus::Failed => { /* ... */ },
///     StepStatus::InProgress => { /* ... */ },
///     StepStatus::Paused => { /* ... */ },
///     StepStatus::Ready => { /* ... */ },
///     StepStatus::UserAttentionRequired => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stepstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StepStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StepStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StepStatus::NewFeature` is defined.
/// Specifically, when `stepstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StepStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StepStatus {
    #[allow(missing_docs)] // documentation missing in model
    AwaitingDependencies,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UserAttentionRequired,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StepStatus {
    fn from(s: &str) -> Self {
        match s {
            "AWAITING_DEPENDENCIES" => StepStatus::AwaitingDependencies,
            "COMPLETED" => StepStatus::Completed,
            "FAILED" => StepStatus::Failed,
            "IN_PROGRESS" => StepStatus::InProgress,
            "PAUSED" => StepStatus::Paused,
            "READY" => StepStatus::Ready,
            "USER_ATTENTION_REQUIRED" => StepStatus::UserAttentionRequired,
            other => StepStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StepStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StepStatus::from(s))
    }
}
impl StepStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StepStatus::AwaitingDependencies => "AWAITING_DEPENDENCIES",
            StepStatus::Completed => "COMPLETED",
            StepStatus::Failed => "FAILED",
            StepStatus::InProgress => "IN_PROGRESS",
            StepStatus::Paused => "PAUSED",
            StepStatus::Ready => "READY",
            StepStatus::UserAttentionRequired => "USER_ATTENTION_REQUIRED",
            StepStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWAITING_DEPENDENCIES",
            "COMPLETED",
            "FAILED",
            "IN_PROGRESS",
            "PAUSED",
            "READY",
            "USER_ATTENTION_REQUIRED",
        ]
    }
}
impl AsRef<str> for StepStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of the step in a migration workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowStepSummary {
    /// <p>The ID of the step.</p>
    #[doc(hidden)]
    pub step_id: std::option::Option<std::string::String>,
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
    #[doc(hidden)]
    pub step_action_type: std::option::Option<crate::model::StepActionType>,
    /// <p>The owner of the step.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<crate::model::Owner>,
    /// <p>The previous step.</p>
    #[doc(hidden)]
    pub previous: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The next step.</p>
    #[doc(hidden)]
    pub next: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The status of the step.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StepStatus>,
    /// <p>The status message of the migration workflow.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The number of servers that have been migrated.</p>
    #[doc(hidden)]
    pub no_of_srv_completed: std::option::Option<i32>,
    /// <p>The number of servers that have failed to migrate.</p>
    #[doc(hidden)]
    pub no_of_srv_failed: std::option::Option<i32>,
    /// <p>The total number of servers that have been migrated.</p>
    #[doc(hidden)]
    pub total_no_of_srv: std::option::Option<i32>,
    /// <p>The description of the step.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The location of the script.</p>
    #[doc(hidden)]
    pub script_location: std::option::Option<std::string::String>,
}
impl WorkflowStepSummary {
    /// <p>The ID of the step.</p>
    pub fn step_id(&self) -> std::option::Option<&str> {
        self.step_id.as_deref()
    }
    /// <p>The name of the step.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
    pub fn step_action_type(&self) -> std::option::Option<&crate::model::StepActionType> {
        self.step_action_type.as_ref()
    }
    /// <p>The owner of the step.</p>
    pub fn owner(&self) -> std::option::Option<&crate::model::Owner> {
        self.owner.as_ref()
    }
    /// <p>The previous step.</p>
    pub fn previous(&self) -> std::option::Option<&[std::string::String]> {
        self.previous.as_deref()
    }
    /// <p>The next step.</p>
    pub fn next(&self) -> std::option::Option<&[std::string::String]> {
        self.next.as_deref()
    }
    /// <p>The status of the step.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StepStatus> {
        self.status.as_ref()
    }
    /// <p>The status message of the migration workflow.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The number of servers that have been migrated.</p>
    pub fn no_of_srv_completed(&self) -> std::option::Option<i32> {
        self.no_of_srv_completed
    }
    /// <p>The number of servers that have failed to migrate.</p>
    pub fn no_of_srv_failed(&self) -> std::option::Option<i32> {
        self.no_of_srv_failed
    }
    /// <p>The total number of servers that have been migrated.</p>
    pub fn total_no_of_srv(&self) -> std::option::Option<i32> {
        self.total_no_of_srv
    }
    /// <p>The description of the step.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The location of the script.</p>
    pub fn script_location(&self) -> std::option::Option<&str> {
        self.script_location.as_deref()
    }
}
impl WorkflowStepSummary {
    /// Creates a new builder-style object to manufacture [`WorkflowStepSummary`](crate::model::WorkflowStepSummary).
    pub fn builder() -> crate::model::workflow_step_summary::Builder {
        crate::model::workflow_step_summary::Builder::default()
    }
}

/// See [`WorkflowStepSummary`](crate::model::WorkflowStepSummary).
pub mod workflow_step_summary {

    /// A builder for [`WorkflowStepSummary`](crate::model::WorkflowStepSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) step_action_type: std::option::Option<crate::model::StepActionType>,
        pub(crate) owner: std::option::Option<crate::model::Owner>,
        pub(crate) previous: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<crate::model::StepStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) no_of_srv_completed: std::option::Option<i32>,
        pub(crate) no_of_srv_failed: std::option::Option<i32>,
        pub(crate) total_no_of_srv: std::option::Option<i32>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) script_location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the step.</p>
        pub fn step_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_id = Some(input.into());
            self
        }
        /// <p>The ID of the step.</p>
        pub fn set_step_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_id = input;
            self
        }
        /// <p>The name of the step.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
        pub fn step_action_type(mut self, input: crate::model::StepActionType) -> Self {
            self.step_action_type = Some(input);
            self
        }
        /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
        pub fn set_step_action_type(
            mut self,
            input: std::option::Option<crate::model::StepActionType>,
        ) -> Self {
            self.step_action_type = input;
            self
        }
        /// <p>The owner of the step.</p>
        pub fn owner(mut self, input: crate::model::Owner) -> Self {
            self.owner = Some(input);
            self
        }
        /// <p>The owner of the step.</p>
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Owner>) -> Self {
            self.owner = input;
            self
        }
        /// Appends an item to `previous`.
        ///
        /// To override the contents of this collection use [`set_previous`](Self::set_previous).
        ///
        /// <p>The previous step.</p>
        pub fn previous(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.previous.unwrap_or_default();
            v.push(input.into());
            self.previous = Some(v);
            self
        }
        /// <p>The previous step.</p>
        pub fn set_previous(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.previous = input;
            self
        }
        /// Appends an item to `next`.
        ///
        /// To override the contents of this collection use [`set_next`](Self::set_next).
        ///
        /// <p>The next step.</p>
        pub fn next(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.next.unwrap_or_default();
            v.push(input.into());
            self.next = Some(v);
            self
        }
        /// <p>The next step.</p>
        pub fn set_next(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.next = input;
            self
        }
        /// <p>The status of the step.</p>
        pub fn status(mut self, input: crate::model::StepStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the step.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::StepStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message of the migration workflow.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message of the migration workflow.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The number of servers that have been migrated.</p>
        pub fn no_of_srv_completed(mut self, input: i32) -> Self {
            self.no_of_srv_completed = Some(input);
            self
        }
        /// <p>The number of servers that have been migrated.</p>
        pub fn set_no_of_srv_completed(mut self, input: std::option::Option<i32>) -> Self {
            self.no_of_srv_completed = input;
            self
        }
        /// <p>The number of servers that have failed to migrate.</p>
        pub fn no_of_srv_failed(mut self, input: i32) -> Self {
            self.no_of_srv_failed = Some(input);
            self
        }
        /// <p>The number of servers that have failed to migrate.</p>
        pub fn set_no_of_srv_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.no_of_srv_failed = input;
            self
        }
        /// <p>The total number of servers that have been migrated.</p>
        pub fn total_no_of_srv(mut self, input: i32) -> Self {
            self.total_no_of_srv = Some(input);
            self
        }
        /// <p>The total number of servers that have been migrated.</p>
        pub fn set_total_no_of_srv(mut self, input: std::option::Option<i32>) -> Self {
            self.total_no_of_srv = input;
            self
        }
        /// <p>The description of the step.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the step.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The location of the script.</p>
        pub fn script_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.script_location = Some(input.into());
            self
        }
        /// <p>The location of the script.</p>
        pub fn set_script_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.script_location = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowStepSummary`](crate::model::WorkflowStepSummary).
        pub fn build(self) -> crate::model::WorkflowStepSummary {
            crate::model::WorkflowStepSummary {
                step_id: self.step_id,
                name: self.name,
                step_action_type: self.step_action_type,
                owner: self.owner,
                previous: self.previous,
                next: self.next,
                status: self.status,
                status_message: self.status_message,
                no_of_srv_completed: self.no_of_srv_completed,
                no_of_srv_failed: self.no_of_srv_failed,
                total_no_of_srv: self.total_no_of_srv,
                description: self.description,
                script_location: self.script_location,
            }
        }
    }
}

/// When writing a match expression against `StepActionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stepactiontype = unimplemented!();
/// match stepactiontype {
///     StepActionType::Automated => { /* ... */ },
///     StepActionType::Manual => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stepactiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StepActionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StepActionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StepActionType::NewFeature` is defined.
/// Specifically, when `stepactiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StepActionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StepActionType {
    #[allow(missing_docs)] // documentation missing in model
    Automated,
    #[allow(missing_docs)] // documentation missing in model
    Manual,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StepActionType {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATED" => StepActionType::Automated,
            "MANUAL" => StepActionType::Manual,
            other => StepActionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StepActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StepActionType::from(s))
    }
}
impl StepActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StepActionType::Automated => "AUTOMATED",
            StepActionType::Manual => "MANUAL",
            StepActionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTOMATED", "MANUAL"]
    }
}
impl AsRef<str> for StepActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The output of a step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowStepOutput {
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the output.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>Determine if an output is required from a step.</p>
    #[doc(hidden)]
    pub required: std::option::Option<bool>,
    /// <p>The value of the output.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::WorkflowStepOutputUnion>,
}
impl WorkflowStepOutput {
    /// <p>The name of the step.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the output.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>Determine if an output is required from a step.</p>
    pub fn required(&self) -> std::option::Option<bool> {
        self.required
    }
    /// <p>The value of the output.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::WorkflowStepOutputUnion> {
        self.value.as_ref()
    }
}
impl WorkflowStepOutput {
    /// Creates a new builder-style object to manufacture [`WorkflowStepOutput`](crate::model::WorkflowStepOutput).
    pub fn builder() -> crate::model::workflow_step_output::Builder {
        crate::model::workflow_step_output::Builder::default()
    }
}

/// See [`WorkflowStepOutput`](crate::model::WorkflowStepOutput).
pub mod workflow_step_output {

    /// A builder for [`WorkflowStepOutput`](crate::model::WorkflowStepOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) required: std::option::Option<bool>,
        pub(crate) value: std::option::Option<crate::model::WorkflowStepOutputUnion>,
    }
    impl Builder {
        /// <p>The name of the step.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the output.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the output.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>Determine if an output is required from a step.</p>
        pub fn required(mut self, input: bool) -> Self {
            self.required = Some(input);
            self
        }
        /// <p>Determine if an output is required from a step.</p>
        pub fn set_required(mut self, input: std::option::Option<bool>) -> Self {
            self.required = input;
            self
        }
        /// <p>The value of the output.</p>
        pub fn value(mut self, input: crate::model::WorkflowStepOutputUnion) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the output.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::WorkflowStepOutputUnion>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowStepOutput`](crate::model::WorkflowStepOutput).
        pub fn build(self) -> crate::model::WorkflowStepOutput {
            crate::model::WorkflowStepOutput {
                name: self.name,
                data_type: self.data_type,
                required: self.required,
                value: self.value,
            }
        }
    }
}

/// <p>A structure to hold multiple values of an output.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum WorkflowStepOutputUnion {
    /// <p>The integer value. </p>
    IntegerValue(i32),
    /// <p>The list of string value.</p>
    ListOfStringValue(std::vec::Vec<std::string::String>),
    /// <p>The string value.</p>
    StringValue(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl WorkflowStepOutputUnion {
    /// Tries to convert the enum instance into [`IntegerValue`](crate::model::WorkflowStepOutputUnion::IntegerValue), extracting the inner [`i32`](i32).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_integer_value(&self) -> std::result::Result<&i32, &Self> {
        if let WorkflowStepOutputUnion::IntegerValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`IntegerValue`](crate::model::WorkflowStepOutputUnion::IntegerValue).
    pub fn is_integer_value(&self) -> bool {
        self.as_integer_value().is_ok()
    }
    /// Tries to convert the enum instance into [`ListOfStringValue`](crate::model::WorkflowStepOutputUnion::ListOfStringValue), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_list_of_string_value(
        &self,
    ) -> std::result::Result<&std::vec::Vec<std::string::String>, &Self> {
        if let WorkflowStepOutputUnion::ListOfStringValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ListOfStringValue`](crate::model::WorkflowStepOutputUnion::ListOfStringValue).
    pub fn is_list_of_string_value(&self) -> bool {
        self.as_list_of_string_value().is_ok()
    }
    /// Tries to convert the enum instance into [`StringValue`](crate::model::WorkflowStepOutputUnion::StringValue), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string_value(&self) -> std::result::Result<&std::string::String, &Self> {
        if let WorkflowStepOutputUnion::StringValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`StringValue`](crate::model::WorkflowStepOutputUnion::StringValue).
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `DataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datatype = unimplemented!();
/// match datatype {
///     DataType::Integer => { /* ... */ },
///     DataType::String => { /* ... */ },
///     DataType::Stringlist => { /* ... */ },
///     DataType::Stringmap => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataType::NewFeature` is defined.
/// Specifically, when `datatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataType {
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Stringlist,
    #[allow(missing_docs)] // documentation missing in model
    Stringmap,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataType {
    fn from(s: &str) -> Self {
        match s {
            "INTEGER" => DataType::Integer,
            "STRING" => DataType::String,
            "STRINGLIST" => DataType::Stringlist,
            "STRINGMAP" => DataType::Stringmap,
            other => DataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataType::from(s))
    }
}
impl DataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataType::Integer => "INTEGER",
            DataType::String => "STRING",
            DataType::Stringlist => "STRINGLIST",
            DataType::Stringmap => "STRINGMAP",
            DataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTEGER", "STRING", "STRINGLIST", "STRINGMAP"]
    }
}
impl AsRef<str> for DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The custom script to run tests on source or target environments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowStepAutomationConfiguration {
    /// <p>The Amazon S3 bucket where the script is located.</p>
    #[doc(hidden)]
    pub script_location_s3_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 key for the script location.</p>
    #[doc(hidden)]
    pub script_location_s3_key: std::option::Option<crate::model::PlatformScriptKey>,
    /// <p>The command required to run the script.</p>
    #[doc(hidden)]
    pub command: std::option::Option<crate::model::PlatformCommand>,
    /// <p>The source or target environment.</p>
    #[doc(hidden)]
    pub run_environment: std::option::Option<crate::model::RunEnvironment>,
    /// <p>The servers on which to run the script.</p>
    #[doc(hidden)]
    pub target_type: std::option::Option<crate::model::TargetType>,
}
impl WorkflowStepAutomationConfiguration {
    /// <p>The Amazon S3 bucket where the script is located.</p>
    pub fn script_location_s3_bucket(&self) -> std::option::Option<&str> {
        self.script_location_s3_bucket.as_deref()
    }
    /// <p>The Amazon S3 key for the script location.</p>
    pub fn script_location_s3_key(&self) -> std::option::Option<&crate::model::PlatformScriptKey> {
        self.script_location_s3_key.as_ref()
    }
    /// <p>The command required to run the script.</p>
    pub fn command(&self) -> std::option::Option<&crate::model::PlatformCommand> {
        self.command.as_ref()
    }
    /// <p>The source or target environment.</p>
    pub fn run_environment(&self) -> std::option::Option<&crate::model::RunEnvironment> {
        self.run_environment.as_ref()
    }
    /// <p>The servers on which to run the script.</p>
    pub fn target_type(&self) -> std::option::Option<&crate::model::TargetType> {
        self.target_type.as_ref()
    }
}
impl WorkflowStepAutomationConfiguration {
    /// Creates a new builder-style object to manufacture [`WorkflowStepAutomationConfiguration`](crate::model::WorkflowStepAutomationConfiguration).
    pub fn builder() -> crate::model::workflow_step_automation_configuration::Builder {
        crate::model::workflow_step_automation_configuration::Builder::default()
    }
}

/// See [`WorkflowStepAutomationConfiguration`](crate::model::WorkflowStepAutomationConfiguration).
pub mod workflow_step_automation_configuration {

    /// A builder for [`WorkflowStepAutomationConfiguration`](crate::model::WorkflowStepAutomationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) script_location_s3_bucket: std::option::Option<std::string::String>,
        pub(crate) script_location_s3_key: std::option::Option<crate::model::PlatformScriptKey>,
        pub(crate) command: std::option::Option<crate::model::PlatformCommand>,
        pub(crate) run_environment: std::option::Option<crate::model::RunEnvironment>,
        pub(crate) target_type: std::option::Option<crate::model::TargetType>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket where the script is located.</p>
        pub fn script_location_s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.script_location_s3_bucket = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket where the script is located.</p>
        pub fn set_script_location_s3_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.script_location_s3_bucket = input;
            self
        }
        /// <p>The Amazon S3 key for the script location.</p>
        pub fn script_location_s3_key(mut self, input: crate::model::PlatformScriptKey) -> Self {
            self.script_location_s3_key = Some(input);
            self
        }
        /// <p>The Amazon S3 key for the script location.</p>
        pub fn set_script_location_s3_key(
            mut self,
            input: std::option::Option<crate::model::PlatformScriptKey>,
        ) -> Self {
            self.script_location_s3_key = input;
            self
        }
        /// <p>The command required to run the script.</p>
        pub fn command(mut self, input: crate::model::PlatformCommand) -> Self {
            self.command = Some(input);
            self
        }
        /// <p>The command required to run the script.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<crate::model::PlatformCommand>,
        ) -> Self {
            self.command = input;
            self
        }
        /// <p>The source or target environment.</p>
        pub fn run_environment(mut self, input: crate::model::RunEnvironment) -> Self {
            self.run_environment = Some(input);
            self
        }
        /// <p>The source or target environment.</p>
        pub fn set_run_environment(
            mut self,
            input: std::option::Option<crate::model::RunEnvironment>,
        ) -> Self {
            self.run_environment = input;
            self
        }
        /// <p>The servers on which to run the script.</p>
        pub fn target_type(mut self, input: crate::model::TargetType) -> Self {
            self.target_type = Some(input);
            self
        }
        /// <p>The servers on which to run the script.</p>
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::TargetType>,
        ) -> Self {
            self.target_type = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowStepAutomationConfiguration`](crate::model::WorkflowStepAutomationConfiguration).
        pub fn build(self) -> crate::model::WorkflowStepAutomationConfiguration {
            crate::model::WorkflowStepAutomationConfiguration {
                script_location_s3_bucket: self.script_location_s3_bucket,
                script_location_s3_key: self.script_location_s3_key,
                command: self.command,
                run_environment: self.run_environment,
                target_type: self.target_type,
            }
        }
    }
}

/// When writing a match expression against `TargetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targettype = unimplemented!();
/// match targettype {
///     TargetType::All => { /* ... */ },
///     TargetType::None => { /* ... */ },
///     TargetType::Single => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetType::NewFeature` is defined.
/// Specifically, when `targettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Single,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => TargetType::All,
            "NONE" => TargetType::None,
            "SINGLE" => TargetType::Single,
            other => TargetType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TargetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetType::from(s))
    }
}
impl TargetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetType::All => "ALL",
            TargetType::None => "NONE",
            TargetType::Single => "SINGLE",
            TargetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "NONE", "SINGLE"]
    }
}
impl AsRef<str> for TargetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RunEnvironment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runenvironment = unimplemented!();
/// match runenvironment {
///     RunEnvironment::Aws => { /* ... */ },
///     RunEnvironment::Onpremise => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runenvironment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RunEnvironment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RunEnvironment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RunEnvironment::NewFeature` is defined.
/// Specifically, when `runenvironment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RunEnvironment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RunEnvironment {
    #[allow(missing_docs)] // documentation missing in model
    Aws,
    #[allow(missing_docs)] // documentation missing in model
    Onpremise,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RunEnvironment {
    fn from(s: &str) -> Self {
        match s {
            "AWS" => RunEnvironment::Aws,
            "ONPREMISE" => RunEnvironment::Onpremise,
            other => RunEnvironment::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RunEnvironment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RunEnvironment::from(s))
    }
}
impl RunEnvironment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RunEnvironment::Aws => "AWS",
            RunEnvironment::Onpremise => "ONPREMISE",
            RunEnvironment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS", "ONPREMISE"]
    }
}
impl AsRef<str> for RunEnvironment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Command to be run on a particular operating system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlatformCommand {
    /// <p>Command for Linux.</p>
    #[doc(hidden)]
    pub linux: std::option::Option<std::string::String>,
    /// <p>Command for Windows.</p>
    #[doc(hidden)]
    pub windows: std::option::Option<std::string::String>,
}
impl PlatformCommand {
    /// <p>Command for Linux.</p>
    pub fn linux(&self) -> std::option::Option<&str> {
        self.linux.as_deref()
    }
    /// <p>Command for Windows.</p>
    pub fn windows(&self) -> std::option::Option<&str> {
        self.windows.as_deref()
    }
}
impl PlatformCommand {
    /// Creates a new builder-style object to manufacture [`PlatformCommand`](crate::model::PlatformCommand).
    pub fn builder() -> crate::model::platform_command::Builder {
        crate::model::platform_command::Builder::default()
    }
}

/// See [`PlatformCommand`](crate::model::PlatformCommand).
pub mod platform_command {

    /// A builder for [`PlatformCommand`](crate::model::PlatformCommand).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) linux: std::option::Option<std::string::String>,
        pub(crate) windows: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Command for Linux.</p>
        pub fn linux(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux = Some(input.into());
            self
        }
        /// <p>Command for Linux.</p>
        pub fn set_linux(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.linux = input;
            self
        }
        /// <p>Command for Windows.</p>
        pub fn windows(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows = Some(input.into());
            self
        }
        /// <p>Command for Windows.</p>
        pub fn set_windows(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.windows = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformCommand`](crate::model::PlatformCommand).
        pub fn build(self) -> crate::model::PlatformCommand {
            crate::model::PlatformCommand {
                linux: self.linux,
                windows: self.windows,
            }
        }
    }
}

/// <p>The script location for a particular operating system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlatformScriptKey {
    /// <p>The script location for Linux.</p>
    #[doc(hidden)]
    pub linux: std::option::Option<std::string::String>,
    /// <p>The script location for Windows.</p>
    #[doc(hidden)]
    pub windows: std::option::Option<std::string::String>,
}
impl PlatformScriptKey {
    /// <p>The script location for Linux.</p>
    pub fn linux(&self) -> std::option::Option<&str> {
        self.linux.as_deref()
    }
    /// <p>The script location for Windows.</p>
    pub fn windows(&self) -> std::option::Option<&str> {
        self.windows.as_deref()
    }
}
impl PlatformScriptKey {
    /// Creates a new builder-style object to manufacture [`PlatformScriptKey`](crate::model::PlatformScriptKey).
    pub fn builder() -> crate::model::platform_script_key::Builder {
        crate::model::platform_script_key::Builder::default()
    }
}

/// See [`PlatformScriptKey`](crate::model::PlatformScriptKey).
pub mod platform_script_key {

    /// A builder for [`PlatformScriptKey`](crate::model::PlatformScriptKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) linux: std::option::Option<std::string::String>,
        pub(crate) windows: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The script location for Linux.</p>
        pub fn linux(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux = Some(input.into());
            self
        }
        /// <p>The script location for Linux.</p>
        pub fn set_linux(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.linux = input;
            self
        }
        /// <p>The script location for Windows.</p>
        pub fn windows(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows = Some(input.into());
            self
        }
        /// <p>The script location for Windows.</p>
        pub fn set_windows(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.windows = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformScriptKey`](crate::model::PlatformScriptKey).
        pub fn build(self) -> crate::model::PlatformScriptKey {
            crate::model::PlatformScriptKey {
                linux: self.linux,
                windows: self.windows,
            }
        }
    }
}

/// <p>The summary of the step group in the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateStepGroupSummary {
    /// <p>The ID of the step group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the step group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The previous step group.</p>
    #[doc(hidden)]
    pub previous: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The next step group.</p>
    #[doc(hidden)]
    pub next: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TemplateStepGroupSummary {
    /// <p>The ID of the step group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the step group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The previous step group.</p>
    pub fn previous(&self) -> std::option::Option<&[std::string::String]> {
        self.previous.as_deref()
    }
    /// <p>The next step group.</p>
    pub fn next(&self) -> std::option::Option<&[std::string::String]> {
        self.next.as_deref()
    }
}
impl TemplateStepGroupSummary {
    /// Creates a new builder-style object to manufacture [`TemplateStepGroupSummary`](crate::model::TemplateStepGroupSummary).
    pub fn builder() -> crate::model::template_step_group_summary::Builder {
        crate::model::template_step_group_summary::Builder::default()
    }
}

/// See [`TemplateStepGroupSummary`](crate::model::TemplateStepGroupSummary).
pub mod template_step_group_summary {

    /// A builder for [`TemplateStepGroupSummary`](crate::model::TemplateStepGroupSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) previous: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the step group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the step group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the step group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the step group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `previous`.
        ///
        /// To override the contents of this collection use [`set_previous`](Self::set_previous).
        ///
        /// <p>The previous step group.</p>
        pub fn previous(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.previous.unwrap_or_default();
            v.push(input.into());
            self.previous = Some(v);
            self
        }
        /// <p>The previous step group.</p>
        pub fn set_previous(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.previous = input;
            self
        }
        /// Appends an item to `next`.
        ///
        /// To override the contents of this collection use [`set_next`](Self::set_next).
        ///
        /// <p>The next step group.</p>
        pub fn next(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.next.unwrap_or_default();
            v.push(input.into());
            self.next = Some(v);
            self
        }
        /// <p>The next step group.</p>
        pub fn set_next(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.next = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateStepGroupSummary`](crate::model::TemplateStepGroupSummary).
        pub fn build(self) -> crate::model::TemplateStepGroupSummary {
            crate::model::TemplateStepGroupSummary {
                id: self.id,
                name: self.name,
                previous: self.previous,
                next: self.next,
            }
        }
    }
}

/// <p>The summary of the step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateStepSummary {
    /// <p>The ID of the step.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The ID of the step group.</p>
    #[doc(hidden)]
    pub step_group_id: std::option::Option<std::string::String>,
    /// <p>The ID of the template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
    #[doc(hidden)]
    pub step_action_type: std::option::Option<crate::model::StepActionType>,
    /// <p>The servers on which to run the script.</p>
    #[doc(hidden)]
    pub target_type: std::option::Option<crate::model::TargetType>,
    /// <p>The owner of the step.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<crate::model::Owner>,
    /// <p>The previous step.</p>
    #[doc(hidden)]
    pub previous: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The next step.</p>
    #[doc(hidden)]
    pub next: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TemplateStepSummary {
    /// <p>The ID of the step.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The ID of the step group.</p>
    pub fn step_group_id(&self) -> std::option::Option<&str> {
        self.step_group_id.as_deref()
    }
    /// <p>The ID of the template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>The name of the step.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
    pub fn step_action_type(&self) -> std::option::Option<&crate::model::StepActionType> {
        self.step_action_type.as_ref()
    }
    /// <p>The servers on which to run the script.</p>
    pub fn target_type(&self) -> std::option::Option<&crate::model::TargetType> {
        self.target_type.as_ref()
    }
    /// <p>The owner of the step.</p>
    pub fn owner(&self) -> std::option::Option<&crate::model::Owner> {
        self.owner.as_ref()
    }
    /// <p>The previous step.</p>
    pub fn previous(&self) -> std::option::Option<&[std::string::String]> {
        self.previous.as_deref()
    }
    /// <p>The next step.</p>
    pub fn next(&self) -> std::option::Option<&[std::string::String]> {
        self.next.as_deref()
    }
}
impl TemplateStepSummary {
    /// Creates a new builder-style object to manufacture [`TemplateStepSummary`](crate::model::TemplateStepSummary).
    pub fn builder() -> crate::model::template_step_summary::Builder {
        crate::model::template_step_summary::Builder::default()
    }
}

/// See [`TemplateStepSummary`](crate::model::TemplateStepSummary).
pub mod template_step_summary {

    /// A builder for [`TemplateStepSummary`](crate::model::TemplateStepSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) step_group_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) step_action_type: std::option::Option<crate::model::StepActionType>,
        pub(crate) target_type: std::option::Option<crate::model::TargetType>,
        pub(crate) owner: std::option::Option<crate::model::Owner>,
        pub(crate) previous: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the step.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the step.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The ID of the step group.</p>
        pub fn step_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_group_id = Some(input.into());
            self
        }
        /// <p>The ID of the step group.</p>
        pub fn set_step_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.step_group_id = input;
            self
        }
        /// <p>The ID of the template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The ID of the template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>The name of the step.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
        pub fn step_action_type(mut self, input: crate::model::StepActionType) -> Self {
            self.step_action_type = Some(input);
            self
        }
        /// <p>The action type of the step. You must run and update the status of a manual step for the workflow to continue after the completion of the step.</p>
        pub fn set_step_action_type(
            mut self,
            input: std::option::Option<crate::model::StepActionType>,
        ) -> Self {
            self.step_action_type = input;
            self
        }
        /// <p>The servers on which to run the script.</p>
        pub fn target_type(mut self, input: crate::model::TargetType) -> Self {
            self.target_type = Some(input);
            self
        }
        /// <p>The servers on which to run the script.</p>
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::TargetType>,
        ) -> Self {
            self.target_type = input;
            self
        }
        /// <p>The owner of the step.</p>
        pub fn owner(mut self, input: crate::model::Owner) -> Self {
            self.owner = Some(input);
            self
        }
        /// <p>The owner of the step.</p>
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Owner>) -> Self {
            self.owner = input;
            self
        }
        /// Appends an item to `previous`.
        ///
        /// To override the contents of this collection use [`set_previous`](Self::set_previous).
        ///
        /// <p>The previous step.</p>
        pub fn previous(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.previous.unwrap_or_default();
            v.push(input.into());
            self.previous = Some(v);
            self
        }
        /// <p>The previous step.</p>
        pub fn set_previous(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.previous = input;
            self
        }
        /// Appends an item to `next`.
        ///
        /// To override the contents of this collection use [`set_next`](Self::set_next).
        ///
        /// <p>The next step.</p>
        pub fn next(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.next.unwrap_or_default();
            v.push(input.into());
            self.next = Some(v);
            self
        }
        /// <p>The next step.</p>
        pub fn set_next(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.next = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateStepSummary`](crate::model::TemplateStepSummary).
        pub fn build(self) -> crate::model::TemplateStepSummary {
            crate::model::TemplateStepSummary {
                id: self.id,
                step_group_id: self.step_group_id,
                template_id: self.template_id,
                name: self.name,
                step_action_type: self.step_action_type,
                target_type: self.target_type,
                owner: self.owner,
                previous: self.previous,
                next: self.next,
            }
        }
    }
}

/// <p>The custom script to run tests on source or target environments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StepAutomationConfiguration {
    /// <p>The Amazon S3 bucket where the script is located.</p>
    #[doc(hidden)]
    pub script_location_s3_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 key for the script location.</p>
    #[doc(hidden)]
    pub script_location_s3_key: std::option::Option<crate::model::PlatformScriptKey>,
    /// <p>The command to run the script.</p>
    #[doc(hidden)]
    pub command: std::option::Option<crate::model::PlatformCommand>,
    /// <p>The source or target environment.</p>
    #[doc(hidden)]
    pub run_environment: std::option::Option<crate::model::RunEnvironment>,
    /// <p>The servers on which to run the script.</p>
    #[doc(hidden)]
    pub target_type: std::option::Option<crate::model::TargetType>,
}
impl StepAutomationConfiguration {
    /// <p>The Amazon S3 bucket where the script is located.</p>
    pub fn script_location_s3_bucket(&self) -> std::option::Option<&str> {
        self.script_location_s3_bucket.as_deref()
    }
    /// <p>The Amazon S3 key for the script location.</p>
    pub fn script_location_s3_key(&self) -> std::option::Option<&crate::model::PlatformScriptKey> {
        self.script_location_s3_key.as_ref()
    }
    /// <p>The command to run the script.</p>
    pub fn command(&self) -> std::option::Option<&crate::model::PlatformCommand> {
        self.command.as_ref()
    }
    /// <p>The source or target environment.</p>
    pub fn run_environment(&self) -> std::option::Option<&crate::model::RunEnvironment> {
        self.run_environment.as_ref()
    }
    /// <p>The servers on which to run the script.</p>
    pub fn target_type(&self) -> std::option::Option<&crate::model::TargetType> {
        self.target_type.as_ref()
    }
}
impl StepAutomationConfiguration {
    /// Creates a new builder-style object to manufacture [`StepAutomationConfiguration`](crate::model::StepAutomationConfiguration).
    pub fn builder() -> crate::model::step_automation_configuration::Builder {
        crate::model::step_automation_configuration::Builder::default()
    }
}

/// See [`StepAutomationConfiguration`](crate::model::StepAutomationConfiguration).
pub mod step_automation_configuration {

    /// A builder for [`StepAutomationConfiguration`](crate::model::StepAutomationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) script_location_s3_bucket: std::option::Option<std::string::String>,
        pub(crate) script_location_s3_key: std::option::Option<crate::model::PlatformScriptKey>,
        pub(crate) command: std::option::Option<crate::model::PlatformCommand>,
        pub(crate) run_environment: std::option::Option<crate::model::RunEnvironment>,
        pub(crate) target_type: std::option::Option<crate::model::TargetType>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket where the script is located.</p>
        pub fn script_location_s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.script_location_s3_bucket = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket where the script is located.</p>
        pub fn set_script_location_s3_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.script_location_s3_bucket = input;
            self
        }
        /// <p>The Amazon S3 key for the script location.</p>
        pub fn script_location_s3_key(mut self, input: crate::model::PlatformScriptKey) -> Self {
            self.script_location_s3_key = Some(input);
            self
        }
        /// <p>The Amazon S3 key for the script location.</p>
        pub fn set_script_location_s3_key(
            mut self,
            input: std::option::Option<crate::model::PlatformScriptKey>,
        ) -> Self {
            self.script_location_s3_key = input;
            self
        }
        /// <p>The command to run the script.</p>
        pub fn command(mut self, input: crate::model::PlatformCommand) -> Self {
            self.command = Some(input);
            self
        }
        /// <p>The command to run the script.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<crate::model::PlatformCommand>,
        ) -> Self {
            self.command = input;
            self
        }
        /// <p>The source or target environment.</p>
        pub fn run_environment(mut self, input: crate::model::RunEnvironment) -> Self {
            self.run_environment = Some(input);
            self
        }
        /// <p>The source or target environment.</p>
        pub fn set_run_environment(
            mut self,
            input: std::option::Option<crate::model::RunEnvironment>,
        ) -> Self {
            self.run_environment = input;
            self
        }
        /// <p>The servers on which to run the script.</p>
        pub fn target_type(mut self, input: crate::model::TargetType) -> Self {
            self.target_type = Some(input);
            self
        }
        /// <p>The servers on which to run the script.</p>
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::TargetType>,
        ) -> Self {
            self.target_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StepAutomationConfiguration`](crate::model::StepAutomationConfiguration).
        pub fn build(self) -> crate::model::StepAutomationConfiguration {
            crate::model::StepAutomationConfiguration {
                script_location_s3_bucket: self.script_location_s3_bucket,
                script_location_s3_key: self.script_location_s3_key,
                command: self.command,
                run_environment: self.run_environment,
                target_type: self.target_type,
            }
        }
    }
}

/// <p>The output of the step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StepOutput {
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the step output.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>Determine if an output is required from a step.</p>
    #[doc(hidden)]
    pub required: std::option::Option<bool>,
}
impl StepOutput {
    /// <p>The name of the step.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the step output.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>Determine if an output is required from a step.</p>
    pub fn required(&self) -> std::option::Option<bool> {
        self.required
    }
}
impl StepOutput {
    /// Creates a new builder-style object to manufacture [`StepOutput`](crate::model::StepOutput).
    pub fn builder() -> crate::model::step_output::Builder {
        crate::model::step_output::Builder::default()
    }
}

/// See [`StepOutput`](crate::model::StepOutput).
pub mod step_output {

    /// A builder for [`StepOutput`](crate::model::StepOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) required: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the step.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the step output.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the step output.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>Determine if an output is required from a step.</p>
        pub fn required(mut self, input: bool) -> Self {
            self.required = Some(input);
            self
        }
        /// <p>Determine if an output is required from a step.</p>
        pub fn set_required(mut self, input: std::option::Option<bool>) -> Self {
            self.required = input;
            self
        }
        /// Consumes the builder and constructs a [`StepOutput`](crate::model::StepOutput).
        pub fn build(self) -> crate::model::StepOutput {
            crate::model::StepOutput {
                name: self.name,
                data_type: self.data_type,
                required: self.required,
            }
        }
    }
}

/// <p>The summary of the Migration Hub Orchestrator plugin.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PluginSummary {
    /// <p>The ID of the plugin.</p>
    #[doc(hidden)]
    pub plugin_id: std::option::Option<std::string::String>,
    /// <p>The name of the host.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The status of the plugin.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PluginHealth>,
    /// <p>The IP address at which the plugin is located.</p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
    /// <p>The version of the plugin.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The time at which the plugin was registered.</p>
    #[doc(hidden)]
    pub registered_time: std::option::Option<std::string::String>,
}
impl PluginSummary {
    /// <p>The ID of the plugin.</p>
    pub fn plugin_id(&self) -> std::option::Option<&str> {
        self.plugin_id.as_deref()
    }
    /// <p>The name of the host.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The status of the plugin.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PluginHealth> {
        self.status.as_ref()
    }
    /// <p>The IP address at which the plugin is located.</p>
    pub fn ip_address(&self) -> std::option::Option<&str> {
        self.ip_address.as_deref()
    }
    /// <p>The version of the plugin.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The time at which the plugin was registered.</p>
    pub fn registered_time(&self) -> std::option::Option<&str> {
        self.registered_time.as_deref()
    }
}
impl PluginSummary {
    /// Creates a new builder-style object to manufacture [`PluginSummary`](crate::model::PluginSummary).
    pub fn builder() -> crate::model::plugin_summary::Builder {
        crate::model::plugin_summary::Builder::default()
    }
}

/// See [`PluginSummary`](crate::model::PluginSummary).
pub mod plugin_summary {

    /// A builder for [`PluginSummary`](crate::model::PluginSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) plugin_id: std::option::Option<std::string::String>,
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::PluginHealth>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) registered_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the plugin.</p>
        pub fn plugin_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.plugin_id = Some(input.into());
            self
        }
        /// <p>The ID of the plugin.</p>
        pub fn set_plugin_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plugin_id = input;
            self
        }
        /// <p>The name of the host.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The name of the host.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The status of the plugin.</p>
        pub fn status(mut self, input: crate::model::PluginHealth) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the plugin.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PluginHealth>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The IP address at which the plugin is located.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p>The IP address at which the plugin is located.</p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// <p>The version of the plugin.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the plugin.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The time at which the plugin was registered.</p>
        pub fn registered_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_time = Some(input.into());
            self
        }
        /// <p>The time at which the plugin was registered.</p>
        pub fn set_registered_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PluginSummary`](crate::model::PluginSummary).
        pub fn build(self) -> crate::model::PluginSummary {
            crate::model::PluginSummary {
                plugin_id: self.plugin_id,
                hostname: self.hostname,
                status: self.status,
                ip_address: self.ip_address,
                version: self.version,
                registered_time: self.registered_time,
            }
        }
    }
}

/// When writing a match expression against `PluginHealth`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pluginhealth = unimplemented!();
/// match pluginhealth {
///     PluginHealth::PluginHealthy => { /* ... */ },
///     PluginHealth::PluginUnhealthy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pluginhealth` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PluginHealth::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PluginHealth::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PluginHealth::NewFeature` is defined.
/// Specifically, when `pluginhealth` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PluginHealth::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PluginHealth {
    #[allow(missing_docs)] // documentation missing in model
    PluginHealthy,
    #[allow(missing_docs)] // documentation missing in model
    PluginUnhealthy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PluginHealth {
    fn from(s: &str) -> Self {
        match s {
            "HEALTHY" => PluginHealth::PluginHealthy,
            "UNHEALTHY" => PluginHealth::PluginUnhealthy,
            other => PluginHealth::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PluginHealth {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PluginHealth::from(s))
    }
}
impl PluginHealth {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PluginHealth::PluginHealthy => "HEALTHY",
            PluginHealth::PluginUnhealthy => "UNHEALTHY",
            PluginHealth::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HEALTHY", "UNHEALTHY"]
    }
}
impl AsRef<str> for PluginHealth {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSummary {
    /// <p>The ID of the template.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The description of the template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl TemplateSummary {
    /// <p>The ID of the template.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The description of the template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl TemplateSummary {
    /// Creates a new builder-style object to manufacture [`TemplateSummary`](crate::model::TemplateSummary).
    pub fn builder() -> crate::model::template_summary::Builder {
        crate::model::template_summary::Builder::default()
    }
}

/// See [`TemplateSummary`](crate::model::TemplateSummary).
pub mod template_summary {

    /// A builder for [`TemplateSummary`](crate::model::TemplateSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the template.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the template.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The description of the template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSummary`](crate::model::TemplateSummary).
        pub fn build(self) -> crate::model::TemplateSummary {
            crate::model::TemplateSummary {
                id: self.id,
                name: self.name,
                arn: self.arn,
                description: self.description,
            }
        }
    }
}

/// When writing a match expression against `TemplateStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let templatestatus = unimplemented!();
/// match templatestatus {
///     TemplateStatus::Created => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `templatestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TemplateStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TemplateStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TemplateStatus::NewFeature` is defined.
/// Specifically, when `templatestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TemplateStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemplateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TemplateStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => TemplateStatus::Created,
            other => TemplateStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TemplateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TemplateStatus::from(s))
    }
}
impl TemplateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TemplateStatus::Created => "CREATED",
            TemplateStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATED"]
    }
}
impl AsRef<str> for TemplateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The input parameters of a template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateInput {
    /// <p>The name of the template.</p>
    #[doc(hidden)]
    pub input_name: std::option::Option<std::string::String>,
    /// <p>The data type of the template input.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>Determine if an input is required from the template.</p>
    #[doc(hidden)]
    pub required: std::option::Option<bool>,
}
impl TemplateInput {
    /// <p>The name of the template.</p>
    pub fn input_name(&self) -> std::option::Option<&str> {
        self.input_name.as_deref()
    }
    /// <p>The data type of the template input.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>Determine if an input is required from the template.</p>
    pub fn required(&self) -> std::option::Option<bool> {
        self.required
    }
}
impl TemplateInput {
    /// Creates a new builder-style object to manufacture [`TemplateInput`](crate::model::TemplateInput).
    pub fn builder() -> crate::model::template_input::Builder {
        crate::model::template_input::Builder::default()
    }
}

/// See [`TemplateInput`](crate::model::TemplateInput).
pub mod template_input {

    /// A builder for [`TemplateInput`](crate::model::TemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) required: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the template.</p>
        pub fn input_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_name = Some(input.into());
            self
        }
        /// <p>The name of the template.</p>
        pub fn set_input_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_name = input;
            self
        }
        /// <p>The data type of the template input.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the template input.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>Determine if an input is required from the template.</p>
        pub fn required(mut self, input: bool) -> Self {
            self.required = Some(input);
            self
        }
        /// <p>Determine if an input is required from the template.</p>
        pub fn set_required(mut self, input: std::option::Option<bool>) -> Self {
            self.required = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateInput`](crate::model::TemplateInput).
        pub fn build(self) -> crate::model::TemplateInput {
            crate::model::TemplateInput {
                input_name: self.input_name,
                data_type: self.data_type,
                required: self.required,
            }
        }
    }
}

/// When writing a match expression against `MigrationWorkflowStatusEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let migrationworkflowstatusenum = unimplemented!();
/// match migrationworkflowstatusenum {
///     MigrationWorkflowStatusEnum::Completed => { /* ... */ },
///     MigrationWorkflowStatusEnum::Creating => { /* ... */ },
///     MigrationWorkflowStatusEnum::CreationFailed => { /* ... */ },
///     MigrationWorkflowStatusEnum::Deleted => { /* ... */ },
///     MigrationWorkflowStatusEnum::Deleting => { /* ... */ },
///     MigrationWorkflowStatusEnum::DeletionFailed => { /* ... */ },
///     MigrationWorkflowStatusEnum::InProgress => { /* ... */ },
///     MigrationWorkflowStatusEnum::NotStarted => { /* ... */ },
///     MigrationWorkflowStatusEnum::Paused => { /* ... */ },
///     MigrationWorkflowStatusEnum::Pausing => { /* ... */ },
///     MigrationWorkflowStatusEnum::PausingFailed => { /* ... */ },
///     MigrationWorkflowStatusEnum::Starting => { /* ... */ },
///     MigrationWorkflowStatusEnum::UserAttentionRequired => { /* ... */ },
///     MigrationWorkflowStatusEnum::WorkflowFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `migrationworkflowstatusenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MigrationWorkflowStatusEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MigrationWorkflowStatusEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MigrationWorkflowStatusEnum::NewFeature` is defined.
/// Specifically, when `migrationworkflowstatusenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MigrationWorkflowStatusEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MigrationWorkflowStatusEnum {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    DeletionFailed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    #[allow(missing_docs)] // documentation missing in model
    Pausing,
    #[allow(missing_docs)] // documentation missing in model
    PausingFailed,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    UserAttentionRequired,
    #[allow(missing_docs)] // documentation missing in model
    WorkflowFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MigrationWorkflowStatusEnum {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => MigrationWorkflowStatusEnum::Completed,
            "CREATING" => MigrationWorkflowStatusEnum::Creating,
            "CREATION_FAILED" => MigrationWorkflowStatusEnum::CreationFailed,
            "DELETED" => MigrationWorkflowStatusEnum::Deleted,
            "DELETING" => MigrationWorkflowStatusEnum::Deleting,
            "DELETION_FAILED" => MigrationWorkflowStatusEnum::DeletionFailed,
            "IN_PROGRESS" => MigrationWorkflowStatusEnum::InProgress,
            "NOT_STARTED" => MigrationWorkflowStatusEnum::NotStarted,
            "PAUSED" => MigrationWorkflowStatusEnum::Paused,
            "PAUSING" => MigrationWorkflowStatusEnum::Pausing,
            "PAUSING_FAILED" => MigrationWorkflowStatusEnum::PausingFailed,
            "STARTING" => MigrationWorkflowStatusEnum::Starting,
            "USER_ATTENTION_REQUIRED" => MigrationWorkflowStatusEnum::UserAttentionRequired,
            "WORKFLOW_FAILED" => MigrationWorkflowStatusEnum::WorkflowFailed,
            other => MigrationWorkflowStatusEnum::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MigrationWorkflowStatusEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MigrationWorkflowStatusEnum::from(s))
    }
}
impl MigrationWorkflowStatusEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MigrationWorkflowStatusEnum::Completed => "COMPLETED",
            MigrationWorkflowStatusEnum::Creating => "CREATING",
            MigrationWorkflowStatusEnum::CreationFailed => "CREATION_FAILED",
            MigrationWorkflowStatusEnum::Deleted => "DELETED",
            MigrationWorkflowStatusEnum::Deleting => "DELETING",
            MigrationWorkflowStatusEnum::DeletionFailed => "DELETION_FAILED",
            MigrationWorkflowStatusEnum::InProgress => "IN_PROGRESS",
            MigrationWorkflowStatusEnum::NotStarted => "NOT_STARTED",
            MigrationWorkflowStatusEnum::Paused => "PAUSED",
            MigrationWorkflowStatusEnum::Pausing => "PAUSING",
            MigrationWorkflowStatusEnum::PausingFailed => "PAUSING_FAILED",
            MigrationWorkflowStatusEnum::Starting => "STARTING",
            MigrationWorkflowStatusEnum::UserAttentionRequired => "USER_ATTENTION_REQUIRED",
            MigrationWorkflowStatusEnum::WorkflowFailed => "WORKFLOW_FAILED",
            MigrationWorkflowStatusEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "CREATING",
            "CREATION_FAILED",
            "DELETED",
            "DELETING",
            "DELETION_FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "PAUSED",
            "PAUSING",
            "PAUSING_FAILED",
            "STARTING",
            "USER_ATTENTION_REQUIRED",
            "WORKFLOW_FAILED",
        ]
    }
}
impl AsRef<str> for MigrationWorkflowStatusEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of a migration workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MigrationWorkflowSummary {
    /// <p>The ID of the migration workflow.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the migration workflow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>The name of the application configured in Application Discovery Service.</p>
    #[doc(hidden)]
    pub ads_application_configuration_name: std::option::Option<std::string::String>,
    /// <p>The status of the migration workflow.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::MigrationWorkflowStatusEnum>,
    /// <p>The time at which the migration workflow was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the migration workflow ended.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status message of the migration workflow.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The steps completed in the migration workflow.</p>
    #[doc(hidden)]
    pub completed_steps: std::option::Option<i32>,
    /// <p>All the steps in a migration workflow.</p>
    #[doc(hidden)]
    pub total_steps: std::option::Option<i32>,
}
impl MigrationWorkflowSummary {
    /// <p>The ID of the migration workflow.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the migration workflow.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>The name of the application configured in Application Discovery Service.</p>
    pub fn ads_application_configuration_name(&self) -> std::option::Option<&str> {
        self.ads_application_configuration_name.as_deref()
    }
    /// <p>The status of the migration workflow.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::MigrationWorkflowStatusEnum> {
        self.status.as_ref()
    }
    /// <p>The time at which the migration workflow was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time at which the migration workflow ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The status message of the migration workflow.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The steps completed in the migration workflow.</p>
    pub fn completed_steps(&self) -> std::option::Option<i32> {
        self.completed_steps
    }
    /// <p>All the steps in a migration workflow.</p>
    pub fn total_steps(&self) -> std::option::Option<i32> {
        self.total_steps
    }
}
impl MigrationWorkflowSummary {
    /// Creates a new builder-style object to manufacture [`MigrationWorkflowSummary`](crate::model::MigrationWorkflowSummary).
    pub fn builder() -> crate::model::migration_workflow_summary::Builder {
        crate::model::migration_workflow_summary::Builder::default()
    }
}

/// See [`MigrationWorkflowSummary`](crate::model::MigrationWorkflowSummary).
pub mod migration_workflow_summary {

    /// A builder for [`MigrationWorkflowSummary`](crate::model::MigrationWorkflowSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) ads_application_configuration_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MigrationWorkflowStatusEnum>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) completed_steps: std::option::Option<i32>,
        pub(crate) total_steps: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the migration workflow.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the migration workflow.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the migration workflow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the migration workflow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The ID of the template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>The name of the application configured in Application Discovery Service.</p>
        pub fn ads_application_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.ads_application_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the application configured in Application Discovery Service.</p>
        pub fn set_ads_application_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ads_application_configuration_name = input;
            self
        }
        /// <p>The status of the migration workflow.</p>
        pub fn status(mut self, input: crate::model::MigrationWorkflowStatusEnum) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the migration workflow.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MigrationWorkflowStatusEnum>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time at which the migration workflow was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time at which the migration workflow was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the migration workflow ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time at which the migration workflow ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The status message of the migration workflow.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message of the migration workflow.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The steps completed in the migration workflow.</p>
        pub fn completed_steps(mut self, input: i32) -> Self {
            self.completed_steps = Some(input);
            self
        }
        /// <p>The steps completed in the migration workflow.</p>
        pub fn set_completed_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.completed_steps = input;
            self
        }
        /// <p>All the steps in a migration workflow.</p>
        pub fn total_steps(mut self, input: i32) -> Self {
            self.total_steps = Some(input);
            self
        }
        /// <p>All the steps in a migration workflow.</p>
        pub fn set_total_steps(mut self, input: std::option::Option<i32>) -> Self {
            self.total_steps = input;
            self
        }
        /// Consumes the builder and constructs a [`MigrationWorkflowSummary`](crate::model::MigrationWorkflowSummary).
        pub fn build(self) -> crate::model::MigrationWorkflowSummary {
            crate::model::MigrationWorkflowSummary {
                id: self.id,
                name: self.name,
                template_id: self.template_id,
                ads_application_configuration_name: self.ads_application_configuration_name,
                status: self.status,
                creation_time: self.creation_time,
                end_time: self.end_time,
                status_message: self.status_message,
                completed_steps: self.completed_steps,
                total_steps: self.total_steps,
            }
        }
    }
}

/// <p>A map of key value pairs that is generated when you create a migration workflow. The key value pairs will differ based on your selection of the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum StepInput {
    /// <p>The value of the integer.</p>
    IntegerValue(i32),
    /// <p>List of string values.</p>
    ListOfStringsValue(std::vec::Vec<std::string::String>),
    /// <p>Map of string values.</p>
    MapOfStringValue(std::collections::HashMap<std::string::String, std::string::String>),
    /// <p>String value.</p>
    StringValue(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl StepInput {
    /// Tries to convert the enum instance into [`IntegerValue`](crate::model::StepInput::IntegerValue), extracting the inner [`i32`](i32).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_integer_value(&self) -> std::result::Result<&i32, &Self> {
        if let StepInput::IntegerValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`IntegerValue`](crate::model::StepInput::IntegerValue).
    pub fn is_integer_value(&self) -> bool {
        self.as_integer_value().is_ok()
    }
    /// Tries to convert the enum instance into [`ListOfStringsValue`](crate::model::StepInput::ListOfStringsValue), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_list_of_strings_value(
        &self,
    ) -> std::result::Result<&std::vec::Vec<std::string::String>, &Self> {
        if let StepInput::ListOfStringsValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ListOfStringsValue`](crate::model::StepInput::ListOfStringsValue).
    pub fn is_list_of_strings_value(&self) -> bool {
        self.as_list_of_strings_value().is_ok()
    }
    /// Tries to convert the enum instance into [`MapOfStringValue`](crate::model::StepInput::MapOfStringValue), extracting the inner [`HashMap`](std::collections::HashMap).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_map_of_string_value(
        &self,
    ) -> std::result::Result<
        &std::collections::HashMap<std::string::String, std::string::String>,
        &Self,
    > {
        if let StepInput::MapOfStringValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`MapOfStringValue`](crate::model::StepInput::MapOfStringValue).
    pub fn is_map_of_string_value(&self) -> bool {
        self.as_map_of_string_value().is_ok()
    }
    /// Tries to convert the enum instance into [`StringValue`](crate::model::StepInput::StringValue), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string_value(&self) -> std::result::Result<&std::string::String, &Self> {
        if let StepInput::StringValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`StringValue`](crate::model::StepInput::StringValue).
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
