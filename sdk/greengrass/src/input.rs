// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AssociateRoleToGroupInput`](crate::input::AssociateRoleToGroupInput).
pub mod associate_role_to_group_input {
    
    /// A builder for [`AssociateRoleToGroupInput`](crate::input::AssociateRoleToGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Consumes the builder and constructs a [`AssociateRoleToGroupInput`](crate::input::AssociateRoleToGroupInput).
        pub fn build(self) -> Result<crate::input::AssociateRoleToGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::AssociateRoleToGroupInput {
                    group_id: self.group_id
                    ,
                    role_arn: self.role_arn
                    ,
                }
            )
        }
    }
    
    
}
impl AssociateRoleToGroupInput {
    /// Consumes the builder and constructs an Operation<[`AssociateRoleToGroup`](crate::operation::AssociateRoleToGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::AssociateRoleToGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::AssociateRoleToGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.group_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/role", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::AssociateRoleToGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_role_to_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::AssociateRoleToGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AssociateRoleToGroup", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateRoleToGroupInput`](crate::input::AssociateRoleToGroupInput).
    pub fn builder() -> crate::input::associate_role_to_group_input::Builder {
        crate::input::associate_role_to_group_input::Builder::default()
    }
}

/// See [`AssociateServiceRoleToAccountInput`](crate::input::AssociateServiceRoleToAccountInput).
pub mod associate_service_role_to_account_input {
    
    /// A builder for [`AssociateServiceRoleToAccountInput`](crate::input::AssociateServiceRoleToAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ARN of the service role you wish to associate with your account.
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// The ARN of the service role you wish to associate with your account.
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Consumes the builder and constructs a [`AssociateServiceRoleToAccountInput`](crate::input::AssociateServiceRoleToAccountInput).
        pub fn build(self) -> Result<crate::input::AssociateServiceRoleToAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::AssociateServiceRoleToAccountInput {
                    role_arn: self.role_arn
                    ,
                }
            )
        }
    }
    
    
}
impl AssociateServiceRoleToAccountInput {
    /// Consumes the builder and constructs an Operation<[`AssociateServiceRoleToAccount`](crate::operation::AssociateServiceRoleToAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::AssociateServiceRoleToAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::AssociateServiceRoleToAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/servicerole").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::AssociateServiceRoleToAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_service_role_to_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::AssociateServiceRoleToAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AssociateServiceRoleToAccount", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateServiceRoleToAccountInput`](crate::input::AssociateServiceRoleToAccountInput).
    pub fn builder() -> crate::input::associate_service_role_to_account_input::Builder {
        crate::input::associate_service_role_to_account_input::Builder::default()
    }
}

/// See [`CreateConnectorDefinitionInput`](crate::input::CreateConnectorDefinitionInput).
pub mod create_connector_definition_input {
    
    /// A builder for [`CreateConnectorDefinitionInput`](crate::input::CreateConnectorDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::ConnectorDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the connector definition.
        pub fn initial_version(mut self, input: crate::model::ConnectorDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the connector definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::ConnectorDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the connector definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the connector definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateConnectorDefinitionInput`](crate::input::CreateConnectorDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateConnectorDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateConnectorDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateConnectorDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnectorDefinition`](crate::operation::CreateConnectorDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateConnectorDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateConnectorDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/connectors").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateConnectorDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_connector_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_connector_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateConnectorDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateConnectorDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateConnectorDefinitionInput`](crate::input::CreateConnectorDefinitionInput).
    pub fn builder() -> crate::input::create_connector_definition_input::Builder {
        crate::input::create_connector_definition_input::Builder::default()
    }
}

/// See [`CreateConnectorDefinitionVersionInput`](crate::input::CreateConnectorDefinitionVersionInput).
pub mod create_connector_definition_version_input {
    
    /// A builder for [`CreateConnectorDefinitionVersionInput`](crate::input::CreateConnectorDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) connector_definition_id: std::option::Option<std::string::String>,
        pub(crate) connectors: std::option::Option<std::vec::Vec<crate::model::Connector>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the connector definition.
        pub fn connector_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_id = Some(input.into());
            self
        }
        /// The ID of the connector definition.
        pub fn set_connector_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_id = input; self
        }
        /// Appends an item to `connectors`.
        ///
        /// To override the contents of this collection use [`set_connectors`](Self::set_connectors).
        ///
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        pub fn connectors(mut self, input: crate::model::Connector) -> Self {
            let mut v = self.connectors.unwrap_or_default();
                            v.push(input);
                            self.connectors = Some(v);
                            self
        }
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        pub fn set_connectors(mut self, input: std::option::Option<std::vec::Vec<crate::model::Connector>>) -> Self {
            self.connectors = input; self
        }
        /// Consumes the builder and constructs a [`CreateConnectorDefinitionVersionInput`](crate::input::CreateConnectorDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateConnectorDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateConnectorDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    connector_definition_id: self.connector_definition_id
                    ,
                    connectors: self.connectors
                    ,
                }
            )
        }
    }
    
    
}
impl CreateConnectorDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnectorDefinitionVersion`](crate::operation::CreateConnectorDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateConnectorDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateConnectorDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.connector_definition_id;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))?;
                let connector_definition_id = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions", ConnectorDefinitionId = connector_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateConnectorDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_connector_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_connector_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateConnectorDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateConnectorDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateConnectorDefinitionVersionInput`](crate::input::CreateConnectorDefinitionVersionInput).
    pub fn builder() -> crate::input::create_connector_definition_version_input::Builder {
        crate::input::create_connector_definition_version_input::Builder::default()
    }
}

/// See [`CreateCoreDefinitionInput`](crate::input::CreateCoreDefinitionInput).
pub mod create_core_definition_input {
    
    /// A builder for [`CreateCoreDefinitionInput`](crate::input::CreateCoreDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::CoreDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the core definition.
        pub fn initial_version(mut self, input: crate::model::CoreDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the core definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::CoreDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the core definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the core definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateCoreDefinitionInput`](crate::input::CreateCoreDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateCoreDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateCoreDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateCoreDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateCoreDefinition`](crate::operation::CreateCoreDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateCoreDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateCoreDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/cores").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateCoreDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_core_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_core_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateCoreDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateCoreDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateCoreDefinitionInput`](crate::input::CreateCoreDefinitionInput).
    pub fn builder() -> crate::input::create_core_definition_input::Builder {
        crate::input::create_core_definition_input::Builder::default()
    }
}

/// See [`CreateCoreDefinitionVersionInput`](crate::input::CreateCoreDefinitionVersionInput).
pub mod create_core_definition_version_input {
    
    /// A builder for [`CreateCoreDefinitionVersionInput`](crate::input::CreateCoreDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) core_definition_id: std::option::Option<std::string::String>,
        pub(crate) cores: std::option::Option<std::vec::Vec<crate::model::Core>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the core definition.
        pub fn core_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_id = Some(input.into());
            self
        }
        /// The ID of the core definition.
        pub fn set_core_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_id = input; self
        }
        /// Appends an item to `cores`.
        ///
        /// To override the contents of this collection use [`set_cores`](Self::set_cores).
        ///
        /// A list of cores in the core definition version.
        pub fn cores(mut self, input: crate::model::Core) -> Self {
            let mut v = self.cores.unwrap_or_default();
                            v.push(input);
                            self.cores = Some(v);
                            self
        }
        /// A list of cores in the core definition version.
        pub fn set_cores(mut self, input: std::option::Option<std::vec::Vec<crate::model::Core>>) -> Self {
            self.cores = input; self
        }
        /// Consumes the builder and constructs a [`CreateCoreDefinitionVersionInput`](crate::input::CreateCoreDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateCoreDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateCoreDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    core_definition_id: self.core_definition_id
                    ,
                    cores: self.cores
                    ,
                }
            )
        }
    }
    
    
}
impl CreateCoreDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateCoreDefinitionVersion`](crate::operation::CreateCoreDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateCoreDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateCoreDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.core_definition_id;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))?;
                let core_definition_id = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/cores/{CoreDefinitionId}/versions", CoreDefinitionId = core_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateCoreDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_core_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_core_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateCoreDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateCoreDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateCoreDefinitionVersionInput`](crate::input::CreateCoreDefinitionVersionInput).
    pub fn builder() -> crate::input::create_core_definition_version_input::Builder {
        crate::input::create_core_definition_version_input::Builder::default()
    }
}

/// See [`CreateDeploymentInput`](crate::input::CreateDeploymentInput).
pub mod create_deployment_input {
    
    /// A builder for [`CreateDeploymentInput`](crate::input::CreateDeploymentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) deployment_id: std::option::Option<std::string::String>,
        pub(crate) deployment_type: std::option::Option<crate::model::DeploymentType>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the deployment if you wish to redeploy a previous deployment.
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_id = Some(input.into());
            self
        }
        /// The ID of the deployment if you wish to redeploy a previous deployment.
        pub fn set_deployment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.deployment_id = input; self
        }
        /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
        pub fn deployment_type(mut self, input: crate::model::DeploymentType) -> Self {
            self.deployment_type = Some(input);
            self
        }
        /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
        pub fn set_deployment_type(mut self, input: std::option::Option<crate::model::DeploymentType>) -> Self {
            self.deployment_type = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The ID of the group version to be deployed.
        pub fn group_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_version_id = Some(input.into());
            self
        }
        /// The ID of the group version to be deployed.
        pub fn set_group_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_version_id = input; self
        }
        /// Consumes the builder and constructs a [`CreateDeploymentInput`](crate::input::CreateDeploymentInput).
        pub fn build(self) -> Result<crate::input::CreateDeploymentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDeploymentInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    deployment_id: self.deployment_id
                    ,
                    deployment_type: self.deployment_type
                    ,
                    group_id: self.group_id
                    ,
                    group_version_id: self.group_version_id
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDeploymentInput {
    /// Consumes the builder and constructs an Operation<[`CreateDeployment`](crate::operation::CreateDeployment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDeployment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDeploymentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.group_id;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/deployments", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDeploymentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_deployment(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_deployment(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDeployment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDeployment", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDeploymentInput`](crate::input::CreateDeploymentInput).
    pub fn builder() -> crate::input::create_deployment_input::Builder {
        crate::input::create_deployment_input::Builder::default()
    }
}

/// See [`CreateDeviceDefinitionInput`](crate::input::CreateDeviceDefinitionInput).
pub mod create_device_definition_input {
    
    /// A builder for [`CreateDeviceDefinitionInput`](crate::input::CreateDeviceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::DeviceDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the device definition.
        pub fn initial_version(mut self, input: crate::model::DeviceDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the device definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::DeviceDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the device definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the device definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateDeviceDefinitionInput`](crate::input::CreateDeviceDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateDeviceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDeviceDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDeviceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateDeviceDefinition`](crate::operation::CreateDeviceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDeviceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDeviceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/devices").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDeviceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_device_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_device_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDeviceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDeviceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDeviceDefinitionInput`](crate::input::CreateDeviceDefinitionInput).
    pub fn builder() -> crate::input::create_device_definition_input::Builder {
        crate::input::create_device_definition_input::Builder::default()
    }
}

/// See [`CreateDeviceDefinitionVersionInput`](crate::input::CreateDeviceDefinitionVersionInput).
pub mod create_device_definition_version_input {
    
    /// A builder for [`CreateDeviceDefinitionVersionInput`](crate::input::CreateDeviceDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) device_definition_id: std::option::Option<std::string::String>,
        pub(crate) devices: std::option::Option<std::vec::Vec<crate::model::Device>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the device definition.
        pub fn device_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_id = Some(input.into());
            self
        }
        /// The ID of the device definition.
        pub fn set_device_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_id = input; self
        }
        /// Appends an item to `devices`.
        ///
        /// To override the contents of this collection use [`set_devices`](Self::set_devices).
        ///
        /// A list of devices in the definition version.
        pub fn devices(mut self, input: crate::model::Device) -> Self {
            let mut v = self.devices.unwrap_or_default();
                            v.push(input);
                            self.devices = Some(v);
                            self
        }
        /// A list of devices in the definition version.
        pub fn set_devices(mut self, input: std::option::Option<std::vec::Vec<crate::model::Device>>) -> Self {
            self.devices = input; self
        }
        /// Consumes the builder and constructs a [`CreateDeviceDefinitionVersionInput`](crate::input::CreateDeviceDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateDeviceDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDeviceDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    device_definition_id: self.device_definition_id
                    ,
                    devices: self.devices
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDeviceDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateDeviceDefinitionVersion`](crate::operation::CreateDeviceDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDeviceDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDeviceDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.device_definition_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))?;
                let device_definition_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/devices/{DeviceDefinitionId}/versions", DeviceDefinitionId = device_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDeviceDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_device_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_device_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDeviceDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDeviceDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDeviceDefinitionVersionInput`](crate::input::CreateDeviceDefinitionVersionInput).
    pub fn builder() -> crate::input::create_device_definition_version_input::Builder {
        crate::input::create_device_definition_version_input::Builder::default()
    }
}

/// See [`CreateFunctionDefinitionInput`](crate::input::CreateFunctionDefinitionInput).
pub mod create_function_definition_input {
    
    /// A builder for [`CreateFunctionDefinitionInput`](crate::input::CreateFunctionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::FunctionDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the function definition.
        pub fn initial_version(mut self, input: crate::model::FunctionDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the function definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::FunctionDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the function definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the function definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateFunctionDefinitionInput`](crate::input::CreateFunctionDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateFunctionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateFunctionDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateFunctionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateFunctionDefinition`](crate::operation::CreateFunctionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateFunctionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateFunctionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/functions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateFunctionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_function_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_function_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateFunctionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateFunctionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateFunctionDefinitionInput`](crate::input::CreateFunctionDefinitionInput).
    pub fn builder() -> crate::input::create_function_definition_input::Builder {
        crate::input::create_function_definition_input::Builder::default()
    }
}

/// See [`CreateFunctionDefinitionVersionInput`](crate::input::CreateFunctionDefinitionVersionInput).
pub mod create_function_definition_version_input {
    
    /// A builder for [`CreateFunctionDefinitionVersionInput`](crate::input::CreateFunctionDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) default_config: std::option::Option<crate::model::FunctionDefaultConfig>,
        pub(crate) function_definition_id: std::option::Option<std::string::String>,
        pub(crate) functions: std::option::Option<std::vec::Vec<crate::model::Function>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        pub fn default_config(mut self, input: crate::model::FunctionDefaultConfig) -> Self {
            self.default_config = Some(input);
            self
        }
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        pub fn set_default_config(mut self, input: std::option::Option<crate::model::FunctionDefaultConfig>) -> Self {
            self.default_config = input; self
        }
        /// The ID of the Lambda function definition.
        pub fn function_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_id = Some(input.into());
            self
        }
        /// The ID of the Lambda function definition.
        pub fn set_function_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_id = input; self
        }
        /// Appends an item to `functions`.
        ///
        /// To override the contents of this collection use [`set_functions`](Self::set_functions).
        ///
        /// A list of Lambda functions in this function definition version.
        pub fn functions(mut self, input: crate::model::Function) -> Self {
            let mut v = self.functions.unwrap_or_default();
                            v.push(input);
                            self.functions = Some(v);
                            self
        }
        /// A list of Lambda functions in this function definition version.
        pub fn set_functions(mut self, input: std::option::Option<std::vec::Vec<crate::model::Function>>) -> Self {
            self.functions = input; self
        }
        /// Consumes the builder and constructs a [`CreateFunctionDefinitionVersionInput`](crate::input::CreateFunctionDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateFunctionDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateFunctionDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    default_config: self.default_config
                    ,
                    function_definition_id: self.function_definition_id
                    ,
                    functions: self.functions
                    ,
                }
            )
        }
    }
    
    
}
impl CreateFunctionDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateFunctionDefinitionVersion`](crate::operation::CreateFunctionDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateFunctionDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateFunctionDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.function_definition_id;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))?;
                let function_definition_id = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/functions/{FunctionDefinitionId}/versions", FunctionDefinitionId = function_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateFunctionDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_function_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_function_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateFunctionDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateFunctionDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateFunctionDefinitionVersionInput`](crate::input::CreateFunctionDefinitionVersionInput).
    pub fn builder() -> crate::input::create_function_definition_version_input::Builder {
        crate::input::create_function_definition_version_input::Builder::default()
    }
}

/// See [`CreateGroupInput`](crate::input::CreateGroupInput).
pub mod create_group_input {
    
    /// A builder for [`CreateGroupInput`](crate::input::CreateGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::GroupVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the group.
        pub fn initial_version(mut self, input: crate::model::GroupVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the group.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::GroupVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the group.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the group.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateGroupInput`](crate::input::CreateGroupInput).
        pub fn build(self) -> Result<crate::input::CreateGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateGroupInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateGroup`](crate::operation::CreateGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/groups").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_group(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateGroup", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateGroupInput`](crate::input::CreateGroupInput).
    pub fn builder() -> crate::input::create_group_input::Builder {
        crate::input::create_group_input::Builder::default()
    }
}

/// See [`CreateGroupCertificateAuthorityInput`](crate::input::CreateGroupCertificateAuthorityInput).
pub mod create_group_certificate_authority_input {
    
    /// A builder for [`CreateGroupCertificateAuthorityInput`](crate::input::CreateGroupCertificateAuthorityInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`CreateGroupCertificateAuthorityInput`](crate::input::CreateGroupCertificateAuthorityInput).
        pub fn build(self) -> Result<crate::input::CreateGroupCertificateAuthorityInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateGroupCertificateAuthorityInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl CreateGroupCertificateAuthorityInput {
    /// Consumes the builder and constructs an Operation<[`CreateGroupCertificateAuthority`](crate::operation::CreateGroupCertificateAuthority)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateGroupCertificateAuthority, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateGroupCertificateAuthorityInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.group_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/certificateauthorities", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateGroupCertificateAuthorityInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_group_certificate_authority(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateGroupCertificateAuthority::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateGroupCertificateAuthority", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateGroupCertificateAuthorityInput`](crate::input::CreateGroupCertificateAuthorityInput).
    pub fn builder() -> crate::input::create_group_certificate_authority_input::Builder {
        crate::input::create_group_certificate_authority_input::Builder::default()
    }
}

/// See [`CreateGroupVersionInput`](crate::input::CreateGroupVersionInput).
pub mod create_group_version_input {
    
    /// A builder for [`CreateGroupVersionInput`](crate::input::CreateGroupVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) connector_definition_version_arn: std::option::Option<std::string::String>,
        pub(crate) core_definition_version_arn: std::option::Option<std::string::String>,
        pub(crate) device_definition_version_arn: std::option::Option<std::string::String>,
        pub(crate) function_definition_version_arn: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) logger_definition_version_arn: std::option::Option<std::string::String>,
        pub(crate) resource_definition_version_arn: std::option::Option<std::string::String>,
        pub(crate) subscription_definition_version_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ARN of the connector definition version for this group.
        pub fn connector_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the connector definition version for this group.
        pub fn set_connector_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_version_arn = input; self
        }
        /// The ARN of the core definition version for this group.
        pub fn core_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the core definition version for this group.
        pub fn set_core_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_version_arn = input; self
        }
        /// The ARN of the device definition version for this group.
        pub fn device_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the device definition version for this group.
        pub fn set_device_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_version_arn = input; self
        }
        /// The ARN of the function definition version for this group.
        pub fn function_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the function definition version for this group.
        pub fn set_function_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_version_arn = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The ARN of the logger definition version for this group.
        pub fn logger_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the logger definition version for this group.
        pub fn set_logger_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_version_arn = input; self
        }
        /// The ARN of the resource definition version for this group.
        pub fn resource_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the resource definition version for this group.
        pub fn set_resource_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_version_arn = input; self
        }
        /// The ARN of the subscription definition version for this group.
        pub fn subscription_definition_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_version_arn = Some(input.into());
            self
        }
        /// The ARN of the subscription definition version for this group.
        pub fn set_subscription_definition_version_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_version_arn = input; self
        }
        /// Consumes the builder and constructs a [`CreateGroupVersionInput`](crate::input::CreateGroupVersionInput).
        pub fn build(self) -> Result<crate::input::CreateGroupVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateGroupVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    connector_definition_version_arn: self.connector_definition_version_arn
                    ,
                    core_definition_version_arn: self.core_definition_version_arn
                    ,
                    device_definition_version_arn: self.device_definition_version_arn
                    ,
                    function_definition_version_arn: self.function_definition_version_arn
                    ,
                    group_id: self.group_id
                    ,
                    logger_definition_version_arn: self.logger_definition_version_arn
                    ,
                    resource_definition_version_arn: self.resource_definition_version_arn
                    ,
                    subscription_definition_version_arn: self.subscription_definition_version_arn
                    ,
                }
            )
        }
    }
    
    
}
impl CreateGroupVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateGroupVersion`](crate::operation::CreateGroupVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateGroupVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateGroupVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_8 = &_input.group_id;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/versions", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateGroupVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_group_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_group_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateGroupVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateGroupVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateGroupVersionInput`](crate::input::CreateGroupVersionInput).
    pub fn builder() -> crate::input::create_group_version_input::Builder {
        crate::input::create_group_version_input::Builder::default()
    }
}

/// See [`CreateLoggerDefinitionInput`](crate::input::CreateLoggerDefinitionInput).
pub mod create_logger_definition_input {
    
    /// A builder for [`CreateLoggerDefinitionInput`](crate::input::CreateLoggerDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::LoggerDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the logger definition.
        pub fn initial_version(mut self, input: crate::model::LoggerDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the logger definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::LoggerDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the logger definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the logger definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateLoggerDefinitionInput`](crate::input::CreateLoggerDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateLoggerDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateLoggerDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateLoggerDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateLoggerDefinition`](crate::operation::CreateLoggerDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateLoggerDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateLoggerDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/loggers").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateLoggerDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_logger_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_logger_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateLoggerDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateLoggerDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateLoggerDefinitionInput`](crate::input::CreateLoggerDefinitionInput).
    pub fn builder() -> crate::input::create_logger_definition_input::Builder {
        crate::input::create_logger_definition_input::Builder::default()
    }
}

/// See [`CreateLoggerDefinitionVersionInput`](crate::input::CreateLoggerDefinitionVersionInput).
pub mod create_logger_definition_version_input {
    
    /// A builder for [`CreateLoggerDefinitionVersionInput`](crate::input::CreateLoggerDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) logger_definition_id: std::option::Option<std::string::String>,
        pub(crate) loggers: std::option::Option<std::vec::Vec<crate::model::Logger>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the logger definition.
        pub fn logger_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_id = Some(input.into());
            self
        }
        /// The ID of the logger definition.
        pub fn set_logger_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_id = input; self
        }
        /// Appends an item to `loggers`.
        ///
        /// To override the contents of this collection use [`set_loggers`](Self::set_loggers).
        ///
        /// A list of loggers.
        pub fn loggers(mut self, input: crate::model::Logger) -> Self {
            let mut v = self.loggers.unwrap_or_default();
                            v.push(input);
                            self.loggers = Some(v);
                            self
        }
        /// A list of loggers.
        pub fn set_loggers(mut self, input: std::option::Option<std::vec::Vec<crate::model::Logger>>) -> Self {
            self.loggers = input; self
        }
        /// Consumes the builder and constructs a [`CreateLoggerDefinitionVersionInput`](crate::input::CreateLoggerDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateLoggerDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateLoggerDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    logger_definition_id: self.logger_definition_id
                    ,
                    loggers: self.loggers
                    ,
                }
            )
        }
    }
    
    
}
impl CreateLoggerDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateLoggerDefinitionVersion`](crate::operation::CreateLoggerDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateLoggerDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateLoggerDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.logger_definition_id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))?;
                let logger_definition_id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/loggers/{LoggerDefinitionId}/versions", LoggerDefinitionId = logger_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateLoggerDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_logger_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_logger_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateLoggerDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateLoggerDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateLoggerDefinitionVersionInput`](crate::input::CreateLoggerDefinitionVersionInput).
    pub fn builder() -> crate::input::create_logger_definition_version_input::Builder {
        crate::input::create_logger_definition_version_input::Builder::default()
    }
}

/// See [`CreateResourceDefinitionInput`](crate::input::CreateResourceDefinitionInput).
pub mod create_resource_definition_input {
    
    /// A builder for [`CreateResourceDefinitionInput`](crate::input::CreateResourceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::ResourceDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the resource definition.
        pub fn initial_version(mut self, input: crate::model::ResourceDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the resource definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::ResourceDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the resource definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the resource definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateResourceDefinitionInput`](crate::input::CreateResourceDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateResourceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateResourceDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateResourceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateResourceDefinition`](crate::operation::CreateResourceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateResourceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateResourceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/resources").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateResourceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_resource_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_resource_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateResourceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateResourceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateResourceDefinitionInput`](crate::input::CreateResourceDefinitionInput).
    pub fn builder() -> crate::input::create_resource_definition_input::Builder {
        crate::input::create_resource_definition_input::Builder::default()
    }
}

/// See [`CreateResourceDefinitionVersionInput`](crate::input::CreateResourceDefinitionVersionInput).
pub mod create_resource_definition_version_input {
    
    /// A builder for [`CreateResourceDefinitionVersionInput`](crate::input::CreateResourceDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) resource_definition_id: std::option::Option<std::string::String>,
        pub(crate) resources: std::option::Option<std::vec::Vec<crate::model::Resource>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the resource definition.
        pub fn resource_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_id = Some(input.into());
            self
        }
        /// The ID of the resource definition.
        pub fn set_resource_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_id = input; self
        }
        /// Appends an item to `resources`.
        ///
        /// To override the contents of this collection use [`set_resources`](Self::set_resources).
        ///
        /// A list of resources.
        pub fn resources(mut self, input: crate::model::Resource) -> Self {
            let mut v = self.resources.unwrap_or_default();
                            v.push(input);
                            self.resources = Some(v);
                            self
        }
        /// A list of resources.
        pub fn set_resources(mut self, input: std::option::Option<std::vec::Vec<crate::model::Resource>>) -> Self {
            self.resources = input; self
        }
        /// Consumes the builder and constructs a [`CreateResourceDefinitionVersionInput`](crate::input::CreateResourceDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateResourceDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateResourceDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    resource_definition_id: self.resource_definition_id
                    ,
                    resources: self.resources
                    ,
                }
            )
        }
    }
    
    
}
impl CreateResourceDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateResourceDefinitionVersion`](crate::operation::CreateResourceDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateResourceDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateResourceDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.resource_definition_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))?;
                let resource_definition_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/resources/{ResourceDefinitionId}/versions", ResourceDefinitionId = resource_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateResourceDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_resource_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_resource_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateResourceDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateResourceDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateResourceDefinitionVersionInput`](crate::input::CreateResourceDefinitionVersionInput).
    pub fn builder() -> crate::input::create_resource_definition_version_input::Builder {
        crate::input::create_resource_definition_version_input::Builder::default()
    }
}

/// See [`CreateSoftwareUpdateJobInput`](crate::input::CreateSoftwareUpdateJobInput).
pub mod create_software_update_job_input {
    
    /// A builder for [`CreateSoftwareUpdateJobInput`](crate::input::CreateSoftwareUpdateJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) s3_url_signer_role: std::option::Option<std::string::String>,
        pub(crate) software_to_update: std::option::Option<crate::model::SoftwareToUpdate>,
        pub(crate) update_agent_log_level: std::option::Option<crate::model::UpdateAgentLogLevel>,
        pub(crate) update_targets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) update_targets_architecture: std::option::Option<crate::model::UpdateTargetsArchitecture>,
        pub(crate) update_targets_operating_system: std::option::Option<crate::model::UpdateTargetsOperatingSystem>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
        pub fn s3_url_signer_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_url_signer_role = Some(input.into());
            self
        }
        /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
        pub fn set_s3_url_signer_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_url_signer_role = input; self
        }
        /// The piece of software on the Greengrass core that will be updated.
        pub fn software_to_update(mut self, input: crate::model::SoftwareToUpdate) -> Self {
            self.software_to_update = Some(input);
            self
        }
        /// The piece of software on the Greengrass core that will be updated.
        pub fn set_software_to_update(mut self, input: std::option::Option<crate::model::SoftwareToUpdate>) -> Self {
            self.software_to_update = input; self
        }
        /// The minimum level of log statements that should be logged by the OTA Agent during an update.
        pub fn update_agent_log_level(mut self, input: crate::model::UpdateAgentLogLevel) -> Self {
            self.update_agent_log_level = Some(input);
            self
        }
        /// The minimum level of log statements that should be logged by the OTA Agent during an update.
        pub fn set_update_agent_log_level(mut self, input: std::option::Option<crate::model::UpdateAgentLogLevel>) -> Self {
            self.update_agent_log_level = input; self
        }
        /// Appends an item to `update_targets`.
        ///
        /// To override the contents of this collection use [`set_update_targets`](Self::set_update_targets).
        ///
        /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
        pub fn update_targets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.update_targets.unwrap_or_default();
                            v.push(input.into());
                            self.update_targets = Some(v);
                            self
        }
        /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
        pub fn set_update_targets(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.update_targets = input; self
        }
        /// The architecture of the cores which are the targets of an update.
        pub fn update_targets_architecture(mut self, input: crate::model::UpdateTargetsArchitecture) -> Self {
            self.update_targets_architecture = Some(input);
            self
        }
        /// The architecture of the cores which are the targets of an update.
        pub fn set_update_targets_architecture(mut self, input: std::option::Option<crate::model::UpdateTargetsArchitecture>) -> Self {
            self.update_targets_architecture = input; self
        }
        /// The operating system of the cores which are the targets of an update.
        pub fn update_targets_operating_system(mut self, input: crate::model::UpdateTargetsOperatingSystem) -> Self {
            self.update_targets_operating_system = Some(input);
            self
        }
        /// The operating system of the cores which are the targets of an update.
        pub fn set_update_targets_operating_system(mut self, input: std::option::Option<crate::model::UpdateTargetsOperatingSystem>) -> Self {
            self.update_targets_operating_system = input; self
        }
        /// Consumes the builder and constructs a [`CreateSoftwareUpdateJobInput`](crate::input::CreateSoftwareUpdateJobInput).
        pub fn build(self) -> Result<crate::input::CreateSoftwareUpdateJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSoftwareUpdateJobInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    s3_url_signer_role: self.s3_url_signer_role
                    ,
                    software_to_update: self.software_to_update
                    ,
                    update_agent_log_level: self.update_agent_log_level
                    ,
                    update_targets: self.update_targets
                    ,
                    update_targets_architecture: self.update_targets_architecture
                    ,
                    update_targets_operating_system: self.update_targets_operating_system
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSoftwareUpdateJobInput {
    /// Consumes the builder and constructs an Operation<[`CreateSoftwareUpdateJob`](crate::operation::CreateSoftwareUpdateJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSoftwareUpdateJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSoftwareUpdateJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/updates").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSoftwareUpdateJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_software_update_job(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_software_update_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSoftwareUpdateJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSoftwareUpdateJob", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSoftwareUpdateJobInput`](crate::input::CreateSoftwareUpdateJobInput).
    pub fn builder() -> crate::input::create_software_update_job_input::Builder {
        crate::input::create_software_update_job_input::Builder::default()
    }
}

/// See [`CreateSubscriptionDefinitionInput`](crate::input::CreateSubscriptionDefinitionInput).
pub mod create_subscription_definition_input {
    
    /// A builder for [`CreateSubscriptionDefinitionInput`](crate::input::CreateSubscriptionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) initial_version: std::option::Option<crate::model::SubscriptionDefinitionVersion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// Information about the initial version of the subscription definition.
        pub fn initial_version(mut self, input: crate::model::SubscriptionDefinitionVersion) -> Self {
            self.initial_version = Some(input);
            self
        }
        /// Information about the initial version of the subscription definition.
        pub fn set_initial_version(mut self, input: std::option::Option<crate::model::SubscriptionDefinitionVersion>) -> Self {
            self.initial_version = input; self
        }
        /// The name of the subscription definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the subscription definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateSubscriptionDefinitionInput`](crate::input::CreateSubscriptionDefinitionInput).
        pub fn build(self) -> Result<crate::input::CreateSubscriptionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSubscriptionDefinitionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    initial_version: self.initial_version
                    ,
                    name: self.name
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSubscriptionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateSubscriptionDefinition`](crate::operation::CreateSubscriptionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSubscriptionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSubscriptionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/subscriptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSubscriptionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_subscription_definition(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_subscription_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSubscriptionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSubscriptionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSubscriptionDefinitionInput`](crate::input::CreateSubscriptionDefinitionInput).
    pub fn builder() -> crate::input::create_subscription_definition_input::Builder {
        crate::input::create_subscription_definition_input::Builder::default()
    }
}

/// See [`CreateSubscriptionDefinitionVersionInput`](crate::input::CreateSubscriptionDefinitionVersionInput).
pub mod create_subscription_definition_version_input {
    
    /// A builder for [`CreateSubscriptionDefinitionVersionInput`](crate::input::CreateSubscriptionDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) subscription_definition_id: std::option::Option<std::string::String>,
        pub(crate) subscriptions: std::option::Option<std::vec::Vec<crate::model::Subscription>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ID of the subscription definition.
        pub fn subscription_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition.
        pub fn set_subscription_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_id = input; self
        }
        /// Appends an item to `subscriptions`.
        ///
        /// To override the contents of this collection use [`set_subscriptions`](Self::set_subscriptions).
        ///
        /// A list of subscriptions.
        pub fn subscriptions(mut self, input: crate::model::Subscription) -> Self {
            let mut v = self.subscriptions.unwrap_or_default();
                            v.push(input);
                            self.subscriptions = Some(v);
                            self
        }
        /// A list of subscriptions.
        pub fn set_subscriptions(mut self, input: std::option::Option<std::vec::Vec<crate::model::Subscription>>) -> Self {
            self.subscriptions = input; self
        }
        /// Consumes the builder and constructs a [`CreateSubscriptionDefinitionVersionInput`](crate::input::CreateSubscriptionDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::CreateSubscriptionDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSubscriptionDefinitionVersionInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    subscription_definition_id: self.subscription_definition_id
                    ,
                    subscriptions: self.subscriptions
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSubscriptionDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateSubscriptionDefinitionVersion`](crate::operation::CreateSubscriptionDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSubscriptionDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSubscriptionDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.subscription_definition_id;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))?;
                let subscription_definition_id = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions", SubscriptionDefinitionId = subscription_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSubscriptionDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_subscription_definition_version(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_subscription_definition_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSubscriptionDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSubscriptionDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSubscriptionDefinitionVersionInput`](crate::input::CreateSubscriptionDefinitionVersionInput).
    pub fn builder() -> crate::input::create_subscription_definition_version_input::Builder {
        crate::input::create_subscription_definition_version_input::Builder::default()
    }
}

/// See [`DeleteConnectorDefinitionInput`](crate::input::DeleteConnectorDefinitionInput).
pub mod delete_connector_definition_input {
    
    /// A builder for [`DeleteConnectorDefinitionInput`](crate::input::DeleteConnectorDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connector_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the connector definition.
        pub fn connector_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_id = Some(input.into());
            self
        }
        /// The ID of the connector definition.
        pub fn set_connector_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteConnectorDefinitionInput`](crate::input::DeleteConnectorDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteConnectorDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteConnectorDefinitionInput {
                    connector_definition_id: self.connector_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteConnectorDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteConnectorDefinition`](crate::operation::DeleteConnectorDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteConnectorDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteConnectorDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.connector_definition_id;
                let input_12 = input_12.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))?;
                let connector_definition_id = aws_smithy_http::label::fmt_string(input_12, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/connectors/{ConnectorDefinitionId}", ConnectorDefinitionId = connector_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteConnectorDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteConnectorDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteConnectorDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteConnectorDefinitionInput`](crate::input::DeleteConnectorDefinitionInput).
    pub fn builder() -> crate::input::delete_connector_definition_input::Builder {
        crate::input::delete_connector_definition_input::Builder::default()
    }
}

/// See [`DeleteCoreDefinitionInput`](crate::input::DeleteCoreDefinitionInput).
pub mod delete_core_definition_input {
    
    /// A builder for [`DeleteCoreDefinitionInput`](crate::input::DeleteCoreDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the core definition.
        pub fn core_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_id = Some(input.into());
            self
        }
        /// The ID of the core definition.
        pub fn set_core_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteCoreDefinitionInput`](crate::input::DeleteCoreDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteCoreDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteCoreDefinitionInput {
                    core_definition_id: self.core_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteCoreDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCoreDefinition`](crate::operation::DeleteCoreDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteCoreDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteCoreDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.core_definition_id;
                let input_13 = input_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))?;
                let core_definition_id = aws_smithy_http::label::fmt_string(input_13, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/cores/{CoreDefinitionId}", CoreDefinitionId = core_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteCoreDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteCoreDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteCoreDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteCoreDefinitionInput`](crate::input::DeleteCoreDefinitionInput).
    pub fn builder() -> crate::input::delete_core_definition_input::Builder {
        crate::input::delete_core_definition_input::Builder::default()
    }
}

/// See [`DeleteDeviceDefinitionInput`](crate::input::DeleteDeviceDefinitionInput).
pub mod delete_device_definition_input {
    
    /// A builder for [`DeleteDeviceDefinitionInput`](crate::input::DeleteDeviceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the device definition.
        pub fn device_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_id = Some(input.into());
            self
        }
        /// The ID of the device definition.
        pub fn set_device_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteDeviceDefinitionInput`](crate::input::DeleteDeviceDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteDeviceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteDeviceDefinitionInput {
                    device_definition_id: self.device_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteDeviceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDeviceDefinition`](crate::operation::DeleteDeviceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteDeviceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteDeviceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.device_definition_id;
                let input_14 = input_14.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))?;
                let device_definition_id = aws_smithy_http::label::fmt_string(input_14, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/devices/{DeviceDefinitionId}", DeviceDefinitionId = device_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteDeviceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteDeviceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteDeviceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDeviceDefinitionInput`](crate::input::DeleteDeviceDefinitionInput).
    pub fn builder() -> crate::input::delete_device_definition_input::Builder {
        crate::input::delete_device_definition_input::Builder::default()
    }
}

/// See [`DeleteFunctionDefinitionInput`](crate::input::DeleteFunctionDefinitionInput).
pub mod delete_function_definition_input {
    
    /// A builder for [`DeleteFunctionDefinitionInput`](crate::input::DeleteFunctionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Lambda function definition.
        pub fn function_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_id = Some(input.into());
            self
        }
        /// The ID of the Lambda function definition.
        pub fn set_function_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteFunctionDefinitionInput`](crate::input::DeleteFunctionDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteFunctionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteFunctionDefinitionInput {
                    function_definition_id: self.function_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteFunctionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteFunctionDefinition`](crate::operation::DeleteFunctionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteFunctionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteFunctionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_15 = &_input.function_definition_id;
                let input_15 = input_15.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))?;
                let function_definition_id = aws_smithy_http::label::fmt_string(input_15, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/functions/{FunctionDefinitionId}", FunctionDefinitionId = function_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteFunctionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteFunctionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteFunctionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteFunctionDefinitionInput`](crate::input::DeleteFunctionDefinitionInput).
    pub fn builder() -> crate::input::delete_function_definition_input::Builder {
        crate::input::delete_function_definition_input::Builder::default()
    }
}

/// See [`DeleteGroupInput`](crate::input::DeleteGroupInput).
pub mod delete_group_input {
    
    /// A builder for [`DeleteGroupInput`](crate::input::DeleteGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteGroupInput`](crate::input::DeleteGroupInput).
        pub fn build(self) -> Result<crate::input::DeleteGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteGroupInput {
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteGroup`](crate::operation::DeleteGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.group_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteGroup", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteGroupInput`](crate::input::DeleteGroupInput).
    pub fn builder() -> crate::input::delete_group_input::Builder {
        crate::input::delete_group_input::Builder::default()
    }
}

/// See [`DeleteLoggerDefinitionInput`](crate::input::DeleteLoggerDefinitionInput).
pub mod delete_logger_definition_input {
    
    /// A builder for [`DeleteLoggerDefinitionInput`](crate::input::DeleteLoggerDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logger_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the logger definition.
        pub fn logger_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_id = Some(input.into());
            self
        }
        /// The ID of the logger definition.
        pub fn set_logger_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteLoggerDefinitionInput`](crate::input::DeleteLoggerDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteLoggerDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteLoggerDefinitionInput {
                    logger_definition_id: self.logger_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteLoggerDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLoggerDefinition`](crate::operation::DeleteLoggerDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteLoggerDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteLoggerDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.logger_definition_id;
                let input_17 = input_17.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))?;
                let logger_definition_id = aws_smithy_http::label::fmt_string(input_17, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/loggers/{LoggerDefinitionId}", LoggerDefinitionId = logger_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteLoggerDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteLoggerDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteLoggerDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteLoggerDefinitionInput`](crate::input::DeleteLoggerDefinitionInput).
    pub fn builder() -> crate::input::delete_logger_definition_input::Builder {
        crate::input::delete_logger_definition_input::Builder::default()
    }
}

/// See [`DeleteResourceDefinitionInput`](crate::input::DeleteResourceDefinitionInput).
pub mod delete_resource_definition_input {
    
    /// A builder for [`DeleteResourceDefinitionInput`](crate::input::DeleteResourceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the resource definition.
        pub fn resource_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_id = Some(input.into());
            self
        }
        /// The ID of the resource definition.
        pub fn set_resource_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteResourceDefinitionInput`](crate::input::DeleteResourceDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteResourceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteResourceDefinitionInput {
                    resource_definition_id: self.resource_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteResourceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteResourceDefinition`](crate::operation::DeleteResourceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteResourceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteResourceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.resource_definition_id;
                let input_18 = input_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))?;
                let resource_definition_id = aws_smithy_http::label::fmt_string(input_18, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/resources/{ResourceDefinitionId}", ResourceDefinitionId = resource_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteResourceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteResourceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteResourceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteResourceDefinitionInput`](crate::input::DeleteResourceDefinitionInput).
    pub fn builder() -> crate::input::delete_resource_definition_input::Builder {
        crate::input::delete_resource_definition_input::Builder::default()
    }
}

/// See [`DeleteSubscriptionDefinitionInput`](crate::input::DeleteSubscriptionDefinitionInput).
pub mod delete_subscription_definition_input {
    
    /// A builder for [`DeleteSubscriptionDefinitionInput`](crate::input::DeleteSubscriptionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the subscription definition.
        pub fn subscription_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition.
        pub fn set_subscription_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteSubscriptionDefinitionInput`](crate::input::DeleteSubscriptionDefinitionInput).
        pub fn build(self) -> Result<crate::input::DeleteSubscriptionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteSubscriptionDefinitionInput {
                    subscription_definition_id: self.subscription_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteSubscriptionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSubscriptionDefinition`](crate::operation::DeleteSubscriptionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteSubscriptionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteSubscriptionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_19 = &_input.subscription_definition_id;
                let input_19 = input_19.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))?;
                let subscription_definition_id = aws_smithy_http::label::fmt_string(input_19, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}", SubscriptionDefinitionId = subscription_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteSubscriptionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteSubscriptionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteSubscriptionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionDefinitionInput`](crate::input::DeleteSubscriptionDefinitionInput).
    pub fn builder() -> crate::input::delete_subscription_definition_input::Builder {
        crate::input::delete_subscription_definition_input::Builder::default()
    }
}

/// See [`DisassociateRoleFromGroupInput`](crate::input::DisassociateRoleFromGroupInput).
pub mod disassociate_role_from_group_input {
    
    /// A builder for [`DisassociateRoleFromGroupInput`](crate::input::DisassociateRoleFromGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`DisassociateRoleFromGroupInput`](crate::input::DisassociateRoleFromGroupInput).
        pub fn build(self) -> Result<crate::input::DisassociateRoleFromGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisassociateRoleFromGroupInput {
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl DisassociateRoleFromGroupInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateRoleFromGroup`](crate::operation::DisassociateRoleFromGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisassociateRoleFromGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisassociateRoleFromGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.group_id;
                let input_20 = input_20.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_20, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/role", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisassociateRoleFromGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisassociateRoleFromGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisassociateRoleFromGroup", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateRoleFromGroupInput`](crate::input::DisassociateRoleFromGroupInput).
    pub fn builder() -> crate::input::disassociate_role_from_group_input::Builder {
        crate::input::disassociate_role_from_group_input::Builder::default()
    }
}

/// See [`DisassociateServiceRoleFromAccountInput`](crate::input::DisassociateServiceRoleFromAccountInput).
pub mod disassociate_service_role_from_account_input {
    
    /// A builder for [`DisassociateServiceRoleFromAccountInput`](crate::input::DisassociateServiceRoleFromAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DisassociateServiceRoleFromAccountInput`](crate::input::DisassociateServiceRoleFromAccountInput).
        pub fn build(self) -> Result<crate::input::DisassociateServiceRoleFromAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisassociateServiceRoleFromAccountInput {
                }
            )
        }
    }
    
    
}
impl DisassociateServiceRoleFromAccountInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateServiceRoleFromAccount`](crate::operation::DisassociateServiceRoleFromAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisassociateServiceRoleFromAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisassociateServiceRoleFromAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/servicerole").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisassociateServiceRoleFromAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisassociateServiceRoleFromAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisassociateServiceRoleFromAccount", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateServiceRoleFromAccountInput`](crate::input::DisassociateServiceRoleFromAccountInput).
    pub fn builder() -> crate::input::disassociate_service_role_from_account_input::Builder {
        crate::input::disassociate_service_role_from_account_input::Builder::default()
    }
}

/// See [`GetAssociatedRoleInput`](crate::input::GetAssociatedRoleInput).
pub mod get_associated_role_input {
    
    /// A builder for [`GetAssociatedRoleInput`](crate::input::GetAssociatedRoleInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`GetAssociatedRoleInput`](crate::input::GetAssociatedRoleInput).
        pub fn build(self) -> Result<crate::input::GetAssociatedRoleInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssociatedRoleInput {
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssociatedRoleInput {
    /// Consumes the builder and constructs an Operation<[`GetAssociatedRole`](crate::operation::GetAssociatedRole)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssociatedRole, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssociatedRoleInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_21 = &_input.group_id;
                let input_21 = input_21.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_21, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/role", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssociatedRoleInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssociatedRole::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssociatedRole", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssociatedRoleInput`](crate::input::GetAssociatedRoleInput).
    pub fn builder() -> crate::input::get_associated_role_input::Builder {
        crate::input::get_associated_role_input::Builder::default()
    }
}

/// See [`GetBulkDeploymentStatusInput`](crate::input::GetBulkDeploymentStatusInput).
pub mod get_bulk_deployment_status_input {
    
    /// A builder for [`GetBulkDeploymentStatusInput`](crate::input::GetBulkDeploymentStatusInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bulk_deployment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the bulk deployment.
        pub fn bulk_deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bulk_deployment_id = Some(input.into());
            self
        }
        /// The ID of the bulk deployment.
        pub fn set_bulk_deployment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bulk_deployment_id = input; self
        }
        /// Consumes the builder and constructs a [`GetBulkDeploymentStatusInput`](crate::input::GetBulkDeploymentStatusInput).
        pub fn build(self) -> Result<crate::input::GetBulkDeploymentStatusInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetBulkDeploymentStatusInput {
                    bulk_deployment_id: self.bulk_deployment_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetBulkDeploymentStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetBulkDeploymentStatus`](crate::operation::GetBulkDeploymentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetBulkDeploymentStatus, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetBulkDeploymentStatusInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_22 = &_input.bulk_deployment_id;
                let input_22 = input_22.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("bulk_deployment_id", "cannot be empty or unset"))?;
                let bulk_deployment_id = aws_smithy_http::label::fmt_string(input_22, aws_smithy_http::label::EncodingStrategy::Default);
                if bulk_deployment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("bulk_deployment_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/bulk/deployments/{BulkDeploymentId}/status", BulkDeploymentId = bulk_deployment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetBulkDeploymentStatusInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetBulkDeploymentStatus::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetBulkDeploymentStatus", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetBulkDeploymentStatusInput`](crate::input::GetBulkDeploymentStatusInput).
    pub fn builder() -> crate::input::get_bulk_deployment_status_input::Builder {
        crate::input::get_bulk_deployment_status_input::Builder::default()
    }
}

/// See [`GetConnectivityInfoInput`](crate::input::GetConnectivityInfoInput).
pub mod get_connectivity_info_input {
    
    /// A builder for [`GetConnectivityInfoInput`](crate::input::GetConnectivityInfoInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The thing name.
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// The thing name.
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input; self
        }
        /// Consumes the builder and constructs a [`GetConnectivityInfoInput`](crate::input::GetConnectivityInfoInput).
        pub fn build(self) -> Result<crate::input::GetConnectivityInfoInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetConnectivityInfoInput {
                    thing_name: self.thing_name
                    ,
                }
            )
        }
    }
    
    
}
impl GetConnectivityInfoInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectivityInfo`](crate::operation::GetConnectivityInfo)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetConnectivityInfo, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetConnectivityInfoInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.thing_name;
                let input_23 = input_23.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))?;
                let thing_name = aws_smithy_http::label::fmt_string(input_23, aws_smithy_http::label::EncodingStrategy::Default);
                if thing_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/things/{ThingName}/connectivityInfo", ThingName = thing_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetConnectivityInfoInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetConnectivityInfo::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetConnectivityInfo", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetConnectivityInfoInput`](crate::input::GetConnectivityInfoInput).
    pub fn builder() -> crate::input::get_connectivity_info_input::Builder {
        crate::input::get_connectivity_info_input::Builder::default()
    }
}

/// See [`GetConnectorDefinitionInput`](crate::input::GetConnectorDefinitionInput).
pub mod get_connector_definition_input {
    
    /// A builder for [`GetConnectorDefinitionInput`](crate::input::GetConnectorDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connector_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the connector definition.
        pub fn connector_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_id = Some(input.into());
            self
        }
        /// The ID of the connector definition.
        pub fn set_connector_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetConnectorDefinitionInput`](crate::input::GetConnectorDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetConnectorDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetConnectorDefinitionInput {
                    connector_definition_id: self.connector_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetConnectorDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectorDefinition`](crate::operation::GetConnectorDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetConnectorDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetConnectorDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.connector_definition_id;
                let input_24 = input_24.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))?;
                let connector_definition_id = aws_smithy_http::label::fmt_string(input_24, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/connectors/{ConnectorDefinitionId}", ConnectorDefinitionId = connector_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetConnectorDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetConnectorDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetConnectorDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetConnectorDefinitionInput`](crate::input::GetConnectorDefinitionInput).
    pub fn builder() -> crate::input::get_connector_definition_input::Builder {
        crate::input::get_connector_definition_input::Builder::default()
    }
}

/// See [`GetConnectorDefinitionVersionInput`](crate::input::GetConnectorDefinitionVersionInput).
pub mod get_connector_definition_version_input {
    
    /// A builder for [`GetConnectorDefinitionVersionInput`](crate::input::GetConnectorDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connector_definition_id: std::option::Option<std::string::String>,
        pub(crate) connector_definition_version_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the connector definition.
        pub fn connector_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_id = Some(input.into());
            self
        }
        /// The ID of the connector definition.
        pub fn set_connector_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_id = input; self
        }
        /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn connector_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_connector_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_version_id = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`GetConnectorDefinitionVersionInput`](crate::input::GetConnectorDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetConnectorDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetConnectorDefinitionVersionInput {
                    connector_definition_id: self.connector_definition_id
                    ,
                    connector_definition_version_id: self.connector_definition_version_id
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetConnectorDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectorDefinitionVersion`](crate::operation::GetConnectorDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetConnectorDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetConnectorDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_25 = &_input.connector_definition_id;
                let input_25 = input_25.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))?;
                let connector_definition_id = aws_smithy_http::label::fmt_string(input_25, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))
                            }
                let input_26 = &_input.connector_definition_version_id;
                let input_26 = input_26.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_version_id", "cannot be empty or unset"))?;
                let connector_definition_version_id = aws_smithy_http::label::fmt_string(input_26, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions/{ConnectorDefinitionVersionId}", ConnectorDefinitionId = connector_definition_id, ConnectorDefinitionVersionId = connector_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetConnectorDefinitionVersionInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_27) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_27));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetConnectorDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetConnectorDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetConnectorDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetConnectorDefinitionVersionInput`](crate::input::GetConnectorDefinitionVersionInput).
    pub fn builder() -> crate::input::get_connector_definition_version_input::Builder {
        crate::input::get_connector_definition_version_input::Builder::default()
    }
}

/// See [`GetCoreDefinitionInput`](crate::input::GetCoreDefinitionInput).
pub mod get_core_definition_input {
    
    /// A builder for [`GetCoreDefinitionInput`](crate::input::GetCoreDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the core definition.
        pub fn core_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_id = Some(input.into());
            self
        }
        /// The ID of the core definition.
        pub fn set_core_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetCoreDefinitionInput`](crate::input::GetCoreDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetCoreDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetCoreDefinitionInput {
                    core_definition_id: self.core_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetCoreDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreDefinition`](crate::operation::GetCoreDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetCoreDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetCoreDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_28 = &_input.core_definition_id;
                let input_28 = input_28.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))?;
                let core_definition_id = aws_smithy_http::label::fmt_string(input_28, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/cores/{CoreDefinitionId}", CoreDefinitionId = core_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetCoreDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetCoreDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetCoreDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetCoreDefinitionInput`](crate::input::GetCoreDefinitionInput).
    pub fn builder() -> crate::input::get_core_definition_input::Builder {
        crate::input::get_core_definition_input::Builder::default()
    }
}

/// See [`GetCoreDefinitionVersionInput`](crate::input::GetCoreDefinitionVersionInput).
pub mod get_core_definition_version_input {
    
    /// A builder for [`GetCoreDefinitionVersionInput`](crate::input::GetCoreDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_definition_id: std::option::Option<std::string::String>,
        pub(crate) core_definition_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the core definition.
        pub fn core_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_id = Some(input.into());
            self
        }
        /// The ID of the core definition.
        pub fn set_core_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_id = input; self
        }
        /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn core_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_core_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_version_id = input; self
        }
        /// Consumes the builder and constructs a [`GetCoreDefinitionVersionInput`](crate::input::GetCoreDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetCoreDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetCoreDefinitionVersionInput {
                    core_definition_id: self.core_definition_id
                    ,
                    core_definition_version_id: self.core_definition_version_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetCoreDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreDefinitionVersion`](crate::operation::GetCoreDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetCoreDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetCoreDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_29 = &_input.core_definition_id;
                let input_29 = input_29.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))?;
                let core_definition_id = aws_smithy_http::label::fmt_string(input_29, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))
                            }
                let input_30 = &_input.core_definition_version_id;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_version_id", "cannot be empty or unset"))?;
                let core_definition_version_id = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/cores/{CoreDefinitionId}/versions/{CoreDefinitionVersionId}", CoreDefinitionId = core_definition_id, CoreDefinitionVersionId = core_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetCoreDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetCoreDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetCoreDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetCoreDefinitionVersionInput`](crate::input::GetCoreDefinitionVersionInput).
    pub fn builder() -> crate::input::get_core_definition_version_input::Builder {
        crate::input::get_core_definition_version_input::Builder::default()
    }
}

/// See [`GetDeploymentStatusInput`](crate::input::GetDeploymentStatusInput).
pub mod get_deployment_status_input {
    
    /// A builder for [`GetDeploymentStatusInput`](crate::input::GetDeploymentStatusInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_id: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the deployment.
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_id = Some(input.into());
            self
        }
        /// The ID of the deployment.
        pub fn set_deployment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.deployment_id = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`GetDeploymentStatusInput`](crate::input::GetDeploymentStatusInput).
        pub fn build(self) -> Result<crate::input::GetDeploymentStatusInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDeploymentStatusInput {
                    deployment_id: self.deployment_id
                    ,
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetDeploymentStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetDeploymentStatus`](crate::operation::GetDeploymentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDeploymentStatus, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDeploymentStatusInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_31 = &_input.group_id;
                let input_31 = input_31.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_31, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                let input_32 = &_input.deployment_id;
                let input_32 = input_32.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("deployment_id", "cannot be empty or unset"))?;
                let deployment_id = aws_smithy_http::label::fmt_string(input_32, aws_smithy_http::label::EncodingStrategy::Default);
                if deployment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("deployment_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/deployments/{DeploymentId}/status", GroupId = group_id, DeploymentId = deployment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDeploymentStatusInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDeploymentStatus::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDeploymentStatus", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDeploymentStatusInput`](crate::input::GetDeploymentStatusInput).
    pub fn builder() -> crate::input::get_deployment_status_input::Builder {
        crate::input::get_deployment_status_input::Builder::default()
    }
}

/// See [`GetDeviceDefinitionInput`](crate::input::GetDeviceDefinitionInput).
pub mod get_device_definition_input {
    
    /// A builder for [`GetDeviceDefinitionInput`](crate::input::GetDeviceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the device definition.
        pub fn device_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_id = Some(input.into());
            self
        }
        /// The ID of the device definition.
        pub fn set_device_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetDeviceDefinitionInput`](crate::input::GetDeviceDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetDeviceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDeviceDefinitionInput {
                    device_definition_id: self.device_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetDeviceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetDeviceDefinition`](crate::operation::GetDeviceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDeviceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDeviceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_33 = &_input.device_definition_id;
                let input_33 = input_33.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))?;
                let device_definition_id = aws_smithy_http::label::fmt_string(input_33, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/devices/{DeviceDefinitionId}", DeviceDefinitionId = device_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDeviceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDeviceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDeviceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDeviceDefinitionInput`](crate::input::GetDeviceDefinitionInput).
    pub fn builder() -> crate::input::get_device_definition_input::Builder {
        crate::input::get_device_definition_input::Builder::default()
    }
}

/// See [`GetDeviceDefinitionVersionInput`](crate::input::GetDeviceDefinitionVersionInput).
pub mod get_device_definition_version_input {
    
    /// A builder for [`GetDeviceDefinitionVersionInput`](crate::input::GetDeviceDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_definition_id: std::option::Option<std::string::String>,
        pub(crate) device_definition_version_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the device definition.
        pub fn device_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_id = Some(input.into());
            self
        }
        /// The ID of the device definition.
        pub fn set_device_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_id = input; self
        }
        /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn device_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_device_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_version_id = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`GetDeviceDefinitionVersionInput`](crate::input::GetDeviceDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetDeviceDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDeviceDefinitionVersionInput {
                    device_definition_id: self.device_definition_id
                    ,
                    device_definition_version_id: self.device_definition_version_id
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetDeviceDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetDeviceDefinitionVersion`](crate::operation::GetDeviceDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDeviceDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDeviceDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.device_definition_id;
                let input_34 = input_34.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))?;
                let device_definition_id = aws_smithy_http::label::fmt_string(input_34, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))
                            }
                let input_35 = &_input.device_definition_version_id;
                let input_35 = input_35.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_version_id", "cannot be empty or unset"))?;
                let device_definition_version_id = aws_smithy_http::label::fmt_string(input_35, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/devices/{DeviceDefinitionId}/versions/{DeviceDefinitionVersionId}", DeviceDefinitionId = device_definition_id, DeviceDefinitionVersionId = device_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetDeviceDefinitionVersionInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_36) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_36));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDeviceDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDeviceDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDeviceDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDeviceDefinitionVersionInput`](crate::input::GetDeviceDefinitionVersionInput).
    pub fn builder() -> crate::input::get_device_definition_version_input::Builder {
        crate::input::get_device_definition_version_input::Builder::default()
    }
}

/// See [`GetFunctionDefinitionInput`](crate::input::GetFunctionDefinitionInput).
pub mod get_function_definition_input {
    
    /// A builder for [`GetFunctionDefinitionInput`](crate::input::GetFunctionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Lambda function definition.
        pub fn function_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_id = Some(input.into());
            self
        }
        /// The ID of the Lambda function definition.
        pub fn set_function_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetFunctionDefinitionInput`](crate::input::GetFunctionDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetFunctionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetFunctionDefinitionInput {
                    function_definition_id: self.function_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetFunctionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetFunctionDefinition`](crate::operation::GetFunctionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetFunctionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetFunctionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_37 = &_input.function_definition_id;
                let input_37 = input_37.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))?;
                let function_definition_id = aws_smithy_http::label::fmt_string(input_37, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/functions/{FunctionDefinitionId}", FunctionDefinitionId = function_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetFunctionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetFunctionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetFunctionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetFunctionDefinitionInput`](crate::input::GetFunctionDefinitionInput).
    pub fn builder() -> crate::input::get_function_definition_input::Builder {
        crate::input::get_function_definition_input::Builder::default()
    }
}

/// See [`GetFunctionDefinitionVersionInput`](crate::input::GetFunctionDefinitionVersionInput).
pub mod get_function_definition_version_input {
    
    /// A builder for [`GetFunctionDefinitionVersionInput`](crate::input::GetFunctionDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_definition_id: std::option::Option<std::string::String>,
        pub(crate) function_definition_version_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Lambda function definition.
        pub fn function_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_id = Some(input.into());
            self
        }
        /// The ID of the Lambda function definition.
        pub fn set_function_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_id = input; self
        }
        /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn function_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_function_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_version_id = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`GetFunctionDefinitionVersionInput`](crate::input::GetFunctionDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetFunctionDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetFunctionDefinitionVersionInput {
                    function_definition_id: self.function_definition_id
                    ,
                    function_definition_version_id: self.function_definition_version_id
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetFunctionDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetFunctionDefinitionVersion`](crate::operation::GetFunctionDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetFunctionDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetFunctionDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_38 = &_input.function_definition_id;
                let input_38 = input_38.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))?;
                let function_definition_id = aws_smithy_http::label::fmt_string(input_38, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))
                            }
                let input_39 = &_input.function_definition_version_id;
                let input_39 = input_39.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_version_id", "cannot be empty or unset"))?;
                let function_definition_version_id = aws_smithy_http::label::fmt_string(input_39, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/functions/{FunctionDefinitionId}/versions/{FunctionDefinitionVersionId}", FunctionDefinitionId = function_definition_id, FunctionDefinitionVersionId = function_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetFunctionDefinitionVersionInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_40) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_40));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetFunctionDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetFunctionDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetFunctionDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetFunctionDefinitionVersionInput`](crate::input::GetFunctionDefinitionVersionInput).
    pub fn builder() -> crate::input::get_function_definition_version_input::Builder {
        crate::input::get_function_definition_version_input::Builder::default()
    }
}

/// See [`GetGroupInput`](crate::input::GetGroupInput).
pub mod get_group_input {
    
    /// A builder for [`GetGroupInput`](crate::input::GetGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`GetGroupInput`](crate::input::GetGroupInput).
        pub fn build(self) -> Result<crate::input::GetGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetGroupInput {
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetGroupInput {
    /// Consumes the builder and constructs an Operation<[`GetGroup`](crate::operation::GetGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_41 = &_input.group_id;
                let input_41 = input_41.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_41, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetGroup", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetGroupInput`](crate::input::GetGroupInput).
    pub fn builder() -> crate::input::get_group_input::Builder {
        crate::input::get_group_input::Builder::default()
    }
}

/// See [`GetGroupCertificateAuthorityInput`](crate::input::GetGroupCertificateAuthorityInput).
pub mod get_group_certificate_authority_input {
    
    /// A builder for [`GetGroupCertificateAuthorityInput`](crate::input::GetGroupCertificateAuthorityInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_authority_id: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the certificate authority.
        pub fn certificate_authority_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_authority_id = Some(input.into());
            self
        }
        /// The ID of the certificate authority.
        pub fn set_certificate_authority_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate_authority_id = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`GetGroupCertificateAuthorityInput`](crate::input::GetGroupCertificateAuthorityInput).
        pub fn build(self) -> Result<crate::input::GetGroupCertificateAuthorityInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetGroupCertificateAuthorityInput {
                    certificate_authority_id: self.certificate_authority_id
                    ,
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetGroupCertificateAuthorityInput {
    /// Consumes the builder and constructs an Operation<[`GetGroupCertificateAuthority`](crate::operation::GetGroupCertificateAuthority)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetGroupCertificateAuthority, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetGroupCertificateAuthorityInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_42 = &_input.group_id;
                let input_42 = input_42.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_42, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                let input_43 = &_input.certificate_authority_id;
                let input_43 = input_43.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("certificate_authority_id", "cannot be empty or unset"))?;
                let certificate_authority_id = aws_smithy_http::label::fmt_string(input_43, aws_smithy_http::label::EncodingStrategy::Default);
                if certificate_authority_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("certificate_authority_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/certificateauthorities/{CertificateAuthorityId}", GroupId = group_id, CertificateAuthorityId = certificate_authority_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetGroupCertificateAuthorityInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetGroupCertificateAuthority::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetGroupCertificateAuthority", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetGroupCertificateAuthorityInput`](crate::input::GetGroupCertificateAuthorityInput).
    pub fn builder() -> crate::input::get_group_certificate_authority_input::Builder {
        crate::input::get_group_certificate_authority_input::Builder::default()
    }
}

/// See [`GetGroupCertificateConfigurationInput`](crate::input::GetGroupCertificateConfigurationInput).
pub mod get_group_certificate_configuration_input {
    
    /// A builder for [`GetGroupCertificateConfigurationInput`](crate::input::GetGroupCertificateConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`GetGroupCertificateConfigurationInput`](crate::input::GetGroupCertificateConfigurationInput).
        pub fn build(self) -> Result<crate::input::GetGroupCertificateConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetGroupCertificateConfigurationInput {
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetGroupCertificateConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetGroupCertificateConfiguration`](crate::operation::GetGroupCertificateConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetGroupCertificateConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetGroupCertificateConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_44 = &_input.group_id;
                let input_44 = input_44.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_44, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetGroupCertificateConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetGroupCertificateConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetGroupCertificateConfiguration", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetGroupCertificateConfigurationInput`](crate::input::GetGroupCertificateConfigurationInput).
    pub fn builder() -> crate::input::get_group_certificate_configuration_input::Builder {
        crate::input::get_group_certificate_configuration_input::Builder::default()
    }
}

/// See [`GetGroupVersionInput`](crate::input::GetGroupVersionInput).
pub mod get_group_version_input {
    
    /// A builder for [`GetGroupVersionInput`](crate::input::GetGroupVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
        pub fn group_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_version_id = Some(input.into());
            self
        }
        /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
        pub fn set_group_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_version_id = input; self
        }
        /// Consumes the builder and constructs a [`GetGroupVersionInput`](crate::input::GetGroupVersionInput).
        pub fn build(self) -> Result<crate::input::GetGroupVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetGroupVersionInput {
                    group_id: self.group_id
                    ,
                    group_version_id: self.group_version_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetGroupVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetGroupVersion`](crate::operation::GetGroupVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetGroupVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetGroupVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_45 = &_input.group_id;
                let input_45 = input_45.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_45, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                let input_46 = &_input.group_version_id;
                let input_46 = input_46.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_version_id", "cannot be empty or unset"))?;
                let group_version_id = aws_smithy_http::label::fmt_string(input_46, aws_smithy_http::label::EncodingStrategy::Default);
                if group_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/versions/{GroupVersionId}", GroupId = group_id, GroupVersionId = group_version_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetGroupVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetGroupVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetGroupVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetGroupVersionInput`](crate::input::GetGroupVersionInput).
    pub fn builder() -> crate::input::get_group_version_input::Builder {
        crate::input::get_group_version_input::Builder::default()
    }
}

/// See [`GetLoggerDefinitionInput`](crate::input::GetLoggerDefinitionInput).
pub mod get_logger_definition_input {
    
    /// A builder for [`GetLoggerDefinitionInput`](crate::input::GetLoggerDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logger_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the logger definition.
        pub fn logger_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_id = Some(input.into());
            self
        }
        /// The ID of the logger definition.
        pub fn set_logger_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetLoggerDefinitionInput`](crate::input::GetLoggerDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetLoggerDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetLoggerDefinitionInput {
                    logger_definition_id: self.logger_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetLoggerDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetLoggerDefinition`](crate::operation::GetLoggerDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetLoggerDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetLoggerDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_47 = &_input.logger_definition_id;
                let input_47 = input_47.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))?;
                let logger_definition_id = aws_smithy_http::label::fmt_string(input_47, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/loggers/{LoggerDefinitionId}", LoggerDefinitionId = logger_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetLoggerDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetLoggerDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetLoggerDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLoggerDefinitionInput`](crate::input::GetLoggerDefinitionInput).
    pub fn builder() -> crate::input::get_logger_definition_input::Builder {
        crate::input::get_logger_definition_input::Builder::default()
    }
}

/// See [`GetLoggerDefinitionVersionInput`](crate::input::GetLoggerDefinitionVersionInput).
pub mod get_logger_definition_version_input {
    
    /// A builder for [`GetLoggerDefinitionVersionInput`](crate::input::GetLoggerDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logger_definition_id: std::option::Option<std::string::String>,
        pub(crate) logger_definition_version_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the logger definition.
        pub fn logger_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_id = Some(input.into());
            self
        }
        /// The ID of the logger definition.
        pub fn set_logger_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_id = input; self
        }
        /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn logger_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_logger_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_version_id = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`GetLoggerDefinitionVersionInput`](crate::input::GetLoggerDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetLoggerDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetLoggerDefinitionVersionInput {
                    logger_definition_id: self.logger_definition_id
                    ,
                    logger_definition_version_id: self.logger_definition_version_id
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetLoggerDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetLoggerDefinitionVersion`](crate::operation::GetLoggerDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetLoggerDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetLoggerDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_48 = &_input.logger_definition_id;
                let input_48 = input_48.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))?;
                let logger_definition_id = aws_smithy_http::label::fmt_string(input_48, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))
                            }
                let input_49 = &_input.logger_definition_version_id;
                let input_49 = input_49.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_version_id", "cannot be empty or unset"))?;
                let logger_definition_version_id = aws_smithy_http::label::fmt_string(input_49, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/loggers/{LoggerDefinitionId}/versions/{LoggerDefinitionVersionId}", LoggerDefinitionId = logger_definition_id, LoggerDefinitionVersionId = logger_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetLoggerDefinitionVersionInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_50) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_50));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetLoggerDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetLoggerDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetLoggerDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLoggerDefinitionVersionInput`](crate::input::GetLoggerDefinitionVersionInput).
    pub fn builder() -> crate::input::get_logger_definition_version_input::Builder {
        crate::input::get_logger_definition_version_input::Builder::default()
    }
}

/// See [`GetResourceDefinitionInput`](crate::input::GetResourceDefinitionInput).
pub mod get_resource_definition_input {
    
    /// A builder for [`GetResourceDefinitionInput`](crate::input::GetResourceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the resource definition.
        pub fn resource_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_id = Some(input.into());
            self
        }
        /// The ID of the resource definition.
        pub fn set_resource_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetResourceDefinitionInput`](crate::input::GetResourceDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetResourceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetResourceDefinitionInput {
                    resource_definition_id: self.resource_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetResourceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetResourceDefinition`](crate::operation::GetResourceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetResourceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetResourceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.resource_definition_id;
                let input_51 = input_51.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))?;
                let resource_definition_id = aws_smithy_http::label::fmt_string(input_51, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/resources/{ResourceDefinitionId}", ResourceDefinitionId = resource_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetResourceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetResourceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetResourceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetResourceDefinitionInput`](crate::input::GetResourceDefinitionInput).
    pub fn builder() -> crate::input::get_resource_definition_input::Builder {
        crate::input::get_resource_definition_input::Builder::default()
    }
}

/// See [`GetResourceDefinitionVersionInput`](crate::input::GetResourceDefinitionVersionInput).
pub mod get_resource_definition_version_input {
    
    /// A builder for [`GetResourceDefinitionVersionInput`](crate::input::GetResourceDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_definition_id: std::option::Option<std::string::String>,
        pub(crate) resource_definition_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the resource definition.
        pub fn resource_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_id = Some(input.into());
            self
        }
        /// The ID of the resource definition.
        pub fn set_resource_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_id = input; self
        }
        /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn resource_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_resource_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_version_id = input; self
        }
        /// Consumes the builder and constructs a [`GetResourceDefinitionVersionInput`](crate::input::GetResourceDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetResourceDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetResourceDefinitionVersionInput {
                    resource_definition_id: self.resource_definition_id
                    ,
                    resource_definition_version_id: self.resource_definition_version_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetResourceDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetResourceDefinitionVersion`](crate::operation::GetResourceDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetResourceDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetResourceDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_52 = &_input.resource_definition_id;
                let input_52 = input_52.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))?;
                let resource_definition_id = aws_smithy_http::label::fmt_string(input_52, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))
                            }
                let input_53 = &_input.resource_definition_version_id;
                let input_53 = input_53.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_version_id", "cannot be empty or unset"))?;
                let resource_definition_version_id = aws_smithy_http::label::fmt_string(input_53, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/resources/{ResourceDefinitionId}/versions/{ResourceDefinitionVersionId}", ResourceDefinitionId = resource_definition_id, ResourceDefinitionVersionId = resource_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetResourceDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetResourceDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetResourceDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetResourceDefinitionVersionInput`](crate::input::GetResourceDefinitionVersionInput).
    pub fn builder() -> crate::input::get_resource_definition_version_input::Builder {
        crate::input::get_resource_definition_version_input::Builder::default()
    }
}

/// See [`GetServiceRoleForAccountInput`](crate::input::GetServiceRoleForAccountInput).
pub mod get_service_role_for_account_input {
    
    /// A builder for [`GetServiceRoleForAccountInput`](crate::input::GetServiceRoleForAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetServiceRoleForAccountInput`](crate::input::GetServiceRoleForAccountInput).
        pub fn build(self) -> Result<crate::input::GetServiceRoleForAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetServiceRoleForAccountInput {
                }
            )
        }
    }
    
    
}
impl GetServiceRoleForAccountInput {
    /// Consumes the builder and constructs an Operation<[`GetServiceRoleForAccount`](crate::operation::GetServiceRoleForAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetServiceRoleForAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetServiceRoleForAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/servicerole").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetServiceRoleForAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetServiceRoleForAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetServiceRoleForAccount", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetServiceRoleForAccountInput`](crate::input::GetServiceRoleForAccountInput).
    pub fn builder() -> crate::input::get_service_role_for_account_input::Builder {
        crate::input::get_service_role_for_account_input::Builder::default()
    }
}

/// See [`GetSubscriptionDefinitionInput`](crate::input::GetSubscriptionDefinitionInput).
pub mod get_subscription_definition_input {
    
    /// A builder for [`GetSubscriptionDefinitionInput`](crate::input::GetSubscriptionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the subscription definition.
        pub fn subscription_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition.
        pub fn set_subscription_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`GetSubscriptionDefinitionInput`](crate::input::GetSubscriptionDefinitionInput).
        pub fn build(self) -> Result<crate::input::GetSubscriptionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetSubscriptionDefinitionInput {
                    subscription_definition_id: self.subscription_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetSubscriptionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`GetSubscriptionDefinition`](crate::operation::GetSubscriptionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetSubscriptionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetSubscriptionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_54 = &_input.subscription_definition_id;
                let input_54 = input_54.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))?;
                let subscription_definition_id = aws_smithy_http::label::fmt_string(input_54, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}", SubscriptionDefinitionId = subscription_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetSubscriptionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetSubscriptionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetSubscriptionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSubscriptionDefinitionInput`](crate::input::GetSubscriptionDefinitionInput).
    pub fn builder() -> crate::input::get_subscription_definition_input::Builder {
        crate::input::get_subscription_definition_input::Builder::default()
    }
}

/// See [`GetSubscriptionDefinitionVersionInput`](crate::input::GetSubscriptionDefinitionVersionInput).
pub mod get_subscription_definition_version_input {
    
    /// A builder for [`GetSubscriptionDefinitionVersionInput`](crate::input::GetSubscriptionDefinitionVersionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) subscription_definition_id: std::option::Option<std::string::String>,
        pub(crate) subscription_definition_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// The ID of the subscription definition.
        pub fn subscription_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition.
        pub fn set_subscription_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_id = input; self
        }
        /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn subscription_definition_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_version_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        pub fn set_subscription_definition_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_version_id = input; self
        }
        /// Consumes the builder and constructs a [`GetSubscriptionDefinitionVersionInput`](crate::input::GetSubscriptionDefinitionVersionInput).
        pub fn build(self) -> Result<crate::input::GetSubscriptionDefinitionVersionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetSubscriptionDefinitionVersionInput {
                    next_token: self.next_token
                    ,
                    subscription_definition_id: self.subscription_definition_id
                    ,
                    subscription_definition_version_id: self.subscription_definition_version_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetSubscriptionDefinitionVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetSubscriptionDefinitionVersion`](crate::operation::GetSubscriptionDefinitionVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetSubscriptionDefinitionVersion, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetSubscriptionDefinitionVersionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_55 = &_input.subscription_definition_id;
                let input_55 = input_55.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))?;
                let subscription_definition_id = aws_smithy_http::label::fmt_string(input_55, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))
                            }
                let input_56 = &_input.subscription_definition_version_id;
                let input_56 = input_56.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_version_id", "cannot be empty or unset"))?;
                let subscription_definition_version_id = aws_smithy_http::label::fmt_string(input_56, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_version_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_version_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions/{SubscriptionDefinitionVersionId}", SubscriptionDefinitionId = subscription_definition_id, SubscriptionDefinitionVersionId = subscription_definition_version_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetSubscriptionDefinitionVersionInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_57) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_57));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetSubscriptionDefinitionVersionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetSubscriptionDefinitionVersion::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetSubscriptionDefinitionVersion", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSubscriptionDefinitionVersionInput`](crate::input::GetSubscriptionDefinitionVersionInput).
    pub fn builder() -> crate::input::get_subscription_definition_version_input::Builder {
        crate::input::get_subscription_definition_version_input::Builder::default()
    }
}

/// See [`GetThingRuntimeConfigurationInput`](crate::input::GetThingRuntimeConfigurationInput).
pub mod get_thing_runtime_configuration_input {
    
    /// A builder for [`GetThingRuntimeConfigurationInput`](crate::input::GetThingRuntimeConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The thing name.
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// The thing name.
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input; self
        }
        /// Consumes the builder and constructs a [`GetThingRuntimeConfigurationInput`](crate::input::GetThingRuntimeConfigurationInput).
        pub fn build(self) -> Result<crate::input::GetThingRuntimeConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetThingRuntimeConfigurationInput {
                    thing_name: self.thing_name
                    ,
                }
            )
        }
    }
    
    
}
impl GetThingRuntimeConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetThingRuntimeConfiguration`](crate::operation::GetThingRuntimeConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetThingRuntimeConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetThingRuntimeConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_58 = &_input.thing_name;
                let input_58 = input_58.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))?;
                let thing_name = aws_smithy_http::label::fmt_string(input_58, aws_smithy_http::label::EncodingStrategy::Default);
                if thing_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/things/{ThingName}/runtimeconfig", ThingName = thing_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetThingRuntimeConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetThingRuntimeConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetThingRuntimeConfiguration", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetThingRuntimeConfigurationInput`](crate::input::GetThingRuntimeConfigurationInput).
    pub fn builder() -> crate::input::get_thing_runtime_configuration_input::Builder {
        crate::input::get_thing_runtime_configuration_input::Builder::default()
    }
}

/// See [`ListBulkDeploymentDetailedReportsInput`](crate::input::ListBulkDeploymentDetailedReportsInput).
pub mod list_bulk_deployment_detailed_reports_input {
    
    /// A builder for [`ListBulkDeploymentDetailedReportsInput`](crate::input::ListBulkDeploymentDetailedReportsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bulk_deployment_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the bulk deployment.
        pub fn bulk_deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bulk_deployment_id = Some(input.into());
            self
        }
        /// The ID of the bulk deployment.
        pub fn set_bulk_deployment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bulk_deployment_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListBulkDeploymentDetailedReportsInput`](crate::input::ListBulkDeploymentDetailedReportsInput).
        pub fn build(self) -> Result<crate::input::ListBulkDeploymentDetailedReportsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListBulkDeploymentDetailedReportsInput {
                    bulk_deployment_id: self.bulk_deployment_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListBulkDeploymentDetailedReportsInput {
    /// Consumes the builder and constructs an Operation<[`ListBulkDeploymentDetailedReports`](crate::operation::ListBulkDeploymentDetailedReports)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListBulkDeploymentDetailedReports, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListBulkDeploymentDetailedReportsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_59 = &_input.bulk_deployment_id;
                let input_59 = input_59.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("bulk_deployment_id", "cannot be empty or unset"))?;
                let bulk_deployment_id = aws_smithy_http::label::fmt_string(input_59, aws_smithy_http::label::EncodingStrategy::Default);
                if bulk_deployment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("bulk_deployment_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/bulk/deployments/{BulkDeploymentId}/detailed-reports", BulkDeploymentId = bulk_deployment_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListBulkDeploymentDetailedReportsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_60) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                if let Some(inner_61) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_61));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListBulkDeploymentDetailedReportsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListBulkDeploymentDetailedReports::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListBulkDeploymentDetailedReports", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListBulkDeploymentDetailedReportsInput`](crate::input::ListBulkDeploymentDetailedReportsInput).
    pub fn builder() -> crate::input::list_bulk_deployment_detailed_reports_input::Builder {
        crate::input::list_bulk_deployment_detailed_reports_input::Builder::default()
    }
}

/// See [`ListBulkDeploymentsInput`](crate::input::ListBulkDeploymentsInput).
pub mod list_bulk_deployments_input {
    
    /// A builder for [`ListBulkDeploymentsInput`](crate::input::ListBulkDeploymentsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListBulkDeploymentsInput`](crate::input::ListBulkDeploymentsInput).
        pub fn build(self) -> Result<crate::input::ListBulkDeploymentsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListBulkDeploymentsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListBulkDeploymentsInput {
    /// Consumes the builder and constructs an Operation<[`ListBulkDeployments`](crate::operation::ListBulkDeployments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListBulkDeployments, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListBulkDeploymentsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/bulk/deployments").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListBulkDeploymentsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_62) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_62));
                    }
                }
                if let Some(inner_63) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_63));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListBulkDeploymentsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListBulkDeployments::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListBulkDeployments", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListBulkDeploymentsInput`](crate::input::ListBulkDeploymentsInput).
    pub fn builder() -> crate::input::list_bulk_deployments_input::Builder {
        crate::input::list_bulk_deployments_input::Builder::default()
    }
}

/// See [`ListConnectorDefinitionsInput`](crate::input::ListConnectorDefinitionsInput).
pub mod list_connector_definitions_input {
    
    /// A builder for [`ListConnectorDefinitionsInput`](crate::input::ListConnectorDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListConnectorDefinitionsInput`](crate::input::ListConnectorDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListConnectorDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListConnectorDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListConnectorDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListConnectorDefinitions`](crate::operation::ListConnectorDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListConnectorDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListConnectorDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/connectors").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListConnectorDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_64) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                if let Some(inner_65) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_65));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListConnectorDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListConnectorDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListConnectorDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListConnectorDefinitionsInput`](crate::input::ListConnectorDefinitionsInput).
    pub fn builder() -> crate::input::list_connector_definitions_input::Builder {
        crate::input::list_connector_definitions_input::Builder::default()
    }
}

/// See [`ListConnectorDefinitionVersionsInput`](crate::input::ListConnectorDefinitionVersionsInput).
pub mod list_connector_definition_versions_input {
    
    /// A builder for [`ListConnectorDefinitionVersionsInput`](crate::input::ListConnectorDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connector_definition_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the connector definition.
        pub fn connector_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_id = Some(input.into());
            self
        }
        /// The ID of the connector definition.
        pub fn set_connector_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListConnectorDefinitionVersionsInput`](crate::input::ListConnectorDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListConnectorDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListConnectorDefinitionVersionsInput {
                    connector_definition_id: self.connector_definition_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListConnectorDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListConnectorDefinitionVersions`](crate::operation::ListConnectorDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListConnectorDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListConnectorDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_66 = &_input.connector_definition_id;
                let input_66 = input_66.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))?;
                let connector_definition_id = aws_smithy_http::label::fmt_string(input_66, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions", ConnectorDefinitionId = connector_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListConnectorDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_67) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_67));
                    }
                }
                if let Some(inner_68) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_68));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListConnectorDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListConnectorDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListConnectorDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListConnectorDefinitionVersionsInput`](crate::input::ListConnectorDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_connector_definition_versions_input::Builder {
        crate::input::list_connector_definition_versions_input::Builder::default()
    }
}

/// See [`ListCoreDefinitionsInput`](crate::input::ListCoreDefinitionsInput).
pub mod list_core_definitions_input {
    
    /// A builder for [`ListCoreDefinitionsInput`](crate::input::ListCoreDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListCoreDefinitionsInput`](crate::input::ListCoreDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListCoreDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListCoreDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListCoreDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListCoreDefinitions`](crate::operation::ListCoreDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListCoreDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListCoreDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/cores").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListCoreDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_69) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_69));
                    }
                }
                if let Some(inner_70) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_70));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListCoreDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListCoreDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListCoreDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCoreDefinitionsInput`](crate::input::ListCoreDefinitionsInput).
    pub fn builder() -> crate::input::list_core_definitions_input::Builder {
        crate::input::list_core_definitions_input::Builder::default()
    }
}

/// See [`ListCoreDefinitionVersionsInput`](crate::input::ListCoreDefinitionVersionsInput).
pub mod list_core_definition_versions_input {
    
    /// A builder for [`ListCoreDefinitionVersionsInput`](crate::input::ListCoreDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_definition_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the core definition.
        pub fn core_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_id = Some(input.into());
            self
        }
        /// The ID of the core definition.
        pub fn set_core_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListCoreDefinitionVersionsInput`](crate::input::ListCoreDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListCoreDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListCoreDefinitionVersionsInput {
                    core_definition_id: self.core_definition_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListCoreDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListCoreDefinitionVersions`](crate::operation::ListCoreDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListCoreDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListCoreDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_71 = &_input.core_definition_id;
                let input_71 = input_71.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))?;
                let core_definition_id = aws_smithy_http::label::fmt_string(input_71, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/cores/{CoreDefinitionId}/versions", CoreDefinitionId = core_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListCoreDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_72) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_72));
                    }
                }
                if let Some(inner_73) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_73));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListCoreDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListCoreDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListCoreDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCoreDefinitionVersionsInput`](crate::input::ListCoreDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_core_definition_versions_input::Builder {
        crate::input::list_core_definition_versions_input::Builder::default()
    }
}

/// See [`ListDeploymentsInput`](crate::input::ListDeploymentsInput).
pub mod list_deployments_input {
    
    /// A builder for [`ListDeploymentsInput`](crate::input::ListDeploymentsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListDeploymentsInput`](crate::input::ListDeploymentsInput).
        pub fn build(self) -> Result<crate::input::ListDeploymentsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListDeploymentsInput {
                    group_id: self.group_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListDeploymentsInput {
    /// Consumes the builder and constructs an Operation<[`ListDeployments`](crate::operation::ListDeployments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListDeployments, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListDeploymentsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_74 = &_input.group_id;
                let input_74 = input_74.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_74, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/deployments", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListDeploymentsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_75) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_75));
                    }
                }
                if let Some(inner_76) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_76));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListDeploymentsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListDeployments::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListDeployments", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDeploymentsInput`](crate::input::ListDeploymentsInput).
    pub fn builder() -> crate::input::list_deployments_input::Builder {
        crate::input::list_deployments_input::Builder::default()
    }
}

/// See [`ListDeviceDefinitionsInput`](crate::input::ListDeviceDefinitionsInput).
pub mod list_device_definitions_input {
    
    /// A builder for [`ListDeviceDefinitionsInput`](crate::input::ListDeviceDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListDeviceDefinitionsInput`](crate::input::ListDeviceDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListDeviceDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListDeviceDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListDeviceDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListDeviceDefinitions`](crate::operation::ListDeviceDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListDeviceDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListDeviceDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/devices").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListDeviceDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_77) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_77));
                    }
                }
                if let Some(inner_78) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_78));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListDeviceDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListDeviceDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListDeviceDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDeviceDefinitionsInput`](crate::input::ListDeviceDefinitionsInput).
    pub fn builder() -> crate::input::list_device_definitions_input::Builder {
        crate::input::list_device_definitions_input::Builder::default()
    }
}

/// See [`ListDeviceDefinitionVersionsInput`](crate::input::ListDeviceDefinitionVersionsInput).
pub mod list_device_definition_versions_input {
    
    /// A builder for [`ListDeviceDefinitionVersionsInput`](crate::input::ListDeviceDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_definition_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the device definition.
        pub fn device_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_id = Some(input.into());
            self
        }
        /// The ID of the device definition.
        pub fn set_device_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListDeviceDefinitionVersionsInput`](crate::input::ListDeviceDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListDeviceDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListDeviceDefinitionVersionsInput {
                    device_definition_id: self.device_definition_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListDeviceDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListDeviceDefinitionVersions`](crate::operation::ListDeviceDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListDeviceDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListDeviceDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_79 = &_input.device_definition_id;
                let input_79 = input_79.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))?;
                let device_definition_id = aws_smithy_http::label::fmt_string(input_79, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/devices/{DeviceDefinitionId}/versions", DeviceDefinitionId = device_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListDeviceDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_80) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_80));
                    }
                }
                if let Some(inner_81) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_81));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListDeviceDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListDeviceDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListDeviceDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDeviceDefinitionVersionsInput`](crate::input::ListDeviceDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_device_definition_versions_input::Builder {
        crate::input::list_device_definition_versions_input::Builder::default()
    }
}

/// See [`ListFunctionDefinitionsInput`](crate::input::ListFunctionDefinitionsInput).
pub mod list_function_definitions_input {
    
    /// A builder for [`ListFunctionDefinitionsInput`](crate::input::ListFunctionDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListFunctionDefinitionsInput`](crate::input::ListFunctionDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListFunctionDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListFunctionDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListFunctionDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListFunctionDefinitions`](crate::operation::ListFunctionDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListFunctionDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListFunctionDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/functions").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListFunctionDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_82) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_82));
                    }
                }
                if let Some(inner_83) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_83));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListFunctionDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListFunctionDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListFunctionDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListFunctionDefinitionsInput`](crate::input::ListFunctionDefinitionsInput).
    pub fn builder() -> crate::input::list_function_definitions_input::Builder {
        crate::input::list_function_definitions_input::Builder::default()
    }
}

/// See [`ListFunctionDefinitionVersionsInput`](crate::input::ListFunctionDefinitionVersionsInput).
pub mod list_function_definition_versions_input {
    
    /// A builder for [`ListFunctionDefinitionVersionsInput`](crate::input::ListFunctionDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_definition_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Lambda function definition.
        pub fn function_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_id = Some(input.into());
            self
        }
        /// The ID of the Lambda function definition.
        pub fn set_function_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListFunctionDefinitionVersionsInput`](crate::input::ListFunctionDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListFunctionDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListFunctionDefinitionVersionsInput {
                    function_definition_id: self.function_definition_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListFunctionDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListFunctionDefinitionVersions`](crate::operation::ListFunctionDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListFunctionDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListFunctionDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_84 = &_input.function_definition_id;
                let input_84 = input_84.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))?;
                let function_definition_id = aws_smithy_http::label::fmt_string(input_84, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/functions/{FunctionDefinitionId}/versions", FunctionDefinitionId = function_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListFunctionDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_85) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_85));
                    }
                }
                if let Some(inner_86) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_86));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListFunctionDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListFunctionDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListFunctionDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListFunctionDefinitionVersionsInput`](crate::input::ListFunctionDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_function_definition_versions_input::Builder {
        crate::input::list_function_definition_versions_input::Builder::default()
    }
}

/// See [`ListGroupCertificateAuthoritiesInput`](crate::input::ListGroupCertificateAuthoritiesInput).
pub mod list_group_certificate_authorities_input {
    
    /// A builder for [`ListGroupCertificateAuthoritiesInput`](crate::input::ListGroupCertificateAuthoritiesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`ListGroupCertificateAuthoritiesInput`](crate::input::ListGroupCertificateAuthoritiesInput).
        pub fn build(self) -> Result<crate::input::ListGroupCertificateAuthoritiesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListGroupCertificateAuthoritiesInput {
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl ListGroupCertificateAuthoritiesInput {
    /// Consumes the builder and constructs an Operation<[`ListGroupCertificateAuthorities`](crate::operation::ListGroupCertificateAuthorities)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListGroupCertificateAuthorities, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListGroupCertificateAuthoritiesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_87 = &_input.group_id;
                let input_87 = input_87.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_87, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/certificateauthorities", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListGroupCertificateAuthoritiesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListGroupCertificateAuthorities::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListGroupCertificateAuthorities", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListGroupCertificateAuthoritiesInput`](crate::input::ListGroupCertificateAuthoritiesInput).
    pub fn builder() -> crate::input::list_group_certificate_authorities_input::Builder {
        crate::input::list_group_certificate_authorities_input::Builder::default()
    }
}

/// See [`ListGroupsInput`](crate::input::ListGroupsInput).
pub mod list_groups_input {
    
    /// A builder for [`ListGroupsInput`](crate::input::ListGroupsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListGroupsInput`](crate::input::ListGroupsInput).
        pub fn build(self) -> Result<crate::input::ListGroupsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListGroupsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListGroups`](crate::operation::ListGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListGroups, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListGroupsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/groups").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListGroupsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_88) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_88));
                    }
                }
                if let Some(inner_89) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_89));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListGroupsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListGroups::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListGroups", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListGroupsInput`](crate::input::ListGroupsInput).
    pub fn builder() -> crate::input::list_groups_input::Builder {
        crate::input::list_groups_input::Builder::default()
    }
}

/// See [`ListGroupVersionsInput`](crate::input::ListGroupVersionsInput).
pub mod list_group_versions_input {
    
    /// A builder for [`ListGroupVersionsInput`](crate::input::ListGroupVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListGroupVersionsInput`](crate::input::ListGroupVersionsInput).
        pub fn build(self) -> Result<crate::input::ListGroupVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListGroupVersionsInput {
                    group_id: self.group_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListGroupVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListGroupVersions`](crate::operation::ListGroupVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListGroupVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListGroupVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_90 = &_input.group_id;
                let input_90 = input_90.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_90, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/versions", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListGroupVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_91) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_91));
                    }
                }
                if let Some(inner_92) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_92));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListGroupVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListGroupVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListGroupVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListGroupVersionsInput`](crate::input::ListGroupVersionsInput).
    pub fn builder() -> crate::input::list_group_versions_input::Builder {
        crate::input::list_group_versions_input::Builder::default()
    }
}

/// See [`ListLoggerDefinitionsInput`](crate::input::ListLoggerDefinitionsInput).
pub mod list_logger_definitions_input {
    
    /// A builder for [`ListLoggerDefinitionsInput`](crate::input::ListLoggerDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListLoggerDefinitionsInput`](crate::input::ListLoggerDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListLoggerDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListLoggerDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListLoggerDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListLoggerDefinitions`](crate::operation::ListLoggerDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListLoggerDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListLoggerDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/loggers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListLoggerDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_93) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_93));
                    }
                }
                if let Some(inner_94) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_94));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListLoggerDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListLoggerDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListLoggerDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLoggerDefinitionsInput`](crate::input::ListLoggerDefinitionsInput).
    pub fn builder() -> crate::input::list_logger_definitions_input::Builder {
        crate::input::list_logger_definitions_input::Builder::default()
    }
}

/// See [`ListLoggerDefinitionVersionsInput`](crate::input::ListLoggerDefinitionVersionsInput).
pub mod list_logger_definition_versions_input {
    
    /// A builder for [`ListLoggerDefinitionVersionsInput`](crate::input::ListLoggerDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logger_definition_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the logger definition.
        pub fn logger_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_id = Some(input.into());
            self
        }
        /// The ID of the logger definition.
        pub fn set_logger_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_id = input; self
        }
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListLoggerDefinitionVersionsInput`](crate::input::ListLoggerDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListLoggerDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListLoggerDefinitionVersionsInput {
                    logger_definition_id: self.logger_definition_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListLoggerDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListLoggerDefinitionVersions`](crate::operation::ListLoggerDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListLoggerDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListLoggerDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_95 = &_input.logger_definition_id;
                let input_95 = input_95.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))?;
                let logger_definition_id = aws_smithy_http::label::fmt_string(input_95, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/loggers/{LoggerDefinitionId}/versions", LoggerDefinitionId = logger_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListLoggerDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_96) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_96));
                    }
                }
                if let Some(inner_97) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_97));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListLoggerDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListLoggerDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListLoggerDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLoggerDefinitionVersionsInput`](crate::input::ListLoggerDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_logger_definition_versions_input::Builder {
        crate::input::list_logger_definition_versions_input::Builder::default()
    }
}

/// See [`ListResourceDefinitionsInput`](crate::input::ListResourceDefinitionsInput).
pub mod list_resource_definitions_input {
    
    /// A builder for [`ListResourceDefinitionsInput`](crate::input::ListResourceDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListResourceDefinitionsInput`](crate::input::ListResourceDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListResourceDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListResourceDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListResourceDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListResourceDefinitions`](crate::operation::ListResourceDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListResourceDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListResourceDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/resources").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListResourceDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_98) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_98));
                    }
                }
                if let Some(inner_99) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_99));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListResourceDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListResourceDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListResourceDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListResourceDefinitionsInput`](crate::input::ListResourceDefinitionsInput).
    pub fn builder() -> crate::input::list_resource_definitions_input::Builder {
        crate::input::list_resource_definitions_input::Builder::default()
    }
}

/// See [`ListResourceDefinitionVersionsInput`](crate::input::ListResourceDefinitionVersionsInput).
pub mod list_resource_definition_versions_input {
    
    /// A builder for [`ListResourceDefinitionVersionsInput`](crate::input::ListResourceDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) resource_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// The ID of the resource definition.
        pub fn resource_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_id = Some(input.into());
            self
        }
        /// The ID of the resource definition.
        pub fn set_resource_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`ListResourceDefinitionVersionsInput`](crate::input::ListResourceDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListResourceDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListResourceDefinitionVersionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    resource_definition_id: self.resource_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl ListResourceDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListResourceDefinitionVersions`](crate::operation::ListResourceDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListResourceDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListResourceDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_100 = &_input.resource_definition_id;
                let input_100 = input_100.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))?;
                let resource_definition_id = aws_smithy_http::label::fmt_string(input_100, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/resources/{ResourceDefinitionId}/versions", ResourceDefinitionId = resource_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListResourceDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_101) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_101));
                    }
                }
                if let Some(inner_102) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_102));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListResourceDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListResourceDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListResourceDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListResourceDefinitionVersionsInput`](crate::input::ListResourceDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_resource_definition_versions_input::Builder {
        crate::input::list_resource_definition_versions_input::Builder::default()
    }
}

/// See [`ListSubscriptionDefinitionsInput`](crate::input::ListSubscriptionDefinitionsInput).
pub mod list_subscription_definitions_input {
    
    /// A builder for [`ListSubscriptionDefinitionsInput`](crate::input::ListSubscriptionDefinitionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListSubscriptionDefinitionsInput`](crate::input::ListSubscriptionDefinitionsInput).
        pub fn build(self) -> Result<crate::input::ListSubscriptionDefinitionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListSubscriptionDefinitionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListSubscriptionDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListSubscriptionDefinitions`](crate::operation::ListSubscriptionDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListSubscriptionDefinitions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListSubscriptionDefinitionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/definition/subscriptions").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListSubscriptionDefinitionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_103) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_103));
                    }
                }
                if let Some(inner_104) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_104));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListSubscriptionDefinitionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListSubscriptionDefinitions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListSubscriptionDefinitions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSubscriptionDefinitionsInput`](crate::input::ListSubscriptionDefinitionsInput).
    pub fn builder() -> crate::input::list_subscription_definitions_input::Builder {
        crate::input::list_subscription_definitions_input::Builder::default()
    }
}

/// See [`ListSubscriptionDefinitionVersionsInput`](crate::input::ListSubscriptionDefinitionVersionsInput).
pub mod list_subscription_definition_versions_input {
    
    /// A builder for [`ListSubscriptionDefinitionVersionsInput`](crate::input::ListSubscriptionDefinitionVersionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) subscription_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The maximum number of results to be returned per request.
        pub fn max_results(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_results = Some(input.into());
            self
        }
        /// The maximum number of results to be returned per request.
        pub fn set_max_results(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_results = input; self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// The token for the next set of results, or ''null'' if there are no additional results.
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// The ID of the subscription definition.
        pub fn subscription_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition.
        pub fn set_subscription_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`ListSubscriptionDefinitionVersionsInput`](crate::input::ListSubscriptionDefinitionVersionsInput).
        pub fn build(self) -> Result<crate::input::ListSubscriptionDefinitionVersionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListSubscriptionDefinitionVersionsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    subscription_definition_id: self.subscription_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl ListSubscriptionDefinitionVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListSubscriptionDefinitionVersions`](crate::operation::ListSubscriptionDefinitionVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListSubscriptionDefinitionVersions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListSubscriptionDefinitionVersionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_105 = &_input.subscription_definition_id;
                let input_105 = input_105.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))?;
                let subscription_definition_id = aws_smithy_http::label::fmt_string(input_105, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions", SubscriptionDefinitionId = subscription_definition_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListSubscriptionDefinitionVersionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_106) = &_input.max_results {
                     {
                        query.push_kv("MaxResults", &aws_smithy_http::query::fmt_string(&inner_106));
                    }
                }
                if let Some(inner_107) = &_input.next_token {
                     {
                        query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_107));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListSubscriptionDefinitionVersionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListSubscriptionDefinitionVersions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListSubscriptionDefinitionVersions", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSubscriptionDefinitionVersionsInput`](crate::input::ListSubscriptionDefinitionVersionsInput).
    pub fn builder() -> crate::input::list_subscription_definition_versions_input::Builder {
        crate::input::list_subscription_definition_versions_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {
    
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The Amazon Resource Name (ARN) of the resource.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// The Amazon Resource Name (ARN) of the resource.
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(self) -> Result<crate::input::ListTagsForResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTagsForResourceInput {
                    resource_arn: self.resource_arn
                    ,
                }
            )
        }
    }
    
    
}
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTagsForResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTagsForResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_108 = &_input.resource_arn;
                let input_108 = input_108.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_108, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTagsForResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTagsForResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTagsForResource", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ResetDeploymentsInput`](crate::input::ResetDeploymentsInput).
pub mod reset_deployments_input {
    
    /// A builder for [`ResetDeploymentsInput`](crate::input::ResetDeploymentsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// If true, performs a best-effort only core reset.
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// If true, performs a best-effort only core reset.
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`ResetDeploymentsInput`](crate::input::ResetDeploymentsInput).
        pub fn build(self) -> Result<crate::input::ResetDeploymentsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ResetDeploymentsInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    force: self.force
                        .unwrap_or_default()
                    ,
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl ResetDeploymentsInput {
    /// Consumes the builder and constructs an Operation<[`ResetDeployments`](crate::operation::ResetDeployments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ResetDeployments, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ResetDeploymentsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_109 = &_input.group_id;
                let input_109 = input_109.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_109, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/deployments/$reset", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ResetDeploymentsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_reset_deployments(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_reset_deployments(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ResetDeployments::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ResetDeployments", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ResetDeploymentsInput`](crate::input::ResetDeploymentsInput).
    pub fn builder() -> crate::input::reset_deployments_input::Builder {
        crate::input::reset_deployments_input::Builder::default()
    }
}

/// See [`StartBulkDeploymentInput`](crate::input::StartBulkDeploymentInput).
pub mod start_bulk_deployment_input {
    
    /// A builder for [`StartBulkDeploymentInput`](crate::input::StartBulkDeploymentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amzn_client_token: std::option::Option<std::string::String>,
        pub(crate) execution_role_arn: std::option::Option<std::string::String>,
        pub(crate) input_file_uri: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// A client token used to correlate requests and responses.
        pub fn amzn_client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.amzn_client_token = Some(input.into());
            self
        }
        /// A client token used to correlate requests and responses.
        pub fn set_amzn_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amzn_client_token = input; self
        }
        /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
        pub fn execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role_arn = Some(input.into());
            self
        }
        /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
        pub fn set_execution_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_role_arn = input; self
        }
        /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
        pub fn input_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_file_uri = Some(input.into());
            self
        }
        /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
        pub fn set_input_file_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_file_uri = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// Tag(s) to add to the new resource.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// Tag(s) to add to the new resource.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`StartBulkDeploymentInput`](crate::input::StartBulkDeploymentInput).
        pub fn build(self) -> Result<crate::input::StartBulkDeploymentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartBulkDeploymentInput {
                    amzn_client_token: self.amzn_client_token
                    ,
                    execution_role_arn: self.execution_role_arn
                    ,
                    input_file_uri: self.input_file_uri
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl StartBulkDeploymentInput {
    /// Consumes the builder and constructs an Operation<[`StartBulkDeployment`](crate::operation::StartBulkDeployment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartBulkDeployment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartBulkDeploymentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/greengrass/bulk/deployments").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartBulkDeploymentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_start_bulk_deployment(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_bulk_deployment(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartBulkDeployment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartBulkDeployment", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartBulkDeploymentInput`](crate::input::StartBulkDeploymentInput).
    pub fn builder() -> crate::input::start_bulk_deployment_input::Builder {
        crate::input::start_bulk_deployment_input::Builder::default()
    }
}

/// See [`StopBulkDeploymentInput`](crate::input::StopBulkDeploymentInput).
pub mod stop_bulk_deployment_input {
    
    /// A builder for [`StopBulkDeploymentInput`](crate::input::StopBulkDeploymentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bulk_deployment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the bulk deployment.
        pub fn bulk_deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bulk_deployment_id = Some(input.into());
            self
        }
        /// The ID of the bulk deployment.
        pub fn set_bulk_deployment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bulk_deployment_id = input; self
        }
        /// Consumes the builder and constructs a [`StopBulkDeploymentInput`](crate::input::StopBulkDeploymentInput).
        pub fn build(self) -> Result<crate::input::StopBulkDeploymentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StopBulkDeploymentInput {
                    bulk_deployment_id: self.bulk_deployment_id
                    ,
                }
            )
        }
    }
    
    
}
impl StopBulkDeploymentInput {
    /// Consumes the builder and constructs an Operation<[`StopBulkDeployment`](crate::operation::StopBulkDeployment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StopBulkDeployment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StopBulkDeploymentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_110 = &_input.bulk_deployment_id;
                let input_110 = input_110.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("bulk_deployment_id", "cannot be empty or unset"))?;
                let bulk_deployment_id = aws_smithy_http::label::fmt_string(input_110, aws_smithy_http::label::EncodingStrategy::Default);
                if bulk_deployment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("bulk_deployment_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/bulk/deployments/{BulkDeploymentId}/$stop", BulkDeploymentId = bulk_deployment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StopBulkDeploymentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StopBulkDeployment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StopBulkDeployment", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StopBulkDeploymentInput`](crate::input::StopBulkDeploymentInput).
    pub fn builder() -> crate::input::stop_bulk_deployment_input::Builder {
        crate::input::stop_bulk_deployment_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {
    
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// The Amazon Resource Name (ARN) of the resource.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// The Amazon Resource Name (ARN) of the resource.
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// The key-value pair for the resource tag.
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// The key-value pair for the resource tag.
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(self) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::TagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::TagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::TagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_111 = &_input.resource_arn;
                let input_111 = input_111.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_111, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::TagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("TagResource", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {
    
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// The Amazon Resource Name (ARN) of the resource.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// The Amazon Resource Name (ARN) of the resource.
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// An array of tag keys to delete
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
                            v.push(input.into());
                            self.tag_keys = Some(v);
                            self
        }
        /// An array of tag keys to delete
        pub fn set_tag_keys(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.tag_keys = input; self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(self) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UntagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tag_keys: self.tag_keys
                    ,
                }
            )
        }
    }
    
    
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UntagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UntagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_112 = &_input.resource_arn;
                let input_112 = input_112.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_112, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UntagResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_113 = &_input.tag_keys;
                let inner_113 = inner_113.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("tag_keys", "cannot be empty or unset"))?;
                for inner_114 in inner_113 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_114));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UntagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UntagResource", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateConnectivityInfoInput`](crate::input::UpdateConnectivityInfoInput).
pub mod update_connectivity_info_input {
    
    /// A builder for [`UpdateConnectivityInfoInput`](crate::input::UpdateConnectivityInfoInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connectivity_info: std::option::Option<std::vec::Vec<crate::model::ConnectivityInfo>>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `connectivity_info`.
        ///
        /// To override the contents of this collection use [`set_connectivity_info`](Self::set_connectivity_info).
        ///
        /// A list of connectivity info.
        pub fn connectivity_info(mut self, input: crate::model::ConnectivityInfo) -> Self {
            let mut v = self.connectivity_info.unwrap_or_default();
                            v.push(input);
                            self.connectivity_info = Some(v);
                            self
        }
        /// A list of connectivity info.
        pub fn set_connectivity_info(mut self, input: std::option::Option<std::vec::Vec<crate::model::ConnectivityInfo>>) -> Self {
            self.connectivity_info = input; self
        }
        /// The thing name.
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// The thing name.
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateConnectivityInfoInput`](crate::input::UpdateConnectivityInfoInput).
        pub fn build(self) -> Result<crate::input::UpdateConnectivityInfoInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateConnectivityInfoInput {
                    connectivity_info: self.connectivity_info
                    ,
                    thing_name: self.thing_name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateConnectivityInfoInput {
    /// Consumes the builder and constructs an Operation<[`UpdateConnectivityInfo`](crate::operation::UpdateConnectivityInfo)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateConnectivityInfo, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateConnectivityInfoInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_115 = &_input.thing_name;
                let input_115 = input_115.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))?;
                let thing_name = aws_smithy_http::label::fmt_string(input_115, aws_smithy_http::label::EncodingStrategy::Default);
                if thing_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/things/{ThingName}/connectivityInfo", ThingName = thing_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateConnectivityInfoInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_connectivity_info(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateConnectivityInfo::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateConnectivityInfo", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateConnectivityInfoInput`](crate::input::UpdateConnectivityInfoInput).
    pub fn builder() -> crate::input::update_connectivity_info_input::Builder {
        crate::input::update_connectivity_info_input::Builder::default()
    }
}

/// See [`UpdateConnectorDefinitionInput`](crate::input::UpdateConnectorDefinitionInput).
pub mod update_connector_definition_input {
    
    /// A builder for [`UpdateConnectorDefinitionInput`](crate::input::UpdateConnectorDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connector_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the connector definition.
        pub fn connector_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connector_definition_id = Some(input.into());
            self
        }
        /// The ID of the connector definition.
        pub fn set_connector_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connector_definition_id = input; self
        }
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateConnectorDefinitionInput`](crate::input::UpdateConnectorDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateConnectorDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateConnectorDefinitionInput {
                    connector_definition_id: self.connector_definition_id
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateConnectorDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateConnectorDefinition`](crate::operation::UpdateConnectorDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateConnectorDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateConnectorDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_116 = &_input.connector_definition_id;
                let input_116 = input_116.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))?;
                let connector_definition_id = aws_smithy_http::label::fmt_string(input_116, aws_smithy_http::label::EncodingStrategy::Default);
                if connector_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("connector_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/connectors/{ConnectorDefinitionId}", ConnectorDefinitionId = connector_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateConnectorDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_connector_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateConnectorDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateConnectorDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateConnectorDefinitionInput`](crate::input::UpdateConnectorDefinitionInput).
    pub fn builder() -> crate::input::update_connector_definition_input::Builder {
        crate::input::update_connector_definition_input::Builder::default()
    }
}

/// See [`UpdateCoreDefinitionInput`](crate::input::UpdateCoreDefinitionInput).
pub mod update_core_definition_input {
    
    /// A builder for [`UpdateCoreDefinitionInput`](crate::input::UpdateCoreDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the core definition.
        pub fn core_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_definition_id = Some(input.into());
            self
        }
        /// The ID of the core definition.
        pub fn set_core_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_definition_id = input; self
        }
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateCoreDefinitionInput`](crate::input::UpdateCoreDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateCoreDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateCoreDefinitionInput {
                    core_definition_id: self.core_definition_id
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateCoreDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCoreDefinition`](crate::operation::UpdateCoreDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateCoreDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateCoreDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_117 = &_input.core_definition_id;
                let input_117 = input_117.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))?;
                let core_definition_id = aws_smithy_http::label::fmt_string(input_117, aws_smithy_http::label::EncodingStrategy::Default);
                if core_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("core_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/cores/{CoreDefinitionId}", CoreDefinitionId = core_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateCoreDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_core_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateCoreDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateCoreDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateCoreDefinitionInput`](crate::input::UpdateCoreDefinitionInput).
    pub fn builder() -> crate::input::update_core_definition_input::Builder {
        crate::input::update_core_definition_input::Builder::default()
    }
}

/// See [`UpdateDeviceDefinitionInput`](crate::input::UpdateDeviceDefinitionInput).
pub mod update_device_definition_input {
    
    /// A builder for [`UpdateDeviceDefinitionInput`](crate::input::UpdateDeviceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the device definition.
        pub fn device_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_definition_id = Some(input.into());
            self
        }
        /// The ID of the device definition.
        pub fn set_device_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_definition_id = input; self
        }
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateDeviceDefinitionInput`](crate::input::UpdateDeviceDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateDeviceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateDeviceDefinitionInput {
                    device_definition_id: self.device_definition_id
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateDeviceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDeviceDefinition`](crate::operation::UpdateDeviceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateDeviceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateDeviceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_118 = &_input.device_definition_id;
                let input_118 = input_118.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))?;
                let device_definition_id = aws_smithy_http::label::fmt_string(input_118, aws_smithy_http::label::EncodingStrategy::Default);
                if device_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("device_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/devices/{DeviceDefinitionId}", DeviceDefinitionId = device_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateDeviceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_device_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateDeviceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateDeviceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDeviceDefinitionInput`](crate::input::UpdateDeviceDefinitionInput).
    pub fn builder() -> crate::input::update_device_definition_input::Builder {
        crate::input::update_device_definition_input::Builder::default()
    }
}

/// See [`UpdateFunctionDefinitionInput`](crate::input::UpdateFunctionDefinitionInput).
pub mod update_function_definition_input {
    
    /// A builder for [`UpdateFunctionDefinitionInput`](crate::input::UpdateFunctionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Lambda function definition.
        pub fn function_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_definition_id = Some(input.into());
            self
        }
        /// The ID of the Lambda function definition.
        pub fn set_function_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_definition_id = input; self
        }
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateFunctionDefinitionInput`](crate::input::UpdateFunctionDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateFunctionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateFunctionDefinitionInput {
                    function_definition_id: self.function_definition_id
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateFunctionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateFunctionDefinition`](crate::operation::UpdateFunctionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateFunctionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateFunctionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_119 = &_input.function_definition_id;
                let input_119 = input_119.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))?;
                let function_definition_id = aws_smithy_http::label::fmt_string(input_119, aws_smithy_http::label::EncodingStrategy::Default);
                if function_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("function_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/functions/{FunctionDefinitionId}", FunctionDefinitionId = function_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateFunctionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_function_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateFunctionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateFunctionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateFunctionDefinitionInput`](crate::input::UpdateFunctionDefinitionInput).
    pub fn builder() -> crate::input::update_function_definition_input::Builder {
        crate::input::update_function_definition_input::Builder::default()
    }
}

/// See [`UpdateGroupInput`](crate::input::UpdateGroupInput).
pub mod update_group_input {
    
    /// A builder for [`UpdateGroupInput`](crate::input::UpdateGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateGroupInput`](crate::input::UpdateGroupInput).
        pub fn build(self) -> Result<crate::input::UpdateGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateGroupInput {
                    group_id: self.group_id
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGroup`](crate::operation::UpdateGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_120 = &_input.group_id;
                let input_120 = input_120.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_120, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateGroup", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateGroupInput`](crate::input::UpdateGroupInput).
    pub fn builder() -> crate::input::update_group_input::Builder {
        crate::input::update_group_input::Builder::default()
    }
}

/// See [`UpdateGroupCertificateConfigurationInput`](crate::input::UpdateGroupCertificateConfigurationInput).
pub mod update_group_certificate_configuration_input {
    
    /// A builder for [`UpdateGroupCertificateConfigurationInput`](crate::input::UpdateGroupCertificateConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_expiry_in_milliseconds: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The amount of time remaining before the certificate expires, in milliseconds.
        pub fn certificate_expiry_in_milliseconds(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_expiry_in_milliseconds = Some(input.into());
            self
        }
        /// The amount of time remaining before the certificate expires, in milliseconds.
        pub fn set_certificate_expiry_in_milliseconds(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate_expiry_in_milliseconds = input; self
        }
        /// The ID of the Greengrass group.
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// The ID of the Greengrass group.
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input; self
        }
        /// Consumes the builder and constructs a [`UpdateGroupCertificateConfigurationInput`](crate::input::UpdateGroupCertificateConfigurationInput).
        pub fn build(self) -> Result<crate::input::UpdateGroupCertificateConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateGroupCertificateConfigurationInput {
                    certificate_expiry_in_milliseconds: self.certificate_expiry_in_milliseconds
                    ,
                    group_id: self.group_id
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateGroupCertificateConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGroupCertificateConfiguration`](crate::operation::UpdateGroupCertificateConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateGroupCertificateConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateGroupCertificateConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_121 = &_input.group_id;
                let input_121 = input_121.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))?;
                let group_id = aws_smithy_http::label::fmt_string(input_121, aws_smithy_http::label::EncodingStrategy::Default);
                if group_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("group_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry", GroupId = group_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateGroupCertificateConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_group_certificate_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateGroupCertificateConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateGroupCertificateConfiguration", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateGroupCertificateConfigurationInput`](crate::input::UpdateGroupCertificateConfigurationInput).
    pub fn builder() -> crate::input::update_group_certificate_configuration_input::Builder {
        crate::input::update_group_certificate_configuration_input::Builder::default()
    }
}

/// See [`UpdateLoggerDefinitionInput`](crate::input::UpdateLoggerDefinitionInput).
pub mod update_logger_definition_input {
    
    /// A builder for [`UpdateLoggerDefinitionInput`](crate::input::UpdateLoggerDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logger_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The ID of the logger definition.
        pub fn logger_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logger_definition_id = Some(input.into());
            self
        }
        /// The ID of the logger definition.
        pub fn set_logger_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logger_definition_id = input; self
        }
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateLoggerDefinitionInput`](crate::input::UpdateLoggerDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateLoggerDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateLoggerDefinitionInput {
                    logger_definition_id: self.logger_definition_id
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateLoggerDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLoggerDefinition`](crate::operation::UpdateLoggerDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateLoggerDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateLoggerDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_122 = &_input.logger_definition_id;
                let input_122 = input_122.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))?;
                let logger_definition_id = aws_smithy_http::label::fmt_string(input_122, aws_smithy_http::label::EncodingStrategy::Default);
                if logger_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("logger_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/loggers/{LoggerDefinitionId}", LoggerDefinitionId = logger_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateLoggerDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_logger_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateLoggerDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateLoggerDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateLoggerDefinitionInput`](crate::input::UpdateLoggerDefinitionInput).
    pub fn builder() -> crate::input::update_logger_definition_input::Builder {
        crate::input::update_logger_definition_input::Builder::default()
    }
}

/// See [`UpdateResourceDefinitionInput`](crate::input::UpdateResourceDefinitionInput).
pub mod update_resource_definition_input {
    
    /// A builder for [`UpdateResourceDefinitionInput`](crate::input::UpdateResourceDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) resource_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// The ID of the resource definition.
        pub fn resource_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_definition_id = Some(input.into());
            self
        }
        /// The ID of the resource definition.
        pub fn set_resource_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`UpdateResourceDefinitionInput`](crate::input::UpdateResourceDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateResourceDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateResourceDefinitionInput {
                    name: self.name
                    ,
                    resource_definition_id: self.resource_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateResourceDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateResourceDefinition`](crate::operation::UpdateResourceDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateResourceDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateResourceDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_123 = &_input.resource_definition_id;
                let input_123 = input_123.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))?;
                let resource_definition_id = aws_smithy_http::label::fmt_string(input_123, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/resources/{ResourceDefinitionId}", ResourceDefinitionId = resource_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateResourceDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_resource_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateResourceDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateResourceDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateResourceDefinitionInput`](crate::input::UpdateResourceDefinitionInput).
    pub fn builder() -> crate::input::update_resource_definition_input::Builder {
        crate::input::update_resource_definition_input::Builder::default()
    }
}

/// See [`UpdateSubscriptionDefinitionInput`](crate::input::UpdateSubscriptionDefinitionInput).
pub mod update_subscription_definition_input {
    
    /// A builder for [`UpdateSubscriptionDefinitionInput`](crate::input::UpdateSubscriptionDefinitionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) subscription_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The name of the definition.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// The name of the definition.
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// The ID of the subscription definition.
        pub fn subscription_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_definition_id = Some(input.into());
            self
        }
        /// The ID of the subscription definition.
        pub fn set_subscription_definition_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_definition_id = input; self
        }
        /// Consumes the builder and constructs a [`UpdateSubscriptionDefinitionInput`](crate::input::UpdateSubscriptionDefinitionInput).
        pub fn build(self) -> Result<crate::input::UpdateSubscriptionDefinitionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateSubscriptionDefinitionInput {
                    name: self.name
                    ,
                    subscription_definition_id: self.subscription_definition_id
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateSubscriptionDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSubscriptionDefinition`](crate::operation::UpdateSubscriptionDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateSubscriptionDefinition, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateSubscriptionDefinitionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_124 = &_input.subscription_definition_id;
                let input_124 = input_124.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))?;
                let subscription_definition_id = aws_smithy_http::label::fmt_string(input_124, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_definition_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_definition_id", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}", SubscriptionDefinitionId = subscription_definition_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateSubscriptionDefinitionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_subscription_definition(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateSubscriptionDefinition::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateSubscriptionDefinition", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSubscriptionDefinitionInput`](crate::input::UpdateSubscriptionDefinitionInput).
    pub fn builder() -> crate::input::update_subscription_definition_input::Builder {
        crate::input::update_subscription_definition_input::Builder::default()
    }
}

/// See [`UpdateThingRuntimeConfigurationInput`](crate::input::UpdateThingRuntimeConfigurationInput).
pub mod update_thing_runtime_configuration_input {
    
    /// A builder for [`UpdateThingRuntimeConfigurationInput`](crate::input::UpdateThingRuntimeConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) telemetry_configuration: std::option::Option<crate::model::TelemetryConfigurationUpdate>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Configuration for telemetry service.
        pub fn telemetry_configuration(mut self, input: crate::model::TelemetryConfigurationUpdate) -> Self {
            self.telemetry_configuration = Some(input);
            self
        }
        /// Configuration for telemetry service.
        pub fn set_telemetry_configuration(mut self, input: std::option::Option<crate::model::TelemetryConfigurationUpdate>) -> Self {
            self.telemetry_configuration = input; self
        }
        /// The thing name.
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// The thing name.
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateThingRuntimeConfigurationInput`](crate::input::UpdateThingRuntimeConfigurationInput).
        pub fn build(self) -> Result<crate::input::UpdateThingRuntimeConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateThingRuntimeConfigurationInput {
                    telemetry_configuration: self.telemetry_configuration
                    ,
                    thing_name: self.thing_name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateThingRuntimeConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateThingRuntimeConfiguration`](crate::operation::UpdateThingRuntimeConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateThingRuntimeConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateThingRuntimeConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_125 = &_input.thing_name;
                let input_125 = input_125.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))?;
                let thing_name = aws_smithy_http::label::fmt_string(input_125, aws_smithy_http::label::EncodingStrategy::Default);
                if thing_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("thing_name", "cannot be empty or unset"))
                            }
                write!(output, "/greengrass/things/{ThingName}/runtimeconfig", ThingName = thing_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateThingRuntimeConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_thing_runtime_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateThingRuntimeConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateThingRuntimeConfiguration", "greengrass"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateThingRuntimeConfigurationInput`](crate::input::UpdateThingRuntimeConfigurationInput).
    pub fn builder() -> crate::input::update_thing_runtime_configuration_input::Builder {
        crate::input::update_thing_runtime_configuration_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateThingRuntimeConfigurationInput  {
    /// Configuration for telemetry service.
    #[doc(hidden)]
    pub telemetry_configuration: std::option::Option<crate::model::TelemetryConfigurationUpdate>,
    /// The thing name.
    #[doc(hidden)]
    pub thing_name: std::option::Option<std::string::String>,
}
impl UpdateThingRuntimeConfigurationInput {
    /// Configuration for telemetry service.
    pub fn telemetry_configuration(&self) -> std::option::Option<& crate::model::TelemetryConfigurationUpdate> {
        self.telemetry_configuration.as_ref()
    }
    /// The thing name.
    pub fn thing_name(&self) -> std::option::Option<& str> {
        self.thing_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSubscriptionDefinitionInput  {
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// The ID of the subscription definition.
    #[doc(hidden)]
    pub subscription_definition_id: std::option::Option<std::string::String>,
}
impl UpdateSubscriptionDefinitionInput {
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// The ID of the subscription definition.
    pub fn subscription_definition_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateResourceDefinitionInput  {
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// The ID of the resource definition.
    #[doc(hidden)]
    pub resource_definition_id: std::option::Option<std::string::String>,
}
impl UpdateResourceDefinitionInput {
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// The ID of the resource definition.
    pub fn resource_definition_id(&self) -> std::option::Option<& str> {
        self.resource_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateLoggerDefinitionInput  {
    /// The ID of the logger definition.
    #[doc(hidden)]
    pub logger_definition_id: std::option::Option<std::string::String>,
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl UpdateLoggerDefinitionInput {
    /// The ID of the logger definition.
    pub fn logger_definition_id(&self) -> std::option::Option<& str> {
        self.logger_definition_id.as_deref()
    }
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateGroupCertificateConfigurationInput  {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    #[doc(hidden)]
    pub certificate_expiry_in_milliseconds: std::option::Option<std::string::String>,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl UpdateGroupCertificateConfigurationInput {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    pub fn certificate_expiry_in_milliseconds(&self) -> std::option::Option<& str> {
        self.certificate_expiry_in_milliseconds.as_deref()
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateGroupInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl UpdateGroupInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFunctionDefinitionInput  {
    /// The ID of the Lambda function definition.
    #[doc(hidden)]
    pub function_definition_id: std::option::Option<std::string::String>,
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl UpdateFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    pub fn function_definition_id(&self) -> std::option::Option<& str> {
        self.function_definition_id.as_deref()
    }
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDeviceDefinitionInput  {
    /// The ID of the device definition.
    #[doc(hidden)]
    pub device_definition_id: std::option::Option<std::string::String>,
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl UpdateDeviceDefinitionInput {
    /// The ID of the device definition.
    pub fn device_definition_id(&self) -> std::option::Option<& str> {
        self.device_definition_id.as_deref()
    }
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCoreDefinitionInput  {
    /// The ID of the core definition.
    #[doc(hidden)]
    pub core_definition_id: std::option::Option<std::string::String>,
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl UpdateCoreDefinitionInput {
    /// The ID of the core definition.
    pub fn core_definition_id(&self) -> std::option::Option<& str> {
        self.core_definition_id.as_deref()
    }
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateConnectorDefinitionInput  {
    /// The ID of the connector definition.
    #[doc(hidden)]
    pub connector_definition_id: std::option::Option<std::string::String>,
    /// The name of the definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl UpdateConnectorDefinitionInput {
    /// The ID of the connector definition.
    pub fn connector_definition_id(&self) -> std::option::Option<& str> {
        self.connector_definition_id.as_deref()
    }
    /// The name of the definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

/// Connectivity information.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateConnectivityInfoInput  {
    /// A list of connectivity info.
    #[doc(hidden)]
    pub connectivity_info: std::option::Option<std::vec::Vec<crate::model::ConnectivityInfo>>,
    /// The thing name.
    #[doc(hidden)]
    pub thing_name: std::option::Option<std::string::String>,
}
impl UpdateConnectivityInfoInput {
    /// A list of connectivity info.
    pub fn connectivity_info(&self) -> std::option::Option<& [crate::model::ConnectivityInfo]> {
        self.connectivity_info.as_deref()
    }
    /// The thing name.
    pub fn thing_name(&self) -> std::option::Option<& str> {
        self.thing_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput  {
    /// The Amazon Resource Name (ARN) of the resource.
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// An array of tag keys to delete
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// An array of tag keys to delete
    pub fn tag_keys(&self) -> std::option::Option<& [std::string::String]> {
        self.tag_keys.as_deref()
    }
}

/// A map of the key-value pairs for the resource tag.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput  {
    /// The Amazon Resource Name (ARN) of the resource.
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// The key-value pair for the resource tag.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// The key-value pair for the resource tag.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopBulkDeploymentInput  {
    /// The ID of the bulk deployment.
    #[doc(hidden)]
    pub bulk_deployment_id: std::option::Option<std::string::String>,
}
impl StopBulkDeploymentInput {
    /// The ID of the bulk deployment.
    pub fn bulk_deployment_id(&self) -> std::option::Option<& str> {
        self.bulk_deployment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartBulkDeploymentInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    #[doc(hidden)]
    pub execution_role_arn: std::option::Option<std::string::String>,
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    #[doc(hidden)]
    pub input_file_uri: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StartBulkDeploymentInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    pub fn execution_role_arn(&self) -> std::option::Option<& str> {
        self.execution_role_arn.as_deref()
    }
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    pub fn input_file_uri(&self) -> std::option::Option<& str> {
        self.input_file_uri.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

/// Information needed to reset deployments.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResetDeploymentsInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// If true, performs a best-effort only core reset.
    #[doc(hidden)]
    pub force: bool,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl ResetDeploymentsInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// If true, performs a best-effort only core reset.
    pub fn force(&self) -> bool {
        self.force
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput  {
    /// The Amazon Resource Name (ARN) of the resource.
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSubscriptionDefinitionVersionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// The ID of the subscription definition.
    #[doc(hidden)]
    pub subscription_definition_id: std::option::Option<std::string::String>,
}
impl ListSubscriptionDefinitionVersionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// The ID of the subscription definition.
    pub fn subscription_definition_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSubscriptionDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSubscriptionDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListResourceDefinitionVersionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// The ID of the resource definition.
    #[doc(hidden)]
    pub resource_definition_id: std::option::Option<std::string::String>,
}
impl ListResourceDefinitionVersionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// The ID of the resource definition.
    pub fn resource_definition_id(&self) -> std::option::Option<& str> {
        self.resource_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListResourceDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListResourceDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLoggerDefinitionVersionsInput  {
    /// The ID of the logger definition.
    #[doc(hidden)]
    pub logger_definition_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLoggerDefinitionVersionsInput {
    /// The ID of the logger definition.
    pub fn logger_definition_id(&self) -> std::option::Option<& str> {
        self.logger_definition_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLoggerDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLoggerDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListGroupVersionsInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListGroupVersionsInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListGroupsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListGroupsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListGroupCertificateAuthoritiesInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl ListGroupCertificateAuthoritiesInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFunctionDefinitionVersionsInput  {
    /// The ID of the Lambda function definition.
    #[doc(hidden)]
    pub function_definition_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListFunctionDefinitionVersionsInput {
    /// The ID of the Lambda function definition.
    pub fn function_definition_id(&self) -> std::option::Option<& str> {
        self.function_definition_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFunctionDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListFunctionDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDeviceDefinitionVersionsInput  {
    /// The ID of the device definition.
    #[doc(hidden)]
    pub device_definition_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDeviceDefinitionVersionsInput {
    /// The ID of the device definition.
    pub fn device_definition_id(&self) -> std::option::Option<& str> {
        self.device_definition_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDeviceDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDeviceDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDeploymentsInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDeploymentsInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCoreDefinitionVersionsInput  {
    /// The ID of the core definition.
    #[doc(hidden)]
    pub core_definition_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCoreDefinitionVersionsInput {
    /// The ID of the core definition.
    pub fn core_definition_id(&self) -> std::option::Option<& str> {
        self.core_definition_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCoreDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCoreDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListConnectorDefinitionVersionsInput  {
    /// The ID of the connector definition.
    #[doc(hidden)]
    pub connector_definition_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListConnectorDefinitionVersionsInput {
    /// The ID of the connector definition.
    pub fn connector_definition_id(&self) -> std::option::Option<& str> {
        self.connector_definition_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListConnectorDefinitionsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListConnectorDefinitionsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListBulkDeploymentsInput  {
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListBulkDeploymentsInput {
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListBulkDeploymentDetailedReportsInput  {
    /// The ID of the bulk deployment.
    #[doc(hidden)]
    pub bulk_deployment_id: std::option::Option<std::string::String>,
    /// The maximum number of results to be returned per request.
    #[doc(hidden)]
    pub max_results: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListBulkDeploymentDetailedReportsInput {
    /// The ID of the bulk deployment.
    pub fn bulk_deployment_id(&self) -> std::option::Option<& str> {
        self.bulk_deployment_id.as_deref()
    }
    /// The maximum number of results to be returned per request.
    pub fn max_results(&self) -> std::option::Option<& str> {
        self.max_results.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetThingRuntimeConfigurationInput  {
    /// The thing name.
    #[doc(hidden)]
    pub thing_name: std::option::Option<std::string::String>,
}
impl GetThingRuntimeConfigurationInput {
    /// The thing name.
    pub fn thing_name(&self) -> std::option::Option<& str> {
        self.thing_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSubscriptionDefinitionVersionInput  {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// The ID of the subscription definition.
    #[doc(hidden)]
    pub subscription_definition_id: std::option::Option<std::string::String>,
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub subscription_definition_version_id: std::option::Option<std::string::String>,
}
impl GetSubscriptionDefinitionVersionInput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// The ID of the subscription definition.
    pub fn subscription_definition_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_id.as_deref()
    }
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn subscription_definition_version_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_version_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSubscriptionDefinitionInput  {
    /// The ID of the subscription definition.
    #[doc(hidden)]
    pub subscription_definition_id: std::option::Option<std::string::String>,
}
impl GetSubscriptionDefinitionInput {
    /// The ID of the subscription definition.
    pub fn subscription_definition_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetServiceRoleForAccountInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetResourceDefinitionVersionInput  {
    /// The ID of the resource definition.
    #[doc(hidden)]
    pub resource_definition_id: std::option::Option<std::string::String>,
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub resource_definition_version_id: std::option::Option<std::string::String>,
}
impl GetResourceDefinitionVersionInput {
    /// The ID of the resource definition.
    pub fn resource_definition_id(&self) -> std::option::Option<& str> {
        self.resource_definition_id.as_deref()
    }
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn resource_definition_version_id(&self) -> std::option::Option<& str> {
        self.resource_definition_version_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetResourceDefinitionInput  {
    /// The ID of the resource definition.
    #[doc(hidden)]
    pub resource_definition_id: std::option::Option<std::string::String>,
}
impl GetResourceDefinitionInput {
    /// The ID of the resource definition.
    pub fn resource_definition_id(&self) -> std::option::Option<& str> {
        self.resource_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLoggerDefinitionVersionInput  {
    /// The ID of the logger definition.
    #[doc(hidden)]
    pub logger_definition_id: std::option::Option<std::string::String>,
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub logger_definition_version_id: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetLoggerDefinitionVersionInput {
    /// The ID of the logger definition.
    pub fn logger_definition_id(&self) -> std::option::Option<& str> {
        self.logger_definition_id.as_deref()
    }
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn logger_definition_version_id(&self) -> std::option::Option<& str> {
        self.logger_definition_version_id.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLoggerDefinitionInput  {
    /// The ID of the logger definition.
    #[doc(hidden)]
    pub logger_definition_id: std::option::Option<std::string::String>,
}
impl GetLoggerDefinitionInput {
    /// The ID of the logger definition.
    pub fn logger_definition_id(&self) -> std::option::Option<& str> {
        self.logger_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetGroupVersionInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    #[doc(hidden)]
    pub group_version_id: std::option::Option<std::string::String>,
}
impl GetGroupVersionInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    pub fn group_version_id(&self) -> std::option::Option<& str> {
        self.group_version_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetGroupCertificateConfigurationInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl GetGroupCertificateConfigurationInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetGroupCertificateAuthorityInput  {
    /// The ID of the certificate authority.
    #[doc(hidden)]
    pub certificate_authority_id: std::option::Option<std::string::String>,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl GetGroupCertificateAuthorityInput {
    /// The ID of the certificate authority.
    pub fn certificate_authority_id(&self) -> std::option::Option<& str> {
        self.certificate_authority_id.as_deref()
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetGroupInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl GetGroupInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetFunctionDefinitionVersionInput  {
    /// The ID of the Lambda function definition.
    #[doc(hidden)]
    pub function_definition_id: std::option::Option<std::string::String>,
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub function_definition_version_id: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetFunctionDefinitionVersionInput {
    /// The ID of the Lambda function definition.
    pub fn function_definition_id(&self) -> std::option::Option<& str> {
        self.function_definition_id.as_deref()
    }
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn function_definition_version_id(&self) -> std::option::Option<& str> {
        self.function_definition_version_id.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetFunctionDefinitionInput  {
    /// The ID of the Lambda function definition.
    #[doc(hidden)]
    pub function_definition_id: std::option::Option<std::string::String>,
}
impl GetFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    pub fn function_definition_id(&self) -> std::option::Option<& str> {
        self.function_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDeviceDefinitionVersionInput  {
    /// The ID of the device definition.
    #[doc(hidden)]
    pub device_definition_id: std::option::Option<std::string::String>,
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub device_definition_version_id: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetDeviceDefinitionVersionInput {
    /// The ID of the device definition.
    pub fn device_definition_id(&self) -> std::option::Option<& str> {
        self.device_definition_id.as_deref()
    }
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn device_definition_version_id(&self) -> std::option::Option<& str> {
        self.device_definition_version_id.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDeviceDefinitionInput  {
    /// The ID of the device definition.
    #[doc(hidden)]
    pub device_definition_id: std::option::Option<std::string::String>,
}
impl GetDeviceDefinitionInput {
    /// The ID of the device definition.
    pub fn device_definition_id(&self) -> std::option::Option<& str> {
        self.device_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDeploymentStatusInput  {
    /// The ID of the deployment.
    #[doc(hidden)]
    pub deployment_id: std::option::Option<std::string::String>,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl GetDeploymentStatusInput {
    /// The ID of the deployment.
    pub fn deployment_id(&self) -> std::option::Option<& str> {
        self.deployment_id.as_deref()
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCoreDefinitionVersionInput  {
    /// The ID of the core definition.
    #[doc(hidden)]
    pub core_definition_id: std::option::Option<std::string::String>,
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub core_definition_version_id: std::option::Option<std::string::String>,
}
impl GetCoreDefinitionVersionInput {
    /// The ID of the core definition.
    pub fn core_definition_id(&self) -> std::option::Option<& str> {
        self.core_definition_id.as_deref()
    }
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn core_definition_version_id(&self) -> std::option::Option<& str> {
        self.core_definition_version_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCoreDefinitionInput  {
    /// The ID of the core definition.
    #[doc(hidden)]
    pub core_definition_id: std::option::Option<std::string::String>,
}
impl GetCoreDefinitionInput {
    /// The ID of the core definition.
    pub fn core_definition_id(&self) -> std::option::Option<& str> {
        self.core_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectorDefinitionVersionInput  {
    /// The ID of the connector definition.
    #[doc(hidden)]
    pub connector_definition_id: std::option::Option<std::string::String>,
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    #[doc(hidden)]
    pub connector_definition_version_id: std::option::Option<std::string::String>,
    /// The token for the next set of results, or ''null'' if there are no additional results.
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetConnectorDefinitionVersionInput {
    /// The ID of the connector definition.
    pub fn connector_definition_id(&self) -> std::option::Option<& str> {
        self.connector_definition_id.as_deref()
    }
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    pub fn connector_definition_version_id(&self) -> std::option::Option<& str> {
        self.connector_definition_version_id.as_deref()
    }
    /// The token for the next set of results, or ''null'' if there are no additional results.
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectorDefinitionInput  {
    /// The ID of the connector definition.
    #[doc(hidden)]
    pub connector_definition_id: std::option::Option<std::string::String>,
}
impl GetConnectorDefinitionInput {
    /// The ID of the connector definition.
    pub fn connector_definition_id(&self) -> std::option::Option<& str> {
        self.connector_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectivityInfoInput  {
    /// The thing name.
    #[doc(hidden)]
    pub thing_name: std::option::Option<std::string::String>,
}
impl GetConnectivityInfoInput {
    /// The thing name.
    pub fn thing_name(&self) -> std::option::Option<& str> {
        self.thing_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetBulkDeploymentStatusInput  {
    /// The ID of the bulk deployment.
    #[doc(hidden)]
    pub bulk_deployment_id: std::option::Option<std::string::String>,
}
impl GetBulkDeploymentStatusInput {
    /// The ID of the bulk deployment.
    pub fn bulk_deployment_id(&self) -> std::option::Option<& str> {
        self.bulk_deployment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssociatedRoleInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl GetAssociatedRoleInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateServiceRoleFromAccountInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateRoleFromGroupInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl DisassociateRoleFromGroupInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSubscriptionDefinitionInput  {
    /// The ID of the subscription definition.
    #[doc(hidden)]
    pub subscription_definition_id: std::option::Option<std::string::String>,
}
impl DeleteSubscriptionDefinitionInput {
    /// The ID of the subscription definition.
    pub fn subscription_definition_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteResourceDefinitionInput  {
    /// The ID of the resource definition.
    #[doc(hidden)]
    pub resource_definition_id: std::option::Option<std::string::String>,
}
impl DeleteResourceDefinitionInput {
    /// The ID of the resource definition.
    pub fn resource_definition_id(&self) -> std::option::Option<& str> {
        self.resource_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteLoggerDefinitionInput  {
    /// The ID of the logger definition.
    #[doc(hidden)]
    pub logger_definition_id: std::option::Option<std::string::String>,
}
impl DeleteLoggerDefinitionInput {
    /// The ID of the logger definition.
    pub fn logger_definition_id(&self) -> std::option::Option<& str> {
        self.logger_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteGroupInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl DeleteGroupInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteFunctionDefinitionInput  {
    /// The ID of the Lambda function definition.
    #[doc(hidden)]
    pub function_definition_id: std::option::Option<std::string::String>,
}
impl DeleteFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    pub fn function_definition_id(&self) -> std::option::Option<& str> {
        self.function_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDeviceDefinitionInput  {
    /// The ID of the device definition.
    #[doc(hidden)]
    pub device_definition_id: std::option::Option<std::string::String>,
}
impl DeleteDeviceDefinitionInput {
    /// The ID of the device definition.
    pub fn device_definition_id(&self) -> std::option::Option<& str> {
        self.device_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCoreDefinitionInput  {
    /// The ID of the core definition.
    #[doc(hidden)]
    pub core_definition_id: std::option::Option<std::string::String>,
}
impl DeleteCoreDefinitionInput {
    /// The ID of the core definition.
    pub fn core_definition_id(&self) -> std::option::Option<& str> {
        self.core_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteConnectorDefinitionInput  {
    /// The ID of the connector definition.
    #[doc(hidden)]
    pub connector_definition_id: std::option::Option<std::string::String>,
}
impl DeleteConnectorDefinitionInput {
    /// The ID of the connector definition.
    pub fn connector_definition_id(&self) -> std::option::Option<& str> {
        self.connector_definition_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSubscriptionDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the subscription definition.
    #[doc(hidden)]
    pub subscription_definition_id: std::option::Option<std::string::String>,
    /// A list of subscriptions.
    #[doc(hidden)]
    pub subscriptions: std::option::Option<std::vec::Vec<crate::model::Subscription>>,
}
impl CreateSubscriptionDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the subscription definition.
    pub fn subscription_definition_id(&self) -> std::option::Option<& str> {
        self.subscription_definition_id.as_deref()
    }
    /// A list of subscriptions.
    pub fn subscriptions(&self) -> std::option::Option<& [crate::model::Subscription]> {
        self.subscriptions.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSubscriptionDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the subscription definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::SubscriptionDefinitionVersion>,
    /// The name of the subscription definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateSubscriptionDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the subscription definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::SubscriptionDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the subscription definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSoftwareUpdateJobInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    #[doc(hidden)]
    pub s3_url_signer_role: std::option::Option<std::string::String>,
    /// The piece of software on the Greengrass core that will be updated.
    #[doc(hidden)]
    pub software_to_update: std::option::Option<crate::model::SoftwareToUpdate>,
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    #[doc(hidden)]
    pub update_agent_log_level: std::option::Option<crate::model::UpdateAgentLogLevel>,
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    #[doc(hidden)]
    pub update_targets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// The architecture of the cores which are the targets of an update.
    #[doc(hidden)]
    pub update_targets_architecture: std::option::Option<crate::model::UpdateTargetsArchitecture>,
    /// The operating system of the cores which are the targets of an update.
    #[doc(hidden)]
    pub update_targets_operating_system: std::option::Option<crate::model::UpdateTargetsOperatingSystem>,
}
impl CreateSoftwareUpdateJobInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    pub fn s3_url_signer_role(&self) -> std::option::Option<& str> {
        self.s3_url_signer_role.as_deref()
    }
    /// The piece of software on the Greengrass core that will be updated.
    pub fn software_to_update(&self) -> std::option::Option<& crate::model::SoftwareToUpdate> {
        self.software_to_update.as_ref()
    }
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    pub fn update_agent_log_level(&self) -> std::option::Option<& crate::model::UpdateAgentLogLevel> {
        self.update_agent_log_level.as_ref()
    }
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    pub fn update_targets(&self) -> std::option::Option<& [std::string::String]> {
        self.update_targets.as_deref()
    }
    /// The architecture of the cores which are the targets of an update.
    pub fn update_targets_architecture(&self) -> std::option::Option<& crate::model::UpdateTargetsArchitecture> {
        self.update_targets_architecture.as_ref()
    }
    /// The operating system of the cores which are the targets of an update.
    pub fn update_targets_operating_system(&self) -> std::option::Option<& crate::model::UpdateTargetsOperatingSystem> {
        self.update_targets_operating_system.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateResourceDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the resource definition.
    #[doc(hidden)]
    pub resource_definition_id: std::option::Option<std::string::String>,
    /// A list of resources.
    #[doc(hidden)]
    pub resources: std::option::Option<std::vec::Vec<crate::model::Resource>>,
}
impl CreateResourceDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the resource definition.
    pub fn resource_definition_id(&self) -> std::option::Option<& str> {
        self.resource_definition_id.as_deref()
    }
    /// A list of resources.
    pub fn resources(&self) -> std::option::Option<& [crate::model::Resource]> {
        self.resources.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateResourceDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the resource definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::ResourceDefinitionVersion>,
    /// The name of the resource definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateResourceDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the resource definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::ResourceDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the resource definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateLoggerDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the logger definition.
    #[doc(hidden)]
    pub logger_definition_id: std::option::Option<std::string::String>,
    /// A list of loggers.
    #[doc(hidden)]
    pub loggers: std::option::Option<std::vec::Vec<crate::model::Logger>>,
}
impl CreateLoggerDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the logger definition.
    pub fn logger_definition_id(&self) -> std::option::Option<& str> {
        self.logger_definition_id.as_deref()
    }
    /// A list of loggers.
    pub fn loggers(&self) -> std::option::Option<& [crate::model::Logger]> {
        self.loggers.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateLoggerDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the logger definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::LoggerDefinitionVersion>,
    /// The name of the logger definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateLoggerDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the logger definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::LoggerDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the logger definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateGroupVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ARN of the connector definition version for this group.
    #[doc(hidden)]
    pub connector_definition_version_arn: std::option::Option<std::string::String>,
    /// The ARN of the core definition version for this group.
    #[doc(hidden)]
    pub core_definition_version_arn: std::option::Option<std::string::String>,
    /// The ARN of the device definition version for this group.
    #[doc(hidden)]
    pub device_definition_version_arn: std::option::Option<std::string::String>,
    /// The ARN of the function definition version for this group.
    #[doc(hidden)]
    pub function_definition_version_arn: std::option::Option<std::string::String>,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The ARN of the logger definition version for this group.
    #[doc(hidden)]
    pub logger_definition_version_arn: std::option::Option<std::string::String>,
    /// The ARN of the resource definition version for this group.
    #[doc(hidden)]
    pub resource_definition_version_arn: std::option::Option<std::string::String>,
    /// The ARN of the subscription definition version for this group.
    #[doc(hidden)]
    pub subscription_definition_version_arn: std::option::Option<std::string::String>,
}
impl CreateGroupVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ARN of the connector definition version for this group.
    pub fn connector_definition_version_arn(&self) -> std::option::Option<& str> {
        self.connector_definition_version_arn.as_deref()
    }
    /// The ARN of the core definition version for this group.
    pub fn core_definition_version_arn(&self) -> std::option::Option<& str> {
        self.core_definition_version_arn.as_deref()
    }
    /// The ARN of the device definition version for this group.
    pub fn device_definition_version_arn(&self) -> std::option::Option<& str> {
        self.device_definition_version_arn.as_deref()
    }
    /// The ARN of the function definition version for this group.
    pub fn function_definition_version_arn(&self) -> std::option::Option<& str> {
        self.function_definition_version_arn.as_deref()
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The ARN of the logger definition version for this group.
    pub fn logger_definition_version_arn(&self) -> std::option::Option<& str> {
        self.logger_definition_version_arn.as_deref()
    }
    /// The ARN of the resource definition version for this group.
    pub fn resource_definition_version_arn(&self) -> std::option::Option<& str> {
        self.resource_definition_version_arn.as_deref()
    }
    /// The ARN of the subscription definition version for this group.
    pub fn subscription_definition_version_arn(&self) -> std::option::Option<& str> {
        self.subscription_definition_version_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateGroupCertificateAuthorityInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl CreateGroupCertificateAuthorityInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateGroupInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the group.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::GroupVersion>,
    /// The name of the group.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateGroupInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the group.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::GroupVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the group.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

/// Information needed to create a function definition version.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFunctionDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    #[doc(hidden)]
    pub default_config: std::option::Option<crate::model::FunctionDefaultConfig>,
    /// The ID of the Lambda function definition.
    #[doc(hidden)]
    pub function_definition_id: std::option::Option<std::string::String>,
    /// A list of Lambda functions in this function definition version.
    #[doc(hidden)]
    pub functions: std::option::Option<std::vec::Vec<crate::model::Function>>,
}
impl CreateFunctionDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    pub fn default_config(&self) -> std::option::Option<& crate::model::FunctionDefaultConfig> {
        self.default_config.as_ref()
    }
    /// The ID of the Lambda function definition.
    pub fn function_definition_id(&self) -> std::option::Option<& str> {
        self.function_definition_id.as_deref()
    }
    /// A list of Lambda functions in this function definition version.
    pub fn functions(&self) -> std::option::Option<& [crate::model::Function]> {
        self.functions.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFunctionDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the function definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::FunctionDefinitionVersion>,
    /// The name of the function definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateFunctionDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the function definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::FunctionDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the function definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDeviceDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the device definition.
    #[doc(hidden)]
    pub device_definition_id: std::option::Option<std::string::String>,
    /// A list of devices in the definition version.
    #[doc(hidden)]
    pub devices: std::option::Option<std::vec::Vec<crate::model::Device>>,
}
impl CreateDeviceDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the device definition.
    pub fn device_definition_id(&self) -> std::option::Option<& str> {
        self.device_definition_id.as_deref()
    }
    /// A list of devices in the definition version.
    pub fn devices(&self) -> std::option::Option<& [crate::model::Device]> {
        self.devices.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDeviceDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the device definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::DeviceDefinitionVersion>,
    /// The name of the device definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateDeviceDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the device definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::DeviceDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the device definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDeploymentInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    #[doc(hidden)]
    pub deployment_id: std::option::Option<std::string::String>,
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    #[doc(hidden)]
    pub deployment_type: std::option::Option<crate::model::DeploymentType>,
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The ID of the group version to be deployed.
    #[doc(hidden)]
    pub group_version_id: std::option::Option<std::string::String>,
}
impl CreateDeploymentInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    pub fn deployment_id(&self) -> std::option::Option<& str> {
        self.deployment_id.as_deref()
    }
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    pub fn deployment_type(&self) -> std::option::Option<& crate::model::DeploymentType> {
        self.deployment_type.as_ref()
    }
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The ID of the group version to be deployed.
    pub fn group_version_id(&self) -> std::option::Option<& str> {
        self.group_version_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCoreDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the core definition.
    #[doc(hidden)]
    pub core_definition_id: std::option::Option<std::string::String>,
    /// A list of cores in the core definition version.
    #[doc(hidden)]
    pub cores: std::option::Option<std::vec::Vec<crate::model::Core>>,
}
impl CreateCoreDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the core definition.
    pub fn core_definition_id(&self) -> std::option::Option<& str> {
        self.core_definition_id.as_deref()
    }
    /// A list of cores in the core definition version.
    pub fn cores(&self) -> std::option::Option<& [crate::model::Core]> {
        self.cores.as_deref()
    }
}

/// Information needed to create a core definition.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCoreDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the core definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::CoreDefinitionVersion>,
    /// The name of the core definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateCoreDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the core definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::CoreDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the core definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateConnectorDefinitionVersionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// The ID of the connector definition.
    #[doc(hidden)]
    pub connector_definition_id: std::option::Option<std::string::String>,
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    #[doc(hidden)]
    pub connectors: std::option::Option<std::vec::Vec<crate::model::Connector>>,
}
impl CreateConnectorDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// The ID of the connector definition.
    pub fn connector_definition_id(&self) -> std::option::Option<& str> {
        self.connector_definition_id.as_deref()
    }
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    pub fn connectors(&self) -> std::option::Option<& [crate::model::Connector]> {
        self.connectors.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateConnectorDefinitionInput  {
    /// A client token used to correlate requests and responses.
    #[doc(hidden)]
    pub amzn_client_token: std::option::Option<std::string::String>,
    /// Information about the initial version of the connector definition.
    #[doc(hidden)]
    pub initial_version: std::option::Option<crate::model::ConnectorDefinitionVersion>,
    /// The name of the connector definition.
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// Tag(s) to add to the new resource.
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateConnectorDefinitionInput {
    /// A client token used to correlate requests and responses.
    pub fn amzn_client_token(&self) -> std::option::Option<& str> {
        self.amzn_client_token.as_deref()
    }
    /// Information about the initial version of the connector definition.
    pub fn initial_version(&self) -> std::option::Option<& crate::model::ConnectorDefinitionVersion> {
        self.initial_version.as_ref()
    }
    /// The name of the connector definition.
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// Tag(s) to add to the new resource.
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateServiceRoleToAccountInput  {
    /// The ARN of the service role you wish to associate with your account.
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl AssociateServiceRoleToAccountInput {
    /// The ARN of the service role you wish to associate with your account.
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateRoleToGroupInput  {
    /// The ID of the Greengrass group.
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl AssociateRoleToGroupInput {
    /// The ID of the Greengrass group.
    pub fn group_id(&self) -> std::option::Option<& str> {
        self.group_id.as_deref()
    }
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
}

