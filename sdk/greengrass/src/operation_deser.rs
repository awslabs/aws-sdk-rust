// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_role_to_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateRoleToGroupOutput,
    crate::error::AssociateRoleToGroupError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AssociateRoleToGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AssociateRoleToGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::AssociateRoleToGroupError {
            meta: generic,
            kind: crate::error::AssociateRoleToGroupErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AssociateRoleToGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => {
            crate::error::AssociateRoleToGroupError {
                meta: generic,
                kind: crate::error::AssociateRoleToGroupErrorKind::InternalServerErrorException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_error_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateRoleToGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::AssociateRoleToGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_role_to_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateRoleToGroupOutput,
    crate::error::AssociateRoleToGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_role_to_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_associate_role_to_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateRoleToGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_service_role_to_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateServiceRoleToAccountOutput,
    crate::error::AssociateServiceRoleToAccountError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AssociateServiceRoleToAccountError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateServiceRoleToAccountError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::AssociateServiceRoleToAccountError {
            meta: generic,
            kind: crate::error::AssociateServiceRoleToAccountErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AssociateServiceRoleToAccountError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::AssociateServiceRoleToAccountError {
            meta: generic,
            kind:
                crate::error::AssociateServiceRoleToAccountErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateServiceRoleToAccountError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::AssociateServiceRoleToAccountError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_service_role_to_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateServiceRoleToAccountOutput,
    crate::error::AssociateServiceRoleToAccountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::associate_service_role_to_account_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_associate_service_role_to_account(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateServiceRoleToAccountError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connector_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConnectorDefinitionOutput,
    crate::error::CreateConnectorDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateConnectorDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateConnectorDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateConnectorDefinitionError {
            meta: generic,
            kind: crate::error::CreateConnectorDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateConnectorDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateConnectorDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connector_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConnectorDefinitionOutput,
    crate::error::CreateConnectorDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_connector_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_connector_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateConnectorDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connector_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConnectorDefinitionVersionOutput,
    crate::error::CreateConnectorDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateConnectorDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateConnectorDefinitionVersionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateConnectorDefinitionVersionError {
            meta: generic,
            kind: crate::error::CreateConnectorDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateConnectorDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateConnectorDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connector_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConnectorDefinitionVersionOutput,
    crate::error::CreateConnectorDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_connector_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_connector_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateConnectorDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_core_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCoreDefinitionOutput,
    crate::error::CreateCoreDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCoreDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCoreDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateCoreDefinitionError {
            meta: generic,
            kind: crate::error::CreateCoreDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCoreDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateCoreDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_core_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCoreDefinitionOutput,
    crate::error::CreateCoreDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_core_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_core_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCoreDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_core_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCoreDefinitionVersionOutput,
    crate::error::CreateCoreDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCoreDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateCoreDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateCoreDefinitionVersionError {
            meta: generic,
            kind: crate::error::CreateCoreDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCoreDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateCoreDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_core_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCoreDefinitionVersionOutput,
    crate::error::CreateCoreDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_core_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_core_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCoreDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDeploymentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDeploymentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_deployment_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_deployment(response.body().as_ref(), output)
                .map_err(crate::error::CreateDeploymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDeviceDefinitionOutput,
    crate::error::CreateDeviceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDeviceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDeviceDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDeviceDefinitionError {
            meta: generic,
            kind: crate::error::CreateDeviceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDeviceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDeviceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDeviceDefinitionOutput,
    crate::error::CreateDeviceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_device_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_device_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDeviceDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDeviceDefinitionVersionOutput,
    crate::error::CreateDeviceDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDeviceDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDeviceDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDeviceDefinitionVersionError {
            meta: generic,
            kind: crate::error::CreateDeviceDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDeviceDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDeviceDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDeviceDefinitionVersionOutput,
    crate::error::CreateDeviceDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_device_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_device_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDeviceDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFunctionDefinitionOutput,
    crate::error::CreateFunctionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateFunctionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateFunctionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateFunctionDefinitionError {
            meta: generic,
            kind: crate::error::CreateFunctionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateFunctionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateFunctionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFunctionDefinitionOutput,
    crate::error::CreateFunctionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_function_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_function_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFunctionDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFunctionDefinitionVersionOutput,
    crate::error::CreateFunctionDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateFunctionDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateFunctionDefinitionVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateFunctionDefinitionVersionError {
            meta: generic,
            kind: crate::error::CreateFunctionDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateFunctionDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateFunctionDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFunctionDefinitionVersionOutput,
    crate::error::CreateFunctionDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_function_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_function_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFunctionDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_group(response.body().as_ref(), output)
            .map_err(crate::error::CreateGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_certificate_authority_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGroupCertificateAuthorityOutput,
    crate::error::CreateGroupCertificateAuthorityError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateGroupCertificateAuthorityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGroupCertificateAuthorityError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateGroupCertificateAuthorityError {
            meta: generic,
            kind: crate::error::CreateGroupCertificateAuthorityErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateGroupCertificateAuthorityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::CreateGroupCertificateAuthorityError {
            meta: generic,
            kind:
                crate::error::CreateGroupCertificateAuthorityErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupCertificateAuthorityError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::CreateGroupCertificateAuthorityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_certificate_authority_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGroupCertificateAuthorityOutput,
    crate::error::CreateGroupCertificateAuthorityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_group_certificate_authority_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_group_certificate_authority(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateGroupCertificateAuthorityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGroupVersionOutput,
    crate::error::CreateGroupVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateGroupVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGroupVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateGroupVersionError {
            meta: generic,
            kind: crate::error::CreateGroupVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateGroupVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateGroupVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGroupVersionOutput,
    crate::error::CreateGroupVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_group_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_group_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateGroupVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_logger_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLoggerDefinitionOutput,
    crate::error::CreateLoggerDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateLoggerDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateLoggerDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateLoggerDefinitionError {
            meta: generic,
            kind: crate::error::CreateLoggerDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateLoggerDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateLoggerDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_logger_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLoggerDefinitionOutput,
    crate::error::CreateLoggerDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_logger_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_logger_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLoggerDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_logger_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLoggerDefinitionVersionOutput,
    crate::error::CreateLoggerDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateLoggerDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateLoggerDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateLoggerDefinitionVersionError {
            meta: generic,
            kind: crate::error::CreateLoggerDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateLoggerDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateLoggerDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_logger_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLoggerDefinitionVersionOutput,
    crate::error::CreateLoggerDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_logger_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_logger_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLoggerDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDefinitionOutput,
    crate::error::CreateResourceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateResourceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateResourceDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateResourceDefinitionError {
            meta: generic,
            kind: crate::error::CreateResourceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateResourceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateResourceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDefinitionOutput,
    crate::error::CreateResourceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_resource_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_resource_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateResourceDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDefinitionVersionOutput,
    crate::error::CreateResourceDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateResourceDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateResourceDefinitionVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateResourceDefinitionVersionError {
            meta: generic,
            kind: crate::error::CreateResourceDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateResourceDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateResourceDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateResourceDefinitionVersionOutput,
    crate::error::CreateResourceDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_resource_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_resource_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateResourceDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_software_update_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSoftwareUpdateJobOutput,
    crate::error::CreateSoftwareUpdateJobError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateSoftwareUpdateJobError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateSoftwareUpdateJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateSoftwareUpdateJobError {
            meta: generic,
            kind: crate::error::CreateSoftwareUpdateJobErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateSoftwareUpdateJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => {
            crate::error::CreateSoftwareUpdateJobError {
                meta: generic,
                kind: crate::error::CreateSoftwareUpdateJobErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateSoftwareUpdateJobError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::CreateSoftwareUpdateJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_software_update_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSoftwareUpdateJobOutput,
    crate::error::CreateSoftwareUpdateJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_software_update_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_software_update_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSoftwareUpdateJobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subscription_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSubscriptionDefinitionOutput,
    crate::error::CreateSubscriptionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateSubscriptionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateSubscriptionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::CreateSubscriptionDefinitionError {
            meta: generic,
            kind: crate::error::CreateSubscriptionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateSubscriptionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateSubscriptionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subscription_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSubscriptionDefinitionOutput,
    crate::error::CreateSubscriptionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_subscription_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_subscription_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSubscriptionDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subscription_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSubscriptionDefinitionVersionOutput,
    crate::error::CreateSubscriptionDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateSubscriptionDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateSubscriptionDefinitionVersionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => {
            crate::error::CreateSubscriptionDefinitionVersionError {
                meta: generic,
                kind:
                    crate::error::CreateSubscriptionDefinitionVersionErrorKind::BadRequestException(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]
                                let mut output =
                                    crate::error::bad_request_exception::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateSubscriptionDefinitionVersionError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::CreateSubscriptionDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subscription_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSubscriptionDefinitionVersionOutput,
    crate::error::CreateSubscriptionDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_subscription_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_subscription_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSubscriptionDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_connector_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConnectorDefinitionOutput,
    crate::error::DeleteConnectorDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteConnectorDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteConnectorDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteConnectorDefinitionError {
            meta: generic,
            kind: crate::error::DeleteConnectorDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteConnectorDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteConnectorDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_connector_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConnectorDefinitionOutput,
    crate::error::DeleteConnectorDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_connector_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_core_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCoreDefinitionOutput,
    crate::error::DeleteCoreDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteCoreDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCoreDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteCoreDefinitionError {
            meta: generic,
            kind: crate::error::DeleteCoreDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteCoreDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteCoreDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_core_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCoreDefinitionOutput,
    crate::error::DeleteCoreDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_core_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDeviceDefinitionOutput,
    crate::error::DeleteDeviceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDeviceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDeviceDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteDeviceDefinitionError {
            meta: generic,
            kind: crate::error::DeleteDeviceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDeviceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDeviceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDeviceDefinitionOutput,
    crate::error::DeleteDeviceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_device_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFunctionDefinitionOutput,
    crate::error::DeleteFunctionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFunctionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteFunctionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteFunctionDefinitionError {
            meta: generic,
            kind: crate::error::DeleteFunctionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFunctionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteFunctionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFunctionDefinitionOutput,
    crate::error::DeleteFunctionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_function_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_logger_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLoggerDefinitionOutput,
    crate::error::DeleteLoggerDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteLoggerDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteLoggerDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteLoggerDefinitionError {
            meta: generic,
            kind: crate::error::DeleteLoggerDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteLoggerDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteLoggerDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_logger_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLoggerDefinitionOutput,
    crate::error::DeleteLoggerDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_logger_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceDefinitionOutput,
    crate::error::DeleteResourceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteResourceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteResourceDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteResourceDefinitionError {
            meta: generic,
            kind: crate::error::DeleteResourceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteResourceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteResourceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceDefinitionOutput,
    crate::error::DeleteResourceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subscription_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSubscriptionDefinitionOutput,
    crate::error::DeleteSubscriptionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSubscriptionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSubscriptionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteSubscriptionDefinitionError {
            meta: generic,
            kind: crate::error::DeleteSubscriptionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteSubscriptionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteSubscriptionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subscription_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSubscriptionDefinitionOutput,
    crate::error::DeleteSubscriptionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_subscription_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_role_from_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateRoleFromGroupOutput,
    crate::error::DisassociateRoleFromGroupError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DisassociateRoleFromGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateRoleFromGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::DisassociateRoleFromGroupError {
            meta: generic,
            kind: crate::error::DisassociateRoleFromGroupErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DisassociateRoleFromGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::DisassociateRoleFromGroupError {
            meta: generic,
            kind: crate::error::DisassociateRoleFromGroupErrorKind::InternalServerErrorException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::internal_server_error_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DisassociateRoleFromGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DisassociateRoleFromGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_role_from_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateRoleFromGroupOutput,
    crate::error::DisassociateRoleFromGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_role_from_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_disassociate_role_from_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateRoleFromGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_service_role_from_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateServiceRoleFromAccountOutput,
    crate::error::DisassociateServiceRoleFromAccountError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DisassociateServiceRoleFromAccountError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateServiceRoleFromAccountError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerErrorException" => crate::error::DisassociateServiceRoleFromAccountError { meta: generic, kind: crate::error::DisassociateServiceRoleFromAccountErrorKind::InternalServerErrorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateServiceRoleFromAccountError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DisassociateServiceRoleFromAccountError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_service_role_from_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateServiceRoleFromAccountOutput,
    crate::error::DisassociateServiceRoleFromAccountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_service_role_from_account_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_disassociate_service_role_from_account(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateServiceRoleFromAccountError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAssociatedRoleOutput, crate::error::GetAssociatedRoleError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAssociatedRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAssociatedRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetAssociatedRoleError {
            meta: generic,
            kind: crate::error::GetAssociatedRoleErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetAssociatedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => {
            crate::error::GetAssociatedRoleError {
                meta: generic,
                kind: crate::error::GetAssociatedRoleErrorKind::InternalServerErrorException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_error_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetAssociatedRoleError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetAssociatedRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAssociatedRoleOutput, crate::error::GetAssociatedRoleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_associated_role_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_associated_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAssociatedRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bulk_deployment_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBulkDeploymentStatusOutput,
    crate::error::GetBulkDeploymentStatusError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBulkDeploymentStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetBulkDeploymentStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetBulkDeploymentStatusError {
            meta: generic,
            kind: crate::error::GetBulkDeploymentStatusErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetBulkDeploymentStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetBulkDeploymentStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bulk_deployment_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBulkDeploymentStatusOutput,
    crate::error::GetBulkDeploymentStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bulk_deployment_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_bulk_deployment_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBulkDeploymentStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connectivity_info_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectivityInfoOutput,
    crate::error::GetConnectivityInfoError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetConnectivityInfoError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetConnectivityInfoError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetConnectivityInfoError {
            meta: generic,
            kind: crate::error::GetConnectivityInfoErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetConnectivityInfoError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => {
            crate::error::GetConnectivityInfoError {
                meta: generic,
                kind: crate::error::GetConnectivityInfoErrorKind::InternalServerErrorException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_error_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetConnectivityInfoError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetConnectivityInfoError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connectivity_info_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectivityInfoOutput,
    crate::error::GetConnectivityInfoError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_connectivity_info_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_connectivity_info(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConnectivityInfoError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connector_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectorDefinitionOutput,
    crate::error::GetConnectorDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetConnectorDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetConnectorDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetConnectorDefinitionError {
            meta: generic,
            kind: crate::error::GetConnectorDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetConnectorDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetConnectorDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connector_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectorDefinitionOutput,
    crate::error::GetConnectorDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_connector_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_connector_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConnectorDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connector_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectorDefinitionVersionOutput,
    crate::error::GetConnectorDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetConnectorDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetConnectorDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetConnectorDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetConnectorDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetConnectorDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetConnectorDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_connector_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConnectorDefinitionVersionOutput,
    crate::error::GetConnectorDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_connector_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_connector_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConnectorDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_core_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCoreDefinitionOutput, crate::error::GetCoreDefinitionError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetCoreDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCoreDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetCoreDefinitionError {
            meta: generic,
            kind: crate::error::GetCoreDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCoreDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCoreDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_core_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCoreDefinitionOutput, crate::error::GetCoreDefinitionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_core_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_core_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCoreDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_core_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCoreDefinitionVersionOutput,
    crate::error::GetCoreDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetCoreDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCoreDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetCoreDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetCoreDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCoreDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCoreDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_core_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCoreDefinitionVersionOutput,
    crate::error::GetCoreDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_core_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_core_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCoreDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployment_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeploymentStatusOutput,
    crate::error::GetDeploymentStatusError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeploymentStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeploymentStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetDeploymentStatusError {
            meta: generic,
            kind: crate::error::GetDeploymentStatusErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeploymentStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDeploymentStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployment_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeploymentStatusOutput,
    crate::error::GetDeploymentStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_deployment_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_deployment_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeploymentStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeviceDefinitionOutput,
    crate::error::GetDeviceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeviceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeviceDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetDeviceDefinitionError {
            meta: generic,
            kind: crate::error::GetDeviceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDeviceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeviceDefinitionOutput,
    crate::error::GetDeviceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_device_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeviceDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeviceDefinitionVersionOutput,
    crate::error::GetDeviceDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeviceDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDeviceDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetDeviceDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetDeviceDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDeviceDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeviceDefinitionVersionOutput,
    crate::error::GetDeviceDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_device_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeviceDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFunctionDefinitionOutput,
    crate::error::GetFunctionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFunctionDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetFunctionDefinitionError {
            meta: generic,
            kind: crate::error::GetFunctionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFunctionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetFunctionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFunctionDefinitionOutput,
    crate::error::GetFunctionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_function_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFunctionDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFunctionDefinitionVersionOutput,
    crate::error::GetFunctionDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFunctionDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetFunctionDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetFunctionDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFunctionDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetFunctionDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFunctionDefinitionVersionOutput,
    crate::error::GetFunctionDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_function_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFunctionDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetGroupError {
            meta: generic,
            kind: crate::error::GetGroupErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_group(response.body().as_ref(), output)
            .map_err(crate::error::GetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_certificate_authority_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGroupCertificateAuthorityOutput,
    crate::error::GetGroupCertificateAuthorityError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGroupCertificateAuthorityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetGroupCertificateAuthorityError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetGroupCertificateAuthorityError {
            meta: generic,
            kind: crate::error::GetGroupCertificateAuthorityErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetGroupCertificateAuthorityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::GetGroupCertificateAuthorityError {
            meta: generic,
            kind: crate::error::GetGroupCertificateAuthorityErrorKind::InternalServerErrorException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_error_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetGroupCertificateAuthorityError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::GetGroupCertificateAuthorityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_certificate_authority_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGroupCertificateAuthorityOutput,
    crate::error::GetGroupCertificateAuthorityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_certificate_authority_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_group_certificate_authority(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGroupCertificateAuthorityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_certificate_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGroupCertificateConfigurationOutput,
    crate::error::GetGroupCertificateConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGroupCertificateConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetGroupCertificateConfigurationError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetGroupCertificateConfigurationError { meta: generic, kind: crate::error::GetGroupCertificateConfigurationErrorKind::BadRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetGroupCertificateConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerErrorException" => crate::error::GetGroupCertificateConfigurationError { meta: generic, kind: crate::error::GetGroupCertificateConfigurationErrorKind::InternalServerErrorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetGroupCertificateConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetGroupCertificateConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_certificate_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGroupCertificateConfigurationOutput,
    crate::error::GetGroupCertificateConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_group_certificate_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_group_certificate_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGroupCertificateConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupVersionOutput, crate::error::GetGroupVersionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGroupVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGroupVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetGroupVersionError {
            meta: generic,
            kind: crate::error::GetGroupVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetGroupVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetGroupVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupVersionOutput, crate::error::GetGroupVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_version_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_group_version(response.body().as_ref(), output)
                .map_err(crate::error::GetGroupVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_logger_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLoggerDefinitionOutput,
    crate::error::GetLoggerDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetLoggerDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLoggerDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetLoggerDefinitionError {
            meta: generic,
            kind: crate::error::GetLoggerDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetLoggerDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetLoggerDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_logger_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLoggerDefinitionOutput,
    crate::error::GetLoggerDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_logger_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_logger_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLoggerDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_logger_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLoggerDefinitionVersionOutput,
    crate::error::GetLoggerDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetLoggerDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetLoggerDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetLoggerDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetLoggerDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetLoggerDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetLoggerDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_logger_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLoggerDefinitionVersionOutput,
    crate::error::GetLoggerDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_logger_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_logger_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLoggerDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourceDefinitionOutput,
    crate::error::GetResourceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetResourceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResourceDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetResourceDefinitionError {
            meta: generic,
            kind: crate::error::GetResourceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetResourceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetResourceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourceDefinitionOutput,
    crate::error::GetResourceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_resource_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetResourceDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourceDefinitionVersionOutput,
    crate::error::GetResourceDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetResourceDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetResourceDefinitionVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetResourceDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetResourceDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetResourceDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetResourceDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourceDefinitionVersionOutput,
    crate::error::GetResourceDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_resource_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetResourceDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_role_for_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceRoleForAccountOutput,
    crate::error::GetServiceRoleForAccountError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetServiceRoleForAccountError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetServiceRoleForAccountError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerErrorException" => {
            crate::error::GetServiceRoleForAccountError {
                meta: generic,
                kind: crate::error::GetServiceRoleForAccountErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetServiceRoleForAccountError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::GetServiceRoleForAccountError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_role_for_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceRoleForAccountOutput,
    crate::error::GetServiceRoleForAccountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_service_role_for_account_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_service_role_for_account(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServiceRoleForAccountError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subscription_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSubscriptionDefinitionOutput,
    crate::error::GetSubscriptionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSubscriptionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetSubscriptionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetSubscriptionDefinitionError {
            meta: generic,
            kind: crate::error::GetSubscriptionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSubscriptionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetSubscriptionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subscription_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSubscriptionDefinitionOutput,
    crate::error::GetSubscriptionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_subscription_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_subscription_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSubscriptionDefinitionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subscription_definition_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSubscriptionDefinitionVersionOutput,
    crate::error::GetSubscriptionDefinitionVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSubscriptionDefinitionVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetSubscriptionDefinitionVersionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetSubscriptionDefinitionVersionError {
            meta: generic,
            kind: crate::error::GetSubscriptionDefinitionVersionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSubscriptionDefinitionVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetSubscriptionDefinitionVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subscription_definition_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSubscriptionDefinitionVersionOutput,
    crate::error::GetSubscriptionDefinitionVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_subscription_definition_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_subscription_definition_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSubscriptionDefinitionVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_thing_runtime_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetThingRuntimeConfigurationOutput,
    crate::error::GetThingRuntimeConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetThingRuntimeConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetThingRuntimeConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::GetThingRuntimeConfigurationError {
            meta: generic,
            kind: crate::error::GetThingRuntimeConfigurationErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetThingRuntimeConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::GetThingRuntimeConfigurationError {
            meta: generic,
            kind: crate::error::GetThingRuntimeConfigurationErrorKind::InternalServerErrorException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_error_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetThingRuntimeConfigurationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::GetThingRuntimeConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_thing_runtime_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetThingRuntimeConfigurationOutput,
    crate::error::GetThingRuntimeConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_thing_runtime_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_thing_runtime_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetThingRuntimeConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bulk_deployment_detailed_reports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBulkDeploymentDetailedReportsOutput,
    crate::error::ListBulkDeploymentDetailedReportsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBulkDeploymentDetailedReportsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListBulkDeploymentDetailedReportsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListBulkDeploymentDetailedReportsError {
            meta: generic,
            kind: crate::error::ListBulkDeploymentDetailedReportsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBulkDeploymentDetailedReportsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListBulkDeploymentDetailedReportsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bulk_deployment_detailed_reports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBulkDeploymentDetailedReportsOutput,
    crate::error::ListBulkDeploymentDetailedReportsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_bulk_deployment_detailed_reports_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_bulk_deployment_detailed_reports(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBulkDeploymentDetailedReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bulk_deployments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBulkDeploymentsOutput,
    crate::error::ListBulkDeploymentsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBulkDeploymentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBulkDeploymentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListBulkDeploymentsError {
            meta: generic,
            kind: crate::error::ListBulkDeploymentsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBulkDeploymentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListBulkDeploymentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bulk_deployments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBulkDeploymentsOutput,
    crate::error::ListBulkDeploymentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_bulk_deployments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_bulk_deployments(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBulkDeploymentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_connector_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConnectorDefinitionsOutput,
    crate::error::ListConnectorDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListConnectorDefinitionsError::unhandled)?;
    Err(crate::error::ListConnectorDefinitionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_connector_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConnectorDefinitionsOutput,
    crate::error::ListConnectorDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_connector_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_connector_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListConnectorDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_connector_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConnectorDefinitionVersionsOutput,
    crate::error::ListConnectorDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListConnectorDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListConnectorDefinitionVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListConnectorDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListConnectorDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListConnectorDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListConnectorDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_connector_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConnectorDefinitionVersionsOutput,
    crate::error::ListConnectorDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_connector_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_connector_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListConnectorDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_core_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCoreDefinitionsOutput,
    crate::error::ListCoreDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListCoreDefinitionsError::unhandled)?;
    Err(crate::error::ListCoreDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_core_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCoreDefinitionsOutput,
    crate::error::ListCoreDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_core_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_core_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCoreDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_core_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCoreDefinitionVersionsOutput,
    crate::error::ListCoreDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListCoreDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCoreDefinitionVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListCoreDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListCoreDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCoreDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListCoreDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_core_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCoreDefinitionVersionsOutput,
    crate::error::ListCoreDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_core_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_core_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCoreDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_deployments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDeploymentsOutput, crate::error::ListDeploymentsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDeploymentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDeploymentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListDeploymentsError {
            meta: generic,
            kind: crate::error::ListDeploymentsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeploymentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListDeploymentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_deployments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDeploymentsOutput, crate::error::ListDeploymentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_deployments_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_deployments(response.body().as_ref(), output)
                .map_err(crate::error::ListDeploymentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceDefinitionsOutput,
    crate::error::ListDeviceDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDeviceDefinitionsError::unhandled)?;
    Err(crate::error::ListDeviceDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceDefinitionsOutput,
    crate::error::ListDeviceDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_device_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeviceDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceDefinitionVersionsOutput,
    crate::error::ListDeviceDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDeviceDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDeviceDefinitionVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListDeviceDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListDeviceDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeviceDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListDeviceDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceDefinitionVersionsOutput,
    crate::error::ListDeviceDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_device_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeviceDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_function_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFunctionDefinitionsOutput,
    crate::error::ListFunctionDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListFunctionDefinitionsError::unhandled)?;
    Err(crate::error::ListFunctionDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_function_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFunctionDefinitionsOutput,
    crate::error::ListFunctionDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_function_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_function_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListFunctionDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_function_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFunctionDefinitionVersionsOutput,
    crate::error::ListFunctionDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListFunctionDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListFunctionDefinitionVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListFunctionDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListFunctionDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListFunctionDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListFunctionDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_function_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFunctionDefinitionVersionsOutput,
    crate::error::ListFunctionDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_function_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_function_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListFunctionDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_certificate_authorities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListGroupCertificateAuthoritiesOutput,
    crate::error::ListGroupCertificateAuthoritiesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListGroupCertificateAuthoritiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupCertificateAuthoritiesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListGroupCertificateAuthoritiesError {
            meta: generic,
            kind: crate::error::ListGroupCertificateAuthoritiesErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListGroupCertificateAuthoritiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::ListGroupCertificateAuthoritiesError {
            meta: generic,
            kind:
                crate::error::ListGroupCertificateAuthoritiesErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListGroupCertificateAuthoritiesError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ListGroupCertificateAuthoritiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_certificate_authorities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListGroupCertificateAuthoritiesOutput,
    crate::error::ListGroupCertificateAuthoritiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_group_certificate_authorities_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_group_certificate_authorities(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGroupCertificateAuthoritiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListGroupsError::unhandled)?;
    Err(crate::error::ListGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_groups(response.body().as_ref(), output)
            .map_err(crate::error::ListGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupVersionsOutput, crate::error::ListGroupVersionsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListGroupVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListGroupVersionsError {
            meta: generic,
            kind: crate::error::ListGroupVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListGroupVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListGroupVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupVersionsOutput, crate::error::ListGroupVersionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_group_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_group_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGroupVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_logger_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListLoggerDefinitionsOutput,
    crate::error::ListLoggerDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListLoggerDefinitionsError::unhandled)?;
    Err(crate::error::ListLoggerDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_logger_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListLoggerDefinitionsOutput,
    crate::error::ListLoggerDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_logger_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_logger_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListLoggerDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_logger_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListLoggerDefinitionVersionsOutput,
    crate::error::ListLoggerDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListLoggerDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListLoggerDefinitionVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListLoggerDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListLoggerDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListLoggerDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListLoggerDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_logger_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListLoggerDefinitionVersionsOutput,
    crate::error::ListLoggerDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_logger_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_logger_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListLoggerDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDefinitionsOutput,
    crate::error::ListResourceDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListResourceDefinitionsError::unhandled)?;
    Err(crate::error::ListResourceDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDefinitionsOutput,
    crate::error::ListResourceDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_resource_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListResourceDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDefinitionVersionsOutput,
    crate::error::ListResourceDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListResourceDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListResourceDefinitionVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListResourceDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListResourceDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListResourceDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListResourceDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceDefinitionVersionsOutput,
    crate::error::ListResourceDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_resource_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_resource_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListResourceDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_subscription_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSubscriptionDefinitionsOutput,
    crate::error::ListSubscriptionDefinitionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSubscriptionDefinitionsError::unhandled)?;
    Err(crate::error::ListSubscriptionDefinitionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_subscription_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSubscriptionDefinitionsOutput,
    crate::error::ListSubscriptionDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_subscription_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_subscription_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSubscriptionDefinitionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_subscription_definition_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSubscriptionDefinitionVersionsOutput,
    crate::error::ListSubscriptionDefinitionVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSubscriptionDefinitionVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListSubscriptionDefinitionVersionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListSubscriptionDefinitionVersionsError {
            meta: generic,
            kind: crate::error::ListSubscriptionDefinitionVersionsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSubscriptionDefinitionVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSubscriptionDefinitionVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_subscription_definition_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSubscriptionDefinitionVersionsOutput,
    crate::error::ListSubscriptionDefinitionVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_subscription_definition_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_subscription_definition_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSubscriptionDefinitionVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_deployments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResetDeploymentsOutput, crate::error::ResetDeploymentsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ResetDeploymentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetDeploymentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::ResetDeploymentsError {
            meta: generic,
            kind: crate::error::ResetDeploymentsErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ResetDeploymentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ResetDeploymentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_deployments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResetDeploymentsOutput, crate::error::ResetDeploymentsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_deployments_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_reset_deployments(response.body().as_ref(), output)
                .map_err(crate::error::ResetDeploymentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_bulk_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartBulkDeploymentOutput,
    crate::error::StartBulkDeploymentError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StartBulkDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartBulkDeploymentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::StartBulkDeploymentError {
            meta: generic,
            kind: crate::error::StartBulkDeploymentErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartBulkDeploymentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartBulkDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_bulk_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartBulkDeploymentOutput,
    crate::error::StartBulkDeploymentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_bulk_deployment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_start_bulk_deployment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartBulkDeploymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_bulk_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopBulkDeploymentOutput,
    crate::error::StopBulkDeploymentError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopBulkDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopBulkDeploymentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::StopBulkDeploymentError {
            meta: generic,
            kind: crate::error::StopBulkDeploymentErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopBulkDeploymentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopBulkDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_bulk_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopBulkDeploymentOutput,
    crate::error::StopBulkDeploymentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_bulk_deployment_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connectivity_info_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConnectivityInfoOutput,
    crate::error::UpdateConnectivityInfoError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateConnectivityInfoError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateConnectivityInfoError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateConnectivityInfoError {
            meta: generic,
            kind: crate::error::UpdateConnectivityInfoErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateConnectivityInfoError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => {
            crate::error::UpdateConnectivityInfoError {
                meta: generic,
                kind: crate::error::UpdateConnectivityInfoErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateConnectivityInfoError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::UpdateConnectivityInfoError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connectivity_info_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConnectivityInfoOutput,
    crate::error::UpdateConnectivityInfoError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_connectivity_info_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_connectivity_info(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateConnectivityInfoError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connector_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConnectorDefinitionOutput,
    crate::error::UpdateConnectorDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateConnectorDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateConnectorDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateConnectorDefinitionError {
            meta: generic,
            kind: crate::error::UpdateConnectorDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateConnectorDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateConnectorDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connector_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConnectorDefinitionOutput,
    crate::error::UpdateConnectorDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_connector_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_core_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCoreDefinitionOutput,
    crate::error::UpdateCoreDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateCoreDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateCoreDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateCoreDefinitionError {
            meta: generic,
            kind: crate::error::UpdateCoreDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateCoreDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateCoreDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_core_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCoreDefinitionOutput,
    crate::error::UpdateCoreDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_core_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDeviceDefinitionOutput,
    crate::error::UpdateDeviceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDeviceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDeviceDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateDeviceDefinitionError {
            meta: generic,
            kind: crate::error::UpdateDeviceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDeviceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDeviceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDeviceDefinitionOutput,
    crate::error::UpdateDeviceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_device_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFunctionDefinitionOutput,
    crate::error::UpdateFunctionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateFunctionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateFunctionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateFunctionDefinitionError {
            meta: generic,
            kind: crate::error::UpdateFunctionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateFunctionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateFunctionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFunctionDefinitionOutput,
    crate::error::UpdateFunctionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_function_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_certificate_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateGroupCertificateConfigurationOutput,
    crate::error::UpdateGroupCertificateConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateGroupCertificateConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateGroupCertificateConfigurationError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateGroupCertificateConfigurationError { meta: generic, kind: crate::error::UpdateGroupCertificateConfigurationErrorKind::BadRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupCertificateConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServerErrorException" => crate::error::UpdateGroupCertificateConfigurationError { meta: generic, kind: crate::error::UpdateGroupCertificateConfigurationErrorKind::InternalServerErrorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::internal_server_error_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupCertificateConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateGroupCertificateConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_certificate_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateGroupCertificateConfigurationOutput,
    crate::error::UpdateGroupCertificateConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_group_certificate_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_group_certificate_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateGroupCertificateConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_logger_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateLoggerDefinitionOutput,
    crate::error::UpdateLoggerDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateLoggerDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateLoggerDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateLoggerDefinitionError {
            meta: generic,
            kind: crate::error::UpdateLoggerDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateLoggerDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateLoggerDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_logger_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateLoggerDefinitionOutput,
    crate::error::UpdateLoggerDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_logger_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResourceDefinitionOutput,
    crate::error::UpdateResourceDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateResourceDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateResourceDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateResourceDefinitionError {
            meta: generic,
            kind: crate::error::UpdateResourceDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateResourceDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateResourceDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateResourceDefinitionOutput,
    crate::error::UpdateResourceDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_resource_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_subscription_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSubscriptionDefinitionOutput,
    crate::error::UpdateSubscriptionDefinitionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateSubscriptionDefinitionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateSubscriptionDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateSubscriptionDefinitionError {
            meta: generic,
            kind: crate::error::UpdateSubscriptionDefinitionErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateSubscriptionDefinitionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateSubscriptionDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_subscription_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSubscriptionDefinitionOutput,
    crate::error::UpdateSubscriptionDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_subscription_definition_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_thing_runtime_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateThingRuntimeConfigurationOutput,
    crate::error::UpdateThingRuntimeConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateThingRuntimeConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateThingRuntimeConfigurationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateThingRuntimeConfigurationError {
            meta: generic,
            kind: crate::error::UpdateThingRuntimeConfigurationErrorKind::BadRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bad_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_bad_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateThingRuntimeConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServerErrorException" => crate::error::UpdateThingRuntimeConfigurationError {
            meta: generic,
            kind:
                crate::error::UpdateThingRuntimeConfigurationErrorKind::InternalServerErrorException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::internal_server_error_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_internal_server_error_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateThingRuntimeConfigurationError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::UpdateThingRuntimeConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_thing_runtime_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateThingRuntimeConfigurationOutput,
    crate::error::UpdateThingRuntimeConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_thing_runtime_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}
