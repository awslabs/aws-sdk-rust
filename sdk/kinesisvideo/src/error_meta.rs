// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>You do not have required permissions to perform this operation.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>You have reached the maximum limit of active signaling channels for this Amazon Web Services account in this region.</p>
    AccountChannelLimitExceededException(crate::error::AccountChannelLimitExceededException),
    /// <p>The number of streams created for the account is too high.</p>
    AccountStreamLimitExceededException(crate::error::AccountStreamLimitExceededException),
    /// <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client calls. Try making the call later.</p>
    ClientLimitExceededException(crate::error::ClientLimitExceededException),
    /// <p>Not implemented. </p>
    DeviceStreamLimitExceededException(crate::error::DeviceStreamLimitExceededException),
    /// <p>The value for this input parameter is invalid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>Not implemented.</p>
    InvalidDeviceException(crate::error::InvalidDeviceException),
    /// <p>The format of the <code>StreamARN</code> is invalid.</p>
    InvalidResourceFormatException(crate::error::InvalidResourceFormatException),
    /// <p>The Stream data retention in hours is equal to zero.</p>
    NoDataRetentionException(crate::error::NoDataRetentionException),
    /// <p>The caller is not authorized to perform this operation.</p>
    NotAuthorizedException(crate::error::NotAuthorizedException),
    /// <p>When the input <code>StreamARN</code> or <code>ChannelARN</code> in <code>CLOUD_STORAGE_MODE</code> is already mapped to a different Kinesis Video Stream resource, or if the provided input <code>StreamARN</code> or <code>ChannelARN</code> is not in Active status, try one of the following : </p>
    /// <ol>
    /// <li> <p>The <code>DescribeMediaStorageConfiguration</code> API to determine what the stream given channel is mapped to. </p> </li>
    /// <li> <p>The <code>DescribeMappedResourceConfiguration</code> API to determine the channel that the given stream is mapped to. </p> </li>
    /// <li> <p>The <code>DescribeStream</code> or <code>DescribeSignalingChannel</code> API to determine the status of the resource. </p> </li>
    /// </ol>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>Amazon Kinesis Video Streams can't find the stream that you specified.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The Exception rendered when the Amazon Kinesis Video Stream can't find a stream's edge configuration that you specified. </p>
    StreamEdgeConfigurationNotFoundException(
        crate::error::StreamEdgeConfigurationNotFoundException,
    ),
    /// <p>You have exceeded the limit of tags that you can associate with the resource. A Kinesis video stream can support up to 50 tags. </p>
    TagsPerResourceExceededLimitException(crate::error::TagsPerResourceExceededLimitException),
    /// <p>The stream version that you specified is not the latest version. To get the latest version, use the <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html">DescribeStream</a> API.</p>
    VersionMismatchException(crate::error::VersionMismatchException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDeniedException(inner) => inner.fmt(f),
            Error::AccountChannelLimitExceededException(inner) => inner.fmt(f),
            Error::AccountStreamLimitExceededException(inner) => inner.fmt(f),
            Error::ClientLimitExceededException(inner) => inner.fmt(f),
            Error::DeviceStreamLimitExceededException(inner) => inner.fmt(f),
            Error::InvalidArgumentException(inner) => inner.fmt(f),
            Error::InvalidDeviceException(inner) => inner.fmt(f),
            Error::InvalidResourceFormatException(inner) => inner.fmt(f),
            Error::NoDataRetentionException(inner) => inner.fmt(f),
            Error::NotAuthorizedException(inner) => inner.fmt(f),
            Error::ResourceInUseException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::StreamEdgeConfigurationNotFoundException(inner) => inner.fmt(f),
            Error::TagsPerResourceExceededLimitException(inner) => inner.fmt(f),
            Error::VersionMismatchException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateSignalingChannelError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateSignalingChannelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateSignalingChannelError> for Error {
    fn from(err: crate::error::CreateSignalingChannelError) -> Self {
        match err {
            crate::error::CreateSignalingChannelError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::CreateSignalingChannelError::AccountChannelLimitExceededException(
                inner,
            ) => Error::AccountChannelLimitExceededException(inner),
            crate::error::CreateSignalingChannelError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::CreateSignalingChannelError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::CreateSignalingChannelError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::CreateSignalingChannelError::TagsPerResourceExceededLimitException(
                inner,
            ) => Error::TagsPerResourceExceededLimitException(inner),
            crate::error::CreateSignalingChannelError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateStreamError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateStreamError> for Error {
    fn from(err: crate::error::CreateStreamError) -> Self {
        match err {
            crate::error::CreateStreamError::AccountStreamLimitExceededException(inner) => {
                Error::AccountStreamLimitExceededException(inner)
            }
            crate::error::CreateStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::CreateStreamError::DeviceStreamLimitExceededException(inner) => {
                Error::DeviceStreamLimitExceededException(inner)
            }
            crate::error::CreateStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::CreateStreamError::InvalidDeviceException(inner) => {
                Error::InvalidDeviceException(inner)
            }
            crate::error::CreateStreamError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::CreateStreamError::TagsPerResourceExceededLimitException(inner) => {
                Error::TagsPerResourceExceededLimitException(inner)
            }
            crate::error::CreateStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteSignalingChannelError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteSignalingChannelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteSignalingChannelError> for Error {
    fn from(err: crate::error::DeleteSignalingChannelError) -> Self {
        match err {
            crate::error::DeleteSignalingChannelError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::DeleteSignalingChannelError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::DeleteSignalingChannelError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DeleteSignalingChannelError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::DeleteSignalingChannelError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DeleteSignalingChannelError::VersionMismatchException(inner) => {
                Error::VersionMismatchException(inner)
            }
            crate::error::DeleteSignalingChannelError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteStreamError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteStreamError> for Error {
    fn from(err: crate::error::DeleteStreamError) -> Self {
        match err {
            crate::error::DeleteStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::DeleteStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DeleteStreamError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::DeleteStreamError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::DeleteStreamError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DeleteStreamError::VersionMismatchException(inner) => {
                Error::VersionMismatchException(inner)
            }
            crate::error::DeleteStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEdgeConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeEdgeConfigurationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEdgeConfigurationError> for Error {
    fn from(err: crate::error::DescribeEdgeConfigurationError) -> Self {
        match err {
            crate::error::DescribeEdgeConfigurationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DescribeEdgeConfigurationError::ClientLimitExceededException(inner) => Error::ClientLimitExceededException(inner),
            crate::error::DescribeEdgeConfigurationError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::error::DescribeEdgeConfigurationError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeEdgeConfigurationError::StreamEdgeConfigurationNotFoundException(inner) => Error::StreamEdgeConfigurationNotFoundException(inner),
            crate::error::DescribeEdgeConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::DescribeImageGenerationConfigurationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeImageGenerationConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeImageGenerationConfigurationError> for Error {
    fn from(err: crate::error::DescribeImageGenerationConfigurationError) -> Self {
        match err {
            crate::error::DescribeImageGenerationConfigurationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DescribeImageGenerationConfigurationError::ClientLimitExceededException(inner) => Error::ClientLimitExceededException(inner),
            crate::error::DescribeImageGenerationConfigurationError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::error::DescribeImageGenerationConfigurationError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeImageGenerationConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::DescribeMappedResourceConfigurationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeMappedResourceConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeMappedResourceConfigurationError> for Error {
    fn from(err: crate::error::DescribeMappedResourceConfigurationError) -> Self {
        match err {
            crate::error::DescribeMappedResourceConfigurationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DescribeMappedResourceConfigurationError::ClientLimitExceededException(inner) => Error::ClientLimitExceededException(inner),
            crate::error::DescribeMappedResourceConfigurationError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::error::DescribeMappedResourceConfigurationError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeMappedResourceConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeMediaStorageConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeMediaStorageConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeMediaStorageConfigurationError> for Error {
    fn from(err: crate::error::DescribeMediaStorageConfigurationError) -> Self {
        match err {
            crate::error::DescribeMediaStorageConfigurationError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::DescribeMediaStorageConfigurationError::ClientLimitExceededException(
                inner,
            ) => Error::ClientLimitExceededException(inner),
            crate::error::DescribeMediaStorageConfigurationError::InvalidArgumentException(
                inner,
            ) => Error::InvalidArgumentException(inner),
            crate::error::DescribeMediaStorageConfigurationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeMediaStorageConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeNotificationConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeNotificationConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeNotificationConfigurationError> for Error {
    fn from(err: crate::error::DescribeNotificationConfigurationError) -> Self {
        match err {
            crate::error::DescribeNotificationConfigurationError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::DescribeNotificationConfigurationError::ClientLimitExceededException(
                inner,
            ) => Error::ClientLimitExceededException(inner),
            crate::error::DescribeNotificationConfigurationError::InvalidArgumentException(
                inner,
            ) => Error::InvalidArgumentException(inner),
            crate::error::DescribeNotificationConfigurationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeNotificationConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeSignalingChannelError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeSignalingChannelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeSignalingChannelError> for Error {
    fn from(err: crate::error::DescribeSignalingChannelError) -> Self {
        match err {
            crate::error::DescribeSignalingChannelError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::DescribeSignalingChannelError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::DescribeSignalingChannelError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeSignalingChannelError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DescribeSignalingChannelError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeStreamError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeStreamError> for Error {
    fn from(err: crate::error::DescribeStreamError) -> Self {
        match err {
            crate::error::DescribeStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::DescribeStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeStreamError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::DescribeStreamError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DescribeStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDataEndpointError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDataEndpointError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDataEndpointError> for Error {
    fn from(err: crate::error::GetDataEndpointError) -> Self {
        match err {
            crate::error::GetDataEndpointError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::GetDataEndpointError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::GetDataEndpointError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::GetDataEndpointError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::GetDataEndpointError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSignalingChannelEndpointError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetSignalingChannelEndpointError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetSignalingChannelEndpointError> for Error {
    fn from(err: crate::error::GetSignalingChannelEndpointError) -> Self {
        match err {
            crate::error::GetSignalingChannelEndpointError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::GetSignalingChannelEndpointError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::GetSignalingChannelEndpointError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::GetSignalingChannelEndpointError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::GetSignalingChannelEndpointError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::GetSignalingChannelEndpointError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListSignalingChannelsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListSignalingChannelsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListSignalingChannelsError> for Error {
    fn from(err: crate::error::ListSignalingChannelsError) -> Self {
        match err {
            crate::error::ListSignalingChannelsError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::ListSignalingChannelsError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::ListSignalingChannelsError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::ListSignalingChannelsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListStreamsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListStreamsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListStreamsError> for Error {
    fn from(err: crate::error::ListStreamsError) -> Self {
        match err {
            crate::error::ListStreamsError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::ListStreamsError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::ListStreamsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::ListTagsForResourceError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::ListTagsForResourceError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::ListTagsForResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForStreamError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForStreamError> for Error {
    fn from(err: crate::error::ListTagsForStreamError) -> Self {
        match err {
            crate::error::ListTagsForStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::ListTagsForStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::ListTagsForStreamError::InvalidResourceFormatException(inner) => {
                Error::InvalidResourceFormatException(inner)
            }
            crate::error::ListTagsForStreamError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::ListTagsForStreamError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListTagsForStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartEdgeConfigurationUpdateError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::StartEdgeConfigurationUpdateError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StartEdgeConfigurationUpdateError> for Error {
    fn from(err: crate::error::StartEdgeConfigurationUpdateError) -> Self {
        match err {
            crate::error::StartEdgeConfigurationUpdateError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::StartEdgeConfigurationUpdateError::ClientLimitExceededException(
                inner,
            ) => Error::ClientLimitExceededException(inner),
            crate::error::StartEdgeConfigurationUpdateError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::StartEdgeConfigurationUpdateError::NoDataRetentionException(inner) => {
                Error::NoDataRetentionException(inner)
            }
            crate::error::StartEdgeConfigurationUpdateError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::StartEdgeConfigurationUpdateError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::StartEdgeConfigurationUpdateError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::TagResourceError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::TagResourceError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::TagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::TagResourceError::TagsPerResourceExceededLimitException(inner) => {
                Error::TagsPerResourceExceededLimitException(inner)
            }
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagStreamError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagStreamError> for Error {
    fn from(err: crate::error::TagStreamError) -> Self {
        match err {
            crate::error::TagStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::TagStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::TagStreamError::InvalidResourceFormatException(inner) => {
                Error::InvalidResourceFormatException(inner)
            }
            crate::error::TagStreamError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::TagStreamError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::TagStreamError::TagsPerResourceExceededLimitException(inner) => {
                Error::TagsPerResourceExceededLimitException(inner)
            }
            crate::error::TagStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::UntagResourceError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::UntagResourceError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UntagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagStreamError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagStreamError> for Error {
    fn from(err: crate::error::UntagStreamError) -> Self {
        match err {
            crate::error::UntagStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::UntagStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UntagStreamError::InvalidResourceFormatException(inner) => {
                Error::InvalidResourceFormatException(inner)
            }
            crate::error::UntagStreamError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::UntagStreamError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UntagStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDataRetentionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDataRetentionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDataRetentionError> for Error {
    fn from(err: crate::error::UpdateDataRetentionError) -> Self {
        match err {
            crate::error::UpdateDataRetentionError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::UpdateDataRetentionError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UpdateDataRetentionError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::UpdateDataRetentionError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateDataRetentionError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateDataRetentionError::VersionMismatchException(inner) => {
                Error::VersionMismatchException(inner)
            }
            crate::error::UpdateDataRetentionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<crate::error::UpdateImageGenerationConfigurationError, R>,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateImageGenerationConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateImageGenerationConfigurationError> for Error {
    fn from(err: crate::error::UpdateImageGenerationConfigurationError) -> Self {
        match err {
            crate::error::UpdateImageGenerationConfigurationError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::UpdateImageGenerationConfigurationError::ClientLimitExceededException(
                inner,
            ) => Error::ClientLimitExceededException(inner),
            crate::error::UpdateImageGenerationConfigurationError::InvalidArgumentException(
                inner,
            ) => Error::InvalidArgumentException(inner),
            crate::error::UpdateImageGenerationConfigurationError::NoDataRetentionException(
                inner,
            ) => Error::NoDataRetentionException(inner),
            crate::error::UpdateImageGenerationConfigurationError::ResourceInUseException(
                inner,
            ) => Error::ResourceInUseException(inner),
            crate::error::UpdateImageGenerationConfigurationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::UpdateImageGenerationConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::UpdateMediaStorageConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateMediaStorageConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateMediaStorageConfigurationError> for Error {
    fn from(err: crate::error::UpdateMediaStorageConfigurationError) -> Self {
        match err {
            crate::error::UpdateMediaStorageConfigurationError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::UpdateMediaStorageConfigurationError::ClientLimitExceededException(
                inner,
            ) => Error::ClientLimitExceededException(inner),
            crate::error::UpdateMediaStorageConfigurationError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UpdateMediaStorageConfigurationError::NoDataRetentionException(inner) => {
                Error::NoDataRetentionException(inner)
            }
            crate::error::UpdateMediaStorageConfigurationError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateMediaStorageConfigurationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::UpdateMediaStorageConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::UpdateNotificationConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateNotificationConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateNotificationConfigurationError> for Error {
    fn from(err: crate::error::UpdateNotificationConfigurationError) -> Self {
        match err {
            crate::error::UpdateNotificationConfigurationError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::UpdateNotificationConfigurationError::ClientLimitExceededException(
                inner,
            ) => Error::ClientLimitExceededException(inner),
            crate::error::UpdateNotificationConfigurationError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UpdateNotificationConfigurationError::NoDataRetentionException(inner) => {
                Error::NoDataRetentionException(inner)
            }
            crate::error::UpdateNotificationConfigurationError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateNotificationConfigurationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::UpdateNotificationConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateSignalingChannelError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateSignalingChannelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateSignalingChannelError> for Error {
    fn from(err: crate::error::UpdateSignalingChannelError) -> Self {
        match err {
            crate::error::UpdateSignalingChannelError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::UpdateSignalingChannelError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::UpdateSignalingChannelError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UpdateSignalingChannelError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateSignalingChannelError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateSignalingChannelError::VersionMismatchException(inner) => {
                Error::VersionMismatchException(inner)
            }
            crate::error::UpdateSignalingChannelError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateStreamError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateStreamError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateStreamError> for Error {
    fn from(err: crate::error::UpdateStreamError) -> Self {
        match err {
            crate::error::UpdateStreamError::ClientLimitExceededException(inner) => {
                Error::ClientLimitExceededException(inner)
            }
            crate::error::UpdateStreamError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UpdateStreamError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::UpdateStreamError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateStreamError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateStreamError::VersionMismatchException(inner) => {
                Error::VersionMismatchException(inner)
            }
            crate::error::UpdateStreamError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDeniedException(e) => e.request_id(),
            Self::AccountChannelLimitExceededException(e) => e.request_id(),
            Self::AccountStreamLimitExceededException(e) => e.request_id(),
            Self::ClientLimitExceededException(e) => e.request_id(),
            Self::DeviceStreamLimitExceededException(e) => e.request_id(),
            Self::InvalidArgumentException(e) => e.request_id(),
            Self::InvalidDeviceException(e) => e.request_id(),
            Self::InvalidResourceFormatException(e) => e.request_id(),
            Self::NoDataRetentionException(e) => e.request_id(),
            Self::NotAuthorizedException(e) => e.request_id(),
            Self::ResourceInUseException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::StreamEdgeConfigurationNotFoundException(e) => e.request_id(),
            Self::TagsPerResourceExceededLimitException(e) => e.request_id(),
            Self::VersionMismatchException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
