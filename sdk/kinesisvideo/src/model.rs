// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SingleMasterConfiguration {
    /// <p>The period of time a signaling channel retains undelivered messages before they are discarded.</p>
    #[doc(hidden)]
    pub message_ttl_seconds: std::option::Option<i32>,
}
impl SingleMasterConfiguration {
    /// <p>The period of time a signaling channel retains undelivered messages before they are discarded.</p>
    pub fn message_ttl_seconds(&self) -> std::option::Option<i32> {
        self.message_ttl_seconds
    }
}
/// See [`SingleMasterConfiguration`](crate::model::SingleMasterConfiguration).
pub mod single_master_configuration {

    /// A builder for [`SingleMasterConfiguration`](crate::model::SingleMasterConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_ttl_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The period of time a signaling channel retains undelivered messages before they are discarded.</p>
        pub fn message_ttl_seconds(mut self, input: i32) -> Self {
            self.message_ttl_seconds = Some(input);
            self
        }
        /// <p>The period of time a signaling channel retains undelivered messages before they are discarded.</p>
        pub fn set_message_ttl_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.message_ttl_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`SingleMasterConfiguration`](crate::model::SingleMasterConfiguration).
        pub fn build(self) -> crate::model::SingleMasterConfiguration {
            crate::model::SingleMasterConfiguration {
                message_ttl_seconds: self.message_ttl_seconds,
            }
        }
    }
}
impl SingleMasterConfiguration {
    /// Creates a new builder-style object to manufacture [`SingleMasterConfiguration`](crate::model::SingleMasterConfiguration).
    pub fn builder() -> crate::model::single_master_configuration::Builder {
        crate::model::single_master_configuration::Builder::default()
    }
}

/// <p>The structure that contains the notification information for the KVS images delivery. If this parameter is null, the configuration will be deleted from the stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotificationConfiguration {
    /// <p>Indicates if a notification configuration is enabled or disabled.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ConfigurationStatus>,
    /// <p>The destination information required to deliver a notification to a customer.</p>
    #[doc(hidden)]
    pub destination_config: std::option::Option<crate::model::NotificationDestinationConfig>,
}
impl NotificationConfiguration {
    /// <p>Indicates if a notification configuration is enabled or disabled.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ConfigurationStatus> {
        self.status.as_ref()
    }
    /// <p>The destination information required to deliver a notification to a customer.</p>
    pub fn destination_config(
        &self,
    ) -> std::option::Option<&crate::model::NotificationDestinationConfig> {
        self.destination_config.as_ref()
    }
}
/// See [`NotificationConfiguration`](crate::model::NotificationConfiguration).
pub mod notification_configuration {

    /// A builder for [`NotificationConfiguration`](crate::model::NotificationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ConfigurationStatus>,
        pub(crate) destination_config:
            std::option::Option<crate::model::NotificationDestinationConfig>,
    }
    impl Builder {
        /// <p>Indicates if a notification configuration is enabled or disabled.</p>
        pub fn status(mut self, input: crate::model::ConfigurationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Indicates if a notification configuration is enabled or disabled.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ConfigurationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The destination information required to deliver a notification to a customer.</p>
        pub fn destination_config(
            mut self,
            input: crate::model::NotificationDestinationConfig,
        ) -> Self {
            self.destination_config = Some(input);
            self
        }
        /// <p>The destination information required to deliver a notification to a customer.</p>
        pub fn set_destination_config(
            mut self,
            input: std::option::Option<crate::model::NotificationDestinationConfig>,
        ) -> Self {
            self.destination_config = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationConfiguration`](crate::model::NotificationConfiguration).
        pub fn build(self) -> crate::model::NotificationConfiguration {
            crate::model::NotificationConfiguration {
                status: self.status,
                destination_config: self.destination_config,
            }
        }
    }
}
impl NotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`NotificationConfiguration`](crate::model::NotificationConfiguration).
    pub fn builder() -> crate::model::notification_configuration::Builder {
        crate::model::notification_configuration::Builder::default()
    }
}

/// <p>The structure that contains the information required to deliver a notification to a customer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotificationDestinationConfig {
    /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
}
impl NotificationDestinationConfig {
    /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
}
/// See [`NotificationDestinationConfig`](crate::model::NotificationDestinationConfig).
pub mod notification_destination_config {

    /// A builder for [`NotificationDestinationConfig`](crate::model::NotificationDestinationConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationDestinationConfig`](crate::model::NotificationDestinationConfig).
        pub fn build(self) -> crate::model::NotificationDestinationConfig {
            crate::model::NotificationDestinationConfig { uri: self.uri }
        }
    }
}
impl NotificationDestinationConfig {
    /// Creates a new builder-style object to manufacture [`NotificationDestinationConfig`](crate::model::NotificationDestinationConfig).
    pub fn builder() -> crate::model::notification_destination_config::Builder {
        crate::model::notification_destination_config::Builder::default()
    }
}

/// When writing a match expression against `ConfigurationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configurationstatus = unimplemented!();
/// match configurationstatus {
///     ConfigurationStatus::Disabled => { /* ... */ },
///     ConfigurationStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configurationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigurationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigurationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigurationStatus::NewFeature` is defined.
/// Specifically, when `configurationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigurationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigurationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigurationStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ConfigurationStatus::Disabled,
            "ENABLED" => ConfigurationStatus::Enabled,
            other => {
                ConfigurationStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConfigurationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigurationStatus::from(s))
    }
}
impl ConfigurationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigurationStatus::Disabled => "DISABLED",
            ConfigurationStatus::Enabled => "ENABLED",
            ConfigurationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for ConfigurationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that encapsulates, or contains, the media storage configuration properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MediaStorageConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the stream </p>
    #[doc(hidden)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The status of the media storage configuration.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::MediaStorageConfigurationStatus>,
}
impl MediaStorageConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the stream </p>
    pub fn stream_arn(&self) -> std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
    /// <p>The status of the media storage configuration.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::MediaStorageConfigurationStatus> {
        self.status.as_ref()
    }
}
/// See [`MediaStorageConfiguration`](crate::model::MediaStorageConfiguration).
pub mod media_storage_configuration {

    /// A builder for [`MediaStorageConfiguration`](crate::model::MediaStorageConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MediaStorageConfigurationStatus>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the stream </p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream </p>
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = input;
            self
        }
        /// <p>The status of the media storage configuration.</p>
        pub fn status(mut self, input: crate::model::MediaStorageConfigurationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the media storage configuration.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MediaStorageConfigurationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`MediaStorageConfiguration`](crate::model::MediaStorageConfiguration).
        pub fn build(self) -> crate::model::MediaStorageConfiguration {
            crate::model::MediaStorageConfiguration {
                stream_arn: self.stream_arn,
                status: self.status,
            }
        }
    }
}
impl MediaStorageConfiguration {
    /// Creates a new builder-style object to manufacture [`MediaStorageConfiguration`](crate::model::MediaStorageConfiguration).
    pub fn builder() -> crate::model::media_storage_configuration::Builder {
        crate::model::media_storage_configuration::Builder::default()
    }
}

/// When writing a match expression against `MediaStorageConfigurationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mediastorageconfigurationstatus = unimplemented!();
/// match mediastorageconfigurationstatus {
///     MediaStorageConfigurationStatus::Disabled => { /* ... */ },
///     MediaStorageConfigurationStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mediastorageconfigurationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MediaStorageConfigurationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MediaStorageConfigurationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MediaStorageConfigurationStatus::NewFeature` is defined.
/// Specifically, when `mediastorageconfigurationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MediaStorageConfigurationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaStorageConfigurationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MediaStorageConfigurationStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => MediaStorageConfigurationStatus::Disabled,
            "ENABLED" => MediaStorageConfigurationStatus::Enabled,
            other => MediaStorageConfigurationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MediaStorageConfigurationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaStorageConfigurationStatus::from(s))
    }
}
impl MediaStorageConfigurationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaStorageConfigurationStatus::Disabled => "DISABLED",
            MediaStorageConfigurationStatus::Enabled => "ENABLED",
            MediaStorageConfigurationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for MediaStorageConfigurationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The structure that contains the information required for the KVS images delivery. If null, the configuration will be deleted from the stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageGenerationConfiguration {
    /// <p>Indicates whether the <code>ContinuousImageGenerationConfigurations</code> API is enabled or disabled.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ConfigurationStatus>,
    /// <p>The origin of the Server or Producer timestamps to use to generate the images.</p>
    #[doc(hidden)]
    pub image_selector_type: std::option::Option<crate::model::ImageSelectorType>,
    /// <p>The structure that contains the information required to deliver images to a customer.</p>
    #[doc(hidden)]
    pub destination_config: std::option::Option<crate::model::ImageGenerationDestinationConfig>,
    /// <p>The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 33 ms, because a camera that generates content at 30 FPS would create a frame every 33.3 ms. If the timestamp range is less than the sampling interval, the Image from the <code>StartTimestamp</code> will be returned if available. </p>
    #[doc(hidden)]
    pub sampling_interval: std::option::Option<i32>,
    /// <p>The accepted image format.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::Format>,
    /// <p>The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The <code>FormatConfig</code> key is the <code>JPEGQuality</code>, which indicates the JPEG quality key to be used to generate the image. The <code>FormatConfig</code> value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the <code>JPEGQuality</code> key will be set to 80.</p>
    #[doc(hidden)]
    pub format_config: std::option::Option<
        std::collections::HashMap<crate::model::FormatConfigKey, std::string::String>,
    >,
    /// <p>The width of the output image that is used in conjunction with the <code>HeightPixels</code> parameter. When both <code>WidthPixels</code> and <code>HeightPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>WidthPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>HeightPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
    #[doc(hidden)]
    pub width_pixels: std::option::Option<i32>,
    /// <p>The height of the output image that is used in conjunction with the <code>WidthPixels</code> parameter. When both <code>HeightPixels</code> and <code>WidthPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>HeightPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>WidthPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
    #[doc(hidden)]
    pub height_pixels: std::option::Option<i32>,
}
impl ImageGenerationConfiguration {
    /// <p>Indicates whether the <code>ContinuousImageGenerationConfigurations</code> API is enabled or disabled.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ConfigurationStatus> {
        self.status.as_ref()
    }
    /// <p>The origin of the Server or Producer timestamps to use to generate the images.</p>
    pub fn image_selector_type(&self) -> std::option::Option<&crate::model::ImageSelectorType> {
        self.image_selector_type.as_ref()
    }
    /// <p>The structure that contains the information required to deliver images to a customer.</p>
    pub fn destination_config(
        &self,
    ) -> std::option::Option<&crate::model::ImageGenerationDestinationConfig> {
        self.destination_config.as_ref()
    }
    /// <p>The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 33 ms, because a camera that generates content at 30 FPS would create a frame every 33.3 ms. If the timestamp range is less than the sampling interval, the Image from the <code>StartTimestamp</code> will be returned if available. </p>
    pub fn sampling_interval(&self) -> std::option::Option<i32> {
        self.sampling_interval
    }
    /// <p>The accepted image format.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::Format> {
        self.format.as_ref()
    }
    /// <p>The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The <code>FormatConfig</code> key is the <code>JPEGQuality</code>, which indicates the JPEG quality key to be used to generate the image. The <code>FormatConfig</code> value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the <code>JPEGQuality</code> key will be set to 80.</p>
    pub fn format_config(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::FormatConfigKey, std::string::String>,
    > {
        self.format_config.as_ref()
    }
    /// <p>The width of the output image that is used in conjunction with the <code>HeightPixels</code> parameter. When both <code>WidthPixels</code> and <code>HeightPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>WidthPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>HeightPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
    pub fn width_pixels(&self) -> std::option::Option<i32> {
        self.width_pixels
    }
    /// <p>The height of the output image that is used in conjunction with the <code>WidthPixels</code> parameter. When both <code>HeightPixels</code> and <code>WidthPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>HeightPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>WidthPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
    pub fn height_pixels(&self) -> std::option::Option<i32> {
        self.height_pixels
    }
}
/// See [`ImageGenerationConfiguration`](crate::model::ImageGenerationConfiguration).
pub mod image_generation_configuration {

    /// A builder for [`ImageGenerationConfiguration`](crate::model::ImageGenerationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ConfigurationStatus>,
        pub(crate) image_selector_type: std::option::Option<crate::model::ImageSelectorType>,
        pub(crate) destination_config:
            std::option::Option<crate::model::ImageGenerationDestinationConfig>,
        pub(crate) sampling_interval: std::option::Option<i32>,
        pub(crate) format: std::option::Option<crate::model::Format>,
        pub(crate) format_config: std::option::Option<
            std::collections::HashMap<crate::model::FormatConfigKey, std::string::String>,
        >,
        pub(crate) width_pixels: std::option::Option<i32>,
        pub(crate) height_pixels: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether the <code>ContinuousImageGenerationConfigurations</code> API is enabled or disabled.</p>
        pub fn status(mut self, input: crate::model::ConfigurationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Indicates whether the <code>ContinuousImageGenerationConfigurations</code> API is enabled or disabled.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ConfigurationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The origin of the Server or Producer timestamps to use to generate the images.</p>
        pub fn image_selector_type(mut self, input: crate::model::ImageSelectorType) -> Self {
            self.image_selector_type = Some(input);
            self
        }
        /// <p>The origin of the Server or Producer timestamps to use to generate the images.</p>
        pub fn set_image_selector_type(
            mut self,
            input: std::option::Option<crate::model::ImageSelectorType>,
        ) -> Self {
            self.image_selector_type = input;
            self
        }
        /// <p>The structure that contains the information required to deliver images to a customer.</p>
        pub fn destination_config(
            mut self,
            input: crate::model::ImageGenerationDestinationConfig,
        ) -> Self {
            self.destination_config = Some(input);
            self
        }
        /// <p>The structure that contains the information required to deliver images to a customer.</p>
        pub fn set_destination_config(
            mut self,
            input: std::option::Option<crate::model::ImageGenerationDestinationConfig>,
        ) -> Self {
            self.destination_config = input;
            self
        }
        /// <p>The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 33 ms, because a camera that generates content at 30 FPS would create a frame every 33.3 ms. If the timestamp range is less than the sampling interval, the Image from the <code>StartTimestamp</code> will be returned if available. </p>
        pub fn sampling_interval(mut self, input: i32) -> Self {
            self.sampling_interval = Some(input);
            self
        }
        /// <p>The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 33 ms, because a camera that generates content at 30 FPS would create a frame every 33.3 ms. If the timestamp range is less than the sampling interval, the Image from the <code>StartTimestamp</code> will be returned if available. </p>
        pub fn set_sampling_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.sampling_interval = input;
            self
        }
        /// <p>The accepted image format.</p>
        pub fn format(mut self, input: crate::model::Format) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The accepted image format.</p>
        pub fn set_format(mut self, input: std::option::Option<crate::model::Format>) -> Self {
            self.format = input;
            self
        }
        /// Adds a key-value pair to `format_config`.
        ///
        /// To override the contents of this collection use [`set_format_config`](Self::set_format_config).
        ///
        /// <p>The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The <code>FormatConfig</code> key is the <code>JPEGQuality</code>, which indicates the JPEG quality key to be used to generate the image. The <code>FormatConfig</code> value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the <code>JPEGQuality</code> key will be set to 80.</p>
        pub fn format_config(
            mut self,
            k: crate::model::FormatConfigKey,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.format_config.unwrap_or_default();
            hash_map.insert(k, v.into());
            self.format_config = Some(hash_map);
            self
        }
        /// <p>The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The <code>FormatConfig</code> key is the <code>JPEGQuality</code>, which indicates the JPEG quality key to be used to generate the image. The <code>FormatConfig</code> value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the <code>JPEGQuality</code> key will be set to 80.</p>
        pub fn set_format_config(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::FormatConfigKey, std::string::String>,
            >,
        ) -> Self {
            self.format_config = input;
            self
        }
        /// <p>The width of the output image that is used in conjunction with the <code>HeightPixels</code> parameter. When both <code>WidthPixels</code> and <code>HeightPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>WidthPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>HeightPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
        pub fn width_pixels(mut self, input: i32) -> Self {
            self.width_pixels = Some(input);
            self
        }
        /// <p>The width of the output image that is used in conjunction with the <code>HeightPixels</code> parameter. When both <code>WidthPixels</code> and <code>HeightPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>WidthPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>HeightPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
        pub fn set_width_pixels(mut self, input: std::option::Option<i32>) -> Self {
            self.width_pixels = input;
            self
        }
        /// <p>The height of the output image that is used in conjunction with the <code>WidthPixels</code> parameter. When both <code>HeightPixels</code> and <code>WidthPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>HeightPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>WidthPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
        pub fn height_pixels(mut self, input: i32) -> Self {
            self.height_pixels = Some(input);
            self
        }
        /// <p>The height of the output image that is used in conjunction with the <code>WidthPixels</code> parameter. When both <code>HeightPixels</code> and <code>WidthPixels</code> parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the <code>HeightPixels</code> parameter is provided, its original aspect ratio will be used to calculate the <code>WidthPixels</code> ratio. If neither parameter is provided, the original image size will be returned.</p>
        pub fn set_height_pixels(mut self, input: std::option::Option<i32>) -> Self {
            self.height_pixels = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageGenerationConfiguration`](crate::model::ImageGenerationConfiguration).
        pub fn build(self) -> crate::model::ImageGenerationConfiguration {
            crate::model::ImageGenerationConfiguration {
                status: self.status,
                image_selector_type: self.image_selector_type,
                destination_config: self.destination_config,
                sampling_interval: self.sampling_interval,
                format: self.format,
                format_config: self.format_config,
                width_pixels: self.width_pixels,
                height_pixels: self.height_pixels,
            }
        }
    }
}
impl ImageGenerationConfiguration {
    /// Creates a new builder-style object to manufacture [`ImageGenerationConfiguration`](crate::model::ImageGenerationConfiguration).
    pub fn builder() -> crate::model::image_generation_configuration::Builder {
        crate::model::image_generation_configuration::Builder::default()
    }
}

/// When writing a match expression against `FormatConfigKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let formatconfigkey = unimplemented!();
/// match formatconfigkey {
///     FormatConfigKey::JpegQuality => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `formatconfigkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FormatConfigKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FormatConfigKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FormatConfigKey::NewFeature` is defined.
/// Specifically, when `formatconfigkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FormatConfigKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FormatConfigKey {
    #[allow(missing_docs)] // documentation missing in model
    JpegQuality,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FormatConfigKey {
    fn from(s: &str) -> Self {
        match s {
            "JPEGQuality" => FormatConfigKey::JpegQuality,
            other => FormatConfigKey::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FormatConfigKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FormatConfigKey::from(s))
    }
}
impl FormatConfigKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FormatConfigKey::JpegQuality => "JPEGQuality",
            FormatConfigKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["JPEGQuality"]
    }
}
impl AsRef<str> for FormatConfigKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Format`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let format = unimplemented!();
/// match format {
///     Format::Jpeg => { /* ... */ },
///     Format::Png => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `format` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Format::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Format::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Format::NewFeature` is defined.
/// Specifically, when `format` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Format::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Format {
    #[allow(missing_docs)] // documentation missing in model
    Jpeg,
    #[allow(missing_docs)] // documentation missing in model
    Png,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Format {
    fn from(s: &str) -> Self {
        match s {
            "JPEG" => Format::Jpeg,
            "PNG" => Format::Png,
            other => Format::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Format {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Format::from(s))
    }
}
impl Format {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Format::Jpeg => "JPEG",
            Format::Png => "PNG",
            Format::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["JPEG", "PNG"]
    }
}
impl AsRef<str> for Format {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The structure that contains the information required to deliver images to a customer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageGenerationDestinationConfig {
    /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>The AWS Region of the S3 bucket where images will be delivered. This <code>DestinationRegion</code> must match the Region where the stream is located.</p>
    #[doc(hidden)]
    pub destination_region: std::option::Option<std::string::String>,
}
impl ImageGenerationDestinationConfig {
    /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The AWS Region of the S3 bucket where images will be delivered. This <code>DestinationRegion</code> must match the Region where the stream is located.</p>
    pub fn destination_region(&self) -> std::option::Option<&str> {
        self.destination_region.as_deref()
    }
}
/// See [`ImageGenerationDestinationConfig`](crate::model::ImageGenerationDestinationConfig).
pub mod image_generation_destination_config {

    /// A builder for [`ImageGenerationDestinationConfig`](crate::model::ImageGenerationDestinationConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) destination_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The Uniform Resource Identifier (URI) that identifies where the images will be delivered.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The AWS Region of the S3 bucket where images will be delivered. This <code>DestinationRegion</code> must match the Region where the stream is located.</p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_region = Some(input.into());
            self
        }
        /// <p>The AWS Region of the S3 bucket where images will be delivered. This <code>DestinationRegion</code> must match the Region where the stream is located.</p>
        pub fn set_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_region = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageGenerationDestinationConfig`](crate::model::ImageGenerationDestinationConfig).
        pub fn build(self) -> crate::model::ImageGenerationDestinationConfig {
            crate::model::ImageGenerationDestinationConfig {
                uri: self.uri,
                destination_region: self.destination_region,
            }
        }
    }
}
impl ImageGenerationDestinationConfig {
    /// Creates a new builder-style object to manufacture [`ImageGenerationDestinationConfig`](crate::model::ImageGenerationDestinationConfig).
    pub fn builder() -> crate::model::image_generation_destination_config::Builder {
        crate::model::image_generation_destination_config::Builder::default()
    }
}

/// When writing a match expression against `ImageSelectorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let imageselectortype = unimplemented!();
/// match imageselectortype {
///     ImageSelectorType::ProducerTimestamp => { /* ... */ },
///     ImageSelectorType::ServerTimestamp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `imageselectortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ImageSelectorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ImageSelectorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ImageSelectorType::NewFeature` is defined.
/// Specifically, when `imageselectortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ImageSelectorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageSelectorType {
    #[allow(missing_docs)] // documentation missing in model
    ProducerTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    ServerTimestamp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ImageSelectorType {
    fn from(s: &str) -> Self {
        match s {
            "PRODUCER_TIMESTAMP" => ImageSelectorType::ProducerTimestamp,
            "SERVER_TIMESTAMP" => ImageSelectorType::ServerTimestamp,
            other => {
                ImageSelectorType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ImageSelectorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageSelectorType::from(s))
    }
}
impl ImageSelectorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageSelectorType::ProducerTimestamp => "PRODUCER_TIMESTAMP",
            ImageSelectorType::ServerTimestamp => "SERVER_TIMESTAMP",
            ImageSelectorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRODUCER_TIMESTAMP", "SERVER_TIMESTAMP"]
    }
}
impl AsRef<str> for ImageSelectorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UpdateDataRetentionOperation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updatedataretentionoperation = unimplemented!();
/// match updatedataretentionoperation {
///     UpdateDataRetentionOperation::DecreaseDataRetention => { /* ... */ },
///     UpdateDataRetentionOperation::IncreaseDataRetention => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatedataretentionoperation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateDataRetentionOperation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateDataRetentionOperation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateDataRetentionOperation::NewFeature` is defined.
/// Specifically, when `updatedataretentionoperation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateDataRetentionOperation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateDataRetentionOperation {
    #[allow(missing_docs)] // documentation missing in model
    DecreaseDataRetention,
    #[allow(missing_docs)] // documentation missing in model
    IncreaseDataRetention,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateDataRetentionOperation {
    fn from(s: &str) -> Self {
        match s {
            "DECREASE_DATA_RETENTION" => UpdateDataRetentionOperation::DecreaseDataRetention,
            "INCREASE_DATA_RETENTION" => UpdateDataRetentionOperation::IncreaseDataRetention,
            other => UpdateDataRetentionOperation::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for UpdateDataRetentionOperation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateDataRetentionOperation::from(s))
    }
}
impl UpdateDataRetentionOperation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateDataRetentionOperation::DecreaseDataRetention => "DECREASE_DATA_RETENTION",
            UpdateDataRetentionOperation::IncreaseDataRetention => "INCREASE_DATA_RETENTION",
            UpdateDataRetentionOperation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DECREASE_DATA_RETENTION", "INCREASE_DATA_RETENTION"]
    }
}
impl AsRef<str> for UpdateDataRetentionOperation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A key and value pair that is associated with the specified signaling channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key of the tag that is associated with the specified signaling channel.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag that is associated with the specified signaling channel.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key of the tag that is associated with the specified signaling channel.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag that is associated with the specified signaling channel.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag that is associated with the specified signaling channel.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the tag that is associated with the specified signaling channel.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag that is associated with the specified signaling channel.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag that is associated with the specified signaling channel.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EdgeConfig {
    /// <p>The "<b>Internet of Things (IoT) Thing</b>" Arn of the stream.</p>
    #[doc(hidden)]
    pub hub_device_arn: std::option::Option<std::string::String>,
    /// <p>The recorder configuration consists of the local <code>MediaSourceConfig</code> details, that are used as credentials to access the local media files streamed on the camera. </p>
    #[doc(hidden)]
    pub recorder_config: std::option::Option<crate::model::RecorderConfig>,
    /// <p>The uploader configuration contains the <code>ScheduleExpression</code> details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.</p>
    #[doc(hidden)]
    pub uploader_config: std::option::Option<crate::model::UploaderConfig>,
    /// <p>The deletion configuration is made up of the retention time (<code>EdgeRetentionInHours</code>) and local size configuration (<code>LocalSizeConfig</code>) details that are used to make the deletion.</p>
    #[doc(hidden)]
    pub deletion_config: std::option::Option<crate::model::DeletionConfig>,
}
impl EdgeConfig {
    /// <p>The "<b>Internet of Things (IoT) Thing</b>" Arn of the stream.</p>
    pub fn hub_device_arn(&self) -> std::option::Option<&str> {
        self.hub_device_arn.as_deref()
    }
    /// <p>The recorder configuration consists of the local <code>MediaSourceConfig</code> details, that are used as credentials to access the local media files streamed on the camera. </p>
    pub fn recorder_config(&self) -> std::option::Option<&crate::model::RecorderConfig> {
        self.recorder_config.as_ref()
    }
    /// <p>The uploader configuration contains the <code>ScheduleExpression</code> details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.</p>
    pub fn uploader_config(&self) -> std::option::Option<&crate::model::UploaderConfig> {
        self.uploader_config.as_ref()
    }
    /// <p>The deletion configuration is made up of the retention time (<code>EdgeRetentionInHours</code>) and local size configuration (<code>LocalSizeConfig</code>) details that are used to make the deletion.</p>
    pub fn deletion_config(&self) -> std::option::Option<&crate::model::DeletionConfig> {
        self.deletion_config.as_ref()
    }
}
/// See [`EdgeConfig`](crate::model::EdgeConfig).
pub mod edge_config {

    /// A builder for [`EdgeConfig`](crate::model::EdgeConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hub_device_arn: std::option::Option<std::string::String>,
        pub(crate) recorder_config: std::option::Option<crate::model::RecorderConfig>,
        pub(crate) uploader_config: std::option::Option<crate::model::UploaderConfig>,
        pub(crate) deletion_config: std::option::Option<crate::model::DeletionConfig>,
    }
    impl Builder {
        /// <p>The "<b>Internet of Things (IoT) Thing</b>" Arn of the stream.</p>
        pub fn hub_device_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.hub_device_arn = Some(input.into());
            self
        }
        /// <p>The "<b>Internet of Things (IoT) Thing</b>" Arn of the stream.</p>
        pub fn set_hub_device_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hub_device_arn = input;
            self
        }
        /// <p>The recorder configuration consists of the local <code>MediaSourceConfig</code> details, that are used as credentials to access the local media files streamed on the camera. </p>
        pub fn recorder_config(mut self, input: crate::model::RecorderConfig) -> Self {
            self.recorder_config = Some(input);
            self
        }
        /// <p>The recorder configuration consists of the local <code>MediaSourceConfig</code> details, that are used as credentials to access the local media files streamed on the camera. </p>
        pub fn set_recorder_config(
            mut self,
            input: std::option::Option<crate::model::RecorderConfig>,
        ) -> Self {
            self.recorder_config = input;
            self
        }
        /// <p>The uploader configuration contains the <code>ScheduleExpression</code> details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.</p>
        pub fn uploader_config(mut self, input: crate::model::UploaderConfig) -> Self {
            self.uploader_config = Some(input);
            self
        }
        /// <p>The uploader configuration contains the <code>ScheduleExpression</code> details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.</p>
        pub fn set_uploader_config(
            mut self,
            input: std::option::Option<crate::model::UploaderConfig>,
        ) -> Self {
            self.uploader_config = input;
            self
        }
        /// <p>The deletion configuration is made up of the retention time (<code>EdgeRetentionInHours</code>) and local size configuration (<code>LocalSizeConfig</code>) details that are used to make the deletion.</p>
        pub fn deletion_config(mut self, input: crate::model::DeletionConfig) -> Self {
            self.deletion_config = Some(input);
            self
        }
        /// <p>The deletion configuration is made up of the retention time (<code>EdgeRetentionInHours</code>) and local size configuration (<code>LocalSizeConfig</code>) details that are used to make the deletion.</p>
        pub fn set_deletion_config(
            mut self,
            input: std::option::Option<crate::model::DeletionConfig>,
        ) -> Self {
            self.deletion_config = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeConfig`](crate::model::EdgeConfig).
        pub fn build(self) -> crate::model::EdgeConfig {
            crate::model::EdgeConfig {
                hub_device_arn: self.hub_device_arn,
                recorder_config: self.recorder_config,
                uploader_config: self.uploader_config,
                deletion_config: self.deletion_config,
            }
        }
    }
}
impl EdgeConfig {
    /// Creates a new builder-style object to manufacture [`EdgeConfig`](crate::model::EdgeConfig).
    pub fn builder() -> crate::model::edge_config::Builder {
        crate::model::edge_config::Builder::default()
    }
}

/// <p>The configuration details required to delete the connection of the stream from the Edge Agent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeletionConfig {
    /// <p>The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.</p>
    #[doc(hidden)]
    pub edge_retention_in_hours: std::option::Option<i32>,
    /// <p>The value of the local size required in order to delete the edge configuration.</p>
    #[doc(hidden)]
    pub local_size_config: std::option::Option<crate::model::LocalSizeConfig>,
    /// <p>The <code>boolean</code> value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to <code>true</code>, such as when the limit for the <code>EdgeRetentionInHours</code>, or the <code>MaxLocalMediaSizeInMB</code>, has been reached. </p>
    /// <p>Since the default value is set to <code>true</code>, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to AWS cloud.</p>
    #[doc(hidden)]
    pub delete_after_upload: std::option::Option<bool>,
}
impl DeletionConfig {
    /// <p>The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.</p>
    pub fn edge_retention_in_hours(&self) -> std::option::Option<i32> {
        self.edge_retention_in_hours
    }
    /// <p>The value of the local size required in order to delete the edge configuration.</p>
    pub fn local_size_config(&self) -> std::option::Option<&crate::model::LocalSizeConfig> {
        self.local_size_config.as_ref()
    }
    /// <p>The <code>boolean</code> value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to <code>true</code>, such as when the limit for the <code>EdgeRetentionInHours</code>, or the <code>MaxLocalMediaSizeInMB</code>, has been reached. </p>
    /// <p>Since the default value is set to <code>true</code>, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to AWS cloud.</p>
    pub fn delete_after_upload(&self) -> std::option::Option<bool> {
        self.delete_after_upload
    }
}
/// See [`DeletionConfig`](crate::model::DeletionConfig).
pub mod deletion_config {

    /// A builder for [`DeletionConfig`](crate::model::DeletionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) edge_retention_in_hours: std::option::Option<i32>,
        pub(crate) local_size_config: std::option::Option<crate::model::LocalSizeConfig>,
        pub(crate) delete_after_upload: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.</p>
        pub fn edge_retention_in_hours(mut self, input: i32) -> Self {
            self.edge_retention_in_hours = Some(input);
            self
        }
        /// <p>The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.</p>
        pub fn set_edge_retention_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.edge_retention_in_hours = input;
            self
        }
        /// <p>The value of the local size required in order to delete the edge configuration.</p>
        pub fn local_size_config(mut self, input: crate::model::LocalSizeConfig) -> Self {
            self.local_size_config = Some(input);
            self
        }
        /// <p>The value of the local size required in order to delete the edge configuration.</p>
        pub fn set_local_size_config(
            mut self,
            input: std::option::Option<crate::model::LocalSizeConfig>,
        ) -> Self {
            self.local_size_config = input;
            self
        }
        /// <p>The <code>boolean</code> value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to <code>true</code>, such as when the limit for the <code>EdgeRetentionInHours</code>, or the <code>MaxLocalMediaSizeInMB</code>, has been reached. </p>
        /// <p>Since the default value is set to <code>true</code>, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to AWS cloud.</p>
        pub fn delete_after_upload(mut self, input: bool) -> Self {
            self.delete_after_upload = Some(input);
            self
        }
        /// <p>The <code>boolean</code> value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to <code>true</code>, such as when the limit for the <code>EdgeRetentionInHours</code>, or the <code>MaxLocalMediaSizeInMB</code>, has been reached. </p>
        /// <p>Since the default value is set to <code>true</code>, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to AWS cloud.</p>
        pub fn set_delete_after_upload(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_after_upload = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletionConfig`](crate::model::DeletionConfig).
        pub fn build(self) -> crate::model::DeletionConfig {
            crate::model::DeletionConfig {
                edge_retention_in_hours: self.edge_retention_in_hours,
                local_size_config: self.local_size_config,
                delete_after_upload: self.delete_after_upload,
            }
        }
    }
}
impl DeletionConfig {
    /// Creates a new builder-style object to manufacture [`DeletionConfig`](crate::model::DeletionConfig).
    pub fn builder() -> crate::model::deletion_config::Builder {
        crate::model::deletion_config::Builder::default()
    }
}

/// <p>The configuration details that include the maximum size of the media (<code>MaxLocalMediaSizeInMB</code>) that you want to store for a stream on the Edge Agent, as well as the strategy that should be used (<code>StrategyOnFullSize</code>) when a stream's maximum size has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LocalSizeConfig {
    /// <p>The overall maximum size of the media that you want to store for a stream on the Edge Agent. </p>
    #[doc(hidden)]
    pub max_local_media_size_in_mb: std::option::Option<i32>,
    /// <p>The strategy to perform when a stream’s <code>MaxLocalMediaSizeInMB</code> limit is reached.</p>
    #[doc(hidden)]
    pub strategy_on_full_size: std::option::Option<crate::model::StrategyOnFullSize>,
}
impl LocalSizeConfig {
    /// <p>The overall maximum size of the media that you want to store for a stream on the Edge Agent. </p>
    pub fn max_local_media_size_in_mb(&self) -> std::option::Option<i32> {
        self.max_local_media_size_in_mb
    }
    /// <p>The strategy to perform when a stream’s <code>MaxLocalMediaSizeInMB</code> limit is reached.</p>
    pub fn strategy_on_full_size(&self) -> std::option::Option<&crate::model::StrategyOnFullSize> {
        self.strategy_on_full_size.as_ref()
    }
}
/// See [`LocalSizeConfig`](crate::model::LocalSizeConfig).
pub mod local_size_config {

    /// A builder for [`LocalSizeConfig`](crate::model::LocalSizeConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_local_media_size_in_mb: std::option::Option<i32>,
        pub(crate) strategy_on_full_size: std::option::Option<crate::model::StrategyOnFullSize>,
    }
    impl Builder {
        /// <p>The overall maximum size of the media that you want to store for a stream on the Edge Agent. </p>
        pub fn max_local_media_size_in_mb(mut self, input: i32) -> Self {
            self.max_local_media_size_in_mb = Some(input);
            self
        }
        /// <p>The overall maximum size of the media that you want to store for a stream on the Edge Agent. </p>
        pub fn set_max_local_media_size_in_mb(mut self, input: std::option::Option<i32>) -> Self {
            self.max_local_media_size_in_mb = input;
            self
        }
        /// <p>The strategy to perform when a stream’s <code>MaxLocalMediaSizeInMB</code> limit is reached.</p>
        pub fn strategy_on_full_size(mut self, input: crate::model::StrategyOnFullSize) -> Self {
            self.strategy_on_full_size = Some(input);
            self
        }
        /// <p>The strategy to perform when a stream’s <code>MaxLocalMediaSizeInMB</code> limit is reached.</p>
        pub fn set_strategy_on_full_size(
            mut self,
            input: std::option::Option<crate::model::StrategyOnFullSize>,
        ) -> Self {
            self.strategy_on_full_size = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalSizeConfig`](crate::model::LocalSizeConfig).
        pub fn build(self) -> crate::model::LocalSizeConfig {
            crate::model::LocalSizeConfig {
                max_local_media_size_in_mb: self.max_local_media_size_in_mb,
                strategy_on_full_size: self.strategy_on_full_size,
            }
        }
    }
}
impl LocalSizeConfig {
    /// Creates a new builder-style object to manufacture [`LocalSizeConfig`](crate::model::LocalSizeConfig).
    pub fn builder() -> crate::model::local_size_config::Builder {
        crate::model::local_size_config::Builder::default()
    }
}

/// When writing a match expression against `StrategyOnFullSize`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let strategyonfullsize = unimplemented!();
/// match strategyonfullsize {
///     StrategyOnFullSize::DeleteOldestMedia => { /* ... */ },
///     StrategyOnFullSize::DenyNewMedia => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `strategyonfullsize` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StrategyOnFullSize::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StrategyOnFullSize::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StrategyOnFullSize::NewFeature` is defined.
/// Specifically, when `strategyonfullsize` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StrategyOnFullSize::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StrategyOnFullSize {
    #[allow(missing_docs)] // documentation missing in model
    DeleteOldestMedia,
    #[allow(missing_docs)] // documentation missing in model
    DenyNewMedia,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StrategyOnFullSize {
    fn from(s: &str) -> Self {
        match s {
            "DELETE_OLDEST_MEDIA" => StrategyOnFullSize::DeleteOldestMedia,
            "DENY_NEW_MEDIA" => StrategyOnFullSize::DenyNewMedia,
            other => {
                StrategyOnFullSize::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StrategyOnFullSize {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StrategyOnFullSize::from(s))
    }
}
impl StrategyOnFullSize {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StrategyOnFullSize::DeleteOldestMedia => "DELETE_OLDEST_MEDIA",
            StrategyOnFullSize::DenyNewMedia => "DENY_NEW_MEDIA",
            StrategyOnFullSize::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETE_OLDEST_MEDIA", "DENY_NEW_MEDIA"]
    }
}
impl AsRef<str> for StrategyOnFullSize {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutesdetails</code>, that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided, then the Edge Agent will always be in upload mode. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UploaderConfig {
    /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code>details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided, then the Edge Agent will always be in recording mode.</p>
    #[doc(hidden)]
    pub schedule_config: std::option::Option<crate::model::ScheduleConfig>,
}
impl UploaderConfig {
    /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code>details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided, then the Edge Agent will always be in recording mode.</p>
    pub fn schedule_config(&self) -> std::option::Option<&crate::model::ScheduleConfig> {
        self.schedule_config.as_ref()
    }
}
/// See [`UploaderConfig`](crate::model::UploaderConfig).
pub mod uploader_config {

    /// A builder for [`UploaderConfig`](crate::model::UploaderConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_config: std::option::Option<crate::model::ScheduleConfig>,
    }
    impl Builder {
        /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code>details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided, then the Edge Agent will always be in recording mode.</p>
        pub fn schedule_config(mut self, input: crate::model::ScheduleConfig) -> Self {
            self.schedule_config = Some(input);
            self
        }
        /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code>details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided, then the Edge Agent will always be in recording mode.</p>
        pub fn set_schedule_config(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfig>,
        ) -> Self {
            self.schedule_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UploaderConfig`](crate::model::UploaderConfig).
        pub fn build(self) -> crate::model::UploaderConfig {
            crate::model::UploaderConfig {
                schedule_config: self.schedule_config,
            }
        }
    }
}
impl UploaderConfig {
    /// Creates a new builder-style object to manufacture [`UploaderConfig`](crate::model::UploaderConfig).
    pub fn builder() -> crate::model::uploader_config::Builder {
        crate::model::uploader_config::Builder::default()
    }
}

/// <p>This API enables you to specify the duration that the camera, or local media file, should record onto the Edge Agent. The <code>ScheduleConfig</code> consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code> attributes. </p>
/// <p>If the <code>ScheduleExpression</code> is not provided, then the Edge Agent will always be set to recording mode.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleConfig {
    /// <p>The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided for the <code>RecorderConfig</code>, then the Edge Agent will always be set to recording mode.</p>
    /// <p>For more information about Quartz, refer to the <a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html"> <i>Cron Trigger Tutorial</i> </a> page to understand the valid expressions and its use.</p>
    #[doc(hidden)]
    pub schedule_expression: std::option::Option<std::string::String>,
    /// <p>The total duration to record the media. If the <code>ScheduleExpression</code> attribute is provided, then the <code>DurationInSeconds</code> attribute should also be specified.</p>
    #[doc(hidden)]
    pub duration_in_seconds: std::option::Option<i32>,
}
impl ScheduleConfig {
    /// <p>The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided for the <code>RecorderConfig</code>, then the Edge Agent will always be set to recording mode.</p>
    /// <p>For more information about Quartz, refer to the <a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html"> <i>Cron Trigger Tutorial</i> </a> page to understand the valid expressions and its use.</p>
    pub fn schedule_expression(&self) -> std::option::Option<&str> {
        self.schedule_expression.as_deref()
    }
    /// <p>The total duration to record the media. If the <code>ScheduleExpression</code> attribute is provided, then the <code>DurationInSeconds</code> attribute should also be specified.</p>
    pub fn duration_in_seconds(&self) -> std::option::Option<i32> {
        self.duration_in_seconds
    }
}
/// See [`ScheduleConfig`](crate::model::ScheduleConfig).
pub mod schedule_config {

    /// A builder for [`ScheduleConfig`](crate::model::ScheduleConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
        pub(crate) duration_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided for the <code>RecorderConfig</code>, then the Edge Agent will always be set to recording mode.</p>
        /// <p>For more information about Quartz, refer to the <a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html"> <i>Cron Trigger Tutorial</i> </a> page to understand the valid expressions and its use.</p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        /// <p>The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> is not provided for the <code>RecorderConfig</code>, then the Edge Agent will always be set to recording mode.</p>
        /// <p>For more information about Quartz, refer to the <a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html"> <i>Cron Trigger Tutorial</i> </a> page to understand the valid expressions and its use.</p>
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// <p>The total duration to record the media. If the <code>ScheduleExpression</code> attribute is provided, then the <code>DurationInSeconds</code> attribute should also be specified.</p>
        pub fn duration_in_seconds(mut self, input: i32) -> Self {
            self.duration_in_seconds = Some(input);
            self
        }
        /// <p>The total duration to record the media. If the <code>ScheduleExpression</code> attribute is provided, then the <code>DurationInSeconds</code> attribute should also be specified.</p>
        pub fn set_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleConfig`](crate::model::ScheduleConfig).
        pub fn build(self) -> crate::model::ScheduleConfig {
            crate::model::ScheduleConfig {
                schedule_expression: self.schedule_expression,
                duration_in_seconds: self.duration_in_seconds,
            }
        }
    }
}
impl ScheduleConfig {
    /// Creates a new builder-style object to manufacture [`ScheduleConfig`](crate::model::ScheduleConfig).
    pub fn builder() -> crate::model::schedule_config::Builder {
        crate::model::schedule_config::Builder::default()
    }
}

/// <p>The recorder configuration consists of the local <code>MediaSourceConfig</code> details that are used as credentials to accesss the local media files streamed on the camera. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecorderConfig {
    /// <p>The configuration details that consist of the credentials required (<code>MediaUriSecretArn</code> and <code>MediaUriType</code>) to access the media files streamed to the camera. </p>
    #[doc(hidden)]
    pub media_source_config: std::option::Option<crate::model::MediaSourceConfig>,
    /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code> details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> attribute is not provided, then the Edge Agent will always be set to recording mode.</p>
    #[doc(hidden)]
    pub schedule_config: std::option::Option<crate::model::ScheduleConfig>,
}
impl RecorderConfig {
    /// <p>The configuration details that consist of the credentials required (<code>MediaUriSecretArn</code> and <code>MediaUriType</code>) to access the media files streamed to the camera. </p>
    pub fn media_source_config(&self) -> std::option::Option<&crate::model::MediaSourceConfig> {
        self.media_source_config.as_ref()
    }
    /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code> details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> attribute is not provided, then the Edge Agent will always be set to recording mode.</p>
    pub fn schedule_config(&self) -> std::option::Option<&crate::model::ScheduleConfig> {
        self.schedule_config.as_ref()
    }
}
/// See [`RecorderConfig`](crate::model::RecorderConfig).
pub mod recorder_config {

    /// A builder for [`RecorderConfig`](crate::model::RecorderConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_source_config: std::option::Option<crate::model::MediaSourceConfig>,
        pub(crate) schedule_config: std::option::Option<crate::model::ScheduleConfig>,
    }
    impl Builder {
        /// <p>The configuration details that consist of the credentials required (<code>MediaUriSecretArn</code> and <code>MediaUriType</code>) to access the media files streamed to the camera. </p>
        pub fn media_source_config(mut self, input: crate::model::MediaSourceConfig) -> Self {
            self.media_source_config = Some(input);
            self
        }
        /// <p>The configuration details that consist of the credentials required (<code>MediaUriSecretArn</code> and <code>MediaUriType</code>) to access the media files streamed to the camera. </p>
        pub fn set_media_source_config(
            mut self,
            input: std::option::Option<crate::model::MediaSourceConfig>,
        ) -> Self {
            self.media_source_config = input;
            self
        }
        /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code> details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> attribute is not provided, then the Edge Agent will always be set to recording mode.</p>
        pub fn schedule_config(mut self, input: crate::model::ScheduleConfig) -> Self {
            self.schedule_config = Some(input);
            self
        }
        /// <p>The configuration that consists of the <code>ScheduleExpression</code> and the <code>DurationInMinutes</code> details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the <code>ScheduleExpression</code> attribute is not provided, then the Edge Agent will always be set to recording mode.</p>
        pub fn set_schedule_config(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfig>,
        ) -> Self {
            self.schedule_config = input;
            self
        }
        /// Consumes the builder and constructs a [`RecorderConfig`](crate::model::RecorderConfig).
        pub fn build(self) -> crate::model::RecorderConfig {
            crate::model::RecorderConfig {
                media_source_config: self.media_source_config,
                schedule_config: self.schedule_config,
            }
        }
    }
}
impl RecorderConfig {
    /// Creates a new builder-style object to manufacture [`RecorderConfig`](crate::model::RecorderConfig).
    pub fn builder() -> crate::model::recorder_config::Builder {
        crate::model::recorder_config::Builder::default()
    }
}

/// <p>The configuration details that consist of the credentials required (<code>MediaUriSecretArn</code> and <code>MediaUriType</code>) to access the media files that are streamed to the camera.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MediaSourceConfig {
    /// <p>The AWS Secrets Manager ARN for the username and password of the camera, or a local media file location.</p>
    #[doc(hidden)]
    pub media_uri_secret_arn: std::option::Option<std::string::String>,
    /// <p>The Uniform Resource Identifier (URI) type. The <code>FILE_URI</code> value can be used to stream local media files.</p> <note>
    /// <p>Preview only supports the <code>RTSP_URI</code> media source URI format .</p>
    /// </note>
    #[doc(hidden)]
    pub media_uri_type: std::option::Option<crate::model::MediaUriType>,
}
impl MediaSourceConfig {
    /// <p>The AWS Secrets Manager ARN for the username and password of the camera, or a local media file location.</p>
    pub fn media_uri_secret_arn(&self) -> std::option::Option<&str> {
        self.media_uri_secret_arn.as_deref()
    }
    /// <p>The Uniform Resource Identifier (URI) type. The <code>FILE_URI</code> value can be used to stream local media files.</p> <note>
    /// <p>Preview only supports the <code>RTSP_URI</code> media source URI format .</p>
    /// </note>
    pub fn media_uri_type(&self) -> std::option::Option<&crate::model::MediaUriType> {
        self.media_uri_type.as_ref()
    }
}
impl std::fmt::Debug for MediaSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MediaSourceConfig");
        formatter.field("media_uri_secret_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("media_uri_type", &self.media_uri_type);
        formatter.finish()
    }
}
/// See [`MediaSourceConfig`](crate::model::MediaSourceConfig).
pub mod media_source_config {

    /// A builder for [`MediaSourceConfig`](crate::model::MediaSourceConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) media_uri_secret_arn: std::option::Option<std::string::String>,
        pub(crate) media_uri_type: std::option::Option<crate::model::MediaUriType>,
    }
    impl Builder {
        /// <p>The AWS Secrets Manager ARN for the username and password of the camera, or a local media file location.</p>
        pub fn media_uri_secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_uri_secret_arn = Some(input.into());
            self
        }
        /// <p>The AWS Secrets Manager ARN for the username and password of the camera, or a local media file location.</p>
        pub fn set_media_uri_secret_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_uri_secret_arn = input;
            self
        }
        /// <p>The Uniform Resource Identifier (URI) type. The <code>FILE_URI</code> value can be used to stream local media files.</p> <note>
        /// <p>Preview only supports the <code>RTSP_URI</code> media source URI format .</p>
        /// </note>
        pub fn media_uri_type(mut self, input: crate::model::MediaUriType) -> Self {
            self.media_uri_type = Some(input);
            self
        }
        /// <p>The Uniform Resource Identifier (URI) type. The <code>FILE_URI</code> value can be used to stream local media files.</p> <note>
        /// <p>Preview only supports the <code>RTSP_URI</code> media source URI format .</p>
        /// </note>
        pub fn set_media_uri_type(
            mut self,
            input: std::option::Option<crate::model::MediaUriType>,
        ) -> Self {
            self.media_uri_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MediaSourceConfig`](crate::model::MediaSourceConfig).
        pub fn build(self) -> crate::model::MediaSourceConfig {
            crate::model::MediaSourceConfig {
                media_uri_secret_arn: self.media_uri_secret_arn,
                media_uri_type: self.media_uri_type,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("media_uri_secret_arn", &"*** Sensitive Data Redacted ***");
            formatter.field("media_uri_type", &self.media_uri_type);
            formatter.finish()
        }
    }
}
impl MediaSourceConfig {
    /// Creates a new builder-style object to manufacture [`MediaSourceConfig`](crate::model::MediaSourceConfig).
    pub fn builder() -> crate::model::media_source_config::Builder {
        crate::model::media_source_config::Builder::default()
    }
}

/// When writing a match expression against `MediaUriType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mediauritype = unimplemented!();
/// match mediauritype {
///     MediaUriType::FileUri => { /* ... */ },
///     MediaUriType::RtspUri => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mediauritype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MediaUriType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MediaUriType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MediaUriType::NewFeature` is defined.
/// Specifically, when `mediauritype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MediaUriType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaUriType {
    #[allow(missing_docs)] // documentation missing in model
    FileUri,
    #[allow(missing_docs)] // documentation missing in model
    RtspUri,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MediaUriType {
    fn from(s: &str) -> Self {
        match s {
            "FILE_URI" => MediaUriType::FileUri,
            "RTSP_URI" => MediaUriType::RtspUri,
            other => MediaUriType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MediaUriType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaUriType::from(s))
    }
}
impl MediaUriType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaUriType::FileUri => "FILE_URI",
            MediaUriType::RtspUri => "RTSP_URI",
            MediaUriType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FILE_URI", "RTSP_URI"]
    }
}
impl AsRef<str> for MediaUriType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SyncStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let syncstatus = unimplemented!();
/// match syncstatus {
///     SyncStatus::Acknowledged => { /* ... */ },
///     SyncStatus::DeleteFailed => { /* ... */ },
///     SyncStatus::Deleting => { /* ... */ },
///     SyncStatus::InSync => { /* ... */ },
///     SyncStatus::Syncing => { /* ... */ },
///     SyncStatus::SyncFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncStatus::NewFeature` is defined.
/// Specifically, when `syncstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SyncStatus {
    #[allow(missing_docs)] // documentation missing in model
    Acknowledged,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    InSync,
    #[allow(missing_docs)] // documentation missing in model
    Syncing,
    #[allow(missing_docs)] // documentation missing in model
    SyncFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SyncStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACKNOWLEDGED" => SyncStatus::Acknowledged,
            "DELETE_FAILED" => SyncStatus::DeleteFailed,
            "DELETING" => SyncStatus::Deleting,
            "IN_SYNC" => SyncStatus::InSync,
            "SYNCING" => SyncStatus::Syncing,
            "SYNC_FAILED" => SyncStatus::SyncFailed,
            other => SyncStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SyncStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SyncStatus::from(s))
    }
}
impl SyncStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncStatus::Acknowledged => "ACKNOWLEDGED",
            SyncStatus::DeleteFailed => "DELETE_FAILED",
            SyncStatus::Deleting => "DELETING",
            SyncStatus::InSync => "IN_SYNC",
            SyncStatus::Syncing => "SYNCING",
            SyncStatus::SyncFailed => "SYNC_FAILED",
            SyncStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACKNOWLEDGED",
            "DELETE_FAILED",
            "DELETING",
            "IN_SYNC",
            "SYNCING",
            "SYNC_FAILED",
        ]
    }
}
impl AsRef<str> for SyncStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object describing a Kinesis video stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamInfo {
    /// <p>The name of the device that is associated with the stream.</p>
    #[doc(hidden)]
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The name of the stream.</p>
    #[doc(hidden)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the stream.</p>
    #[doc(hidden)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The <code>MediaType</code> of the stream. </p>
    #[doc(hidden)]
    pub media_type: std::option::Option<std::string::String>,
    /// <p>The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The version of the stream.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The status of the stream.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>A time stamp that indicates when the stream was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>How long the stream retains data, in hours.</p>
    #[doc(hidden)]
    pub data_retention_in_hours: std::option::Option<i32>,
}
impl StreamInfo {
    /// <p>The name of the device that is associated with the stream.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>The name of the stream.</p>
    pub fn stream_name(&self) -> std::option::Option<&str> {
        self.stream_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the stream.</p>
    pub fn stream_arn(&self) -> std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
    /// <p>The <code>MediaType</code> of the stream. </p>
    pub fn media_type(&self) -> std::option::Option<&str> {
        self.media_type.as_deref()
    }
    /// <p>The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The version of the stream.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The status of the stream.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>A time stamp that indicates when the stream was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>How long the stream retains data, in hours.</p>
    pub fn data_retention_in_hours(&self) -> std::option::Option<i32> {
        self.data_retention_in_hours
    }
}
/// See [`StreamInfo`](crate::model::StreamInfo).
pub mod stream_info {

    /// A builder for [`StreamInfo`](crate::model::StreamInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) stream_name: std::option::Option<std::string::String>,
        pub(crate) stream_arn: std::option::Option<std::string::String>,
        pub(crate) media_type: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) data_retention_in_hours: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the device that is associated with the stream.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The name of the device that is associated with the stream.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(input.into());
            self
        }
        /// <p>The name of the stream.</p>
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream.</p>
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = input;
            self
        }
        /// <p>The <code>MediaType</code> of the stream. </p>
        pub fn media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_type = Some(input.into());
            self
        }
        /// <p>The <code>MediaType</code> of the stream. </p>
        pub fn set_media_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_type = input;
            self
        }
        /// <p>The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The version of the stream.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the stream.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The status of the stream.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the stream.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>A time stamp that indicates when the stream was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A time stamp that indicates when the stream was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>How long the stream retains data, in hours.</p>
        pub fn data_retention_in_hours(mut self, input: i32) -> Self {
            self.data_retention_in_hours = Some(input);
            self
        }
        /// <p>How long the stream retains data, in hours.</p>
        pub fn set_data_retention_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.data_retention_in_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamInfo`](crate::model::StreamInfo).
        pub fn build(self) -> crate::model::StreamInfo {
            crate::model::StreamInfo {
                device_name: self.device_name,
                stream_name: self.stream_name,
                stream_arn: self.stream_arn,
                media_type: self.media_type,
                kms_key_id: self.kms_key_id,
                version: self.version,
                status: self.status,
                creation_time: self.creation_time,
                data_retention_in_hours: self.data_retention_in_hours,
            }
        }
    }
}
impl StreamInfo {
    /// Creates a new builder-style object to manufacture [`StreamInfo`](crate::model::StreamInfo).
    pub fn builder() -> crate::model::stream_info::Builder {
        crate::model::stream_info::Builder::default()
    }
}

/// When writing a match expression against `Status`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let status = unimplemented!();
/// match status {
///     Status::Active => { /* ... */ },
///     Status::Creating => { /* ... */ },
///     Status::Deleting => { /* ... */ },
///     Status::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `status` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Status::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Status::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Status::NewFeature` is defined.
/// Specifically, when `status` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Status::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Status {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => Status::Active,
            "CREATING" => Status::Creating,
            "DELETING" => Status::Deleting,
            "UPDATING" => Status::Updating,
            other => Status::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Status {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Status::from(s))
    }
}
impl Status {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Status::Active => "ACTIVE",
            Status::Creating => "CREATING",
            Status::Deleting => "DELETING",
            Status::Updating => "UPDATING",
            Status::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "UPDATING"]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the condition that streams must satisfy to be returned when you list streams (see the <code>ListStreams</code> API). A condition has a comparison operation and a value. Currently, you can specify only the <code>BEGINS_WITH</code> operator, which finds streams whose names start with a given prefix. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamNameCondition {
    /// <p>A comparison operator. Currently, you can specify only the <code>BEGINS_WITH</code> operator, which finds streams whose names start with a given prefix.</p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p>A value to compare.</p>
    #[doc(hidden)]
    pub comparison_value: std::option::Option<std::string::String>,
}
impl StreamNameCondition {
    /// <p>A comparison operator. Currently, you can specify only the <code>BEGINS_WITH</code> operator, which finds streams whose names start with a given prefix.</p>
    pub fn comparison_operator(&self) -> std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>A value to compare.</p>
    pub fn comparison_value(&self) -> std::option::Option<&str> {
        self.comparison_value.as_deref()
    }
}
/// See [`StreamNameCondition`](crate::model::StreamNameCondition).
pub mod stream_name_condition {

    /// A builder for [`StreamNameCondition`](crate::model::StreamNameCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) comparison_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A comparison operator. Currently, you can specify only the <code>BEGINS_WITH</code> operator, which finds streams whose names start with a given prefix.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p>A comparison operator. Currently, you can specify only the <code>BEGINS_WITH</code> operator, which finds streams whose names start with a given prefix.</p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p>A value to compare.</p>
        pub fn comparison_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.comparison_value = Some(input.into());
            self
        }
        /// <p>A value to compare.</p>
        pub fn set_comparison_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.comparison_value = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamNameCondition`](crate::model::StreamNameCondition).
        pub fn build(self) -> crate::model::StreamNameCondition {
            crate::model::StreamNameCondition {
                comparison_operator: self.comparison_operator,
                comparison_value: self.comparison_value,
            }
        }
    }
}
impl StreamNameCondition {
    /// Creates a new builder-style object to manufacture [`StreamNameCondition`](crate::model::StreamNameCondition).
    pub fn builder() -> crate::model::stream_name_condition::Builder {
        crate::model::stream_name_condition::Builder::default()
    }
}

/// When writing a match expression against `ComparisonOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let comparisonoperator = unimplemented!();
/// match comparisonoperator {
///     ComparisonOperator::BeginsWith => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `comparisonoperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComparisonOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComparisonOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComparisonOperator::NewFeature` is defined.
/// Specifically, when `comparisonoperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComparisonOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComparisonOperator {
    #[allow(missing_docs)] // documentation missing in model
    BeginsWith,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComparisonOperator {
    fn from(s: &str) -> Self {
        match s {
            "BEGINS_WITH" => ComparisonOperator::BeginsWith,
            other => {
                ComparisonOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ComparisonOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComparisonOperator::from(s))
    }
}
impl ComparisonOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComparisonOperator::BeginsWith => "BEGINS_WITH",
            ComparisonOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BEGINS_WITH"]
    }
}
impl AsRef<str> for ComparisonOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that encapsulates a signaling channel's metadata and properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChannelInfo {
    /// <p>The name of the signaling channel.</p>
    #[doc(hidden)]
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the signaling channel.</p>
    #[doc(hidden)]
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The type of the signaling channel.</p>
    #[doc(hidden)]
    pub channel_type: std::option::Option<crate::model::ChannelType>,
    /// <p>Current status of the signaling channel.</p>
    #[doc(hidden)]
    pub channel_status: std::option::Option<crate::model::Status>,
    /// <p>The time at which the signaling channel was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.</p>
    #[doc(hidden)]
    pub single_master_configuration: std::option::Option<crate::model::SingleMasterConfiguration>,
    /// <p>The current version of the signaling channel.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
}
impl ChannelInfo {
    /// <p>The name of the signaling channel.</p>
    pub fn channel_name(&self) -> std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the signaling channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The type of the signaling channel.</p>
    pub fn channel_type(&self) -> std::option::Option<&crate::model::ChannelType> {
        self.channel_type.as_ref()
    }
    /// <p>Current status of the signaling channel.</p>
    pub fn channel_status(&self) -> std::option::Option<&crate::model::Status> {
        self.channel_status.as_ref()
    }
    /// <p>The time at which the signaling channel was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.</p>
    pub fn single_master_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SingleMasterConfiguration> {
        self.single_master_configuration.as_ref()
    }
    /// <p>The current version of the signaling channel.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
/// See [`ChannelInfo`](crate::model::ChannelInfo).
pub mod channel_info {

    /// A builder for [`ChannelInfo`](crate::model::ChannelInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_type: std::option::Option<crate::model::ChannelType>,
        pub(crate) channel_status: std::option::Option<crate::model::Status>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) single_master_configuration:
            std::option::Option<crate::model::SingleMasterConfiguration>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the signaling channel.</p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        /// <p>The name of the signaling channel.</p>
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the signaling channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the signaling channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The type of the signaling channel.</p>
        pub fn channel_type(mut self, input: crate::model::ChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The type of the signaling channel.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::ChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// <p>Current status of the signaling channel.</p>
        pub fn channel_status(mut self, input: crate::model::Status) -> Self {
            self.channel_status = Some(input);
            self
        }
        /// <p>Current status of the signaling channel.</p>
        pub fn set_channel_status(
            mut self,
            input: std::option::Option<crate::model::Status>,
        ) -> Self {
            self.channel_status = input;
            self
        }
        /// <p>The time at which the signaling channel was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time at which the signaling channel was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.</p>
        pub fn single_master_configuration(
            mut self,
            input: crate::model::SingleMasterConfiguration,
        ) -> Self {
            self.single_master_configuration = Some(input);
            self
        }
        /// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.</p>
        pub fn set_single_master_configuration(
            mut self,
            input: std::option::Option<crate::model::SingleMasterConfiguration>,
        ) -> Self {
            self.single_master_configuration = input;
            self
        }
        /// <p>The current version of the signaling channel.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The current version of the signaling channel.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelInfo`](crate::model::ChannelInfo).
        pub fn build(self) -> crate::model::ChannelInfo {
            crate::model::ChannelInfo {
                channel_name: self.channel_name,
                channel_arn: self.channel_arn,
                channel_type: self.channel_type,
                channel_status: self.channel_status,
                creation_time: self.creation_time,
                single_master_configuration: self.single_master_configuration,
                version: self.version,
            }
        }
    }
}
impl ChannelInfo {
    /// Creates a new builder-style object to manufacture [`ChannelInfo`](crate::model::ChannelInfo).
    pub fn builder() -> crate::model::channel_info::Builder {
        crate::model::channel_info::Builder::default()
    }
}

/// When writing a match expression against `ChannelType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let channeltype = unimplemented!();
/// match channeltype {
///     ChannelType::FullMesh => { /* ... */ },
///     ChannelType::SingleMaster => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `channeltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChannelType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChannelType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChannelType::NewFeature` is defined.
/// Specifically, when `channeltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChannelType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelType {
    #[allow(missing_docs)] // documentation missing in model
    FullMesh,
    #[allow(missing_docs)] // documentation missing in model
    SingleMaster,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChannelType {
    fn from(s: &str) -> Self {
        match s {
            "FULL_MESH" => ChannelType::FullMesh,
            "SINGLE_MASTER" => ChannelType::SingleMaster,
            other => ChannelType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChannelType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelType::from(s))
    }
}
impl ChannelType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelType::FullMesh => "FULL_MESH",
            ChannelType::SingleMaster => "SINGLE_MASTER",
            ChannelType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FULL_MESH", "SINGLE_MASTER"]
    }
}
impl AsRef<str> for ChannelType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An optional input parameter for the <code>ListSignalingChannels</code> API. When this parameter is specified while invoking <code>ListSignalingChannels</code>, the API returns only the channels that satisfy a condition specified in <code>ChannelNameCondition</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChannelNameCondition {
    /// <p>A comparison operator. Currently, you can only specify the <code>BEGINS_WITH</code> operator, which finds signaling channels whose names begin with a given prefix.</p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p>A value to compare.</p>
    #[doc(hidden)]
    pub comparison_value: std::option::Option<std::string::String>,
}
impl ChannelNameCondition {
    /// <p>A comparison operator. Currently, you can only specify the <code>BEGINS_WITH</code> operator, which finds signaling channels whose names begin with a given prefix.</p>
    pub fn comparison_operator(&self) -> std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>A value to compare.</p>
    pub fn comparison_value(&self) -> std::option::Option<&str> {
        self.comparison_value.as_deref()
    }
}
/// See [`ChannelNameCondition`](crate::model::ChannelNameCondition).
pub mod channel_name_condition {

    /// A builder for [`ChannelNameCondition`](crate::model::ChannelNameCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) comparison_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A comparison operator. Currently, you can only specify the <code>BEGINS_WITH</code> operator, which finds signaling channels whose names begin with a given prefix.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p>A comparison operator. Currently, you can only specify the <code>BEGINS_WITH</code> operator, which finds signaling channels whose names begin with a given prefix.</p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p>A value to compare.</p>
        pub fn comparison_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.comparison_value = Some(input.into());
            self
        }
        /// <p>A value to compare.</p>
        pub fn set_comparison_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.comparison_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelNameCondition`](crate::model::ChannelNameCondition).
        pub fn build(self) -> crate::model::ChannelNameCondition {
            crate::model::ChannelNameCondition {
                comparison_operator: self.comparison_operator,
                comparison_value: self.comparison_value,
            }
        }
    }
}
impl ChannelNameCondition {
    /// Creates a new builder-style object to manufacture [`ChannelNameCondition`](crate::model::ChannelNameCondition).
    pub fn builder() -> crate::model::channel_name_condition::Builder {
        crate::model::channel_name_condition::Builder::default()
    }
}

/// <p>An object that describes the endpoint of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceEndpointListItem {
    /// <p>The protocol of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::model::ChannelProtocol>,
    /// <p>The endpoint of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
    #[doc(hidden)]
    pub resource_endpoint: std::option::Option<std::string::String>,
}
impl ResourceEndpointListItem {
    /// <p>The protocol of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::model::ChannelProtocol> {
        self.protocol.as_ref()
    }
    /// <p>The endpoint of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
    pub fn resource_endpoint(&self) -> std::option::Option<&str> {
        self.resource_endpoint.as_deref()
    }
}
/// See [`ResourceEndpointListItem`](crate::model::ResourceEndpointListItem).
pub mod resource_endpoint_list_item {

    /// A builder for [`ResourceEndpointListItem`](crate::model::ResourceEndpointListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::ChannelProtocol>,
        pub(crate) resource_endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The protocol of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
        pub fn protocol(mut self, input: crate::model::ChannelProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ChannelProtocol>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The endpoint of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
        pub fn resource_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the signaling channel returned by the <code>GetSignalingChannelEndpoint</code> API.</p>
        pub fn set_resource_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceEndpointListItem`](crate::model::ResourceEndpointListItem).
        pub fn build(self) -> crate::model::ResourceEndpointListItem {
            crate::model::ResourceEndpointListItem {
                protocol: self.protocol,
                resource_endpoint: self.resource_endpoint,
            }
        }
    }
}
impl ResourceEndpointListItem {
    /// Creates a new builder-style object to manufacture [`ResourceEndpointListItem`](crate::model::ResourceEndpointListItem).
    pub fn builder() -> crate::model::resource_endpoint_list_item::Builder {
        crate::model::resource_endpoint_list_item::Builder::default()
    }
}

/// When writing a match expression against `ChannelProtocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let channelprotocol = unimplemented!();
/// match channelprotocol {
///     ChannelProtocol::Https => { /* ... */ },
///     ChannelProtocol::Webrtc => { /* ... */ },
///     ChannelProtocol::Wss => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `channelprotocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChannelProtocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChannelProtocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChannelProtocol::NewFeature` is defined.
/// Specifically, when `channelprotocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChannelProtocol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelProtocol {
    #[allow(missing_docs)] // documentation missing in model
    Https,
    #[allow(missing_docs)] // documentation missing in model
    Webrtc,
    #[allow(missing_docs)] // documentation missing in model
    Wss,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChannelProtocol {
    fn from(s: &str) -> Self {
        match s {
            "HTTPS" => ChannelProtocol::Https,
            "WEBRTC" => ChannelProtocol::Webrtc,
            "WSS" => ChannelProtocol::Wss,
            other => ChannelProtocol::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChannelProtocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelProtocol::from(s))
    }
}
impl ChannelProtocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelProtocol::Https => "HTTPS",
            ChannelProtocol::Webrtc => "WEBRTC",
            ChannelProtocol::Wss => "WSS",
            ChannelProtocol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTTPS", "WEBRTC", "WSS"]
    }
}
impl AsRef<str> for ChannelProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains the endpoint configuration for the <code>SINGLE_MASTER</code> channel type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SingleMasterChannelEndpointConfiguration {
    /// <p>This property is used to determine the nature of communication over this <code>SINGLE_MASTER</code> signaling channel. If <code>WSS</code> is specified, this API returns a websocket endpoint. If <code>HTTPS</code> is specified, this API returns an <code>HTTPS</code> endpoint.</p>
    #[doc(hidden)]
    pub protocols: std::option::Option<std::vec::Vec<crate::model::ChannelProtocol>>,
    /// <p>This property is used to determine messaging permissions in this <code>SINGLE_MASTER</code> signaling channel. If <code>MASTER</code> is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If <code>VIEWER</code> is specified, this API returns an endpoint that a client can use only to send offers to another <code>MASTER</code> client on this signaling channel. </p>
    #[doc(hidden)]
    pub role: std::option::Option<crate::model::ChannelRole>,
}
impl SingleMasterChannelEndpointConfiguration {
    /// <p>This property is used to determine the nature of communication over this <code>SINGLE_MASTER</code> signaling channel. If <code>WSS</code> is specified, this API returns a websocket endpoint. If <code>HTTPS</code> is specified, this API returns an <code>HTTPS</code> endpoint.</p>
    pub fn protocols(&self) -> std::option::Option<&[crate::model::ChannelProtocol]> {
        self.protocols.as_deref()
    }
    /// <p>This property is used to determine messaging permissions in this <code>SINGLE_MASTER</code> signaling channel. If <code>MASTER</code> is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If <code>VIEWER</code> is specified, this API returns an endpoint that a client can use only to send offers to another <code>MASTER</code> client on this signaling channel. </p>
    pub fn role(&self) -> std::option::Option<&crate::model::ChannelRole> {
        self.role.as_ref()
    }
}
/// See [`SingleMasterChannelEndpointConfiguration`](crate::model::SingleMasterChannelEndpointConfiguration).
pub mod single_master_channel_endpoint_configuration {

    /// A builder for [`SingleMasterChannelEndpointConfiguration`](crate::model::SingleMasterChannelEndpointConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocols: std::option::Option<std::vec::Vec<crate::model::ChannelProtocol>>,
        pub(crate) role: std::option::Option<crate::model::ChannelRole>,
    }
    impl Builder {
        /// Appends an item to `protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>This property is used to determine the nature of communication over this <code>SINGLE_MASTER</code> signaling channel. If <code>WSS</code> is specified, this API returns a websocket endpoint. If <code>HTTPS</code> is specified, this API returns an <code>HTTPS</code> endpoint.</p>
        pub fn protocols(mut self, input: crate::model::ChannelProtocol) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input);
            self.protocols = Some(v);
            self
        }
        /// <p>This property is used to determine the nature of communication over this <code>SINGLE_MASTER</code> signaling channel. If <code>WSS</code> is specified, this API returns a websocket endpoint. If <code>HTTPS</code> is specified, this API returns an <code>HTTPS</code> endpoint.</p>
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChannelProtocol>>,
        ) -> Self {
            self.protocols = input;
            self
        }
        /// <p>This property is used to determine messaging permissions in this <code>SINGLE_MASTER</code> signaling channel. If <code>MASTER</code> is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If <code>VIEWER</code> is specified, this API returns an endpoint that a client can use only to send offers to another <code>MASTER</code> client on this signaling channel. </p>
        pub fn role(mut self, input: crate::model::ChannelRole) -> Self {
            self.role = Some(input);
            self
        }
        /// <p>This property is used to determine messaging permissions in this <code>SINGLE_MASTER</code> signaling channel. If <code>MASTER</code> is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If <code>VIEWER</code> is specified, this API returns an endpoint that a client can use only to send offers to another <code>MASTER</code> client on this signaling channel. </p>
        pub fn set_role(mut self, input: std::option::Option<crate::model::ChannelRole>) -> Self {
            self.role = input;
            self
        }
        /// Consumes the builder and constructs a [`SingleMasterChannelEndpointConfiguration`](crate::model::SingleMasterChannelEndpointConfiguration).
        pub fn build(self) -> crate::model::SingleMasterChannelEndpointConfiguration {
            crate::model::SingleMasterChannelEndpointConfiguration {
                protocols: self.protocols,
                role: self.role,
            }
        }
    }
}
impl SingleMasterChannelEndpointConfiguration {
    /// Creates a new builder-style object to manufacture [`SingleMasterChannelEndpointConfiguration`](crate::model::SingleMasterChannelEndpointConfiguration).
    pub fn builder() -> crate::model::single_master_channel_endpoint_configuration::Builder {
        crate::model::single_master_channel_endpoint_configuration::Builder::default()
    }
}

/// When writing a match expression against `ChannelRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let channelrole = unimplemented!();
/// match channelrole {
///     ChannelRole::Master => { /* ... */ },
///     ChannelRole::Viewer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `channelrole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChannelRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChannelRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChannelRole::NewFeature` is defined.
/// Specifically, when `channelrole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChannelRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelRole {
    #[allow(missing_docs)] // documentation missing in model
    Master,
    #[allow(missing_docs)] // documentation missing in model
    Viewer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChannelRole {
    fn from(s: &str) -> Self {
        match s {
            "MASTER" => ChannelRole::Master,
            "VIEWER" => ChannelRole::Viewer,
            other => ChannelRole::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChannelRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelRole::from(s))
    }
}
impl ChannelRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelRole::Master => "MASTER",
            ChannelRole::Viewer => "VIEWER",
            ChannelRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MASTER", "VIEWER"]
    }
}
impl AsRef<str> for ChannelRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ApiName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let apiname = unimplemented!();
/// match apiname {
///     ApiName::GetClip => { /* ... */ },
///     ApiName::GetDashStreamingSessionUrl => { /* ... */ },
///     ApiName::GetHlsStreamingSessionUrl => { /* ... */ },
///     ApiName::GetImages => { /* ... */ },
///     ApiName::GetMedia => { /* ... */ },
///     ApiName::GetMediaForFragmentList => { /* ... */ },
///     ApiName::ListFragments => { /* ... */ },
///     ApiName::PutMedia => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `apiname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApiName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApiName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApiName::NewFeature` is defined.
/// Specifically, when `apiname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApiName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApiName {
    #[allow(missing_docs)] // documentation missing in model
    GetClip,
    #[allow(missing_docs)] // documentation missing in model
    GetDashStreamingSessionUrl,
    #[allow(missing_docs)] // documentation missing in model
    GetHlsStreamingSessionUrl,
    #[allow(missing_docs)] // documentation missing in model
    GetImages,
    #[allow(missing_docs)] // documentation missing in model
    GetMedia,
    #[allow(missing_docs)] // documentation missing in model
    GetMediaForFragmentList,
    #[allow(missing_docs)] // documentation missing in model
    ListFragments,
    #[allow(missing_docs)] // documentation missing in model
    PutMedia,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApiName {
    fn from(s: &str) -> Self {
        match s {
            "GET_CLIP" => ApiName::GetClip,
            "GET_DASH_STREAMING_SESSION_URL" => ApiName::GetDashStreamingSessionUrl,
            "GET_HLS_STREAMING_SESSION_URL" => ApiName::GetHlsStreamingSessionUrl,
            "GET_IMAGES" => ApiName::GetImages,
            "GET_MEDIA" => ApiName::GetMedia,
            "GET_MEDIA_FOR_FRAGMENT_LIST" => ApiName::GetMediaForFragmentList,
            "LIST_FRAGMENTS" => ApiName::ListFragments,
            "PUT_MEDIA" => ApiName::PutMedia,
            other => ApiName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ApiName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApiName::from(s))
    }
}
impl ApiName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApiName::GetClip => "GET_CLIP",
            ApiName::GetDashStreamingSessionUrl => "GET_DASH_STREAMING_SESSION_URL",
            ApiName::GetHlsStreamingSessionUrl => "GET_HLS_STREAMING_SESSION_URL",
            ApiName::GetImages => "GET_IMAGES",
            ApiName::GetMedia => "GET_MEDIA",
            ApiName::GetMediaForFragmentList => "GET_MEDIA_FOR_FRAGMENT_LIST",
            ApiName::ListFragments => "LIST_FRAGMENTS",
            ApiName::PutMedia => "PUT_MEDIA",
            ApiName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "GET_CLIP",
            "GET_DASH_STREAMING_SESSION_URL",
            "GET_HLS_STREAMING_SESSION_URL",
            "GET_IMAGES",
            "GET_MEDIA",
            "GET_MEDIA_FOR_FRAGMENT_LIST",
            "LIST_FRAGMENTS",
            "PUT_MEDIA",
        ]
    }
}
impl AsRef<str> for ApiName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that encapsulates, or contains, the media storage configuration properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MappedResourceConfigurationListItem {
    /// <p>The type of the associated resource for the kinesis video stream.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl MappedResourceConfigurationListItem {
    /// <p>The type of the associated resource for the kinesis video stream.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`MappedResourceConfigurationListItem`](crate::model::MappedResourceConfigurationListItem).
pub mod mapped_resource_configuration_list_item {

    /// A builder for [`MappedResourceConfigurationListItem`](crate::model::MappedResourceConfigurationListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the associated resource for the kinesis video stream.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the associated resource for the kinesis video stream.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MappedResourceConfigurationListItem`](crate::model::MappedResourceConfigurationListItem).
        pub fn build(self) -> crate::model::MappedResourceConfigurationListItem {
            crate::model::MappedResourceConfigurationListItem {
                r#type: self.r#type,
                arn: self.arn,
            }
        }
    }
}
impl MappedResourceConfigurationListItem {
    /// Creates a new builder-style object to manufacture [`MappedResourceConfigurationListItem`](crate::model::MappedResourceConfigurationListItem).
    pub fn builder() -> crate::model::mapped_resource_configuration_list_item::Builder {
        crate::model::mapped_resource_configuration_list_item::Builder::default()
    }
}
