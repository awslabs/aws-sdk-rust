// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a signaling channel. </p>
/// <p>
/// <code>CreateSignalingChannel</code> is an asynchronous operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSignalingChannel {
    _private: (),
}
impl CreateSignalingChannel {
    /// Creates a new builder-style object to manufacture [`CreateSignalingChannelInput`](crate::input::CreateSignalingChannelInput)
    pub fn builder() -> crate::input::create_signaling_channel_input::Builder {
        crate::input::create_signaling_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSignalingChannel {
    type Output = std::result::Result<
        crate::output::CreateSignalingChannelOutput,
        crate::error::CreateSignalingChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_signaling_channel_error(response)
        } else {
            crate::operation_deser::parse_create_signaling_channel_response(response)
        }
    }
}

/// <p>Creates a new Kinesis video stream. </p>
/// <p>When you create a new stream, Kinesis Video Streams assigns it a version number.
/// When you change the stream's metadata, Kinesis Video Streams updates the version. </p>
/// <p>
/// <code>CreateStream</code> is an asynchronous operation.</p>
/// <p>For information about how the service works, see <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/how-it-works.html">How it Works</a>. </p>
/// <p>You must have permissions for the <code>KinesisVideo:CreateStream</code>
/// action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStream {
    _private: (),
}
impl CreateStream {
    /// Creates a new builder-style object to manufacture [`CreateStreamInput`](crate::input::CreateStreamInput)
    pub fn builder() -> crate::input::create_stream_input::Builder {
        crate::input::create_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStream {
    type Output =
        std::result::Result<crate::output::CreateStreamOutput, crate::error::CreateStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_stream_error(response)
        } else {
            crate::operation_deser::parse_create_stream_response(response)
        }
    }
}

/// <p>Deletes a specified signaling channel. <code>DeleteSignalingChannel</code> is an
/// asynchronous operation. If you don't specify the channel's current version, the most
/// recent version is deleted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSignalingChannel {
    _private: (),
}
impl DeleteSignalingChannel {
    /// Creates a new builder-style object to manufacture [`DeleteSignalingChannelInput`](crate::input::DeleteSignalingChannelInput)
    pub fn builder() -> crate::input::delete_signaling_channel_input::Builder {
        crate::input::delete_signaling_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSignalingChannel {
    type Output = std::result::Result<
        crate::output::DeleteSignalingChannelOutput,
        crate::error::DeleteSignalingChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_signaling_channel_error(response)
        } else {
            crate::operation_deser::parse_delete_signaling_channel_response(response)
        }
    }
}

/// <p>Deletes a Kinesis video stream and the data contained in the stream. </p>
/// <p>This method marks the stream for deletion, and makes the data in the stream
/// inaccessible immediately.</p>
/// <p> </p>
/// <p> To ensure that you have the latest version of the stream before deleting it, you
/// can specify the stream version. Kinesis Video Streams assigns a version to each stream.
/// When you update a stream, Kinesis Video Streams assigns a new version number. To get the
/// latest stream version, use the <code>DescribeStream</code> API. </p>
/// <p>This operation requires permission for the <code>KinesisVideo:DeleteStream</code>
/// action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStream {
    _private: (),
}
impl DeleteStream {
    /// Creates a new builder-style object to manufacture [`DeleteStreamInput`](crate::input::DeleteStreamInput)
    pub fn builder() -> crate::input::delete_stream_input::Builder {
        crate::input::delete_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStream {
    type Output =
        std::result::Result<crate::output::DeleteStreamOutput, crate::error::DeleteStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_stream_error(response)
        } else {
            crate::operation_deser::parse_delete_stream_response(response)
        }
    }
}

/// <p>Returns the most current information about the signaling channel. You must specify
/// either the name or the Amazon Resource Name (ARN) of the channel that you want to
/// describe.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSignalingChannel {
    _private: (),
}
impl DescribeSignalingChannel {
    /// Creates a new builder-style object to manufacture [`DescribeSignalingChannelInput`](crate::input::DescribeSignalingChannelInput)
    pub fn builder() -> crate::input::describe_signaling_channel_input::Builder {
        crate::input::describe_signaling_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSignalingChannel {
    type Output = std::result::Result<
        crate::output::DescribeSignalingChannelOutput,
        crate::error::DescribeSignalingChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_signaling_channel_error(response)
        } else {
            crate::operation_deser::parse_describe_signaling_channel_response(response)
        }
    }
}

/// <p>Returns the most current information about the specified stream. You must specify
/// either the <code>StreamName</code> or the <code>StreamARN</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStream {
    _private: (),
}
impl DescribeStream {
    /// Creates a new builder-style object to manufacture [`DescribeStreamInput`](crate::input::DescribeStreamInput)
    pub fn builder() -> crate::input::describe_stream_input::Builder {
        crate::input::describe_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStream {
    type Output =
        std::result::Result<crate::output::DescribeStreamOutput, crate::error::DescribeStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_stream_error(response)
        } else {
            crate::operation_deser::parse_describe_stream_response(response)
        }
    }
}

/// <p>Gets an endpoint for a specified stream for either reading or writing. Use this
/// endpoint in your application to read from the specified stream (using the
/// <code>GetMedia</code> or <code>GetMediaForFragmentList</code> operations) or write
/// to it (using the <code>PutMedia</code> operation).
/// </p>
/// <note>
/// <p>The returned endpoint does not have the API name appended. The client needs to
/// add the API name to the returned endpoint.</p>
/// </note>
/// <p>In the request, specify the stream either by <code>StreamName</code> or
/// <code>StreamARN</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDataEndpoint {
    _private: (),
}
impl GetDataEndpoint {
    /// Creates a new builder-style object to manufacture [`GetDataEndpointInput`](crate::input::GetDataEndpointInput)
    pub fn builder() -> crate::input::get_data_endpoint_input::Builder {
        crate::input::get_data_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDataEndpoint {
    type Output = std::result::Result<
        crate::output::GetDataEndpointOutput,
        crate::error::GetDataEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_data_endpoint_error(response)
        } else {
            crate::operation_deser::parse_get_data_endpoint_response(response)
        }
    }
}

/// <p>Provides an endpoint for the specified signaling channel to send and receive messages.
/// This API uses the <code>SingleMasterChannelEndpointConfiguration</code> input parameter,
/// which consists of the <code>Protocols</code> and <code>Role</code> properties.</p>
/// <p>
/// <code>Protocols</code> is used to determine the communication mechanism. For example,
/// if you specify <code>WSS</code> as the protocol, this API produces a secure websocket
/// endpoint. If you specify <code>HTTPS</code> as the protocol, this API generates an HTTPS
/// endpoint. </p>
/// <p>
/// <code>Role</code> determines the messaging permissions. A <code>MASTER</code> role
/// results in this API generating an endpoint that a client can use to communicate with any
/// of the viewers on the channel. A <code>VIEWER</code> role results in this API generating
/// an endpoint that a client can use to communicate only with a
/// <code>MASTER</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSignalingChannelEndpoint {
    _private: (),
}
impl GetSignalingChannelEndpoint {
    /// Creates a new builder-style object to manufacture [`GetSignalingChannelEndpointInput`](crate::input::GetSignalingChannelEndpointInput)
    pub fn builder() -> crate::input::get_signaling_channel_endpoint_input::Builder {
        crate::input::get_signaling_channel_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSignalingChannelEndpoint {
    type Output = std::result::Result<
        crate::output::GetSignalingChannelEndpointOutput,
        crate::error::GetSignalingChannelEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_signaling_channel_endpoint_error(response)
        } else {
            crate::operation_deser::parse_get_signaling_channel_endpoint_response(response)
        }
    }
}

/// <p>Returns an array of <code>ChannelInfo</code> objects. Each object describes a
/// signaling channel. To retrieve only those channels that satisfy a specific condition, you can
/// specify a <code>ChannelNameCondition</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSignalingChannels {
    _private: (),
}
impl ListSignalingChannels {
    /// Creates a new builder-style object to manufacture [`ListSignalingChannelsInput`](crate::input::ListSignalingChannelsInput)
    pub fn builder() -> crate::input::list_signaling_channels_input::Builder {
        crate::input::list_signaling_channels_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSignalingChannels {
    type Output = std::result::Result<
        crate::output::ListSignalingChannelsOutput,
        crate::error::ListSignalingChannelsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_signaling_channels_error(response)
        } else {
            crate::operation_deser::parse_list_signaling_channels_response(response)
        }
    }
}

/// <p>Returns an array of <code>StreamInfo</code> objects. Each object describes a
/// stream. To retrieve only streams that satisfy a specific condition, you can specify a
/// <code>StreamNameCondition</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStreams {
    _private: (),
}
impl ListStreams {
    /// Creates a new builder-style object to manufacture [`ListStreamsInput`](crate::input::ListStreamsInput)
    pub fn builder() -> crate::input::list_streams_input::Builder {
        crate::input::list_streams_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStreams {
    type Output =
        std::result::Result<crate::output::ListStreamsOutput, crate::error::ListStreamsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_streams_error(response)
        } else {
            crate::operation_deser::parse_list_streams_response(response)
        }
    }
}

/// <p>Returns a list of tags associated with the specified signaling channel.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Returns a list of tags associated with the specified stream.</p>
/// <p>In the request, you must specify either the <code>StreamName</code> or the
/// <code>StreamARN</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForStream {
    _private: (),
}
impl ListTagsForStream {
    /// Creates a new builder-style object to manufacture [`ListTagsForStreamInput`](crate::input::ListTagsForStreamInput)
    pub fn builder() -> crate::input::list_tags_for_stream_input::Builder {
        crate::input::list_tags_for_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForStream {
    type Output = std::result::Result<
        crate::output::ListTagsForStreamOutput,
        crate::error::ListTagsForStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_stream_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_stream_response(response)
        }
    }
}

/// <p>Adds one or more tags to a signaling channel. A <i>tag</i> is a
/// key-value pair (the value is optional) that you can define and assign to AWS resources.
/// If you specify a tag that already exists, the tag value is replaced with the value that
/// you specify in the request. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
/// Tags</a> in the <i>AWS Billing and Cost Management User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Adds one or more tags to a stream. A <i>tag</i> is a key-value pair
/// (the value is optional) that you can define and assign to AWS resources. If you specify
/// a tag that already exists, the tag value is replaced with the value that you specify in
/// the request. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
/// Tags</a> in the <i>AWS Billing and Cost Management User Guide</i>. </p>
/// <p>You must provide either the <code>StreamName</code> or the
/// <code>StreamARN</code>.</p>
/// <p>This operation requires permission for the <code>KinesisVideo:TagStream</code>
/// action.</p>
/// <p>Kinesis video streams support up to 50 tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagStream {
    _private: (),
}
impl TagStream {
    /// Creates a new builder-style object to manufacture [`TagStreamInput`](crate::input::TagStreamInput)
    pub fn builder() -> crate::input::tag_stream_input::Builder {
        crate::input::tag_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagStream {
    type Output = std::result::Result<crate::output::TagStreamOutput, crate::error::TagStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_stream_error(response)
        } else {
            crate::operation_deser::parse_tag_stream_response(response)
        }
    }
}

/// <p>Removes one or more tags from a signaling channel. In the request, specify only a tag
/// key or keys; don't specify the value. If you specify a tag key that does not exist, it's
/// ignored.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from a stream. In the request, specify only a tag key or
/// keys; don't specify the value. If you specify a tag key that does not exist, it's
/// ignored.</p>
/// <p>In the request, you must provide the <code>StreamName</code> or
/// <code>StreamARN</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagStream {
    _private: (),
}
impl UntagStream {
    /// Creates a new builder-style object to manufacture [`UntagStreamInput`](crate::input::UntagStreamInput)
    pub fn builder() -> crate::input::untag_stream_input::Builder {
        crate::input::untag_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagStream {
    type Output =
        std::result::Result<crate::output::UntagStreamOutput, crate::error::UntagStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_stream_error(response)
        } else {
            crate::operation_deser::parse_untag_stream_response(response)
        }
    }
}

/// <p> Increases or decreases the stream's data retention period by the value that you
/// specify. To indicate whether you want to increase or decrease the data retention period,
/// specify the <code>Operation</code> parameter in the request body. In the request, you
/// must specify either the <code>StreamName</code> or the <code>StreamARN</code>. </p>
/// <note>
/// <p>The retention period that you specify replaces the current value.</p>
/// </note>
/// <p>This operation requires permission for the
/// <code>KinesisVideo:UpdateDataRetention</code> action.</p>
/// <p>Changing the data retention period affects the data in the stream as
/// follows:</p>
/// <ul>
/// <li>
/// <p>If the data retention period is increased, existing data is retained for
/// the new retention period. For example, if the data retention period is increased
/// from one hour to seven hours, all existing data is retained for seven
/// hours.</p>
/// </li>
/// <li>
/// <p>If the data retention period is decreased, existing data is retained for
/// the new retention period. For example, if the data retention period is decreased
/// from seven hours to one hour, all existing data is retained for one hour, and
/// any data older than one hour is deleted immediately.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataRetention {
    _private: (),
}
impl UpdateDataRetention {
    /// Creates a new builder-style object to manufacture [`UpdateDataRetentionInput`](crate::input::UpdateDataRetentionInput)
    pub fn builder() -> crate::input::update_data_retention_input::Builder {
        crate::input::update_data_retention_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataRetention {
    type Output = std::result::Result<
        crate::output::UpdateDataRetentionOutput,
        crate::error::UpdateDataRetentionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_data_retention_error(response)
        } else {
            crate::operation_deser::parse_update_data_retention_response(response)
        }
    }
}

/// <p>Updates the existing signaling channel. This is an asynchronous operation and takes
/// time to complete. </p>
/// <p>If the <code>MessageTtlSeconds</code> value is updated (either increased or reduced),
/// it only applies to new messages sent via this channel after it's been updated. Existing
/// messages are still expired as per the previous <code>MessageTtlSeconds</code>
/// value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSignalingChannel {
    _private: (),
}
impl UpdateSignalingChannel {
    /// Creates a new builder-style object to manufacture [`UpdateSignalingChannelInput`](crate::input::UpdateSignalingChannelInput)
    pub fn builder() -> crate::input::update_signaling_channel_input::Builder {
        crate::input::update_signaling_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSignalingChannel {
    type Output = std::result::Result<
        crate::output::UpdateSignalingChannelOutput,
        crate::error::UpdateSignalingChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_signaling_channel_error(response)
        } else {
            crate::operation_deser::parse_update_signaling_channel_response(response)
        }
    }
}

/// <p>Updates stream metadata, such as the device name and media type.</p>
/// <p>You must provide the stream name or the Amazon Resource Name (ARN) of the
/// stream.</p>
/// <p>To make sure that you have the latest version of the stream before updating it, you
/// can specify the stream version. Kinesis Video Streams assigns a version to each stream.
/// When you update a stream, Kinesis Video Streams assigns a new version number. To get the
/// latest stream version, use the <code>DescribeStream</code> API. </p>
/// <p>
/// <code>UpdateStream</code> is an asynchronous operation, and takes time to
/// complete.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateStream {
    _private: (),
}
impl UpdateStream {
    /// Creates a new builder-style object to manufacture [`UpdateStreamInput`](crate::input::UpdateStreamInput)
    pub fn builder() -> crate::input::update_stream_input::Builder {
        crate::input::update_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateStream {
    type Output =
        std::result::Result<crate::output::UpdateStreamOutput, crate::error::UpdateStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_stream_error(response)
        } else {
            crate::operation_deser::parse_update_stream_response(response)
        }
    }
}
