// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListEfficiencyMetricsInput {
    /// <p>The dimension by which to group the cost efficiency metrics. Valid values include account ID, Amazon Web Services Region. When no grouping is specified, metrics are aggregated across all resources in the specified time period.</p>
    pub group_by: ::std::option::Option<::std::string::String>,
    /// <p>The time granularity for the cost efficiency metrics. Specify <code>Daily</code> for metrics aggregated by day, or <code>Monthly</code> for metrics aggregated by month.</p>
    pub granularity: ::std::option::Option<crate::types::GranularityType>,
    /// <p>The time period for which to retrieve the cost efficiency metrics. The start date is inclusive and the end date is exclusive. Dates can be specified in either YYYY-MM-DD format or YYYY-MM format depending on the desired granularity.</p>
    pub time_period: ::std::option::Option<crate::types::TimePeriod>,
    /// <p>The maximum number of groups to return in the response. Valid values range from 0 to 1000. Use in conjunction with <code>nextToken</code> to paginate through results when the total number of groups exceeds this limit.</p>
    pub max_results: ::std::option::Option<i32>,
    /// <p>The ordering specification for the results. Defines which dimension to sort by and whether to sort in ascending or descending order.</p>
    pub order_by: ::std::option::Option<crate::types::OrderBy>,
    /// <p>The token to retrieve the next page of results. This value is returned in the response when the number of groups exceeds the specified <code>maxResults</code> value.</p>
    pub next_token: ::std::option::Option<::std::string::String>,
}
impl ListEfficiencyMetricsInput {
    /// <p>The dimension by which to group the cost efficiency metrics. Valid values include account ID, Amazon Web Services Region. When no grouping is specified, metrics are aggregated across all resources in the specified time period.</p>
    pub fn group_by(&self) -> ::std::option::Option<&str> {
        self.group_by.as_deref()
    }
    /// <p>The time granularity for the cost efficiency metrics. Specify <code>Daily</code> for metrics aggregated by day, or <code>Monthly</code> for metrics aggregated by month.</p>
    pub fn granularity(&self) -> ::std::option::Option<&crate::types::GranularityType> {
        self.granularity.as_ref()
    }
    /// <p>The time period for which to retrieve the cost efficiency metrics. The start date is inclusive and the end date is exclusive. Dates can be specified in either YYYY-MM-DD format or YYYY-MM format depending on the desired granularity.</p>
    pub fn time_period(&self) -> ::std::option::Option<&crate::types::TimePeriod> {
        self.time_period.as_ref()
    }
    /// <p>The maximum number of groups to return in the response. Valid values range from 0 to 1000. Use in conjunction with <code>nextToken</code> to paginate through results when the total number of groups exceeds this limit.</p>
    pub fn max_results(&self) -> ::std::option::Option<i32> {
        self.max_results
    }
    /// <p>The ordering specification for the results. Defines which dimension to sort by and whether to sort in ascending or descending order.</p>
    pub fn order_by(&self) -> ::std::option::Option<&crate::types::OrderBy> {
        self.order_by.as_ref()
    }
    /// <p>The token to retrieve the next page of results. This value is returned in the response when the number of groups exceeds the specified <code>maxResults</code> value.</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListEfficiencyMetricsInput {
    /// Creates a new builder-style object to manufacture [`ListEfficiencyMetricsInput`](crate::operation::list_efficiency_metrics::ListEfficiencyMetricsInput).
    pub fn builder() -> crate::operation::list_efficiency_metrics::builders::ListEfficiencyMetricsInputBuilder {
        crate::operation::list_efficiency_metrics::builders::ListEfficiencyMetricsInputBuilder::default()
    }
}

/// A builder for [`ListEfficiencyMetricsInput`](crate::operation::list_efficiency_metrics::ListEfficiencyMetricsInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ListEfficiencyMetricsInputBuilder {
    pub(crate) group_by: ::std::option::Option<::std::string::String>,
    pub(crate) granularity: ::std::option::Option<crate::types::GranularityType>,
    pub(crate) time_period: ::std::option::Option<crate::types::TimePeriod>,
    pub(crate) max_results: ::std::option::Option<i32>,
    pub(crate) order_by: ::std::option::Option<crate::types::OrderBy>,
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
}
impl ListEfficiencyMetricsInputBuilder {
    /// <p>The dimension by which to group the cost efficiency metrics. Valid values include account ID, Amazon Web Services Region. When no grouping is specified, metrics are aggregated across all resources in the specified time period.</p>
    pub fn group_by(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.group_by = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The dimension by which to group the cost efficiency metrics. Valid values include account ID, Amazon Web Services Region. When no grouping is specified, metrics are aggregated across all resources in the specified time period.</p>
    pub fn set_group_by(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.group_by = input;
        self
    }
    /// <p>The dimension by which to group the cost efficiency metrics. Valid values include account ID, Amazon Web Services Region. When no grouping is specified, metrics are aggregated across all resources in the specified time period.</p>
    pub fn get_group_by(&self) -> &::std::option::Option<::std::string::String> {
        &self.group_by
    }
    /// <p>The time granularity for the cost efficiency metrics. Specify <code>Daily</code> for metrics aggregated by day, or <code>Monthly</code> for metrics aggregated by month.</p>
    /// This field is required.
    pub fn granularity(mut self, input: crate::types::GranularityType) -> Self {
        self.granularity = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time granularity for the cost efficiency metrics. Specify <code>Daily</code> for metrics aggregated by day, or <code>Monthly</code> for metrics aggregated by month.</p>
    pub fn set_granularity(mut self, input: ::std::option::Option<crate::types::GranularityType>) -> Self {
        self.granularity = input;
        self
    }
    /// <p>The time granularity for the cost efficiency metrics. Specify <code>Daily</code> for metrics aggregated by day, or <code>Monthly</code> for metrics aggregated by month.</p>
    pub fn get_granularity(&self) -> &::std::option::Option<crate::types::GranularityType> {
        &self.granularity
    }
    /// <p>The time period for which to retrieve the cost efficiency metrics. The start date is inclusive and the end date is exclusive. Dates can be specified in either YYYY-MM-DD format or YYYY-MM format depending on the desired granularity.</p>
    /// This field is required.
    pub fn time_period(mut self, input: crate::types::TimePeriod) -> Self {
        self.time_period = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time period for which to retrieve the cost efficiency metrics. The start date is inclusive and the end date is exclusive. Dates can be specified in either YYYY-MM-DD format or YYYY-MM format depending on the desired granularity.</p>
    pub fn set_time_period(mut self, input: ::std::option::Option<crate::types::TimePeriod>) -> Self {
        self.time_period = input;
        self
    }
    /// <p>The time period for which to retrieve the cost efficiency metrics. The start date is inclusive and the end date is exclusive. Dates can be specified in either YYYY-MM-DD format or YYYY-MM format depending on the desired granularity.</p>
    pub fn get_time_period(&self) -> &::std::option::Option<crate::types::TimePeriod> {
        &self.time_period
    }
    /// <p>The maximum number of groups to return in the response. Valid values range from 0 to 1000. Use in conjunction with <code>nextToken</code> to paginate through results when the total number of groups exceeds this limit.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.max_results = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of groups to return in the response. Valid values range from 0 to 1000. Use in conjunction with <code>nextToken</code> to paginate through results when the total number of groups exceeds this limit.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_results = input;
        self
    }
    /// <p>The maximum number of groups to return in the response. Valid values range from 0 to 1000. Use in conjunction with <code>nextToken</code> to paginate through results when the total number of groups exceeds this limit.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        &self.max_results
    }
    /// <p>The ordering specification for the results. Defines which dimension to sort by and whether to sort in ascending or descending order.</p>
    pub fn order_by(mut self, input: crate::types::OrderBy) -> Self {
        self.order_by = ::std::option::Option::Some(input);
        self
    }
    /// <p>The ordering specification for the results. Defines which dimension to sort by and whether to sort in ascending or descending order.</p>
    pub fn set_order_by(mut self, input: ::std::option::Option<crate::types::OrderBy>) -> Self {
        self.order_by = input;
        self
    }
    /// <p>The ordering specification for the results. Defines which dimension to sort by and whether to sort in ascending or descending order.</p>
    pub fn get_order_by(&self) -> &::std::option::Option<crate::types::OrderBy> {
        &self.order_by
    }
    /// <p>The token to retrieve the next page of results. This value is returned in the response when the number of groups exceeds the specified <code>maxResults</code> value.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The token to retrieve the next page of results. This value is returned in the response when the number of groups exceeds the specified <code>maxResults</code> value.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>The token to retrieve the next page of results. This value is returned in the response when the number of groups exceeds the specified <code>maxResults</code> value.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    /// Consumes the builder and constructs a [`ListEfficiencyMetricsInput`](crate::operation::list_efficiency_metrics::ListEfficiencyMetricsInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::list_efficiency_metrics::ListEfficiencyMetricsInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::list_efficiency_metrics::ListEfficiencyMetricsInput {
            group_by: self.group_by,
            granularity: self.granularity,
            time_period: self.time_period,
            max_results: self.max_results,
            order_by: self.order_by,
            next_token: self.next_token,
        })
    }
}
