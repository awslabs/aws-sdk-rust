// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Performs <a>GetChannel</a> on multiple ARNs simultaneously.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetChannel {
    _private: (),
}
impl BatchGetChannel {
    /// Creates a new builder-style object to manufacture [`BatchGetChannelInput`](crate::input::BatchGetChannelInput)
    pub fn builder() -> crate::input::batch_get_channel_input::Builder {
        crate::input::batch_get_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetChannel {
    type Output = std::result::Result<
        crate::output::BatchGetChannelOutput,
        crate::error::BatchGetChannelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_channel_error(response)
        } else {
            crate::operation_deser::parse_batch_get_channel_response(response)
        }
    }
}

/// <p>Performs <a>GetStreamKey</a> on multiple ARNs simultaneously.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetStreamKey {
    _private: (),
}
impl BatchGetStreamKey {
    /// Creates a new builder-style object to manufacture [`BatchGetStreamKeyInput`](crate::input::BatchGetStreamKeyInput)
    pub fn builder() -> crate::input::batch_get_stream_key_input::Builder {
        crate::input::batch_get_stream_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetStreamKey {
    type Output = std::result::Result<
        crate::output::BatchGetStreamKeyOutput,
        crate::error::BatchGetStreamKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_stream_key_error(response)
        } else {
            crate::operation_deser::parse_batch_get_stream_key_response(response)
        }
    }
}

/// <p>Creates a new channel and an associated stream key to start streaming.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateChannel {
    _private: (),
}
impl CreateChannel {
    /// Creates a new builder-style object to manufacture [`CreateChannelInput`](crate::input::CreateChannelInput)
    pub fn builder() -> crate::input::create_channel_input::Builder {
        crate::input::create_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateChannel {
    type Output =
        std::result::Result<crate::output::CreateChannelOutput, crate::error::CreateChannelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_channel_error(response)
        } else {
            crate::operation_deser::parse_create_channel_response(response)
        }
    }
}

/// <p>Creates a new recording configuration, used to enable recording to Amazon S3.</p>
/// <p>
/// <b>Known issue:</b> In the us-east-1 region, if you use the AWS
/// CLI to create a recording configuration, it returns success even if the S3 bucket is in a
/// different region. In this case, the <code>state</code> of the recording configuration is
/// <code>CREATE_FAILED</code> (instead of <code>ACTIVE</code>). (In other regions, the CLI
/// correctly returns failure if the bucket is in a different region.)</p>
/// <p>
/// <b>Workaround:</b> Ensure that your S3 bucket is in the same region as the recording
/// configuration. If you create a recording configuration in a different region as your S3
/// bucket, delete that recording configuration and create a new one with an S3 bucket from the
/// correct region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRecordingConfiguration {
    _private: (),
}
impl CreateRecordingConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateRecordingConfigurationInput`](crate::input::CreateRecordingConfigurationInput)
    pub fn builder() -> crate::input::create_recording_configuration_input::Builder {
        crate::input::create_recording_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRecordingConfiguration {
    type Output = std::result::Result<
        crate::output::CreateRecordingConfigurationOutput,
        crate::error::CreateRecordingConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_recording_configuration_error(response)
        } else {
            crate::operation_deser::parse_create_recording_configuration_response(response)
        }
    }
}

/// <p>Creates a stream key, used to initiate a stream, for the specified channel ARN.</p>
/// <p>Note that <a>CreateChannel</a> creates a stream key. If you subsequently use
/// CreateStreamKey on the same channel, it will fail because a stream key already exists and
/// there is a limit of 1 stream key per channel. To reset the stream key on a channel, use <a>DeleteStreamKey</a> and then CreateStreamKey.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStreamKey {
    _private: (),
}
impl CreateStreamKey {
    /// Creates a new builder-style object to manufacture [`CreateStreamKeyInput`](crate::input::CreateStreamKeyInput)
    pub fn builder() -> crate::input::create_stream_key_input::Builder {
        crate::input::create_stream_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStreamKey {
    type Output = std::result::Result<
        crate::output::CreateStreamKeyOutput,
        crate::error::CreateStreamKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_stream_key_error(response)
        } else {
            crate::operation_deser::parse_create_stream_key_response(response)
        }
    }
}

/// <p>Deletes the specified channel and its associated stream keys.</p>
/// <p>If you try to delete a live channel, you will get an error (409 ConflictException). To
/// delete a channel that is live, call <a>StopStream</a>, wait for the Amazon
/// EventBridge "Stream End" event (to verify that the stream's state was changed from Live to
/// Offline), then call DeleteChannel. (See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html"> Using EventBridge with Amazon IVS</a>.) </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteChannel {
    _private: (),
}
impl DeleteChannel {
    /// Creates a new builder-style object to manufacture [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    pub fn builder() -> crate::input::delete_channel_input::Builder {
        crate::input::delete_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteChannel {
    type Output =
        std::result::Result<crate::output::DeleteChannelOutput, crate::error::DeleteChannelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_channel_error(response)
        } else {
            crate::operation_deser::parse_delete_channel_response(response)
        }
    }
}

/// <p>Deletes a specified authorization key pair. This invalidates future viewer tokens
/// generated using the key pairâ€™s <code>privateKey</code>. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private
/// Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePlaybackKeyPair {
    _private: (),
}
impl DeletePlaybackKeyPair {
    /// Creates a new builder-style object to manufacture [`DeletePlaybackKeyPairInput`](crate::input::DeletePlaybackKeyPairInput)
    pub fn builder() -> crate::input::delete_playback_key_pair_input::Builder {
        crate::input::delete_playback_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePlaybackKeyPair {
    type Output = std::result::Result<
        crate::output::DeletePlaybackKeyPairOutput,
        crate::error::DeletePlaybackKeyPairError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_playback_key_pair_error(response)
        } else {
            crate::operation_deser::parse_delete_playback_key_pair_response(response)
        }
    }
}

/// <p>Deletes the recording configuration for the specified ARN.</p>
/// <p>If you try to delete a recording configuration that is associated with a channel, you will
/// get an error (409 ConflictException). To avoid this, for all channels that reference the
/// recording configuration, first use <a>UpdateChannel</a> to set the
/// <code>recordingConfigurationArn</code> field to an empty string, then use
/// DeleteRecordingConfiguration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRecordingConfiguration {
    _private: (),
}
impl DeleteRecordingConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteRecordingConfigurationInput`](crate::input::DeleteRecordingConfigurationInput)
    pub fn builder() -> crate::input::delete_recording_configuration_input::Builder {
        crate::input::delete_recording_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRecordingConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteRecordingConfigurationOutput,
        crate::error::DeleteRecordingConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_recording_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_recording_configuration_response(response)
        }
    }
}

/// <p>Deletes the stream key for the specified ARN, so it can no longer be used to
/// stream.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStreamKey {
    _private: (),
}
impl DeleteStreamKey {
    /// Creates a new builder-style object to manufacture [`DeleteStreamKeyInput`](crate::input::DeleteStreamKeyInput)
    pub fn builder() -> crate::input::delete_stream_key_input::Builder {
        crate::input::delete_stream_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStreamKey {
    type Output = std::result::Result<
        crate::output::DeleteStreamKeyOutput,
        crate::error::DeleteStreamKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_stream_key_error(response)
        } else {
            crate::operation_deser::parse_delete_stream_key_response(response)
        }
    }
}

/// <p>Gets the channel configuration for the specified channel ARN. See also <a>BatchGetChannel</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetChannel {
    _private: (),
}
impl GetChannel {
    /// Creates a new builder-style object to manufacture [`GetChannelInput`](crate::input::GetChannelInput)
    pub fn builder() -> crate::input::get_channel_input::Builder {
        crate::input::get_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetChannel {
    type Output =
        std::result::Result<crate::output::GetChannelOutput, crate::error::GetChannelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_channel_error(response)
        } else {
            crate::operation_deser::parse_get_channel_response(response)
        }
    }
}

/// <p>Gets a specified playback authorization key pair and returns the <code>arn</code> and
/// <code>fingerprint</code>. The <code>privateKey</code> held by the caller can be used to
/// generate viewer authorization tokens, to grant viewers access to private channels. For more
/// information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPlaybackKeyPair {
    _private: (),
}
impl GetPlaybackKeyPair {
    /// Creates a new builder-style object to manufacture [`GetPlaybackKeyPairInput`](crate::input::GetPlaybackKeyPairInput)
    pub fn builder() -> crate::input::get_playback_key_pair_input::Builder {
        crate::input::get_playback_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPlaybackKeyPair {
    type Output = std::result::Result<
        crate::output::GetPlaybackKeyPairOutput,
        crate::error::GetPlaybackKeyPairError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_playback_key_pair_error(response)
        } else {
            crate::operation_deser::parse_get_playback_key_pair_response(response)
        }
    }
}

/// <p>Gets the recording configuration for the specified ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRecordingConfiguration {
    _private: (),
}
impl GetRecordingConfiguration {
    /// Creates a new builder-style object to manufacture [`GetRecordingConfigurationInput`](crate::input::GetRecordingConfigurationInput)
    pub fn builder() -> crate::input::get_recording_configuration_input::Builder {
        crate::input::get_recording_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRecordingConfiguration {
    type Output = std::result::Result<
        crate::output::GetRecordingConfigurationOutput,
        crate::error::GetRecordingConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_recording_configuration_error(response)
        } else {
            crate::operation_deser::parse_get_recording_configuration_response(response)
        }
    }
}

/// <p>Gets information about the active (live) stream on a specified channel.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStream {
    _private: (),
}
impl GetStream {
    /// Creates a new builder-style object to manufacture [`GetStreamInput`](crate::input::GetStreamInput)
    pub fn builder() -> crate::input::get_stream_input::Builder {
        crate::input::get_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStream {
    type Output = std::result::Result<crate::output::GetStreamOutput, crate::error::GetStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_stream_error(response)
        } else {
            crate::operation_deser::parse_get_stream_response(response)
        }
    }
}

/// <p>Gets stream-key information for a specified ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStreamKey {
    _private: (),
}
impl GetStreamKey {
    /// Creates a new builder-style object to manufacture [`GetStreamKeyInput`](crate::input::GetStreamKeyInput)
    pub fn builder() -> crate::input::get_stream_key_input::Builder {
        crate::input::get_stream_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStreamKey {
    type Output =
        std::result::Result<crate::output::GetStreamKeyOutput, crate::error::GetStreamKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_stream_key_error(response)
        } else {
            crate::operation_deser::parse_get_stream_key_response(response)
        }
    }
}

/// <p>Imports the public portion of a new key pair and returns its <code>arn</code> and
/// <code>fingerprint</code>. The <code>privateKey</code> can then be used to generate viewer
/// authorization tokens, to grant viewers access to private channels. For more information, see
/// <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up
/// Private Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportPlaybackKeyPair {
    _private: (),
}
impl ImportPlaybackKeyPair {
    /// Creates a new builder-style object to manufacture [`ImportPlaybackKeyPairInput`](crate::input::ImportPlaybackKeyPairInput)
    pub fn builder() -> crate::input::import_playback_key_pair_input::Builder {
        crate::input::import_playback_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportPlaybackKeyPair {
    type Output = std::result::Result<
        crate::output::ImportPlaybackKeyPairOutput,
        crate::error::ImportPlaybackKeyPairError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_playback_key_pair_error(response)
        } else {
            crate::operation_deser::parse_import_playback_key_pair_response(response)
        }
    }
}

/// <p>Gets summary information about all channels in your account, in the AWS region where the
/// API request is processed. This list can be filtered to match a specified name or
/// recording-configuration ARN. Filters are mutually exclusive and cannot be used together. If
/// you try to use both filters, you will get an error (409 ConflictException).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListChannels {
    _private: (),
}
impl ListChannels {
    /// Creates a new builder-style object to manufacture [`ListChannelsInput`](crate::input::ListChannelsInput)
    pub fn builder() -> crate::input::list_channels_input::Builder {
        crate::input::list_channels_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListChannels {
    type Output =
        std::result::Result<crate::output::ListChannelsOutput, crate::error::ListChannelsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_channels_error(response)
        } else {
            crate::operation_deser::parse_list_channels_response(response)
        }
    }
}

/// <p>Gets summary information about playback key pairs. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private
/// Channels</a> in the <i>Amazon IVS User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPlaybackKeyPairs {
    _private: (),
}
impl ListPlaybackKeyPairs {
    /// Creates a new builder-style object to manufacture [`ListPlaybackKeyPairsInput`](crate::input::ListPlaybackKeyPairsInput)
    pub fn builder() -> crate::input::list_playback_key_pairs_input::Builder {
        crate::input::list_playback_key_pairs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPlaybackKeyPairs {
    type Output = std::result::Result<
        crate::output::ListPlaybackKeyPairsOutput,
        crate::error::ListPlaybackKeyPairsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_playback_key_pairs_error(response)
        } else {
            crate::operation_deser::parse_list_playback_key_pairs_response(response)
        }
    }
}

/// <p>Gets summary information about all recording configurations in your account, in the AWS
/// region where the API request is processed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRecordingConfigurations {
    _private: (),
}
impl ListRecordingConfigurations {
    /// Creates a new builder-style object to manufacture [`ListRecordingConfigurationsInput`](crate::input::ListRecordingConfigurationsInput)
    pub fn builder() -> crate::input::list_recording_configurations_input::Builder {
        crate::input::list_recording_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRecordingConfigurations {
    type Output = std::result::Result<
        crate::output::ListRecordingConfigurationsOutput,
        crate::error::ListRecordingConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_recording_configurations_error(response)
        } else {
            crate::operation_deser::parse_list_recording_configurations_response(response)
        }
    }
}

/// <p>Gets summary information about stream keys for the specified channel.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStreamKeys {
    _private: (),
}
impl ListStreamKeys {
    /// Creates a new builder-style object to manufacture [`ListStreamKeysInput`](crate::input::ListStreamKeysInput)
    pub fn builder() -> crate::input::list_stream_keys_input::Builder {
        crate::input::list_stream_keys_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStreamKeys {
    type Output =
        std::result::Result<crate::output::ListStreamKeysOutput, crate::error::ListStreamKeysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_stream_keys_error(response)
        } else {
            crate::operation_deser::parse_list_stream_keys_response(response)
        }
    }
}

/// <p>Gets summary information about live streams in your account, in the AWS region where the
/// API request is processed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStreams {
    _private: (),
}
impl ListStreams {
    /// Creates a new builder-style object to manufacture [`ListStreamsInput`](crate::input::ListStreamsInput)
    pub fn builder() -> crate::input::list_streams_input::Builder {
        crate::input::list_streams_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStreams {
    type Output =
        std::result::Result<crate::output::ListStreamsOutput, crate::error::ListStreamsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_streams_error(response)
        } else {
            crate::operation_deser::parse_list_streams_response(response)
        }
    }
}

/// <p>Gets information about AWS tags for the specified ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Inserts metadata into the active stream of the specified channel. A maximum of 5 requests
/// per second per channel is allowed, each with a maximum 1 KB payload. (If 5 TPS is not
/// sufficient for your needs, we recommend batching your data into a single PutMetadata call.)
/// Also see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/metadata.html">Embedding Metadata
/// within a Video Stream</a> in the <i>Amazon IVS User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutMetadata {
    _private: (),
}
impl PutMetadata {
    /// Creates a new builder-style object to manufacture [`PutMetadataInput`](crate::input::PutMetadataInput)
    pub fn builder() -> crate::input::put_metadata_input::Builder {
        crate::input::put_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutMetadata {
    type Output =
        std::result::Result<crate::output::PutMetadataOutput, crate::error::PutMetadataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_metadata_error(response)
        } else {
            crate::operation_deser::parse_put_metadata_response(response)
        }
    }
}

/// <p>Disconnects the incoming RTMPS stream for the specified channel. Can be used in
/// conjunction with <a>DeleteStreamKey</a> to prevent further streaming to a
/// channel.</p>
/// <note>
/// <p>Many streaming client-software libraries automatically reconnect a dropped RTMPS
/// session, so to stop the stream permanently, you may want to first revoke the
/// <code>streamKey</code> attached to the channel.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopStream {
    _private: (),
}
impl StopStream {
    /// Creates a new builder-style object to manufacture [`StopStreamInput`](crate::input::StopStreamInput)
    pub fn builder() -> crate::input::stop_stream_input::Builder {
        crate::input::stop_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopStream {
    type Output =
        std::result::Result<crate::output::StopStreamOutput, crate::error::StopStreamError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_stream_error(response)
        } else {
            crate::operation_deser::parse_stop_stream_response(response)
        }
    }
}

/// <p>Adds or updates tags for the AWS resource with the specified ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes tags from the resource with the specified ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates a channel's configuration. This does not affect an ongoing stream of this channel.
/// You must stop and restart the stream for the changes to take effect.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateChannel {
    _private: (),
}
impl UpdateChannel {
    /// Creates a new builder-style object to manufacture [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    pub fn builder() -> crate::input::update_channel_input::Builder {
        crate::input::update_channel_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateChannel {
    type Output =
        std::result::Result<crate::output::UpdateChannelOutput, crate::error::UpdateChannelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_channel_error(response)
        } else {
            crate::operation_deser::parse_update_channel_response(response)
        }
    }
}
