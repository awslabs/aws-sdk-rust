// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a batch inference job. The operation can handle up to 50 million records and the
/// input file must be in JSON format. For more information, see <a>recommendations-batch</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBatchInferenceJob {
    _private: (),
}
impl CreateBatchInferenceJob {
    /// Creates a new builder-style object to manufacture [`CreateBatchInferenceJobInput`](crate::input::CreateBatchInferenceJobInput)
    pub fn builder() -> crate::input::create_batch_inference_job_input::Builder {
        crate::input::create_batch_inference_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBatchInferenceJob {
    type Output = std::result::Result<
        crate::output::CreateBatchInferenceJobOutput,
        crate::error::CreateBatchInferenceJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_batch_inference_job_error(response)
        } else {
            crate::operation_deser::parse_create_batch_inference_job_response(response)
        }
    }
}

/// <p>Creates a campaign by deploying a solution version. When a client calls the
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a>
/// and
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetPersonalizedRanking.html">GetPersonalizedRanking</a>
/// APIs, a campaign is specified in the request.</p>
/// <p>
/// <b>Minimum Provisioned TPS and Auto-Scaling</b>
/// </p>
/// <p>A transaction is a single <code>GetRecommendations</code> or
/// <code>GetPersonalizedRanking</code> call. Transactions per second (TPS) is the throughput
/// and unit of billing for Amazon Personalize. The minimum provisioned TPS
/// (<code>minProvisionedTPS</code>) specifies the baseline throughput provisioned by
/// Amazon Personalize, and thus, the minimum billing charge.
/// </p>
/// <p>
/// If your TPS increases beyond
/// <code>minProvisionedTPS</code>, Amazon Personalize auto-scales the provisioned capacity up and down,
/// but never below <code>minProvisionedTPS</code>.
/// There's a short time delay while the capacity is increased that might cause loss of
/// transactions.</p>
/// <p>The actual TPS used is calculated as the average requests/second within a 5-minute window.
/// You pay for maximum of either the minimum provisioned TPS or the actual TPS.
/// We recommend starting with a low <code>minProvisionedTPS</code>, track
/// your usage using Amazon CloudWatch metrics, and then increase the <code>minProvisionedTPS</code>
/// as necessary.</p>
/// <p>
/// <b>Status</b>
/// </p>
/// <p>A campaign can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// <li>
/// <p>DELETE PENDING > DELETE IN_PROGRESS</p>
/// </li>
/// </ul>
/// <p>To get the campaign status, call <a>DescribeCampaign</a>.</p>
/// <note>
/// <p>Wait until the <code>status</code> of the campaign
/// is <code>ACTIVE</code> before asking the campaign for recommendations.</p>
/// </note>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListCampaigns</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeCampaign</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>UpdateCampaign</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteCampaign</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCampaign {
    _private: (),
}
impl CreateCampaign {
    /// Creates a new builder-style object to manufacture [`CreateCampaignInput`](crate::input::CreateCampaignInput)
    pub fn builder() -> crate::input::create_campaign_input::Builder {
        crate::input::create_campaign_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCampaign {
    type Output =
        std::result::Result<crate::output::CreateCampaignOutput, crate::error::CreateCampaignError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_campaign_error(response)
        } else {
            crate::operation_deser::parse_create_campaign_response(response)
        }
    }
}

/// <p>Creates an empty dataset and adds it to the specified dataset group. Use <a>CreateDatasetImportJob</a> to import your training data to a dataset.</p>
/// <p>There are three types of datasets:</p>
/// <ul>
/// <li>
/// <p>Interactions</p>
/// </li>
/// <li>
/// <p>Items</p>
/// </li>
/// <li>
/// <p>Users</p>
/// </li>
/// </ul>
/// <p>Each dataset type has an associated schema with required field types. Only the
/// <code>Interactions</code> dataset is required in order to train a model (also referred to as
/// creating a solution).</p>
/// <p>A dataset can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// <li>
/// <p>DELETE PENDING > DELETE IN_PROGRESS</p>
/// </li>
/// </ul>
/// <p>To get the status of the dataset, call <a>DescribeDataset</a>.</p>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>CreateDatasetGroup</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>ListDatasets</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeDataset</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteDataset</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataset {
    _private: (),
}
impl CreateDataset {
    /// Creates a new builder-style object to manufacture [`CreateDatasetInput`](crate::input::CreateDatasetInput)
    pub fn builder() -> crate::input::create_dataset_input::Builder {
        crate::input::create_dataset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataset {
    type Output =
        std::result::Result<crate::output::CreateDatasetOutput, crate::error::CreateDatasetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_response(response)
        }
    }
}

/// <p>
/// Creates a job that exports data from your dataset to an Amazon S3 bucket.
/// To allow Amazon Personalize to export the training data, you must specify an
/// service-linked IAM role that gives Amazon Personalize <code>PutObject</code> permissions for your Amazon S3 bucket.
/// For information, see <a href="https://docs.aws.amazon.com/personalize/latest/dg/export-data.html">Exporting a dataset</a>
/// in the Amazon Personalize developer guide.
/// </p>
/// <p>
/// <b>Status</b>
/// </p>
/// <p>A dataset export job can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// </ul>
/// <p>
/// To get the status of the export job, call <a>DescribeDatasetExportJob</a>,
/// and specify the Amazon Resource Name (ARN) of the dataset export job. The dataset export is
/// complete when the status shows as ACTIVE. If the status shows as CREATE FAILED, the response
/// includes a <code>failureReason</code> key, which describes why the job failed.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDatasetExportJob {
    _private: (),
}
impl CreateDatasetExportJob {
    /// Creates a new builder-style object to manufacture [`CreateDatasetExportJobInput`](crate::input::CreateDatasetExportJobInput)
    pub fn builder() -> crate::input::create_dataset_export_job_input::Builder {
        crate::input::create_dataset_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDatasetExportJob {
    type Output = std::result::Result<
        crate::output::CreateDatasetExportJobOutput,
        crate::error::CreateDatasetExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_export_job_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_export_job_response(response)
        }
    }
}

/// <p>Creates an empty dataset group. A dataset group contains related datasets that supply data
/// for training a model. A dataset group can contain at most three datasets, one for each type of
/// dataset:</p>
/// <ul>
/// <li>
/// <p>Interactions</p>
/// </li>
/// <li>
/// <p>Items</p>
/// </li>
/// <li>
/// <p>Users</p>
/// </li>
/// </ul>
/// <p>To train a model (create a solution), a dataset group that contains an
/// <code>Interactions</code> dataset is required. Call <a>CreateDataset</a> to add a
/// dataset to the group.</p>
/// <p>A dataset group can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// <li>
/// <p>DELETE PENDING</p>
/// </li>
/// </ul>
/// <p>To get the status of the dataset group, call <a>DescribeDatasetGroup</a>. If
/// the status shows as CREATE FAILED, the response includes a <code>failureReason</code> key,
/// which describes why the creation failed.</p>
/// <note>
/// <p>You must wait until the <code>status</code> of the dataset group is <code>ACTIVE</code>
/// before adding a dataset to the group.</p>
/// </note>
/// <p>You can specify an Key Management Service (KMS) key to encrypt the datasets in the group. If you
/// specify a KMS key, you must also include an Identity and Access Management (IAM) role that has permission to
/// access the key.</p>
/// <p class="title">
/// <b>APIs that require a dataset group ARN in the request</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>CreateDataset</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>CreateEventTracker</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>CreateSolution</a>
/// </p>
/// </li>
/// </ul>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListDatasetGroups</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeDatasetGroup</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteDatasetGroup</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDatasetGroup {
    _private: (),
}
impl CreateDatasetGroup {
    /// Creates a new builder-style object to manufacture [`CreateDatasetGroupInput`](crate::input::CreateDatasetGroupInput)
    pub fn builder() -> crate::input::create_dataset_group_input::Builder {
        crate::input::create_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDatasetGroup {
    type Output = std::result::Result<
        crate::output::CreateDatasetGroupOutput,
        crate::error::CreateDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_group_response(response)
        }
    }
}

/// <p>Creates a job that imports training data from your data source (an Amazon S3 bucket) to an
/// Amazon Personalize dataset. To allow Amazon Personalize to import the training data, you must specify an
/// IAM service role that has permission to read from the data source, as Amazon Personalize makes a
/// copy of your data and processes it internally. For information on granting access
/// to your Amazon S3 bucket, see <a href="https://docs.aws.amazon.com/personalize/latest/dg/granting-personalize-s3-access.html">Giving Amazon Personalize
/// Access to Amazon S3 Resources</a>. </p>
/// <important>
/// <p>The dataset import job replaces any existing data in the dataset that you imported in bulk.</p>
/// </important>
/// <p>
/// <b>Status</b>
/// </p>
/// <p>A dataset import job can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// </ul>
/// <p>To get the status of the import job, call <a>DescribeDatasetImportJob</a>,
/// providing the Amazon Resource Name (ARN) of the dataset import job. The dataset import is
/// complete when the status shows as ACTIVE. If the status shows as CREATE FAILED, the response
/// includes a <code>failureReason</code> key, which describes why the job failed.</p>
/// <note>
/// <p>Importing takes time. You must wait until the status shows as ACTIVE before training a
/// model using the dataset.</p>
/// </note>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListDatasetImportJobs</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeDatasetImportJob</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDatasetImportJob {
    _private: (),
}
impl CreateDatasetImportJob {
    /// Creates a new builder-style object to manufacture [`CreateDatasetImportJobInput`](crate::input::CreateDatasetImportJobInput)
    pub fn builder() -> crate::input::create_dataset_import_job_input::Builder {
        crate::input::create_dataset_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDatasetImportJob {
    type Output = std::result::Result<
        crate::output::CreateDatasetImportJobOutput,
        crate::error::CreateDatasetImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_import_job_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_import_job_response(response)
        }
    }
}

/// <p>Creates an event tracker that you use when adding event data to a specified dataset
/// group using the
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents</a> API.</p>
/// <note>
/// <p>Only one event tracker can be associated with a dataset group. You will get
/// an error if you call <code>CreateEventTracker</code> using the same dataset group as an
/// existing event tracker.</p>
/// </note>
/// <p>When you create an event tracker, the response includes a tracking ID, which you pass as a parameter when you use the
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents</a> operation.
/// Amazon Personalize then appends the event data to the Interactions dataset of the dataset group you specify
/// in your event tracker.
/// </p>
/// <p>The event tracker can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// <li>
/// <p>DELETE PENDING > DELETE IN_PROGRESS</p>
/// </li>
/// </ul>
/// <p>To get the status of the event tracker, call <a>DescribeEventTracker</a>.</p>
/// <note>
/// <p>The event tracker must be in the ACTIVE state before using the tracking ID.</p>
/// </note>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListEventTrackers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeEventTracker</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteEventTracker</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEventTracker {
    _private: (),
}
impl CreateEventTracker {
    /// Creates a new builder-style object to manufacture [`CreateEventTrackerInput`](crate::input::CreateEventTrackerInput)
    pub fn builder() -> crate::input::create_event_tracker_input::Builder {
        crate::input::create_event_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEventTracker {
    type Output = std::result::Result<
        crate::output::CreateEventTrackerOutput,
        crate::error::CreateEventTrackerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_event_tracker_error(response)
        } else {
            crate::operation_deser::parse_create_event_tracker_response(response)
        }
    }
}

/// <p>Creates a recommendation filter. For more information, see <a>filter</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFilter {
    _private: (),
}
impl CreateFilter {
    /// Creates a new builder-style object to manufacture [`CreateFilterInput`](crate::input::CreateFilterInput)
    pub fn builder() -> crate::input::create_filter_input::Builder {
        crate::input::create_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFilter {
    type Output =
        std::result::Result<crate::output::CreateFilterOutput, crate::error::CreateFilterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_filter_error(response)
        } else {
            crate::operation_deser::parse_create_filter_response(response)
        }
    }
}

/// <p>Creates an Amazon Personalize schema from the specified schema string. The schema you create
/// must be in Avro JSON format.</p>
/// <p>Amazon Personalize recognizes three schema variants. Each schema is associated with a dataset
/// type and has a set of required field and keywords.
/// You specify a schema when you call <a>CreateDataset</a>.</p>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListSchemas</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeSchema</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteSchema</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSchema {
    _private: (),
}
impl CreateSchema {
    /// Creates a new builder-style object to manufacture [`CreateSchemaInput`](crate::input::CreateSchemaInput)
    pub fn builder() -> crate::input::create_schema_input::Builder {
        crate::input::create_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSchema {
    type Output =
        std::result::Result<crate::output::CreateSchemaOutput, crate::error::CreateSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_schema_error(response)
        } else {
            crate::operation_deser::parse_create_schema_response(response)
        }
    }
}

/// <p>Creates the configuration for training a model. A trained model is known as
/// a solution. After the configuration is created, you train the model (create a solution)
/// by calling the <a>CreateSolutionVersion</a> operation. Every time you call
/// <code>CreateSolutionVersion</code>, a new version of the solution is created.</p>
/// <p>After creating a solution version, you check its accuracy by calling
/// <a>GetSolutionMetrics</a>. When you are satisfied with the version, you
/// deploy it using <a>CreateCampaign</a>. The campaign provides recommendations
/// to a client through the
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a> API.</p>
/// <p>To train a model, Amazon Personalize requires training data and a recipe. The training data
/// comes from the dataset group that you provide in the request. A recipe specifies
/// the training algorithm and a feature transformation. You can specify one of the predefined
/// recipes provided by Amazon Personalize. Alternatively, you can specify
/// <code>performAutoML</code> and Amazon Personalize will analyze your data and select the
/// optimum USER_PERSONALIZATION recipe for you.</p>
/// <note>
/// <p>Amazon Personalize doesn't support configuring the <code>hpoObjective</code>
/// for solution hyperparameter optimization at this time.</p>
/// </note>
/// <p>
/// <b>Status</b>
/// </p>
/// <p>A solution can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// <li>
/// <p>DELETE PENDING > DELETE IN_PROGRESS</p>
/// </li>
/// </ul>
/// <p>To get the status of the solution, call <a>DescribeSolution</a>. Wait
/// until the status shows as ACTIVE before calling <code>CreateSolutionVersion</code>.</p>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListSolutions</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>CreateSolutionVersion</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeSolution</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteSolution</a>
/// </p>
/// </li>
/// </ul>
/// <ul>
/// <li>
/// <p>
/// <a>ListSolutionVersions</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeSolutionVersion</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSolution {
    _private: (),
}
impl CreateSolution {
    /// Creates a new builder-style object to manufacture [`CreateSolutionInput`](crate::input::CreateSolutionInput)
    pub fn builder() -> crate::input::create_solution_input::Builder {
        crate::input::create_solution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSolution {
    type Output =
        std::result::Result<crate::output::CreateSolutionOutput, crate::error::CreateSolutionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_solution_error(response)
        } else {
            crate::operation_deser::parse_create_solution_response(response)
        }
    }
}

/// <p>Trains or retrains an active solution. A solution is created using the <a>CreateSolution</a> operation and must be in the ACTIVE state before calling
/// <code>CreateSolutionVersion</code>. A new version of the solution is created every time you
/// call this operation.</p>
/// <p>
/// <b>Status</b>
/// </p>
/// <p>A solution version can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING</p>
/// </li>
/// <li>
/// <p>CREATE IN_PROGRESS</p>
/// </li>
/// <li>
/// <p>ACTIVE</p>
/// </li>
/// <li>
/// <p>CREATE FAILED</p>
/// </li>
/// <li>
/// <p>CREATE STOPPING</p>
/// </li>
/// <li>
/// <p>CREATE STOPPED</p>
/// </li>
/// </ul>
/// <p>To get the status of the version, call <a>DescribeSolutionVersion</a>. Wait
/// until the status shows as ACTIVE before calling <code>CreateCampaign</code>.</p>
/// <p>If the status shows as CREATE FAILED, the response includes a <code>failureReason</code>
/// key, which describes why the job failed.</p>
/// <p class="title">
/// <b>Related APIs</b>
/// </p>
/// <ul>
/// <li>
/// <p>
/// <a>ListSolutionVersions</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeSolutionVersion</a>
/// </p>
/// </li>
/// </ul>
/// <ul>
/// <li>
/// <p>
/// <a>ListSolutions</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>CreateSolution</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DescribeSolution</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>DeleteSolution</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSolutionVersion {
    _private: (),
}
impl CreateSolutionVersion {
    /// Creates a new builder-style object to manufacture [`CreateSolutionVersionInput`](crate::input::CreateSolutionVersionInput)
    pub fn builder() -> crate::input::create_solution_version_input::Builder {
        crate::input::create_solution_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSolutionVersion {
    type Output = std::result::Result<
        crate::output::CreateSolutionVersionOutput,
        crate::error::CreateSolutionVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_solution_version_error(response)
        } else {
            crate::operation_deser::parse_create_solution_version_response(response)
        }
    }
}

/// <p>Removes a campaign by deleting the solution deployment. The solution that
/// the campaign is based on is not deleted and can be redeployed when needed. A deleted campaign can no
/// longer be specified in a
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a>
/// request.
/// For more information on campaigns, see <a>CreateCampaign</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCampaign {
    _private: (),
}
impl DeleteCampaign {
    /// Creates a new builder-style object to manufacture [`DeleteCampaignInput`](crate::input::DeleteCampaignInput)
    pub fn builder() -> crate::input::delete_campaign_input::Builder {
        crate::input::delete_campaign_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCampaign {
    type Output =
        std::result::Result<crate::output::DeleteCampaignOutput, crate::error::DeleteCampaignError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_campaign_error(response)
        } else {
            crate::operation_deser::parse_delete_campaign_response(response)
        }
    }
}

/// <p>Deletes a dataset. You can't delete a dataset if an associated
/// <code>DatasetImportJob</code> or <code>SolutionVersion</code> is in the CREATE PENDING or IN
/// PROGRESS state. For more information on datasets, see <a>CreateDataset</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDataset {
    _private: (),
}
impl DeleteDataset {
    /// Creates a new builder-style object to manufacture [`DeleteDatasetInput`](crate::input::DeleteDatasetInput)
    pub fn builder() -> crate::input::delete_dataset_input::Builder {
        crate::input::delete_dataset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDataset {
    type Output =
        std::result::Result<crate::output::DeleteDatasetOutput, crate::error::DeleteDatasetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dataset_error(response)
        } else {
            crate::operation_deser::parse_delete_dataset_response(response)
        }
    }
}

/// <p>Deletes a dataset group. Before you delete a dataset group, you must delete the
/// following:</p>
/// <ul>
/// <li>
/// <p>All associated event trackers.</p>
/// </li>
/// <li>
/// <p>All associated solutions.</p>
/// </li>
/// <li>
/// <p>All datasets in the dataset group.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDatasetGroup {
    _private: (),
}
impl DeleteDatasetGroup {
    /// Creates a new builder-style object to manufacture [`DeleteDatasetGroupInput`](crate::input::DeleteDatasetGroupInput)
    pub fn builder() -> crate::input::delete_dataset_group_input::Builder {
        crate::input::delete_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDatasetGroup {
    type Output = std::result::Result<
        crate::output::DeleteDatasetGroupOutput,
        crate::error::DeleteDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_delete_dataset_group_response(response)
        }
    }
}

/// <p>Deletes the event tracker. Does not delete the event-interactions dataset from
/// the associated dataset group. For more
/// information on event trackers, see <a>CreateEventTracker</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEventTracker {
    _private: (),
}
impl DeleteEventTracker {
    /// Creates a new builder-style object to manufacture [`DeleteEventTrackerInput`](crate::input::DeleteEventTrackerInput)
    pub fn builder() -> crate::input::delete_event_tracker_input::Builder {
        crate::input::delete_event_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEventTracker {
    type Output = std::result::Result<
        crate::output::DeleteEventTrackerOutput,
        crate::error::DeleteEventTrackerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_event_tracker_error(response)
        } else {
            crate::operation_deser::parse_delete_event_tracker_response(response)
        }
    }
}

/// <p>Deletes a filter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFilter {
    _private: (),
}
impl DeleteFilter {
    /// Creates a new builder-style object to manufacture [`DeleteFilterInput`](crate::input::DeleteFilterInput)
    pub fn builder() -> crate::input::delete_filter_input::Builder {
        crate::input::delete_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFilter {
    type Output =
        std::result::Result<crate::output::DeleteFilterOutput, crate::error::DeleteFilterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_filter_error(response)
        } else {
            crate::operation_deser::parse_delete_filter_response(response)
        }
    }
}

/// <p>Deletes a schema. Before deleting a schema, you must delete all
/// datasets referencing the schema. For more information on schemas, see
/// <a>CreateSchema</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSchema {
    _private: (),
}
impl DeleteSchema {
    /// Creates a new builder-style object to manufacture [`DeleteSchemaInput`](crate::input::DeleteSchemaInput)
    pub fn builder() -> crate::input::delete_schema_input::Builder {
        crate::input::delete_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSchema {
    type Output =
        std::result::Result<crate::output::DeleteSchemaOutput, crate::error::DeleteSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_schema_error(response)
        } else {
            crate::operation_deser::parse_delete_schema_response(response)
        }
    }
}

/// <p>Deletes all versions of a solution and the <code>Solution</code> object itself.
/// Before deleting a solution, you must delete all campaigns based on
/// the solution. To determine what campaigns are using the solution, call
/// <a>ListCampaigns</a> and supply the Amazon Resource Name (ARN) of the solution.
/// You can't delete a solution if an associated <code>SolutionVersion</code> is in the
/// CREATE PENDING or IN PROGRESS state.
/// For more information on solutions, see <a>CreateSolution</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSolution {
    _private: (),
}
impl DeleteSolution {
    /// Creates a new builder-style object to manufacture [`DeleteSolutionInput`](crate::input::DeleteSolutionInput)
    pub fn builder() -> crate::input::delete_solution_input::Builder {
        crate::input::delete_solution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSolution {
    type Output =
        std::result::Result<crate::output::DeleteSolutionOutput, crate::error::DeleteSolutionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_solution_error(response)
        } else {
            crate::operation_deser::parse_delete_solution_response(response)
        }
    }
}

/// <p>Describes the given algorithm.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAlgorithm {
    _private: (),
}
impl DescribeAlgorithm {
    /// Creates a new builder-style object to manufacture [`DescribeAlgorithmInput`](crate::input::DescribeAlgorithmInput)
    pub fn builder() -> crate::input::describe_algorithm_input::Builder {
        crate::input::describe_algorithm_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAlgorithm {
    type Output = std::result::Result<
        crate::output::DescribeAlgorithmOutput,
        crate::error::DescribeAlgorithmError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_algorithm_error(response)
        } else {
            crate::operation_deser::parse_describe_algorithm_response(response)
        }
    }
}

/// <p>Gets the properties of a batch inference job including name, Amazon Resource Name (ARN),
/// status, input and output configurations, and the ARN of the solution version used to generate
/// the recommendations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBatchInferenceJob {
    _private: (),
}
impl DescribeBatchInferenceJob {
    /// Creates a new builder-style object to manufacture [`DescribeBatchInferenceJobInput`](crate::input::DescribeBatchInferenceJobInput)
    pub fn builder() -> crate::input::describe_batch_inference_job_input::Builder {
        crate::input::describe_batch_inference_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBatchInferenceJob {
    type Output = std::result::Result<
        crate::output::DescribeBatchInferenceJobOutput,
        crate::error::DescribeBatchInferenceJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_batch_inference_job_error(response)
        } else {
            crate::operation_deser::parse_describe_batch_inference_job_response(response)
        }
    }
}

/// <p>Describes the given campaign, including its status.</p>
/// <p>A campaign can be in one of the following states:</p>
/// <ul>
/// <li>
/// <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
/// </li>
/// <li>
/// <p>DELETE PENDING > DELETE IN_PROGRESS</p>
/// </li>
/// </ul>
/// <p>When the <code>status</code> is <code>CREATE FAILED</code>, the response includes the
/// <code>failureReason</code> key, which describes why.</p>
/// <p>For more information on campaigns, see <a>CreateCampaign</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCampaign {
    _private: (),
}
impl DescribeCampaign {
    /// Creates a new builder-style object to manufacture [`DescribeCampaignInput`](crate::input::DescribeCampaignInput)
    pub fn builder() -> crate::input::describe_campaign_input::Builder {
        crate::input::describe_campaign_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCampaign {
    type Output = std::result::Result<
        crate::output::DescribeCampaignOutput,
        crate::error::DescribeCampaignError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_campaign_error(response)
        } else {
            crate::operation_deser::parse_describe_campaign_response(response)
        }
    }
}

/// <p>Describes the given dataset. For more information on datasets, see <a>CreateDataset</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataset {
    _private: (),
}
impl DescribeDataset {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetInput`](crate::input::DescribeDatasetInput)
    pub fn builder() -> crate::input::describe_dataset_input::Builder {
        crate::input::describe_dataset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataset {
    type Output = std::result::Result<
        crate::output::DescribeDatasetOutput,
        crate::error::DescribeDatasetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_response(response)
        }
    }
}

/// <p>Describes the dataset export job created by <a>CreateDatasetExportJob</a>,
/// including the export job status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDatasetExportJob {
    _private: (),
}
impl DescribeDatasetExportJob {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetExportJobInput`](crate::input::DescribeDatasetExportJobInput)
    pub fn builder() -> crate::input::describe_dataset_export_job_input::Builder {
        crate::input::describe_dataset_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDatasetExportJob {
    type Output = std::result::Result<
        crate::output::DescribeDatasetExportJobOutput,
        crate::error::DescribeDatasetExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_export_job_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_export_job_response(response)
        }
    }
}

/// <p>Describes the given dataset group. For more information on dataset groups, see <a>CreateDatasetGroup</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDatasetGroup {
    _private: (),
}
impl DescribeDatasetGroup {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetGroupInput`](crate::input::DescribeDatasetGroupInput)
    pub fn builder() -> crate::input::describe_dataset_group_input::Builder {
        crate::input::describe_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDatasetGroup {
    type Output = std::result::Result<
        crate::output::DescribeDatasetGroupOutput,
        crate::error::DescribeDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_group_response(response)
        }
    }
}

/// <p>Describes the dataset import job created by <a>CreateDatasetImportJob</a>,
/// including the import job status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDatasetImportJob {
    _private: (),
}
impl DescribeDatasetImportJob {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetImportJobInput`](crate::input::DescribeDatasetImportJobInput)
    pub fn builder() -> crate::input::describe_dataset_import_job_input::Builder {
        crate::input::describe_dataset_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDatasetImportJob {
    type Output = std::result::Result<
        crate::output::DescribeDatasetImportJobOutput,
        crate::error::DescribeDatasetImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_import_job_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_import_job_response(response)
        }
    }
}

/// <p>Describes an event tracker. The response includes the <code>trackingId</code> and
/// <code>status</code> of the event tracker.
/// For more information on event trackers, see <a>CreateEventTracker</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEventTracker {
    _private: (),
}
impl DescribeEventTracker {
    /// Creates a new builder-style object to manufacture [`DescribeEventTrackerInput`](crate::input::DescribeEventTrackerInput)
    pub fn builder() -> crate::input::describe_event_tracker_input::Builder {
        crate::input::describe_event_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEventTracker {
    type Output = std::result::Result<
        crate::output::DescribeEventTrackerOutput,
        crate::error::DescribeEventTrackerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_event_tracker_error(response)
        } else {
            crate::operation_deser::parse_describe_event_tracker_response(response)
        }
    }
}

/// <p>Describes the given feature transformation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFeatureTransformation {
    _private: (),
}
impl DescribeFeatureTransformation {
    /// Creates a new builder-style object to manufacture [`DescribeFeatureTransformationInput`](crate::input::DescribeFeatureTransformationInput)
    pub fn builder() -> crate::input::describe_feature_transformation_input::Builder {
        crate::input::describe_feature_transformation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFeatureTransformation {
    type Output = std::result::Result<
        crate::output::DescribeFeatureTransformationOutput,
        crate::error::DescribeFeatureTransformationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_feature_transformation_error(response)
        } else {
            crate::operation_deser::parse_describe_feature_transformation_response(response)
        }
    }
}

/// <p>Describes a filter's properties.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFilter {
    _private: (),
}
impl DescribeFilter {
    /// Creates a new builder-style object to manufacture [`DescribeFilterInput`](crate::input::DescribeFilterInput)
    pub fn builder() -> crate::input::describe_filter_input::Builder {
        crate::input::describe_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFilter {
    type Output =
        std::result::Result<crate::output::DescribeFilterOutput, crate::error::DescribeFilterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_filter_error(response)
        } else {
            crate::operation_deser::parse_describe_filter_response(response)
        }
    }
}

/// <p>Describes a recipe.</p>
/// <p>A recipe contains three items:</p>
/// <ul>
/// <li>
/// <p>An algorithm that trains a model.</p>
/// </li>
/// <li>
/// <p>Hyperparameters that govern the training.</p>
/// </li>
/// <li>
/// <p>Feature transformation information for modifying the input data before training.</p>
/// </li>
/// </ul>
/// <p>Amazon Personalize provides a set of predefined recipes. You specify a recipe when you create a
/// solution with the <a>CreateSolution</a> API.
/// <code>CreateSolution</code> trains a model by using the algorithm
/// in the specified recipe and a training dataset. The solution, when deployed as a campaign,
/// can provide recommendations using the
/// <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRecipe {
    _private: (),
}
impl DescribeRecipe {
    /// Creates a new builder-style object to manufacture [`DescribeRecipeInput`](crate::input::DescribeRecipeInput)
    pub fn builder() -> crate::input::describe_recipe_input::Builder {
        crate::input::describe_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRecipe {
    type Output =
        std::result::Result<crate::output::DescribeRecipeOutput, crate::error::DescribeRecipeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_recipe_error(response)
        } else {
            crate::operation_deser::parse_describe_recipe_response(response)
        }
    }
}

/// <p>Describes a schema. For more information on schemas, see
/// <a>CreateSchema</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSchema {
    _private: (),
}
impl DescribeSchema {
    /// Creates a new builder-style object to manufacture [`DescribeSchemaInput`](crate::input::DescribeSchemaInput)
    pub fn builder() -> crate::input::describe_schema_input::Builder {
        crate::input::describe_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSchema {
    type Output =
        std::result::Result<crate::output::DescribeSchemaOutput, crate::error::DescribeSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_schema_error(response)
        } else {
            crate::operation_deser::parse_describe_schema_response(response)
        }
    }
}

/// <p>Describes a solution.
/// For more information on solutions, see <a>CreateSolution</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSolution {
    _private: (),
}
impl DescribeSolution {
    /// Creates a new builder-style object to manufacture [`DescribeSolutionInput`](crate::input::DescribeSolutionInput)
    pub fn builder() -> crate::input::describe_solution_input::Builder {
        crate::input::describe_solution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSolution {
    type Output = std::result::Result<
        crate::output::DescribeSolutionOutput,
        crate::error::DescribeSolutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_solution_error(response)
        } else {
            crate::operation_deser::parse_describe_solution_response(response)
        }
    }
}

/// <p>Describes a specific version of a solution. For more information on solutions, see <a>CreateSolution</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSolutionVersion {
    _private: (),
}
impl DescribeSolutionVersion {
    /// Creates a new builder-style object to manufacture [`DescribeSolutionVersionInput`](crate::input::DescribeSolutionVersionInput)
    pub fn builder() -> crate::input::describe_solution_version_input::Builder {
        crate::input::describe_solution_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSolutionVersion {
    type Output = std::result::Result<
        crate::output::DescribeSolutionVersionOutput,
        crate::error::DescribeSolutionVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_solution_version_error(response)
        } else {
            crate::operation_deser::parse_describe_solution_version_response(response)
        }
    }
}

/// <p>Gets the metrics for the specified solution version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSolutionMetrics {
    _private: (),
}
impl GetSolutionMetrics {
    /// Creates a new builder-style object to manufacture [`GetSolutionMetricsInput`](crate::input::GetSolutionMetricsInput)
    pub fn builder() -> crate::input::get_solution_metrics_input::Builder {
        crate::input::get_solution_metrics_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSolutionMetrics {
    type Output = std::result::Result<
        crate::output::GetSolutionMetricsOutput,
        crate::error::GetSolutionMetricsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_solution_metrics_error(response)
        } else {
            crate::operation_deser::parse_get_solution_metrics_response(response)
        }
    }
}

/// <p>Gets a list of the batch inference jobs that have been performed off of a solution
/// version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBatchInferenceJobs {
    _private: (),
}
impl ListBatchInferenceJobs {
    /// Creates a new builder-style object to manufacture [`ListBatchInferenceJobsInput`](crate::input::ListBatchInferenceJobsInput)
    pub fn builder() -> crate::input::list_batch_inference_jobs_input::Builder {
        crate::input::list_batch_inference_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBatchInferenceJobs {
    type Output = std::result::Result<
        crate::output::ListBatchInferenceJobsOutput,
        crate::error::ListBatchInferenceJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_batch_inference_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_batch_inference_jobs_response(response)
        }
    }
}

/// <p>Returns a list of campaigns that use the given solution.
/// When a solution is not specified, all the campaigns associated with the account are listed.
/// The response provides the properties for each campaign, including the Amazon Resource Name (ARN).
/// For more information on campaigns, see <a>CreateCampaign</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCampaigns {
    _private: (),
}
impl ListCampaigns {
    /// Creates a new builder-style object to manufacture [`ListCampaignsInput`](crate::input::ListCampaignsInput)
    pub fn builder() -> crate::input::list_campaigns_input::Builder {
        crate::input::list_campaigns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCampaigns {
    type Output =
        std::result::Result<crate::output::ListCampaignsOutput, crate::error::ListCampaignsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_campaigns_error(response)
        } else {
            crate::operation_deser::parse_list_campaigns_response(response)
        }
    }
}

/// <p>Returns a list of dataset export jobs that use the given dataset. When a dataset is not
/// specified, all the dataset export jobs associated with the account are listed. The response
/// provides the properties for each dataset export job, including the Amazon Resource Name (ARN).
/// For more information on dataset export jobs, see <a>CreateDatasetExportJob</a>. For
/// more information on datasets, see <a>CreateDataset</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasetExportJobs {
    _private: (),
}
impl ListDatasetExportJobs {
    /// Creates a new builder-style object to manufacture [`ListDatasetExportJobsInput`](crate::input::ListDatasetExportJobsInput)
    pub fn builder() -> crate::input::list_dataset_export_jobs_input::Builder {
        crate::input::list_dataset_export_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasetExportJobs {
    type Output = std::result::Result<
        crate::output::ListDatasetExportJobsOutput,
        crate::error::ListDatasetExportJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dataset_export_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_dataset_export_jobs_response(response)
        }
    }
}

/// <p>Returns a list of dataset groups. The response provides the properties for each dataset
/// group, including the Amazon Resource Name (ARN). For more information on dataset groups, see
/// <a>CreateDatasetGroup</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasetGroups {
    _private: (),
}
impl ListDatasetGroups {
    /// Creates a new builder-style object to manufacture [`ListDatasetGroupsInput`](crate::input::ListDatasetGroupsInput)
    pub fn builder() -> crate::input::list_dataset_groups_input::Builder {
        crate::input::list_dataset_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasetGroups {
    type Output = std::result::Result<
        crate::output::ListDatasetGroupsOutput,
        crate::error::ListDatasetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dataset_groups_error(response)
        } else {
            crate::operation_deser::parse_list_dataset_groups_response(response)
        }
    }
}

/// <p>Returns a list of dataset import jobs that use the given dataset. When a dataset is not
/// specified, all the dataset import jobs associated with the account are listed. The response
/// provides the properties for each dataset import job, including the Amazon Resource Name (ARN).
/// For more information on dataset import jobs, see <a>CreateDatasetImportJob</a>. For
/// more information on datasets, see <a>CreateDataset</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasetImportJobs {
    _private: (),
}
impl ListDatasetImportJobs {
    /// Creates a new builder-style object to manufacture [`ListDatasetImportJobsInput`](crate::input::ListDatasetImportJobsInput)
    pub fn builder() -> crate::input::list_dataset_import_jobs_input::Builder {
        crate::input::list_dataset_import_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasetImportJobs {
    type Output = std::result::Result<
        crate::output::ListDatasetImportJobsOutput,
        crate::error::ListDatasetImportJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dataset_import_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_dataset_import_jobs_response(response)
        }
    }
}

/// <p>Returns the list of datasets contained in the given dataset group. The response provides
/// the properties for each dataset, including the Amazon Resource Name (ARN). For more
/// information on datasets, see <a>CreateDataset</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasets {
    _private: (),
}
impl ListDatasets {
    /// Creates a new builder-style object to manufacture [`ListDatasetsInput`](crate::input::ListDatasetsInput)
    pub fn builder() -> crate::input::list_datasets_input::Builder {
        crate::input::list_datasets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasets {
    type Output =
        std::result::Result<crate::output::ListDatasetsOutput, crate::error::ListDatasetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_datasets_error(response)
        } else {
            crate::operation_deser::parse_list_datasets_response(response)
        }
    }
}

/// <p>Returns the list of event trackers associated with the account.
/// The response provides the properties for each event tracker, including the Amazon Resource
/// Name (ARN) and tracking ID. For more
/// information on event trackers, see <a>CreateEventTracker</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEventTrackers {
    _private: (),
}
impl ListEventTrackers {
    /// Creates a new builder-style object to manufacture [`ListEventTrackersInput`](crate::input::ListEventTrackersInput)
    pub fn builder() -> crate::input::list_event_trackers_input::Builder {
        crate::input::list_event_trackers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEventTrackers {
    type Output = std::result::Result<
        crate::output::ListEventTrackersOutput,
        crate::error::ListEventTrackersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_event_trackers_error(response)
        } else {
            crate::operation_deser::parse_list_event_trackers_response(response)
        }
    }
}

/// <p>Lists all filters that belong to a given dataset group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFilters {
    _private: (),
}
impl ListFilters {
    /// Creates a new builder-style object to manufacture [`ListFiltersInput`](crate::input::ListFiltersInput)
    pub fn builder() -> crate::input::list_filters_input::Builder {
        crate::input::list_filters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFilters {
    type Output =
        std::result::Result<crate::output::ListFiltersOutput, crate::error::ListFiltersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_filters_error(response)
        } else {
            crate::operation_deser::parse_list_filters_response(response)
        }
    }
}

/// <p>Returns a list of available recipes. The response provides the properties
/// for each recipe, including the recipe's Amazon Resource Name (ARN).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRecipes {
    _private: (),
}
impl ListRecipes {
    /// Creates a new builder-style object to manufacture [`ListRecipesInput`](crate::input::ListRecipesInput)
    pub fn builder() -> crate::input::list_recipes_input::Builder {
        crate::input::list_recipes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRecipes {
    type Output =
        std::result::Result<crate::output::ListRecipesOutput, crate::error::ListRecipesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_recipes_error(response)
        } else {
            crate::operation_deser::parse_list_recipes_response(response)
        }
    }
}

/// <p>Returns the list of schemas associated with the account. The response provides the
/// properties for each schema, including the Amazon Resource Name (ARN).
/// For more information on schemas, see <a>CreateSchema</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSchemas {
    _private: (),
}
impl ListSchemas {
    /// Creates a new builder-style object to manufacture [`ListSchemasInput`](crate::input::ListSchemasInput)
    pub fn builder() -> crate::input::list_schemas_input::Builder {
        crate::input::list_schemas_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSchemas {
    type Output =
        std::result::Result<crate::output::ListSchemasOutput, crate::error::ListSchemasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_schemas_error(response)
        } else {
            crate::operation_deser::parse_list_schemas_response(response)
        }
    }
}

/// <p>Returns a list of solutions that use the given dataset group.
/// When a dataset group is not specified, all the solutions associated with the account are listed.
/// The response provides the properties for each solution, including the Amazon Resource Name (ARN).
/// For more information on solutions, see <a>CreateSolution</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSolutions {
    _private: (),
}
impl ListSolutions {
    /// Creates a new builder-style object to manufacture [`ListSolutionsInput`](crate::input::ListSolutionsInput)
    pub fn builder() -> crate::input::list_solutions_input::Builder {
        crate::input::list_solutions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSolutions {
    type Output =
        std::result::Result<crate::output::ListSolutionsOutput, crate::error::ListSolutionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_solutions_error(response)
        } else {
            crate::operation_deser::parse_list_solutions_response(response)
        }
    }
}

/// <p>Returns a list of solution versions for the given solution. When a solution is not
/// specified, all the solution versions associated with the account are listed. The response
/// provides the properties for each solution version, including the Amazon Resource Name (ARN).
/// For more information on solutions, see <a>CreateSolution</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSolutionVersions {
    _private: (),
}
impl ListSolutionVersions {
    /// Creates a new builder-style object to manufacture [`ListSolutionVersionsInput`](crate::input::ListSolutionVersionsInput)
    pub fn builder() -> crate::input::list_solution_versions_input::Builder {
        crate::input::list_solution_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSolutionVersions {
    type Output = std::result::Result<
        crate::output::ListSolutionVersionsOutput,
        crate::error::ListSolutionVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_solution_versions_error(response)
        } else {
            crate::operation_deser::parse_list_solution_versions_response(response)
        }
    }
}

/// <p>Stops creating a solution version that is in a state of CREATE_PENDING or CREATE IN_PROGRESS.
/// </p>
/// <p>Depending on the current state of the solution version, the solution version state changes as follows:</p>
/// <ul>
/// <li>
/// <p>CREATE_PENDING > CREATE_STOPPED</p>
/// <p>or</p>
/// </li>
/// <li>
/// <p>CREATE_IN_PROGRESS > CREATE_STOPPING > CREATE_STOPPED</p>
/// </li>
/// </ul>
/// <p>You are billed for all of the training completed up
/// until you stop the solution version creation. You cannot resume creating a solution version once it has been stopped.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopSolutionVersionCreation {
    _private: (),
}
impl StopSolutionVersionCreation {
    /// Creates a new builder-style object to manufacture [`StopSolutionVersionCreationInput`](crate::input::StopSolutionVersionCreationInput)
    pub fn builder() -> crate::input::stop_solution_version_creation_input::Builder {
        crate::input::stop_solution_version_creation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopSolutionVersionCreation {
    type Output = std::result::Result<
        crate::output::StopSolutionVersionCreationOutput,
        crate::error::StopSolutionVersionCreationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_solution_version_creation_error(response)
        } else {
            crate::operation_deser::parse_stop_solution_version_creation_response(response)
        }
    }
}

/// <p>Updates a campaign by either deploying a new solution or changing the value of the
/// campaign's <code>minProvisionedTPS</code> parameter.</p>
/// <p>To update a campaign, the campaign status must be ACTIVE or CREATE FAILED.
/// Check the campaign status using the <a>DescribeCampaign</a> API.</p>
/// <note>
/// <p>You must wait until the <code>status</code> of the
/// updated campaign is <code>ACTIVE</code> before asking the campaign for recommendations.</p>
/// </note>
/// <p>For more information on campaigns, see <a>CreateCampaign</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCampaign {
    _private: (),
}
impl UpdateCampaign {
    /// Creates a new builder-style object to manufacture [`UpdateCampaignInput`](crate::input::UpdateCampaignInput)
    pub fn builder() -> crate::input::update_campaign_input::Builder {
        crate::input::update_campaign_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCampaign {
    type Output =
        std::result::Result<crate::output::UpdateCampaignOutput, crate::error::UpdateCampaignError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_campaign_error(response)
        } else {
            crate::operation_deser::parse_update_campaign_response(response)
        }
    }
}
