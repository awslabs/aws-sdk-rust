// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AddProfileKeyInput`](crate::input::AddProfileKeyInput)
pub mod add_profile_key_input {
    /// A builder for [`AddProfileKeyInput`](crate::input::AddProfileKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of a customer profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input;
            self
        }
        /// <p>A searchable identifier of a customer profile.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AddProfileKeyInput`](crate::input::AddProfileKeyInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::AddProfileKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AddProfileKeyInput {
                profile_id: self.profile_id,
                key_name: self.key_name,
                values: self.values,
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AddProfileKeyInputOperationOutputAlias = crate::operation::AddProfileKey;
#[doc(hidden)]
pub type AddProfileKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddProfileKeyInput {
    /// Consumes the builder and constructs an Operation<[`AddProfileKey`](crate::operation::AddProfileKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AddProfileKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_add_profile_key(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AddProfileKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AddProfileKey",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/keys",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddProfileKeyInput`](crate::input::AddProfileKeyInput)
    pub fn builder() -> crate::input::add_profile_key_input::Builder {
        crate::input::add_profile_key_input::Builder::default()
    }
}

/// See [`CreateDomainInput`](crate::input::CreateDomainInput)
pub mod create_domain_input {
    /// A builder for [`CreateDomainInput`](crate::input::CreateDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) default_expiration_days: std::option::Option<i32>,
        pub(crate) default_encryption_key: std::option::Option<std::string::String>,
        pub(crate) dead_letter_queue_url: std::option::Option<std::string::String>,
        pub(crate) matching: std::option::Option<crate::model::MatchingRequest>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The default number of days until the data within the domain expires.</p>
        pub fn default_expiration_days(mut self, input: i32) -> Self {
            self.default_expiration_days = Some(input);
            self
        }
        pub fn set_default_expiration_days(mut self, input: std::option::Option<i32>) -> Self {
            self.default_expiration_days = input;
            self
        }
        /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
        /// of encryption key is specified. It is used to encrypt all data before it is placed in
        /// permanent or semi-permanent storage.</p>
        pub fn default_encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_encryption_key = Some(input.into());
            self
        }
        pub fn set_default_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_encryption_key = input;
            self
        }
        /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
        /// ingesting data from third party applications. You must set up a policy on the
        /// DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send
        /// messages to the DeadLetterQueue.</p>
        pub fn dead_letter_queue_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.dead_letter_queue_url = Some(input.into());
            self
        }
        pub fn set_dead_letter_queue_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dead_letter_queue_url = input;
            self
        }
        /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
        pub fn matching(mut self, input: crate::model::MatchingRequest) -> Self {
            self.matching = Some(input);
            self
        }
        pub fn set_matching(
            mut self,
            input: std::option::Option<crate::model::MatchingRequest>,
        ) -> Self {
            self.matching = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDomainInput`](crate::input::CreateDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateDomainInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateDomainInput {
                domain_name: self.domain_name,
                default_expiration_days: self.default_expiration_days,
                default_encryption_key: self.default_encryption_key,
                dead_letter_queue_url: self.dead_letter_queue_url,
                matching: self.matching,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDomainInputOperationOutputAlias = crate::operation::CreateDomain;
#[doc(hidden)]
pub type CreateDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDomainInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomain`](crate::operation::CreateDomain)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_domain(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateDomain::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateDomain",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/domains/{DomainName}", DomainName = domain_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput)
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
}

/// See [`CreateProfileInput`](crate::input::CreateProfileInput)
pub mod create_profile_input {
    /// A builder for [`CreateProfileInput`](crate::input::CreateProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) account_number: std::option::Option<std::string::String>,
        pub(crate) additional_information: std::option::Option<std::string::String>,
        pub(crate) party_type: std::option::Option<crate::model::PartyType>,
        pub(crate) business_name: std::option::Option<std::string::String>,
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) middle_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
        pub(crate) birth_date: std::option::Option<std::string::String>,
        pub(crate) gender: std::option::Option<crate::model::Gender>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) mobile_phone_number: std::option::Option<std::string::String>,
        pub(crate) home_phone_number: std::option::Option<std::string::String>,
        pub(crate) business_phone_number: std::option::Option<std::string::String>,
        pub(crate) email_address: std::option::Option<std::string::String>,
        pub(crate) personal_email_address: std::option::Option<std::string::String>,
        pub(crate) business_email_address: std::option::Option<std::string::String>,
        pub(crate) address: std::option::Option<crate::model::Address>,
        pub(crate) shipping_address: std::option::Option<crate::model::Address>,
        pub(crate) mailing_address: std::option::Option<crate::model::Address>,
        pub(crate) billing_address: std::option::Option<crate::model::Address>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>A unique account number that you have given to the customer.</p>
        pub fn account_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_number = Some(input.into());
            self
        }
        pub fn set_account_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.account_number = input;
            self
        }
        /// <p>Any additional information relevant to the customer’s profile.</p>
        pub fn additional_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_information = Some(input.into());
            self
        }
        pub fn set_additional_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_information = input;
            self
        }
        /// <p>The type of profile used to describe the customer.</p>
        pub fn party_type(mut self, input: crate::model::PartyType) -> Self {
            self.party_type = Some(input);
            self
        }
        pub fn set_party_type(
            mut self,
            input: std::option::Option<crate::model::PartyType>,
        ) -> Self {
            self.party_type = input;
            self
        }
        /// <p>The name of the customer’s business.</p>
        pub fn business_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.business_name = Some(input.into());
            self
        }
        pub fn set_business_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.business_name = input;
            self
        }
        /// <p>The customer’s first name.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The customer’s middle name.</p>
        pub fn middle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.middle_name = Some(input.into());
            self
        }
        pub fn set_middle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.middle_name = input;
            self
        }
        /// <p>The customer’s last name.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// <p>The customer’s birth date. </p>
        pub fn birth_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.birth_date = Some(input.into());
            self
        }
        pub fn set_birth_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.birth_date = input;
            self
        }
        /// <p>The gender with which the customer identifies. </p>
        pub fn gender(mut self, input: crate::model::Gender) -> Self {
            self.gender = Some(input);
            self
        }
        pub fn set_gender(mut self, input: std::option::Option<crate::model::Gender>) -> Self {
            self.gender = input;
            self
        }
        /// <p>The customer’s phone number, which has not been specified as a mobile, home, or business
        /// number. </p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The customer’s mobile phone number.</p>
        pub fn mobile_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.mobile_phone_number = Some(input.into());
            self
        }
        pub fn set_mobile_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mobile_phone_number = input;
            self
        }
        /// <p>The customer’s home phone number.</p>
        pub fn home_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_phone_number = Some(input.into());
            self
        }
        pub fn set_home_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.home_phone_number = input;
            self
        }
        /// <p>The customer’s business phone number.</p>
        pub fn business_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.business_phone_number = Some(input.into());
            self
        }
        pub fn set_business_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.business_phone_number = input;
            self
        }
        /// <p>The customer’s email address, which has not been specified as a personal or business
        /// address. </p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.email_address = Some(input.into());
            self
        }
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.email_address = input;
            self
        }
        /// <p>The customer’s personal email address.</p>
        pub fn personal_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.personal_email_address = Some(input.into());
            self
        }
        pub fn set_personal_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.personal_email_address = input;
            self
        }
        /// <p>The customer’s business email address.</p>
        pub fn business_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.business_email_address = Some(input.into());
            self
        }
        pub fn set_business_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.business_email_address = input;
            self
        }
        /// <p>A generic address associated with the customer that is not mailing, shipping, or
        /// billing.</p>
        pub fn address(mut self, input: crate::model::Address) -> Self {
            self.address = Some(input);
            self
        }
        pub fn set_address(mut self, input: std::option::Option<crate::model::Address>) -> Self {
            self.address = input;
            self
        }
        /// <p>The customer’s shipping address.</p>
        pub fn shipping_address(mut self, input: crate::model::Address) -> Self {
            self.shipping_address = Some(input);
            self
        }
        pub fn set_shipping_address(
            mut self,
            input: std::option::Option<crate::model::Address>,
        ) -> Self {
            self.shipping_address = input;
            self
        }
        /// <p>The customer’s mailing address.</p>
        pub fn mailing_address(mut self, input: crate::model::Address) -> Self {
            self.mailing_address = Some(input);
            self
        }
        pub fn set_mailing_address(
            mut self,
            input: std::option::Option<crate::model::Address>,
        ) -> Self {
            self.mailing_address = input;
            self
        }
        /// <p>The customer’s billing address.</p>
        pub fn billing_address(mut self, input: crate::model::Address) -> Self {
            self.billing_address = Some(input);
            self
        }
        pub fn set_billing_address(
            mut self,
            input: std::option::Option<crate::model::Address>,
        ) -> Self {
            self.billing_address = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProfileInput`](crate::input::CreateProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateProfileInput {
                domain_name: self.domain_name,
                account_number: self.account_number,
                additional_information: self.additional_information,
                party_type: self.party_type,
                business_name: self.business_name,
                first_name: self.first_name,
                middle_name: self.middle_name,
                last_name: self.last_name,
                birth_date: self.birth_date,
                gender: self.gender,
                phone_number: self.phone_number,
                mobile_phone_number: self.mobile_phone_number,
                home_phone_number: self.home_phone_number,
                business_phone_number: self.business_phone_number,
                email_address: self.email_address,
                personal_email_address: self.personal_email_address,
                business_email_address: self.business_email_address,
                address: self.address,
                shipping_address: self.shipping_address,
                mailing_address: self.mailing_address,
                billing_address: self.billing_address,
                attributes: self.attributes,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProfileInputOperationOutputAlias = crate::operation::CreateProfile;
#[doc(hidden)]
pub type CreateProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateProfile`](crate::operation::CreateProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_profile(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateProfile",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateProfileInput`](crate::input::CreateProfileInput)
    pub fn builder() -> crate::input::create_profile_input::Builder {
        crate::input::create_profile_input::Builder::default()
    }
}

/// See [`DeleteDomainInput`](crate::input::DeleteDomainInput)
pub mod delete_domain_input {
    /// A builder for [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDomainInput`](crate::input::DeleteDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteDomainInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteDomainInput {
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDomainInputOperationOutputAlias = crate::operation::DeleteDomain;
#[doc(hidden)]
pub type DeleteDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDomainInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDomain`](crate::operation::DeleteDomain)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteDomain::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteDomain",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/domains/{DomainName}", DomainName = domain_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
}

/// See [`DeleteIntegrationInput`](crate::input::DeleteIntegrationInput)
pub mod delete_integration_input {
    /// A builder for [`DeleteIntegrationInput`](crate::input::DeleteIntegrationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The URI of the S3 bucket or any other type of data source.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteIntegrationInput`](crate::input::DeleteIntegrationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteIntegrationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteIntegrationInput {
                domain_name: self.domain_name,
                uri: self.uri,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteIntegrationInputOperationOutputAlias = crate::operation::DeleteIntegration;
#[doc(hidden)]
pub type DeleteIntegrationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteIntegrationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteIntegration`](crate::operation::DeleteIntegration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteIntegration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_integration(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteIntegration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteIntegration",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/integrations/delete",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteIntegrationInput`](crate::input::DeleteIntegrationInput)
    pub fn builder() -> crate::input::delete_integration_input::Builder {
        crate::input::delete_integration_input::Builder::default()
    }
}

/// See [`DeleteProfileInput`](crate::input::DeleteProfileInput)
pub mod delete_profile_input {
    /// A builder for [`DeleteProfileInput`](crate::input::DeleteProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of a customer profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProfileInput`](crate::input::DeleteProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteProfileInput {
                profile_id: self.profile_id,
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProfileInputOperationOutputAlias = crate::operation::DeleteProfile;
#[doc(hidden)]
pub type DeleteProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProfileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProfile`](crate::operation::DeleteProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_profile(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteProfile",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/delete",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProfileInput`](crate::input::DeleteProfileInput)
    pub fn builder() -> crate::input::delete_profile_input::Builder {
        crate::input::delete_profile_input::Builder::default()
    }
}

/// See [`DeleteProfileKeyInput`](crate::input::DeleteProfileKeyInput)
pub mod delete_profile_key_input {
    /// A builder for [`DeleteProfileKeyInput`](crate::input::DeleteProfileKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of a customer profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input;
            self
        }
        /// <p>A searchable identifier of a customer profile.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProfileKeyInput`](crate::input::DeleteProfileKeyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProfileKeyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProfileKeyInput {
                profile_id: self.profile_id,
                key_name: self.key_name,
                values: self.values,
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProfileKeyInputOperationOutputAlias = crate::operation::DeleteProfileKey;
#[doc(hidden)]
pub type DeleteProfileKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProfileKeyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProfileKey`](crate::operation::DeleteProfileKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProfileKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_profile_key(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteProfileKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteProfileKey",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/keys/delete",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProfileKeyInput`](crate::input::DeleteProfileKeyInput)
    pub fn builder() -> crate::input::delete_profile_key_input::Builder {
        crate::input::delete_profile_key_input::Builder::default()
    }
}

/// See [`DeleteProfileObjectInput`](crate::input::DeleteProfileObjectInput)
pub mod delete_profile_object_input {
    /// A builder for [`DeleteProfileObjectInput`](crate::input::DeleteProfileObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
        pub(crate) profile_object_unique_key: std::option::Option<std::string::String>,
        pub(crate) object_type_name: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of a customer profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input;
            self
        }
        /// <p>The unique identifier of the profile object generated by the service.</p>
        pub fn profile_object_unique_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_object_unique_key = Some(input.into());
            self
        }
        pub fn set_profile_object_unique_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.profile_object_unique_key = input;
            self
        }
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProfileObjectInput`](crate::input::DeleteProfileObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProfileObjectInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProfileObjectInput {
                profile_id: self.profile_id,
                profile_object_unique_key: self.profile_object_unique_key,
                object_type_name: self.object_type_name,
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProfileObjectInputOperationOutputAlias = crate::operation::DeleteProfileObject;
#[doc(hidden)]
pub type DeleteProfileObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProfileObjectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProfileObject`](crate::operation::DeleteProfileObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProfileObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_profile_object(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteProfileObject::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteProfileObject",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/objects/delete",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProfileObjectInput`](crate::input::DeleteProfileObjectInput)
    pub fn builder() -> crate::input::delete_profile_object_input::Builder {
        crate::input::delete_profile_object_input::Builder::default()
    }
}

/// See [`DeleteProfileObjectTypeInput`](crate::input::DeleteProfileObjectTypeInput)
pub mod delete_profile_object_type_input {
    /// A builder for [`DeleteProfileObjectTypeInput`](crate::input::DeleteProfileObjectTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) object_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProfileObjectTypeInput`](crate::input::DeleteProfileObjectTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProfileObjectTypeInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProfileObjectTypeInput {
                domain_name: self.domain_name,
                object_type_name: self.object_type_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProfileObjectTypeInputOperationOutputAlias =
    crate::operation::DeleteProfileObjectType;
#[doc(hidden)]
pub type DeleteProfileObjectTypeInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteProfileObjectTypeInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProfileObjectType`](crate::operation::DeleteProfileObjectType)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteProfileObjectType,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteProfileObjectType::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteProfileObjectType",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let object_type_name = {
            let input = &self.object_type_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "object_type_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "object_type_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/object-types/{ObjectTypeName}",
            DomainName = domain_name,
            ObjectTypeName = object_type_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteProfileObjectTypeInput`](crate::input::DeleteProfileObjectTypeInput)
    pub fn builder() -> crate::input::delete_profile_object_type_input::Builder {
        crate::input::delete_profile_object_type_input::Builder::default()
    }
}

/// See [`GetDomainInput`](crate::input::GetDomainInput)
pub mod get_domain_input {
    /// A builder for [`GetDomainInput`](crate::input::GetDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDomainInput`](crate::input::GetDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetDomainInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetDomainInput {
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDomainInputOperationOutputAlias = crate::operation::GetDomain;
#[doc(hidden)]
pub type GetDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDomainInput {
    /// Consumes the builder and constructs an Operation<[`GetDomain`](crate::operation::GetDomain)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetDomain::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "GetDomain",
                        "customerprofiles",
                    ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/domains/{DomainName}", DomainName = domain_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDomainInput`](crate::input::GetDomainInput)
    pub fn builder() -> crate::input::get_domain_input::Builder {
        crate::input::get_domain_input::Builder::default()
    }
}

/// See [`GetIntegrationInput`](crate::input::GetIntegrationInput)
pub mod get_integration_input {
    /// A builder for [`GetIntegrationInput`](crate::input::GetIntegrationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The URI of the S3 bucket or any other type of data source.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// Consumes the builder and constructs a [`GetIntegrationInput`](crate::input::GetIntegrationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetIntegrationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetIntegrationInput {
                domain_name: self.domain_name,
                uri: self.uri,
            })
        }
    }
}
#[doc(hidden)]
pub type GetIntegrationInputOperationOutputAlias = crate::operation::GetIntegration;
#[doc(hidden)]
pub type GetIntegrationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetIntegrationInput {
    /// Consumes the builder and constructs an Operation<[`GetIntegration`](crate::operation::GetIntegration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetIntegration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_integration(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetIntegration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetIntegration",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/integrations",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetIntegrationInput`](crate::input::GetIntegrationInput)
    pub fn builder() -> crate::input::get_integration_input::Builder {
        crate::input::get_integration_input::Builder::default()
    }
}

/// See [`GetMatchesInput`](crate::input::GetMatchesInput)
pub mod get_matches_input {
    /// A builder for [`GetMatchesInput`](crate::input::GetMatchesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMatchesInput`](crate::input::GetMatchesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetMatchesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetMatchesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMatchesInputOperationOutputAlias = crate::operation::GetMatches;
#[doc(hidden)]
pub type GetMatchesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMatchesInput {
    /// Consumes the builder and constructs an Operation<[`GetMatches`](crate::operation::GetMatches)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetMatches,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetMatches::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetMatches",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/matches",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_1) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_1));
        }
        if let Some(inner_2) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_2));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMatchesInput`](crate::input::GetMatchesInput)
    pub fn builder() -> crate::input::get_matches_input::Builder {
        crate::input::get_matches_input::Builder::default()
    }
}

/// See [`GetProfileObjectTypeInput`](crate::input::GetProfileObjectTypeInput)
pub mod get_profile_object_type_input {
    /// A builder for [`GetProfileObjectTypeInput`](crate::input::GetProfileObjectTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) object_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetProfileObjectTypeInput`](crate::input::GetProfileObjectTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetProfileObjectTypeInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetProfileObjectTypeInput {
                domain_name: self.domain_name,
                object_type_name: self.object_type_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetProfileObjectTypeInputOperationOutputAlias = crate::operation::GetProfileObjectType;
#[doc(hidden)]
pub type GetProfileObjectTypeInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetProfileObjectTypeInput {
    /// Consumes the builder and constructs an Operation<[`GetProfileObjectType`](crate::operation::GetProfileObjectType)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetProfileObjectType,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetProfileObjectType::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetProfileObjectType",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let object_type_name = {
            let input = &self.object_type_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "object_type_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "object_type_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/object-types/{ObjectTypeName}",
            DomainName = domain_name,
            ObjectTypeName = object_type_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetProfileObjectTypeInput`](crate::input::GetProfileObjectTypeInput)
    pub fn builder() -> crate::input::get_profile_object_type_input::Builder {
        crate::input::get_profile_object_type_input::Builder::default()
    }
}

/// See [`GetProfileObjectTypeTemplateInput`](crate::input::GetProfileObjectTypeTemplateInput)
pub mod get_profile_object_type_template_input {
    /// A builder for [`GetProfileObjectTypeTemplateInput`](crate::input::GetProfileObjectTypeTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the object template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetProfileObjectTypeTemplateInput`](crate::input::GetProfileObjectTypeTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetProfileObjectTypeTemplateInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetProfileObjectTypeTemplateInput {
                template_id: self.template_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetProfileObjectTypeTemplateInputOperationOutputAlias =
    crate::operation::GetProfileObjectTypeTemplate;
#[doc(hidden)]
pub type GetProfileObjectTypeTemplateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetProfileObjectTypeTemplateInput {
    /// Consumes the builder and constructs an Operation<[`GetProfileObjectTypeTemplate`](crate::operation::GetProfileObjectTypeTemplate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetProfileObjectTypeTemplate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetProfileObjectTypeTemplate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetProfileObjectTypeTemplate",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let template_id = {
            let input = &self.template_id;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "template_id",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "template_id",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/templates/{TemplateId}", TemplateId = template_id)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetProfileObjectTypeTemplateInput`](crate::input::GetProfileObjectTypeTemplateInput)
    pub fn builder() -> crate::input::get_profile_object_type_template_input::Builder {
        crate::input::get_profile_object_type_template_input::Builder::default()
    }
}

/// See [`ListAccountIntegrationsInput`](crate::input::ListAccountIntegrationsInput)
pub mod list_account_integrations_input {
    /// A builder for [`ListAccountIntegrationsInput`](crate::input::ListAccountIntegrationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The URI of the S3 bucket or any other type of data source.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The pagination token from the previous ListAccountIntegrations API call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAccountIntegrationsInput`](crate::input::ListAccountIntegrationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAccountIntegrationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAccountIntegrationsInput {
                uri: self.uri,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAccountIntegrationsInputOperationOutputAlias =
    crate::operation::ListAccountIntegrations;
#[doc(hidden)]
pub type ListAccountIntegrationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAccountIntegrationsInput {
    /// Consumes the builder and constructs an Operation<[`ListAccountIntegrations`](crate::operation::ListAccountIntegrations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListAccountIntegrations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_account_integrations(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAccountIntegrations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAccountIntegrations",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/integrations").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_3) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_3));
        }
        if let Some(inner_4) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_4));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAccountIntegrationsInput`](crate::input::ListAccountIntegrationsInput)
    pub fn builder() -> crate::input::list_account_integrations_input::Builder {
        crate::input::list_account_integrations_input::Builder::default()
    }
}

/// See [`ListDomainsInput`](crate::input::ListDomainsInput)
pub mod list_domains_input {
    /// A builder for [`ListDomainsInput`](crate::input::ListDomainsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The pagination token from the previous ListDomain API call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDomainsInput`](crate::input::ListDomainsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListDomainsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListDomainsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListDomainsInputOperationOutputAlias = crate::operation::ListDomains;
#[doc(hidden)]
pub type ListDomainsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListDomainsInput {
    /// Consumes the builder and constructs an Operation<[`ListDomains`](crate::operation::ListDomains)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListDomains,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListDomains::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListDomains",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/domains").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_5) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_5));
        }
        if let Some(inner_6) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_6));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput)
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
}

/// See [`ListIntegrationsInput`](crate::input::ListIntegrationsInput)
pub mod list_integrations_input {
    /// A builder for [`ListIntegrationsInput`](crate::input::ListIntegrationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The pagination token from the previous ListIntegrations API call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIntegrationsInput`](crate::input::ListIntegrationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListIntegrationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListIntegrationsInput {
                domain_name: self.domain_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListIntegrationsInputOperationOutputAlias = crate::operation::ListIntegrations;
#[doc(hidden)]
pub type ListIntegrationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListIntegrationsInput {
    /// Consumes the builder and constructs an Operation<[`ListIntegrations`](crate::operation::ListIntegrations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListIntegrations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListIntegrations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListIntegrations",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/integrations",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_7) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_7));
        }
        if let Some(inner_8) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_8));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListIntegrationsInput`](crate::input::ListIntegrationsInput)
    pub fn builder() -> crate::input::list_integrations_input::Builder {
        crate::input::list_integrations_input::Builder::default()
    }
}

/// See [`ListProfileObjectsInput`](crate::input::ListProfileObjectsInput)
pub mod list_profile_objects_input {
    /// A builder for [`ListProfileObjectsInput`](crate::input::ListProfileObjectsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) object_type_name: std::option::Option<std::string::String>,
        pub(crate) profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The pagination token from the previous call to ListProfileObjects.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        /// <p>The unique identifier of a customer profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProfileObjectsInput`](crate::input::ListProfileObjectsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProfileObjectsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProfileObjectsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                domain_name: self.domain_name,
                object_type_name: self.object_type_name,
                profile_id: self.profile_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProfileObjectsInputOperationOutputAlias = crate::operation::ListProfileObjects;
#[doc(hidden)]
pub type ListProfileObjectsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListProfileObjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListProfileObjects`](crate::operation::ListProfileObjects)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListProfileObjects,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_profile_objects(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListProfileObjects::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListProfileObjects",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/objects",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_9) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_9));
        }
        if let Some(inner_10) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_10));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListProfileObjectsInput`](crate::input::ListProfileObjectsInput)
    pub fn builder() -> crate::input::list_profile_objects_input::Builder {
        crate::input::list_profile_objects_input::Builder::default()
    }
}

/// See [`ListProfileObjectTypesInput`](crate::input::ListProfileObjectTypesInput)
pub mod list_profile_object_types_input {
    /// A builder for [`ListProfileObjectTypesInput`](crate::input::ListProfileObjectTypesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProfileObjectTypesInput`](crate::input::ListProfileObjectTypesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProfileObjectTypesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProfileObjectTypesInput {
                domain_name: self.domain_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProfileObjectTypesInputOperationOutputAlias = crate::operation::ListProfileObjectTypes;
#[doc(hidden)]
pub type ListProfileObjectTypesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListProfileObjectTypesInput {
    /// Consumes the builder and constructs an Operation<[`ListProfileObjectTypes`](crate::operation::ListProfileObjectTypes)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListProfileObjectTypes,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListProfileObjectTypes::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListProfileObjectTypes",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/object-types",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_11) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_11));
        }
        if let Some(inner_12) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_12));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListProfileObjectTypesInput`](crate::input::ListProfileObjectTypesInput)
    pub fn builder() -> crate::input::list_profile_object_types_input::Builder {
        crate::input::list_profile_object_types_input::Builder::default()
    }
}

/// See [`ListProfileObjectTypeTemplatesInput`](crate::input::ListProfileObjectTypeTemplatesInput)
pub mod list_profile_object_type_templates_input {
    /// A builder for [`ListProfileObjectTypeTemplatesInput`](crate::input::ListProfileObjectTypeTemplatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The pagination token from the previous ListObjectTypeTemplates API call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProfileObjectTypeTemplatesInput`](crate::input::ListProfileObjectTypeTemplatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProfileObjectTypeTemplatesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProfileObjectTypeTemplatesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProfileObjectTypeTemplatesInputOperationOutputAlias =
    crate::operation::ListProfileObjectTypeTemplates;
#[doc(hidden)]
pub type ListProfileObjectTypeTemplatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListProfileObjectTypeTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListProfileObjectTypeTemplates`](crate::operation::ListProfileObjectTypeTemplates)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListProfileObjectTypeTemplates,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListProfileObjectTypeTemplates::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListProfileObjectTypeTemplates",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/templates").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_13) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_13));
        }
        if let Some(inner_14) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_14));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListProfileObjectTypeTemplatesInput`](crate::input::ListProfileObjectTypeTemplatesInput)
    pub fn builder() -> crate::input::list_profile_object_type_templates_input::Builder {
        crate::input::list_profile_object_type_templates_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource for which you want to view tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListTagsForResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListTagsForResource",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let resource_arn = {
            let input = &self.resource_arn;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`MergeProfilesInput`](crate::input::MergeProfilesInput)
pub mod merge_profiles_input {
    /// A builder for [`MergeProfilesInput`](crate::input::MergeProfilesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) main_profile_id: std::option::Option<std::string::String>,
        pub(crate) profile_ids_to_be_merged:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) field_source_profile_ids:
            std::option::Option<crate::model::FieldSourceProfileIds>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The identifier of the profile to be taken.</p>
        pub fn main_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.main_profile_id = Some(input.into());
            self
        }
        pub fn set_main_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.main_profile_id = input;
            self
        }
        pub fn profile_ids_to_be_merged(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.profile_ids_to_be_merged.unwrap_or_default();
            v.push(input.into());
            self.profile_ids_to_be_merged = Some(v);
            self
        }
        pub fn set_profile_ids_to_be_merged(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.profile_ids_to_be_merged = input;
            self
        }
        /// <p>The identifiers of the fields in the profile that has the information you want to apply to the
        /// merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the
        /// identifier of the EmailAddress field in Profile1. </p>
        pub fn field_source_profile_ids(
            mut self,
            input: crate::model::FieldSourceProfileIds,
        ) -> Self {
            self.field_source_profile_ids = Some(input);
            self
        }
        pub fn set_field_source_profile_ids(
            mut self,
            input: std::option::Option<crate::model::FieldSourceProfileIds>,
        ) -> Self {
            self.field_source_profile_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`MergeProfilesInput`](crate::input::MergeProfilesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::MergeProfilesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::MergeProfilesInput {
                domain_name: self.domain_name,
                main_profile_id: self.main_profile_id,
                profile_ids_to_be_merged: self.profile_ids_to_be_merged,
                field_source_profile_ids: self.field_source_profile_ids,
            })
        }
    }
}
#[doc(hidden)]
pub type MergeProfilesInputOperationOutputAlias = crate::operation::MergeProfiles;
#[doc(hidden)]
pub type MergeProfilesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl MergeProfilesInput {
    /// Consumes the builder and constructs an Operation<[`MergeProfiles`](crate::operation::MergeProfiles)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::MergeProfiles,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_merge_profiles(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::MergeProfiles::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "MergeProfiles",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/objects/merge",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`MergeProfilesInput`](crate::input::MergeProfilesInput)
    pub fn builder() -> crate::input::merge_profiles_input::Builder {
        crate::input::merge_profiles_input::Builder::default()
    }
}

/// See [`PutIntegrationInput`](crate::input::PutIntegrationInput)
pub mod put_integration_input {
    /// A builder for [`PutIntegrationInput`](crate::input::PutIntegrationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) object_type_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) flow_definition: std::option::Option<crate::model::FlowDefinition>,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The URI of the S3 bucket or any other type of data source.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The configuration that controls how Customer Profiles retrieves data from the
        /// source.</p>
        pub fn flow_definition(mut self, input: crate::model::FlowDefinition) -> Self {
            self.flow_definition = Some(input);
            self
        }
        pub fn set_flow_definition(
            mut self,
            input: std::option::Option<crate::model::FlowDefinition>,
        ) -> Self {
            self.flow_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`PutIntegrationInput`](crate::input::PutIntegrationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutIntegrationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutIntegrationInput {
                domain_name: self.domain_name,
                uri: self.uri,
                object_type_name: self.object_type_name,
                tags: self.tags,
                flow_definition: self.flow_definition,
            })
        }
    }
}
#[doc(hidden)]
pub type PutIntegrationInputOperationOutputAlias = crate::operation::PutIntegration;
#[doc(hidden)]
pub type PutIntegrationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutIntegrationInput {
    /// Consumes the builder and constructs an Operation<[`PutIntegration`](crate::operation::PutIntegration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutIntegration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_integration(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutIntegration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutIntegration",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/integrations",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutIntegrationInput`](crate::input::PutIntegrationInput)
    pub fn builder() -> crate::input::put_integration_input::Builder {
        crate::input::put_integration_input::Builder::default()
    }
}

/// See [`PutProfileObjectInput`](crate::input::PutProfileObjectInput)
pub mod put_profile_object_input {
    /// A builder for [`PutProfileObjectInput`](crate::input::PutProfileObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) object_type_name: std::option::Option<std::string::String>,
        pub(crate) object: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        /// <p>A string that is serialized from a JSON object.</p>
        pub fn object(mut self, input: impl Into<std::string::String>) -> Self {
            self.object = Some(input.into());
            self
        }
        pub fn set_object(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PutProfileObjectInput`](crate::input::PutProfileObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutProfileObjectInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutProfileObjectInput {
                object_type_name: self.object_type_name,
                object: self.object,
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type PutProfileObjectInputOperationOutputAlias = crate::operation::PutProfileObject;
#[doc(hidden)]
pub type PutProfileObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutProfileObjectInput {
    /// Consumes the builder and constructs an Operation<[`PutProfileObject`](crate::operation::PutProfileObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutProfileObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_profile_object(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutProfileObject::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutProfileObject",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/objects",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutProfileObjectInput`](crate::input::PutProfileObjectInput)
    pub fn builder() -> crate::input::put_profile_object_input::Builder {
        crate::input::put_profile_object_input::Builder::default()
    }
}

/// See [`PutProfileObjectTypeInput`](crate::input::PutProfileObjectTypeInput)
pub mod put_profile_object_type_input {
    /// A builder for [`PutProfileObjectTypeInput`](crate::input::PutProfileObjectTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) object_type_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) expiration_days: std::option::Option<i32>,
        pub(crate) encryption_key: std::option::Option<std::string::String>,
        pub(crate) allow_profile_creation: std::option::Option<bool>,
        pub(crate) fields: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ObjectTypeField>,
        >,
        pub(crate) keys: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::vec::Vec<crate::model::ObjectTypeKey>,
            >,
        >,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The name of the profile object type.</p>
        pub fn object_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_type_name = Some(input.into());
            self
        }
        pub fn set_object_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_type_name = input;
            self
        }
        /// <p>Description of the profile object type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A unique identifier for the object template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>The number of days until the data in the object expires.</p>
        pub fn expiration_days(mut self, input: i32) -> Self {
            self.expiration_days = Some(input);
            self
        }
        pub fn set_expiration_days(mut self, input: std::option::Option<i32>) -> Self {
            self.expiration_days = input;
            self
        }
        /// <p>The customer-provided key to encrypt the profile object that will be created in this
        /// profile object type.</p>
        pub fn encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key = Some(input.into());
            self
        }
        pub fn set_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key = input;
            self
        }
        /// <p>Indicates whether a profile should be created when data is received if one doesn’t exist
        /// for an object of this type. The default is <code>FALSE</code>. If the AllowProfileCreation
        /// flag is set to <code>FALSE</code>, then the service tries to fetch a standard profile and
        /// associate this object with the profile. If it is set to <code>TRUE</code>, and if no match
        /// is found, then the service creates a new standard profile.</p>
        pub fn allow_profile_creation(mut self, input: bool) -> Self {
            self.allow_profile_creation = Some(input);
            self
        }
        pub fn set_allow_profile_creation(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_profile_creation = input;
            self
        }
        pub fn fields(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::ObjectTypeField>,
        ) -> Self {
            let mut hash_map = self.fields.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.fields = Some(hash_map);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ObjectTypeField>,
            >,
        ) -> Self {
            self.fields = input;
            self
        }
        pub fn keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<crate::model::ObjectTypeKey>>,
        ) -> Self {
            let mut hash_map = self.keys.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.keys = Some(hash_map);
            self
        }
        pub fn set_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::vec::Vec<crate::model::ObjectTypeKey>,
                >,
            >,
        ) -> Self {
            self.keys = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PutProfileObjectTypeInput`](crate::input::PutProfileObjectTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutProfileObjectTypeInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutProfileObjectTypeInput {
                domain_name: self.domain_name,
                object_type_name: self.object_type_name,
                description: self.description,
                template_id: self.template_id,
                expiration_days: self.expiration_days,
                encryption_key: self.encryption_key,
                allow_profile_creation: self.allow_profile_creation.unwrap_or_default(),
                fields: self.fields,
                keys: self.keys,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type PutProfileObjectTypeInputOperationOutputAlias = crate::operation::PutProfileObjectType;
#[doc(hidden)]
pub type PutProfileObjectTypeInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutProfileObjectTypeInput {
    /// Consumes the builder and constructs an Operation<[`PutProfileObjectType`](crate::operation::PutProfileObjectType)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutProfileObjectType,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_profile_object_type(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutProfileObjectType::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutProfileObjectType",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let object_type_name = {
            let input = &self.object_type_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "object_type_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "object_type_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/object-types/{ObjectTypeName}",
            DomainName = domain_name,
            ObjectTypeName = object_type_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutProfileObjectTypeInput`](crate::input::PutProfileObjectTypeInput)
    pub fn builder() -> crate::input::put_profile_object_type_input::Builder {
        crate::input::put_profile_object_type_input::Builder::default()
    }
}

/// See [`SearchProfilesInput`](crate::input::SearchProfilesInput)
pub mod search_profiles_input {
    /// A builder for [`SearchProfilesInput`](crate::input::SearchProfilesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The pagination token from the previous SearchProfiles API call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects returned per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId,
        /// _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId,
        /// _salesforceContactId, _zendeskUserId, _zendeskExternalId, _serviceNowSystemId.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchProfilesInput`](crate::input::SearchProfilesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SearchProfilesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SearchProfilesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                domain_name: self.domain_name,
                key_name: self.key_name,
                values: self.values,
            })
        }
    }
}
#[doc(hidden)]
pub type SearchProfilesInputOperationOutputAlias = crate::operation::SearchProfiles;
#[doc(hidden)]
pub type SearchProfilesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SearchProfilesInput {
    /// Consumes the builder and constructs an Operation<[`SearchProfiles`](crate::operation::SearchProfiles)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::SearchProfiles,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_search_profiles(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::SearchProfiles::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "SearchProfiles",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles/search",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_15) = &self.next_token {
            query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_15));
        }
        if let Some(inner_16) = &self.max_results {
            query.push_kv("max-results", &smithy_http::query::fmt_default(&inner_16));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SearchProfilesInput`](crate::input::SearchProfilesInput)
    pub fn builder() -> crate::input::search_profiles_input::Builder {
        crate::input::search_profiles_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the resource that you're adding tags to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_resource(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagResource",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let resource_arn = {
            let input = &self.resource_arn;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the resource from which you are removing tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagResource",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let resource_arn = {
            let input = &self.resource_arn;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_17) = &self.tag_keys {
            for inner_18 in inner_17 {
                query.push_kv("tagKeys", &smithy_http::query::fmt_string(&inner_18));
            }
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateDomainInput`](crate::input::UpdateDomainInput)
pub mod update_domain_input {
    /// A builder for [`UpdateDomainInput`](crate::input::UpdateDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) default_expiration_days: std::option::Option<i32>,
        pub(crate) default_encryption_key: std::option::Option<std::string::String>,
        pub(crate) dead_letter_queue_url: std::option::Option<std::string::String>,
        pub(crate) matching: std::option::Option<crate::model::MatchingRequest>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The default number of days until the data within the domain expires.</p>
        pub fn default_expiration_days(mut self, input: i32) -> Self {
            self.default_expiration_days = Some(input);
            self
        }
        pub fn set_default_expiration_days(mut self, input: std::option::Option<i32>) -> Self {
            self.default_expiration_days = input;
            self
        }
        /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
        /// of encryption key is specified. It is used to encrypt all data before it is placed in
        /// permanent or semi-permanent storage. If specified as an empty string, it will clear any
        /// existing value.</p>
        pub fn default_encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_encryption_key = Some(input.into());
            self
        }
        pub fn set_default_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_encryption_key = input;
            self
        }
        /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
        /// ingesting data from third party applications. If specified as an empty string, it will
        /// clear any existing value. You must set up a policy on the DeadLetterQueue for the
        /// SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the
        /// DeadLetterQueue.</p>
        pub fn dead_letter_queue_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.dead_letter_queue_url = Some(input.into());
            self
        }
        pub fn set_dead_letter_queue_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dead_letter_queue_url = input;
            self
        }
        /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
        pub fn matching(mut self, input: crate::model::MatchingRequest) -> Self {
            self.matching = Some(input);
            self
        }
        pub fn set_matching(
            mut self,
            input: std::option::Option<crate::model::MatchingRequest>,
        ) -> Self {
            self.matching = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDomainInput`](crate::input::UpdateDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateDomainInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateDomainInput {
                domain_name: self.domain_name,
                default_expiration_days: self.default_expiration_days,
                default_encryption_key: self.default_encryption_key,
                dead_letter_queue_url: self.dead_letter_queue_url,
                matching: self.matching,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDomainInputOperationOutputAlias = crate::operation::UpdateDomain;
#[doc(hidden)]
pub type UpdateDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateDomainInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDomain`](crate::operation::UpdateDomain)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_domain(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateDomain::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateDomain",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/domains/{DomainName}", DomainName = domain_name)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateDomainInput`](crate::input::UpdateDomainInput)
    pub fn builder() -> crate::input::update_domain_input::Builder {
        crate::input::update_domain_input::Builder::default()
    }
}

/// See [`UpdateProfileInput`](crate::input::UpdateProfileInput)
pub mod update_profile_input {
    /// A builder for [`UpdateProfileInput`](crate::input::UpdateProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) profile_id: std::option::Option<std::string::String>,
        pub(crate) additional_information: std::option::Option<std::string::String>,
        pub(crate) account_number: std::option::Option<std::string::String>,
        pub(crate) party_type: std::option::Option<crate::model::PartyType>,
        pub(crate) business_name: std::option::Option<std::string::String>,
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) middle_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
        pub(crate) birth_date: std::option::Option<std::string::String>,
        pub(crate) gender: std::option::Option<crate::model::Gender>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) mobile_phone_number: std::option::Option<std::string::String>,
        pub(crate) home_phone_number: std::option::Option<std::string::String>,
        pub(crate) business_phone_number: std::option::Option<std::string::String>,
        pub(crate) email_address: std::option::Option<std::string::String>,
        pub(crate) personal_email_address: std::option::Option<std::string::String>,
        pub(crate) business_email_address: std::option::Option<std::string::String>,
        pub(crate) address: std::option::Option<crate::model::UpdateAddress>,
        pub(crate) shipping_address: std::option::Option<crate::model::UpdateAddress>,
        pub(crate) mailing_address: std::option::Option<crate::model::UpdateAddress>,
        pub(crate) billing_address: std::option::Option<crate::model::UpdateAddress>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The unique identifier of a customer profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input;
            self
        }
        /// <p>Any additional information relevant to the customer’s profile.</p>
        pub fn additional_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_information = Some(input.into());
            self
        }
        pub fn set_additional_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_information = input;
            self
        }
        /// <p>A unique account number that you have given to the customer.</p>
        pub fn account_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_number = Some(input.into());
            self
        }
        pub fn set_account_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.account_number = input;
            self
        }
        /// <p>The type of profile used to describe the customer.</p>
        pub fn party_type(mut self, input: crate::model::PartyType) -> Self {
            self.party_type = Some(input);
            self
        }
        pub fn set_party_type(
            mut self,
            input: std::option::Option<crate::model::PartyType>,
        ) -> Self {
            self.party_type = input;
            self
        }
        /// <p>The name of the customer’s business.</p>
        pub fn business_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.business_name = Some(input.into());
            self
        }
        pub fn set_business_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.business_name = input;
            self
        }
        /// <p>The customer’s first name.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The customer’s middle name.</p>
        pub fn middle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.middle_name = Some(input.into());
            self
        }
        pub fn set_middle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.middle_name = input;
            self
        }
        /// <p>The customer’s last name.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// <p>The customer’s birth date. </p>
        pub fn birth_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.birth_date = Some(input.into());
            self
        }
        pub fn set_birth_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.birth_date = input;
            self
        }
        /// <p>The gender with which the customer identifies. </p>
        pub fn gender(mut self, input: crate::model::Gender) -> Self {
            self.gender = Some(input);
            self
        }
        pub fn set_gender(mut self, input: std::option::Option<crate::model::Gender>) -> Self {
            self.gender = input;
            self
        }
        /// <p>The customer’s phone number, which has not been specified as a mobile, home, or business
        /// number. </p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The customer’s mobile phone number.</p>
        pub fn mobile_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.mobile_phone_number = Some(input.into());
            self
        }
        pub fn set_mobile_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mobile_phone_number = input;
            self
        }
        /// <p>The customer’s home phone number.</p>
        pub fn home_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_phone_number = Some(input.into());
            self
        }
        pub fn set_home_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.home_phone_number = input;
            self
        }
        /// <p>The customer’s business phone number.</p>
        pub fn business_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.business_phone_number = Some(input.into());
            self
        }
        pub fn set_business_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.business_phone_number = input;
            self
        }
        /// <p>The customer’s email address, which has not been specified as a personal or business
        /// address. </p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.email_address = Some(input.into());
            self
        }
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.email_address = input;
            self
        }
        /// <p>The customer’s personal email address.</p>
        pub fn personal_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.personal_email_address = Some(input.into());
            self
        }
        pub fn set_personal_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.personal_email_address = input;
            self
        }
        /// <p>The customer’s business email address.</p>
        pub fn business_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.business_email_address = Some(input.into());
            self
        }
        pub fn set_business_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.business_email_address = input;
            self
        }
        /// <p>A generic address associated with the customer that is not mailing, shipping, or
        /// billing.</p>
        pub fn address(mut self, input: crate::model::UpdateAddress) -> Self {
            self.address = Some(input);
            self
        }
        pub fn set_address(
            mut self,
            input: std::option::Option<crate::model::UpdateAddress>,
        ) -> Self {
            self.address = input;
            self
        }
        /// <p>The customer’s shipping address.</p>
        pub fn shipping_address(mut self, input: crate::model::UpdateAddress) -> Self {
            self.shipping_address = Some(input);
            self
        }
        pub fn set_shipping_address(
            mut self,
            input: std::option::Option<crate::model::UpdateAddress>,
        ) -> Self {
            self.shipping_address = input;
            self
        }
        /// <p>The customer’s mailing address.</p>
        pub fn mailing_address(mut self, input: crate::model::UpdateAddress) -> Self {
            self.mailing_address = Some(input);
            self
        }
        pub fn set_mailing_address(
            mut self,
            input: std::option::Option<crate::model::UpdateAddress>,
        ) -> Self {
            self.mailing_address = input;
            self
        }
        /// <p>The customer’s billing address.</p>
        pub fn billing_address(mut self, input: crate::model::UpdateAddress) -> Self {
            self.billing_address = Some(input);
            self
        }
        pub fn set_billing_address(
            mut self,
            input: std::option::Option<crate::model::UpdateAddress>,
        ) -> Self {
            self.billing_address = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateProfileInput`](crate::input::UpdateProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateProfileInput {
                domain_name: self.domain_name,
                profile_id: self.profile_id,
                additional_information: self.additional_information,
                account_number: self.account_number,
                party_type: self.party_type,
                business_name: self.business_name,
                first_name: self.first_name,
                middle_name: self.middle_name,
                last_name: self.last_name,
                birth_date: self.birth_date,
                gender: self.gender,
                phone_number: self.phone_number,
                mobile_phone_number: self.mobile_phone_number,
                home_phone_number: self.home_phone_number,
                business_phone_number: self.business_phone_number,
                email_address: self.email_address,
                personal_email_address: self.personal_email_address,
                business_email_address: self.business_email_address,
                address: self.address,
                shipping_address: self.shipping_address,
                mailing_address: self.mailing_address,
                billing_address: self.billing_address,
                attributes: self.attributes,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateProfileInputOperationOutputAlias = crate::operation::UpdateProfile;
#[doc(hidden)]
pub type UpdateProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateProfileInput {
    /// Consumes the builder and constructs an Operation<[`UpdateProfile`](crate::operation::UpdateProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_profile(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateProfile",
                "customerprofiles",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let domain_name = {
            let input = &self.domain_name;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "domain_name",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(
            output,
            "/domains/{DomainName}/profiles",
            DomainName = domain_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateProfileInput`](crate::input::UpdateProfileInput)
    pub fn builder() -> crate::input::update_profile_input::Builder {
        crate::input::update_profile_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateProfileInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a customer profile.</p>
    pub profile_id: std::option::Option<std::string::String>,
    /// <p>Any additional information relevant to the customer’s profile.</p>
    pub additional_information: std::option::Option<std::string::String>,
    /// <p>A unique account number that you have given to the customer.</p>
    pub account_number: std::option::Option<std::string::String>,
    /// <p>The type of profile used to describe the customer.</p>
    pub party_type: std::option::Option<crate::model::PartyType>,
    /// <p>The name of the customer’s business.</p>
    pub business_name: std::option::Option<std::string::String>,
    /// <p>The customer’s first name.</p>
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The customer’s middle name.</p>
    pub middle_name: std::option::Option<std::string::String>,
    /// <p>The customer’s last name.</p>
    pub last_name: std::option::Option<std::string::String>,
    /// <p>The customer’s birth date. </p>
    pub birth_date: std::option::Option<std::string::String>,
    /// <p>The gender with which the customer identifies. </p>
    pub gender: std::option::Option<crate::model::Gender>,
    /// <p>The customer’s phone number, which has not been specified as a mobile, home, or business
    /// number. </p>
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s mobile phone number.</p>
    pub mobile_phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s home phone number.</p>
    pub home_phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s business phone number.</p>
    pub business_phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s email address, which has not been specified as a personal or business
    /// address. </p>
    pub email_address: std::option::Option<std::string::String>,
    /// <p>The customer’s personal email address.</p>
    pub personal_email_address: std::option::Option<std::string::String>,
    /// <p>The customer’s business email address.</p>
    pub business_email_address: std::option::Option<std::string::String>,
    /// <p>A generic address associated with the customer that is not mailing, shipping, or
    /// billing.</p>
    pub address: std::option::Option<crate::model::UpdateAddress>,
    /// <p>The customer’s shipping address.</p>
    pub shipping_address: std::option::Option<crate::model::UpdateAddress>,
    /// <p>The customer’s mailing address.</p>
    pub mailing_address: std::option::Option<crate::model::UpdateAddress>,
    /// <p>The customer’s billing address.</p>
    pub billing_address: std::option::Option<crate::model::UpdateAddress>,
    /// <p>A key value pair of attributes of a customer profile.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for UpdateProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateProfileInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("profile_id", &self.profile_id);
        formatter.field("additional_information", &self.additional_information);
        formatter.field("account_number", &self.account_number);
        formatter.field("party_type", &self.party_type);
        formatter.field("business_name", &self.business_name);
        formatter.field("first_name", &self.first_name);
        formatter.field("middle_name", &self.middle_name);
        formatter.field("last_name", &self.last_name);
        formatter.field("birth_date", &self.birth_date);
        formatter.field("gender", &self.gender);
        formatter.field("phone_number", &self.phone_number);
        formatter.field("mobile_phone_number", &self.mobile_phone_number);
        formatter.field("home_phone_number", &self.home_phone_number);
        formatter.field("business_phone_number", &self.business_phone_number);
        formatter.field("email_address", &self.email_address);
        formatter.field("personal_email_address", &self.personal_email_address);
        formatter.field("business_email_address", &self.business_email_address);
        formatter.field("address", &self.address);
        formatter.field("shipping_address", &self.shipping_address);
        formatter.field("mailing_address", &self.mailing_address);
        formatter.field("billing_address", &self.billing_address);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDomainInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The default number of days until the data within the domain expires.</p>
    pub default_expiration_days: std::option::Option<i32>,
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    /// of encryption key is specified. It is used to encrypt all data before it is placed in
    /// permanent or semi-permanent storage. If specified as an empty string, it will clear any
    /// existing value.</p>
    pub default_encryption_key: std::option::Option<std::string::String>,
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    /// ingesting data from third party applications. If specified as an empty string, it will
    /// clear any existing value. You must set up a policy on the DeadLetterQueue for the
    /// SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the
    /// DeadLetterQueue.</p>
    pub dead_letter_queue_url: std::option::Option<std::string::String>,
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    pub matching: std::option::Option<crate::model::MatchingRequest>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for UpdateDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("default_expiration_days", &self.default_expiration_days);
        formatter.field("default_encryption_key", &self.default_encryption_key);
        formatter.field("dead_letter_queue_url", &self.dead_letter_queue_url);
        formatter.field("matching", &self.matching);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The ARN of the resource from which you are removing tags.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The list of tag keys to remove from the resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The ARN of the resource that you're adding tags to.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchProfilesInput {
    /// <p>The pagination token from the previous SearchProfiles API call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId,
    /// _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId,
    /// _salesforceContactId, _zendeskUserId, _zendeskExternalId, _serviceNowSystemId.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>A list of key values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SearchProfilesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchProfilesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("key_name", &self.key_name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutProfileObjectTypeInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
    /// <p>Description of the profile object type.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the object template.</p>
    pub template_id: std::option::Option<std::string::String>,
    /// <p>The number of days until the data in the object expires.</p>
    pub expiration_days: std::option::Option<i32>,
    /// <p>The customer-provided key to encrypt the profile object that will be created in this
    /// profile object type.</p>
    pub encryption_key: std::option::Option<std::string::String>,
    /// <p>Indicates whether a profile should be created when data is received if one doesn’t exist
    /// for an object of this type. The default is <code>FALSE</code>. If the AllowProfileCreation
    /// flag is set to <code>FALSE</code>, then the service tries to fetch a standard profile and
    /// associate this object with the profile. If it is set to <code>TRUE</code>, and if no match
    /// is found, then the service creates a new standard profile.</p>
    pub allow_profile_creation: bool,
    /// <p>A map of the name and ObjectType field.</p>
    pub fields: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ObjectTypeField>,
    >,
    /// <p>A list of unique keys that can be used to map data to the profile.</p>
    pub keys: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::ObjectTypeKey>>,
    >,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for PutProfileObjectTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutProfileObjectTypeInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("object_type_name", &self.object_type_name);
        formatter.field("description", &self.description);
        formatter.field("template_id", &self.template_id);
        formatter.field("expiration_days", &self.expiration_days);
        formatter.field("encryption_key", &self.encryption_key);
        formatter.field("allow_profile_creation", &self.allow_profile_creation);
        formatter.field("fields", &self.fields);
        formatter.field("keys", &self.keys);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutProfileObjectInput {
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
    /// <p>A string that is serialized from a JSON object.</p>
    pub object: std::option::Option<std::string::String>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutProfileObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutProfileObjectInput");
        formatter.field("object_type_name", &self.object_type_name);
        formatter.field("object", &self.object);
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutIntegrationInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    pub uri: std::option::Option<std::string::String>,
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The configuration that controls how Customer Profiles retrieves data from the
    /// source.</p>
    pub flow_definition: std::option::Option<crate::model::FlowDefinition>,
}
impl std::fmt::Debug for PutIntegrationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutIntegrationInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("uri", &self.uri);
        formatter.field("object_type_name", &self.object_type_name);
        formatter.field("tags", &self.tags);
        formatter.field("flow_definition", &self.flow_definition);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MergeProfilesInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the profile to be taken.</p>
    pub main_profile_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the profile to be merged into MainProfileId.</p>
    pub profile_ids_to_be_merged: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifiers of the fields in the profile that has the information you want to apply to the
    /// merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the
    /// identifier of the EmailAddress field in Profile1. </p>
    pub field_source_profile_ids: std::option::Option<crate::model::FieldSourceProfileIds>,
}
impl std::fmt::Debug for MergeProfilesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MergeProfilesInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("main_profile_id", &self.main_profile_id);
        formatter.field("profile_ids_to_be_merged", &self.profile_ids_to_be_merged);
        formatter.field("field_source_profile_ids", &self.field_source_profile_ids);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The ARN of the resource for which you want to view tags.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProfileObjectTypeTemplatesInput {
    /// <p>The pagination token from the previous ListObjectTypeTemplates API call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListProfileObjectTypeTemplatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProfileObjectTypeTemplatesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProfileObjectTypesInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListProfileObjectTypesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProfileObjectTypesInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProfileObjectsInput {
    /// <p>The pagination token from the previous call to ListProfileObjects.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a customer profile.</p>
    pub profile_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListProfileObjectsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProfileObjectsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("object_type_name", &self.object_type_name);
        formatter.field("profile_id", &self.profile_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListIntegrationsInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The pagination token from the previous ListIntegrations API call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListIntegrationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListIntegrationsInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDomainsInput {
    /// <p>The pagination token from the previous ListDomain API call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListDomainsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDomainsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAccountIntegrationsInput {
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    pub uri: std::option::Option<std::string::String>,
    /// <p>The pagination token from the previous ListAccountIntegrations API call.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects returned per page.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAccountIntegrationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAccountIntegrationsInput");
        formatter.field("uri", &self.uri);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetProfileObjectTypeTemplateInput {
    /// <p>A unique identifier for the object template.</p>
    pub template_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetProfileObjectTypeTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetProfileObjectTypeTemplateInput");
        formatter.field("template_id", &self.template_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetProfileObjectTypeInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetProfileObjectTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetProfileObjectTypeInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("object_type_name", &self.object_type_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMatchesInput {
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMatchesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMatchesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIntegrationInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    pub uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetIntegrationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetIntegrationInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("uri", &self.uri);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDomainInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProfileObjectTypeInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProfileObjectTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProfileObjectTypeInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("object_type_name", &self.object_type_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProfileObjectInput {
    /// <p>The unique identifier of a customer profile.</p>
    pub profile_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the profile object generated by the service.</p>
    pub profile_object_unique_key: std::option::Option<std::string::String>,
    /// <p>The name of the profile object type.</p>
    pub object_type_name: std::option::Option<std::string::String>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProfileObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProfileObjectInput");
        formatter.field("profile_id", &self.profile_id);
        formatter.field("profile_object_unique_key", &self.profile_object_unique_key);
        formatter.field("object_type_name", &self.object_type_name);
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProfileKeyInput {
    /// <p>The unique identifier of a customer profile.</p>
    pub profile_id: std::option::Option<std::string::String>,
    /// <p>A searchable identifier of a customer profile.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>A list of key values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProfileKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProfileKeyInput");
        formatter.field("profile_id", &self.profile_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("values", &self.values);
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProfileInput {
    /// <p>The unique identifier of a customer profile.</p>
    pub profile_id: std::option::Option<std::string::String>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProfileInput");
        formatter.field("profile_id", &self.profile_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteIntegrationInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The URI of the S3 bucket or any other type of data source.</p>
    pub uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteIntegrationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteIntegrationInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("uri", &self.uri);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDomainInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProfileInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>A unique account number that you have given to the customer.</p>
    pub account_number: std::option::Option<std::string::String>,
    /// <p>Any additional information relevant to the customer’s profile.</p>
    pub additional_information: std::option::Option<std::string::String>,
    /// <p>The type of profile used to describe the customer.</p>
    pub party_type: std::option::Option<crate::model::PartyType>,
    /// <p>The name of the customer’s business.</p>
    pub business_name: std::option::Option<std::string::String>,
    /// <p>The customer’s first name.</p>
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The customer’s middle name.</p>
    pub middle_name: std::option::Option<std::string::String>,
    /// <p>The customer’s last name.</p>
    pub last_name: std::option::Option<std::string::String>,
    /// <p>The customer’s birth date. </p>
    pub birth_date: std::option::Option<std::string::String>,
    /// <p>The gender with which the customer identifies. </p>
    pub gender: std::option::Option<crate::model::Gender>,
    /// <p>The customer’s phone number, which has not been specified as a mobile, home, or business
    /// number. </p>
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s mobile phone number.</p>
    pub mobile_phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s home phone number.</p>
    pub home_phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s business phone number.</p>
    pub business_phone_number: std::option::Option<std::string::String>,
    /// <p>The customer’s email address, which has not been specified as a personal or business
    /// address. </p>
    pub email_address: std::option::Option<std::string::String>,
    /// <p>The customer’s personal email address.</p>
    pub personal_email_address: std::option::Option<std::string::String>,
    /// <p>The customer’s business email address.</p>
    pub business_email_address: std::option::Option<std::string::String>,
    /// <p>A generic address associated with the customer that is not mailing, shipping, or
    /// billing.</p>
    pub address: std::option::Option<crate::model::Address>,
    /// <p>The customer’s shipping address.</p>
    pub shipping_address: std::option::Option<crate::model::Address>,
    /// <p>The customer’s mailing address.</p>
    pub mailing_address: std::option::Option<crate::model::Address>,
    /// <p>The customer’s billing address.</p>
    pub billing_address: std::option::Option<crate::model::Address>,
    /// <p>A key value pair of attributes of a customer profile.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProfileInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("account_number", &self.account_number);
        formatter.field("additional_information", &self.additional_information);
        formatter.field("party_type", &self.party_type);
        formatter.field("business_name", &self.business_name);
        formatter.field("first_name", &self.first_name);
        formatter.field("middle_name", &self.middle_name);
        formatter.field("last_name", &self.last_name);
        formatter.field("birth_date", &self.birth_date);
        formatter.field("gender", &self.gender);
        formatter.field("phone_number", &self.phone_number);
        formatter.field("mobile_phone_number", &self.mobile_phone_number);
        formatter.field("home_phone_number", &self.home_phone_number);
        formatter.field("business_phone_number", &self.business_phone_number);
        formatter.field("email_address", &self.email_address);
        formatter.field("personal_email_address", &self.personal_email_address);
        formatter.field("business_email_address", &self.business_email_address);
        formatter.field("address", &self.address);
        formatter.field("shipping_address", &self.shipping_address);
        formatter.field("mailing_address", &self.mailing_address);
        formatter.field("billing_address", &self.billing_address);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDomainInput {
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The default number of days until the data within the domain expires.</p>
    pub default_expiration_days: std::option::Option<i32>,
    /// <p>The default encryption key, which is an AWS managed key, is used when no specific type
    /// of encryption key is specified. It is used to encrypt all data before it is placed in
    /// permanent or semi-permanent storage.</p>
    pub default_encryption_key: std::option::Option<std::string::String>,
    /// <p>The URL of the SQS dead letter queue, which is used for reporting errors associated with
    /// ingesting data from third party applications. You must set up a policy on the
    /// DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send
    /// messages to the DeadLetterQueue.</p>
    pub dead_letter_queue_url: std::option::Option<std::string::String>,
    /// <p>The process of matching duplicate profiles. This process runs every Saturday at 12AM.</p>
    pub matching: std::option::Option<crate::model::MatchingRequest>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("default_expiration_days", &self.default_expiration_days);
        formatter.field("default_encryption_key", &self.default_encryption_key);
        formatter.field("dead_letter_queue_url", &self.dead_letter_queue_url);
        formatter.field("matching", &self.matching);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddProfileKeyInput {
    /// <p>The unique identifier of a customer profile.</p>
    pub profile_id: std::option::Option<std::string::String>,
    /// <p>A searchable identifier of a customer profile.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>A list of key values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The unique name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddProfileKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddProfileKeyInput");
        formatter.field("profile_id", &self.profile_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("values", &self.values);
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}
