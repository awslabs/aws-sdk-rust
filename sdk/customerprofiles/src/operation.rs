// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associates a new key value with a specific profile, such as a Contact Trace Record (CTR)
/// ContactId.</p>
/// <p>A profile object can have a single unique key and any number of additional keys that can
/// be used to identify the profile that it belongs to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddProfileKey {
    _private: (),
}
impl AddProfileKey {
    /// Creates a new builder-style object to manufacture [`AddProfileKeyInput`](crate::input::AddProfileKeyInput)
    pub fn builder() -> crate::input::add_profile_key_input::Builder {
        crate::input::add_profile_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddProfileKey {
    type Output =
        std::result::Result<crate::output::AddProfileKeyOutput, crate::error::AddProfileKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_profile_key_error(response)
        } else {
            crate::operation_deser::parse_add_profile_key_response(response)
        }
    }
}

/// <p>Creates a domain, which is a container for all customer data, such as customer profile
/// attributes, object types, profile keys, and encryption keys. You can create multiple
/// domains, and each domain can have multiple third-party integrations.</p>
/// <p>Each Amazon Connect instance can be associated with only one domain. Multiple Amazon Connect instances can
/// be associated with one domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDomain {
    _private: (),
}
impl CreateDomain {
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput)
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDomain {
    type Output =
        std::result::Result<crate::output::CreateDomainOutput, crate::error::CreateDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_domain_error(response)
        } else {
            crate::operation_deser::parse_create_domain_response(response)
        }
    }
}

/// <p>Creates a standard profile.</p>
/// <p>A standard profile represents the following attributes for a customer profile in a
/// domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateProfile {
    _private: (),
}
impl CreateProfile {
    /// Creates a new builder-style object to manufacture [`CreateProfileInput`](crate::input::CreateProfileInput)
    pub fn builder() -> crate::input::create_profile_input::Builder {
        crate::input::create_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateProfile {
    type Output =
        std::result::Result<crate::output::CreateProfileOutput, crate::error::CreateProfileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_profile_error(response)
        } else {
            crate::operation_deser::parse_create_profile_response(response)
        }
    }
}

/// <p>Deletes a specific domain and all of its customer data, such as customer profile
/// attributes and their related objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDomain {
    _private: (),
}
impl DeleteDomain {
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDomain {
    type Output =
        std::result::Result<crate::output::DeleteDomainOutput, crate::error::DeleteDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_domain_error(response)
        } else {
            crate::operation_deser::parse_delete_domain_response(response)
        }
    }
}

/// <p>Removes an integration from a specific domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIntegration {
    _private: (),
}
impl DeleteIntegration {
    /// Creates a new builder-style object to manufacture [`DeleteIntegrationInput`](crate::input::DeleteIntegrationInput)
    pub fn builder() -> crate::input::delete_integration_input::Builder {
        crate::input::delete_integration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIntegration {
    type Output = std::result::Result<
        crate::output::DeleteIntegrationOutput,
        crate::error::DeleteIntegrationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_integration_error(response)
        } else {
            crate::operation_deser::parse_delete_integration_response(response)
        }
    }
}

/// <p>Deletes the standard customer profile and all data pertaining to the profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteProfile {
    _private: (),
}
impl DeleteProfile {
    /// Creates a new builder-style object to manufacture [`DeleteProfileInput`](crate::input::DeleteProfileInput)
    pub fn builder() -> crate::input::delete_profile_input::Builder {
        crate::input::delete_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteProfile {
    type Output =
        std::result::Result<crate::output::DeleteProfileOutput, crate::error::DeleteProfileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_profile_error(response)
        } else {
            crate::operation_deser::parse_delete_profile_response(response)
        }
    }
}

/// <p>Removes a searchable key from a customer profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteProfileKey {
    _private: (),
}
impl DeleteProfileKey {
    /// Creates a new builder-style object to manufacture [`DeleteProfileKeyInput`](crate::input::DeleteProfileKeyInput)
    pub fn builder() -> crate::input::delete_profile_key_input::Builder {
        crate::input::delete_profile_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteProfileKey {
    type Output = std::result::Result<
        crate::output::DeleteProfileKeyOutput,
        crate::error::DeleteProfileKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_profile_key_error(response)
        } else {
            crate::operation_deser::parse_delete_profile_key_response(response)
        }
    }
}

/// <p>Removes an object associated with a profile of a given ProfileObjectType.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteProfileObject {
    _private: (),
}
impl DeleteProfileObject {
    /// Creates a new builder-style object to manufacture [`DeleteProfileObjectInput`](crate::input::DeleteProfileObjectInput)
    pub fn builder() -> crate::input::delete_profile_object_input::Builder {
        crate::input::delete_profile_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteProfileObject {
    type Output = std::result::Result<
        crate::output::DeleteProfileObjectOutput,
        crate::error::DeleteProfileObjectError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_profile_object_error(response)
        } else {
            crate::operation_deser::parse_delete_profile_object_response(response)
        }
    }
}

/// <p>Removes a ProfileObjectType from a specific domain as well as removes all the
/// ProfileObjects of that type. It also disables integrations from this specific
/// ProfileObjectType. In addition, it scrubs all of the fields of the standard profile that
/// were populated from this ProfileObjectType.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteProfileObjectType {
    _private: (),
}
impl DeleteProfileObjectType {
    /// Creates a new builder-style object to manufacture [`DeleteProfileObjectTypeInput`](crate::input::DeleteProfileObjectTypeInput)
    pub fn builder() -> crate::input::delete_profile_object_type_input::Builder {
        crate::input::delete_profile_object_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteProfileObjectType {
    type Output = std::result::Result<
        crate::output::DeleteProfileObjectTypeOutput,
        crate::error::DeleteProfileObjectTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_profile_object_type_error(response)
        } else {
            crate::operation_deser::parse_delete_profile_object_type_response(response)
        }
    }
}

/// <p>Returns information about a specific domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomain {
    _private: (),
}
impl GetDomain {
    /// Creates a new builder-style object to manufacture [`GetDomainInput`](crate::input::GetDomainInput)
    pub fn builder() -> crate::input::get_domain_input::Builder {
        crate::input::get_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomain {
    type Output = std::result::Result<crate::output::GetDomainOutput, crate::error::GetDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_error(response)
        } else {
            crate::operation_deser::parse_get_domain_response(response)
        }
    }
}

/// <p>Returns an integration for a domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIntegration {
    _private: (),
}
impl GetIntegration {
    /// Creates a new builder-style object to manufacture [`GetIntegrationInput`](crate::input::GetIntegrationInput)
    pub fn builder() -> crate::input::get_integration_input::Builder {
        crate::input::get_integration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIntegration {
    type Output =
        std::result::Result<crate::output::GetIntegrationOutput, crate::error::GetIntegrationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_integration_error(response)
        } else {
            crate::operation_deser::parse_get_integration_response(response)
        }
    }
}

/// <p>This API is in preview release for Amazon Connect and subject to change.</p>
/// <p>Before calling this API, use <a href="https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_CreateDomain.html">CreateDomain</a> or
/// <a href="https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_UpdateDomain.html">UpdateDomain</a> to
/// enable identity resolution: set <code>Matching</code> to true.</p>
/// <p>GetMatches returns potentially matching profiles, based on the results of the latest run
/// of a machine learning process. </p>
/// <important>
/// <p>Amazon Connect runs a batch process every Saturday at 12AM UTC to identify matching profiles.
/// The results are returned up to seven days after the Saturday run.</p>
/// </important>
/// <p>Amazon Connect uses the following profile attributes to identify matches:</p>
/// <ul>
/// <li>
/// <p>PhoneNumber</p>
/// </li>
/// <li>
/// <p>HomePhoneNumber</p>
/// </li>
/// <li>
/// <p>BusinessPhoneNumber</p>
/// </li>
/// <li>
/// <p>MobilePhoneNumber</p>
/// </li>
/// <li>
/// <p>EmailAddress</p>
/// </li>
/// <li>
/// <p>PersonalEmailAddress</p>
/// </li>
/// <li>
/// <p>BusinessEmailAddress</p>
/// </li>
/// <li>
/// <p>FullName</p>
/// </li>
/// <li>
/// <p>BusinessName</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMatches {
    _private: (),
}
impl GetMatches {
    /// Creates a new builder-style object to manufacture [`GetMatchesInput`](crate::input::GetMatchesInput)
    pub fn builder() -> crate::input::get_matches_input::Builder {
        crate::input::get_matches_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMatches {
    type Output =
        std::result::Result<crate::output::GetMatchesOutput, crate::error::GetMatchesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_matches_error(response)
        } else {
            crate::operation_deser::parse_get_matches_response(response)
        }
    }
}

/// <p>Returns the object types for a specific domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetProfileObjectType {
    _private: (),
}
impl GetProfileObjectType {
    /// Creates a new builder-style object to manufacture [`GetProfileObjectTypeInput`](crate::input::GetProfileObjectTypeInput)
    pub fn builder() -> crate::input::get_profile_object_type_input::Builder {
        crate::input::get_profile_object_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetProfileObjectType {
    type Output = std::result::Result<
        crate::output::GetProfileObjectTypeOutput,
        crate::error::GetProfileObjectTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_profile_object_type_error(response)
        } else {
            crate::operation_deser::parse_get_profile_object_type_response(response)
        }
    }
}

/// <p>Returns the template information for a specific object type.</p>
/// <p>A template is a predefined ProfileObjectType, such as “Salesforce-Account” or
/// “Salesforce-Contact.” When a user sends a ProfileObject, using the PutProfileObject API,
/// with an ObjectTypeName that matches one of the TemplateIds, it uses the mappings from the
/// template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetProfileObjectTypeTemplate {
    _private: (),
}
impl GetProfileObjectTypeTemplate {
    /// Creates a new builder-style object to manufacture [`GetProfileObjectTypeTemplateInput`](crate::input::GetProfileObjectTypeTemplateInput)
    pub fn builder() -> crate::input::get_profile_object_type_template_input::Builder {
        crate::input::get_profile_object_type_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetProfileObjectTypeTemplate {
    type Output = std::result::Result<
        crate::output::GetProfileObjectTypeTemplateOutput,
        crate::error::GetProfileObjectTypeTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_profile_object_type_template_error(response)
        } else {
            crate::operation_deser::parse_get_profile_object_type_template_response(response)
        }
    }
}

/// <p>Lists all of the integrations associated to a specific URI in the AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAccountIntegrations {
    _private: (),
}
impl ListAccountIntegrations {
    /// Creates a new builder-style object to manufacture [`ListAccountIntegrationsInput`](crate::input::ListAccountIntegrationsInput)
    pub fn builder() -> crate::input::list_account_integrations_input::Builder {
        crate::input::list_account_integrations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAccountIntegrations {
    type Output = std::result::Result<
        crate::output::ListAccountIntegrationsOutput,
        crate::error::ListAccountIntegrationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_account_integrations_error(response)
        } else {
            crate::operation_deser::parse_list_account_integrations_response(response)
        }
    }
}

/// <p>Returns a list of all the domains for an AWS account that have been created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomains {
    _private: (),
}
impl ListDomains {
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput)
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomains {
    type Output =
        std::result::Result<crate::output::ListDomainsOutput, crate::error::ListDomainsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domains_error(response)
        } else {
            crate::operation_deser::parse_list_domains_response(response)
        }
    }
}

/// <p>Lists all of the integrations in your domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIntegrations {
    _private: (),
}
impl ListIntegrations {
    /// Creates a new builder-style object to manufacture [`ListIntegrationsInput`](crate::input::ListIntegrationsInput)
    pub fn builder() -> crate::input::list_integrations_input::Builder {
        crate::input::list_integrations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIntegrations {
    type Output = std::result::Result<
        crate::output::ListIntegrationsOutput,
        crate::error::ListIntegrationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_integrations_error(response)
        } else {
            crate::operation_deser::parse_list_integrations_response(response)
        }
    }
}

/// <p>Returns a list of objects associated with a profile of a given ProfileObjectType.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListProfileObjects {
    _private: (),
}
impl ListProfileObjects {
    /// Creates a new builder-style object to manufacture [`ListProfileObjectsInput`](crate::input::ListProfileObjectsInput)
    pub fn builder() -> crate::input::list_profile_objects_input::Builder {
        crate::input::list_profile_objects_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListProfileObjects {
    type Output = std::result::Result<
        crate::output::ListProfileObjectsOutput,
        crate::error::ListProfileObjectsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_profile_objects_error(response)
        } else {
            crate::operation_deser::parse_list_profile_objects_response(response)
        }
    }
}

/// <p>Lists all of the templates available within the service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListProfileObjectTypes {
    _private: (),
}
impl ListProfileObjectTypes {
    /// Creates a new builder-style object to manufacture [`ListProfileObjectTypesInput`](crate::input::ListProfileObjectTypesInput)
    pub fn builder() -> crate::input::list_profile_object_types_input::Builder {
        crate::input::list_profile_object_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListProfileObjectTypes {
    type Output = std::result::Result<
        crate::output::ListProfileObjectTypesOutput,
        crate::error::ListProfileObjectTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_profile_object_types_error(response)
        } else {
            crate::operation_deser::parse_list_profile_object_types_response(response)
        }
    }
}

/// <p>Lists all of the template information for object types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListProfileObjectTypeTemplates {
    _private: (),
}
impl ListProfileObjectTypeTemplates {
    /// Creates a new builder-style object to manufacture [`ListProfileObjectTypeTemplatesInput`](crate::input::ListProfileObjectTypeTemplatesInput)
    pub fn builder() -> crate::input::list_profile_object_type_templates_input::Builder {
        crate::input::list_profile_object_type_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListProfileObjectTypeTemplates {
    type Output = std::result::Result<
        crate::output::ListProfileObjectTypeTemplatesOutput,
        crate::error::ListProfileObjectTypeTemplatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_profile_object_type_templates_error(response)
        } else {
            crate::operation_deser::parse_list_profile_object_type_templates_response(response)
        }
    }
}

/// <p>Displays the tags associated with an Amazon Connect Customer Profiles resource. In Connect
/// Customer Profiles, domains, profile object types, and integrations can be tagged.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>This API is in preview release for Amazon Connect and subject to change.</p>
/// <p>Runs an AWS Lambda job that does the following:</p>
/// <ol>
/// <li>
/// <p>All the profileKeys in the <code>ProfileToBeMerged</code> will be moved to the
/// main profile.</p>
/// </li>
/// <li>
/// <p>All the objects in the <code>ProfileToBeMerged</code> will be moved to the main
/// profile.</p>
/// </li>
/// <li>
/// <p>All the <code>ProfileToBeMerged</code> will be deleted at the end.</p>
/// </li>
/// <li>
/// <p>All the profileKeys in the <code>ProfileIdsToBeMerged</code> will be moved to the
/// main profile.</p>
/// </li>
/// <li>
/// <p>Standard fields are merged as follows:</p>
/// <ol>
/// <li>
/// <p>Fields are always "union"-ed if there are no conflicts in standard fields or
/// attributeKeys.</p>
/// </li>
/// <li>
/// <p>When there are conflicting fields:</p>
/// <ol>
/// <li>
/// <p>If no <code>SourceProfileIds</code> entry is specified, the main
/// Profile value is always taken. </p>
/// </li>
/// <li>
/// <p>If a <code>SourceProfileIds</code> entry is specified, the specified
/// profileId is always taken, even if it is a NULL value.</p>
/// </li>
/// </ol>
/// </li>
/// </ol>
/// </li>
/// </ol>
/// <p>You can use MergeProfiles together with <a href="https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_GetMatches.html">GetMatches</a>, which
/// returns potentially matching profiles, or use it with the results of another matching
/// system. After profiles have been merged, they cannot be separated (unmerged).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergeProfiles {
    _private: (),
}
impl MergeProfiles {
    /// Creates a new builder-style object to manufacture [`MergeProfilesInput`](crate::input::MergeProfilesInput)
    pub fn builder() -> crate::input::merge_profiles_input::Builder {
        crate::input::merge_profiles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergeProfiles {
    type Output =
        std::result::Result<crate::output::MergeProfilesOutput, crate::error::MergeProfilesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_profiles_error(response)
        } else {
            crate::operation_deser::parse_merge_profiles_response(response)
        }
    }
}

/// <p>Adds an integration between the service and a third-party service, which includes
/// Amazon AppFlow and Amazon Connect.</p>
/// <p>An integration can belong to only one domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutIntegration {
    _private: (),
}
impl PutIntegration {
    /// Creates a new builder-style object to manufacture [`PutIntegrationInput`](crate::input::PutIntegrationInput)
    pub fn builder() -> crate::input::put_integration_input::Builder {
        crate::input::put_integration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutIntegration {
    type Output =
        std::result::Result<crate::output::PutIntegrationOutput, crate::error::PutIntegrationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_integration_error(response)
        } else {
            crate::operation_deser::parse_put_integration_response(response)
        }
    }
}

/// <p>Adds additional objects to customer profiles of a given ObjectType.</p>
/// <p>When adding a specific profile object, like a Contact Trace Record (CTR), an inferred
/// profile can get created if it is not mapped to an existing profile. The resulting profile
/// will only have a phone number populated in the standard ProfileObject. Any additional CTRs
/// with the same phone number will be mapped to the same inferred profile.</p>
/// <p>When a ProfileObject is created and if a ProfileObjectType already exists for the
/// ProfileObject, it will provide data to a standard profile depending on the
/// ProfileObjectType definition.</p>
/// <p>PutProfileObject needs an ObjectType, which can be created using
/// PutProfileObjectType.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutProfileObject {
    _private: (),
}
impl PutProfileObject {
    /// Creates a new builder-style object to manufacture [`PutProfileObjectInput`](crate::input::PutProfileObjectInput)
    pub fn builder() -> crate::input::put_profile_object_input::Builder {
        crate::input::put_profile_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutProfileObject {
    type Output = std::result::Result<
        crate::output::PutProfileObjectOutput,
        crate::error::PutProfileObjectError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_profile_object_error(response)
        } else {
            crate::operation_deser::parse_put_profile_object_response(response)
        }
    }
}

/// <p>Defines a ProfileObjectType.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutProfileObjectType {
    _private: (),
}
impl PutProfileObjectType {
    /// Creates a new builder-style object to manufacture [`PutProfileObjectTypeInput`](crate::input::PutProfileObjectTypeInput)
    pub fn builder() -> crate::input::put_profile_object_type_input::Builder {
        crate::input::put_profile_object_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutProfileObjectType {
    type Output = std::result::Result<
        crate::output::PutProfileObjectTypeOutput,
        crate::error::PutProfileObjectTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_profile_object_type_error(response)
        } else {
            crate::operation_deser::parse_put_profile_object_type_response(response)
        }
    }
}

/// <p>Searches for profiles within a specific domain name using name, phone number, email
/// address, account number, or a custom defined index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchProfiles {
    _private: (),
}
impl SearchProfiles {
    /// Creates a new builder-style object to manufacture [`SearchProfilesInput`](crate::input::SearchProfilesInput)
    pub fn builder() -> crate::input::search_profiles_input::Builder {
        crate::input::search_profiles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchProfiles {
    type Output =
        std::result::Result<crate::output::SearchProfilesOutput, crate::error::SearchProfilesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_profiles_error(response)
        } else {
            crate::operation_deser::parse_search_profiles_response(response)
        }
    }
}

/// <p>Assigns one or more tags (key-value pairs) to the specified Amazon Connect Customer Profiles
/// resource. Tags can help you organize and categorize your resources. You can also use them
/// to scope user permissions by granting a user permission to access or change only resources
/// with certain tag values. In Connect Customer Profiles, domains, profile object types, and
/// integrations can be tagged.</p>
/// <p>Tags don't have any semantic meaning to AWS and are interpreted strictly as strings of
/// characters.</p>
/// <p>You can use the TagResource action with a resource that already has tags. If you specify
/// a new tag key, this tag is appended to the list of tags associated with the resource. If
/// you specify a tag key that is already associated with the resource, the new tag value that
/// you specify replaces the previous value for that tag.</p>
/// <p>You can associate as many as 50 tags with a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from the specified Amazon Connect Customer Profiles resource. In Connect
/// Customer Profiles, domains, profile object types, and integrations can be tagged.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the properties of a domain, including creating or selecting a dead letter queue
/// or an encryption key.</p>
/// <p>After a domain is created, the name can’t be changed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDomain {
    _private: (),
}
impl UpdateDomain {
    /// Creates a new builder-style object to manufacture [`UpdateDomainInput`](crate::input::UpdateDomainInput)
    pub fn builder() -> crate::input::update_domain_input::Builder {
        crate::input::update_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDomain {
    type Output =
        std::result::Result<crate::output::UpdateDomainOutput, crate::error::UpdateDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_domain_error(response)
        } else {
            crate::operation_deser::parse_update_domain_response(response)
        }
    }
}

/// <p>Updates the properties of a profile. The ProfileId is required for updating a customer
/// profile.</p>
/// <p>When calling the UpdateProfile API, specifying an empty string value means that any
/// existing value will be removed. Not specifying a string value means that any value already
/// there will be kept.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateProfile {
    _private: (),
}
impl UpdateProfile {
    /// Creates a new builder-style object to manufacture [`UpdateProfileInput`](crate::input::UpdateProfileInput)
    pub fn builder() -> crate::input::update_profile_input::Builder {
        crate::input::update_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateProfile {
    type Output =
        std::result::Result<crate::output::UpdateProfileOutput, crate::error::UpdateProfileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_profile_error(response)
        } else {
            crate::operation_deser::parse_update_profile_response(response)
        }
    }
}
