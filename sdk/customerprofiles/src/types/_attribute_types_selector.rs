// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Configuration information about the <code>AttributeTypesSelector </code>where the rule-based identity resolution uses to match profiles. You can choose how profiles are compared across attribute types and which attribute to use for matching from each type. There are three attribute types you can configure:</p>
/// <ul>
/// <li> <p>Email type</p>
/// <ul>
/// <li> <p>You can choose from <code>Email</code>, <code>BusinessEmail</code>, and <code>PersonalEmail</code> </p> </li>
/// </ul> </li>
/// <li> <p>Phone number type</p>
/// <ul>
/// <li> <p>You can choose from <code>Phone</code>, <code>HomePhone</code>, and <code>MobilePhone</code> </p> </li>
/// </ul> </li>
/// <li> <p>Address type</p>
/// <ul>
/// <li> <p>You can choose from <code>Address</code>, <code>BusinessAddress</code>, <code>MaillingAddress</code>, and <code>ShippingAddress</code> </p> </li>
/// </ul> </li>
/// </ul>
/// <p>You can either choose <code>ONE_TO_ONE</code> or <code>MANY_TO_MANY</code> as the <code>AttributeMatchingModel</code>. When choosing <code>MANY_TO_MANY</code>, the system can match attribute across the sub-types of an attribute type. For example, if the value of the <code>Email</code> field of Profile A and the value of <code>BusinessEmail</code> field of Profile B matches, the two profiles are matched on the Email type. When choosing <code>ONE_TO_ONE</code> the system can only match if the sub-types are exact matches. For example, only when the value of the <code>Email</code> field of Profile A and the value of the <code>Email</code> field of Profile B matches, the two profiles are matched on the Email type.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AttributeTypesSelector {
    /// <p>Configures the <code>AttributeMatchingModel</code>, you can either choose <code>ONE_TO_ONE</code> or <code>MANY_TO_MANY</code>.</p>
    pub attribute_matching_model: crate::types::AttributeMatchingModel,
    /// <p>The <code>Address</code> type. You can choose from <code>Address</code>, <code>BusinessAddress</code>, <code>MaillingAddress</code>, and <code>ShippingAddress</code>.</p>
    /// <p>You only can use the Address type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>BusinessAddress.City</code> or <code>MaillingAddress.City</code>, you need to choose the <code>BusinessAddress</code> and the <code>MaillingAddress</code> to represent the Address type and specify the <code>Address.City</code> on the matching rule.</p>
    pub address: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The <code>PhoneNumber</code> type. You can choose from <code>PhoneNumber</code>, <code>HomePhoneNumber</code>, and <code>MobilePhoneNumber</code>.</p>
    /// <p>You only can use the <code>PhoneNumber</code> type in the <code>MatchingRule</code>. For example, if you want to match a profile based on <code>Phone</code> or <code>HomePhone</code>, you need to choose the <code>Phone</code> and the <code>HomePhone</code> to represent the <code>PhoneNumber</code> type and only specify the <code>PhoneNumber</code> on the matching rule.</p>
    pub phone_number: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The <code>Email</code> type. You can choose from <code>EmailAddress</code>, <code>BusinessEmailAddress</code> and <code>PersonalEmailAddress</code>.</p>
    /// <p>You only can use the <code>EmailAddress</code> type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>PersonalEmailAddress</code> or <code>BusinessEmailAddress</code>, you need to choose the <code>PersonalEmailAddress</code> and the <code>BusinessEmailAddress</code> to represent the <code>EmailAddress</code> type and only specify the <code>EmailAddress</code> on the matching rule.</p>
    pub email_address: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl AttributeTypesSelector {
    /// <p>Configures the <code>AttributeMatchingModel</code>, you can either choose <code>ONE_TO_ONE</code> or <code>MANY_TO_MANY</code>.</p>
    pub fn attribute_matching_model(&self) -> &crate::types::AttributeMatchingModel {
        &self.attribute_matching_model
    }
    /// <p>The <code>Address</code> type. You can choose from <code>Address</code>, <code>BusinessAddress</code>, <code>MaillingAddress</code>, and <code>ShippingAddress</code>.</p>
    /// <p>You only can use the Address type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>BusinessAddress.City</code> or <code>MaillingAddress.City</code>, you need to choose the <code>BusinessAddress</code> and the <code>MaillingAddress</code> to represent the Address type and specify the <code>Address.City</code> on the matching rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.address.is_none()`.
    pub fn address(&self) -> &[::std::string::String] {
        self.address.as_deref().unwrap_or_default()
    }
    /// <p>The <code>PhoneNumber</code> type. You can choose from <code>PhoneNumber</code>, <code>HomePhoneNumber</code>, and <code>MobilePhoneNumber</code>.</p>
    /// <p>You only can use the <code>PhoneNumber</code> type in the <code>MatchingRule</code>. For example, if you want to match a profile based on <code>Phone</code> or <code>HomePhone</code>, you need to choose the <code>Phone</code> and the <code>HomePhone</code> to represent the <code>PhoneNumber</code> type and only specify the <code>PhoneNumber</code> on the matching rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phone_number.is_none()`.
    pub fn phone_number(&self) -> &[::std::string::String] {
        self.phone_number.as_deref().unwrap_or_default()
    }
    /// <p>The <code>Email</code> type. You can choose from <code>EmailAddress</code>, <code>BusinessEmailAddress</code> and <code>PersonalEmailAddress</code>.</p>
    /// <p>You only can use the <code>EmailAddress</code> type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>PersonalEmailAddress</code> or <code>BusinessEmailAddress</code>, you need to choose the <code>PersonalEmailAddress</code> and the <code>BusinessEmailAddress</code> to represent the <code>EmailAddress</code> type and only specify the <code>EmailAddress</code> on the matching rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.email_address.is_none()`.
    pub fn email_address(&self) -> &[::std::string::String] {
        self.email_address.as_deref().unwrap_or_default()
    }
}
impl AttributeTypesSelector {
    /// Creates a new builder-style object to manufacture [`AttributeTypesSelector`](crate::types::AttributeTypesSelector).
    pub fn builder() -> crate::types::builders::AttributeTypesSelectorBuilder {
        crate::types::builders::AttributeTypesSelectorBuilder::default()
    }
}

/// A builder for [`AttributeTypesSelector`](crate::types::AttributeTypesSelector).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct AttributeTypesSelectorBuilder {
    pub(crate) attribute_matching_model: ::std::option::Option<crate::types::AttributeMatchingModel>,
    pub(crate) address: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) phone_number: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) email_address: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl AttributeTypesSelectorBuilder {
    /// <p>Configures the <code>AttributeMatchingModel</code>, you can either choose <code>ONE_TO_ONE</code> or <code>MANY_TO_MANY</code>.</p>
    /// This field is required.
    pub fn attribute_matching_model(mut self, input: crate::types::AttributeMatchingModel) -> Self {
        self.attribute_matching_model = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configures the <code>AttributeMatchingModel</code>, you can either choose <code>ONE_TO_ONE</code> or <code>MANY_TO_MANY</code>.</p>
    pub fn set_attribute_matching_model(mut self, input: ::std::option::Option<crate::types::AttributeMatchingModel>) -> Self {
        self.attribute_matching_model = input;
        self
    }
    /// <p>Configures the <code>AttributeMatchingModel</code>, you can either choose <code>ONE_TO_ONE</code> or <code>MANY_TO_MANY</code>.</p>
    pub fn get_attribute_matching_model(&self) -> &::std::option::Option<crate::types::AttributeMatchingModel> {
        &self.attribute_matching_model
    }
    /// Appends an item to `address`.
    ///
    /// To override the contents of this collection use [`set_address`](Self::set_address).
    ///
    /// <p>The <code>Address</code> type. You can choose from <code>Address</code>, <code>BusinessAddress</code>, <code>MaillingAddress</code>, and <code>ShippingAddress</code>.</p>
    /// <p>You only can use the Address type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>BusinessAddress.City</code> or <code>MaillingAddress.City</code>, you need to choose the <code>BusinessAddress</code> and the <code>MaillingAddress</code> to represent the Address type and specify the <code>Address.City</code> on the matching rule.</p>
    pub fn address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.address.unwrap_or_default();
        v.push(input.into());
        self.address = ::std::option::Option::Some(v);
        self
    }
    /// <p>The <code>Address</code> type. You can choose from <code>Address</code>, <code>BusinessAddress</code>, <code>MaillingAddress</code>, and <code>ShippingAddress</code>.</p>
    /// <p>You only can use the Address type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>BusinessAddress.City</code> or <code>MaillingAddress.City</code>, you need to choose the <code>BusinessAddress</code> and the <code>MaillingAddress</code> to represent the Address type and specify the <code>Address.City</code> on the matching rule.</p>
    pub fn set_address(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.address = input;
        self
    }
    /// <p>The <code>Address</code> type. You can choose from <code>Address</code>, <code>BusinessAddress</code>, <code>MaillingAddress</code>, and <code>ShippingAddress</code>.</p>
    /// <p>You only can use the Address type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>BusinessAddress.City</code> or <code>MaillingAddress.City</code>, you need to choose the <code>BusinessAddress</code> and the <code>MaillingAddress</code> to represent the Address type and specify the <code>Address.City</code> on the matching rule.</p>
    pub fn get_address(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.address
    }
    /// Appends an item to `phone_number`.
    ///
    /// To override the contents of this collection use [`set_phone_number`](Self::set_phone_number).
    ///
    /// <p>The <code>PhoneNumber</code> type. You can choose from <code>PhoneNumber</code>, <code>HomePhoneNumber</code>, and <code>MobilePhoneNumber</code>.</p>
    /// <p>You only can use the <code>PhoneNumber</code> type in the <code>MatchingRule</code>. For example, if you want to match a profile based on <code>Phone</code> or <code>HomePhone</code>, you need to choose the <code>Phone</code> and the <code>HomePhone</code> to represent the <code>PhoneNumber</code> type and only specify the <code>PhoneNumber</code> on the matching rule.</p>
    pub fn phone_number(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.phone_number.unwrap_or_default();
        v.push(input.into());
        self.phone_number = ::std::option::Option::Some(v);
        self
    }
    /// <p>The <code>PhoneNumber</code> type. You can choose from <code>PhoneNumber</code>, <code>HomePhoneNumber</code>, and <code>MobilePhoneNumber</code>.</p>
    /// <p>You only can use the <code>PhoneNumber</code> type in the <code>MatchingRule</code>. For example, if you want to match a profile based on <code>Phone</code> or <code>HomePhone</code>, you need to choose the <code>Phone</code> and the <code>HomePhone</code> to represent the <code>PhoneNumber</code> type and only specify the <code>PhoneNumber</code> on the matching rule.</p>
    pub fn set_phone_number(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.phone_number = input;
        self
    }
    /// <p>The <code>PhoneNumber</code> type. You can choose from <code>PhoneNumber</code>, <code>HomePhoneNumber</code>, and <code>MobilePhoneNumber</code>.</p>
    /// <p>You only can use the <code>PhoneNumber</code> type in the <code>MatchingRule</code>. For example, if you want to match a profile based on <code>Phone</code> or <code>HomePhone</code>, you need to choose the <code>Phone</code> and the <code>HomePhone</code> to represent the <code>PhoneNumber</code> type and only specify the <code>PhoneNumber</code> on the matching rule.</p>
    pub fn get_phone_number(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.phone_number
    }
    /// Appends an item to `email_address`.
    ///
    /// To override the contents of this collection use [`set_email_address`](Self::set_email_address).
    ///
    /// <p>The <code>Email</code> type. You can choose from <code>EmailAddress</code>, <code>BusinessEmailAddress</code> and <code>PersonalEmailAddress</code>.</p>
    /// <p>You only can use the <code>EmailAddress</code> type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>PersonalEmailAddress</code> or <code>BusinessEmailAddress</code>, you need to choose the <code>PersonalEmailAddress</code> and the <code>BusinessEmailAddress</code> to represent the <code>EmailAddress</code> type and only specify the <code>EmailAddress</code> on the matching rule.</p>
    pub fn email_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.email_address.unwrap_or_default();
        v.push(input.into());
        self.email_address = ::std::option::Option::Some(v);
        self
    }
    /// <p>The <code>Email</code> type. You can choose from <code>EmailAddress</code>, <code>BusinessEmailAddress</code> and <code>PersonalEmailAddress</code>.</p>
    /// <p>You only can use the <code>EmailAddress</code> type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>PersonalEmailAddress</code> or <code>BusinessEmailAddress</code>, you need to choose the <code>PersonalEmailAddress</code> and the <code>BusinessEmailAddress</code> to represent the <code>EmailAddress</code> type and only specify the <code>EmailAddress</code> on the matching rule.</p>
    pub fn set_email_address(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.email_address = input;
        self
    }
    /// <p>The <code>Email</code> type. You can choose from <code>EmailAddress</code>, <code>BusinessEmailAddress</code> and <code>PersonalEmailAddress</code>.</p>
    /// <p>You only can use the <code>EmailAddress</code> type in the <code>MatchingRule</code>. For example, if you want to match profile based on <code>PersonalEmailAddress</code> or <code>BusinessEmailAddress</code>, you need to choose the <code>PersonalEmailAddress</code> and the <code>BusinessEmailAddress</code> to represent the <code>EmailAddress</code> type and only specify the <code>EmailAddress</code> on the matching rule.</p>
    pub fn get_email_address(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.email_address
    }
    /// Consumes the builder and constructs a [`AttributeTypesSelector`](crate::types::AttributeTypesSelector).
    /// This method will fail if any of the following fields are not set:
    /// - [`attribute_matching_model`](crate::types::builders::AttributeTypesSelectorBuilder::attribute_matching_model)
    pub fn build(self) -> ::std::result::Result<crate::types::AttributeTypesSelector, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::AttributeTypesSelector {
            attribute_matching_model: self.attribute_matching_model.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "attribute_matching_model",
                    "attribute_matching_model was not specified but it is required when building AttributeTypesSelector",
                )
            })?,
            address: self.address,
            phone_number: self.phone_number,
            email_address: self.email_address,
        })
    }
}
