// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A generic address associated with the customer that is not mailing, shipping, or billing.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct Address  {
    /// <p>The first line of a customer address.</p>
    pub address1: ::std::option::Option<::std::string::String>,
    /// <p>The second line of a customer address.</p>
    pub address2: ::std::option::Option<::std::string::String>,
    /// <p>The third line of a customer address.</p>
    pub address3: ::std::option::Option<::std::string::String>,
    /// <p>The fourth line of a customer address.</p>
    pub address4: ::std::option::Option<::std::string::String>,
    /// <p>The city in which a customer lives.</p>
    pub city: ::std::option::Option<::std::string::String>,
    /// <p>The county in which a customer lives.</p>
    pub county: ::std::option::Option<::std::string::String>,
    /// <p>The state in which a customer lives.</p>
    pub state: ::std::option::Option<::std::string::String>,
    /// <p>The province in which a customer lives.</p>
    pub province: ::std::option::Option<::std::string::String>,
    /// <p>The country in which a customer lives.</p>
    pub country: ::std::option::Option<::std::string::String>,
    /// <p>The postal code of a customer address.</p>
    pub postal_code: ::std::option::Option<::std::string::String>,
}
impl  Address  {
    /// <p>The first line of a customer address.</p>
    pub fn address1(&self) -> ::std::option::Option<& str> {
        self.address1.as_deref()
    }
    /// <p>The second line of a customer address.</p>
    pub fn address2(&self) -> ::std::option::Option<& str> {
        self.address2.as_deref()
    }
    /// <p>The third line of a customer address.</p>
    pub fn address3(&self) -> ::std::option::Option<& str> {
        self.address3.as_deref()
    }
    /// <p>The fourth line of a customer address.</p>
    pub fn address4(&self) -> ::std::option::Option<& str> {
        self.address4.as_deref()
    }
    /// <p>The city in which a customer lives.</p>
    pub fn city(&self) -> ::std::option::Option<& str> {
        self.city.as_deref()
    }
    /// <p>The county in which a customer lives.</p>
    pub fn county(&self) -> ::std::option::Option<& str> {
        self.county.as_deref()
    }
    /// <p>The state in which a customer lives.</p>
    pub fn state(&self) -> ::std::option::Option<& str> {
        self.state.as_deref()
    }
    /// <p>The province in which a customer lives.</p>
    pub fn province(&self) -> ::std::option::Option<& str> {
        self.province.as_deref()
    }
    /// <p>The country in which a customer lives.</p>
    pub fn country(&self) -> ::std::option::Option<& str> {
        self.country.as_deref()
    }
    /// <p>The postal code of a customer address.</p>
    pub fn postal_code(&self) -> ::std::option::Option<& str> {
        self.postal_code.as_deref()
    }
}
impl  ::std::fmt::Debug for Address  {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("Address");
        formatter.field("address1", &"*** Sensitive Data Redacted ***");
        formatter.field("address2", &"*** Sensitive Data Redacted ***");
        formatter.field("address3", &"*** Sensitive Data Redacted ***");
        formatter.field("address4", &"*** Sensitive Data Redacted ***");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("county", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &"*** Sensitive Data Redacted ***");
        formatter.field("province", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl Address {
    /// Creates a new builder-style object to manufacture [`Address`](crate::types::Address).
    pub fn builder() -> crate::types::builders::AddressBuilder {
        crate::types::builders::AddressBuilder::default()
    }
}

/// A builder for [`Address`](crate::types::Address).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct AddressBuilder {
    pub(crate) address1: ::std::option::Option<::std::string::String>,
    pub(crate) address2: ::std::option::Option<::std::string::String>,
    pub(crate) address3: ::std::option::Option<::std::string::String>,
    pub(crate) address4: ::std::option::Option<::std::string::String>,
    pub(crate) city: ::std::option::Option<::std::string::String>,
    pub(crate) county: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<::std::string::String>,
    pub(crate) province: ::std::option::Option<::std::string::String>,
    pub(crate) country: ::std::option::Option<::std::string::String>,
    pub(crate) postal_code: ::std::option::Option<::std::string::String>,
}
impl AddressBuilder {
    /// <p>The first line of a customer address.</p>
    pub fn address1(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.address1 = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The first line of a customer address.</p>
    pub fn set_address1(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.address1 = input; self
    }
    /// <p>The first line of a customer address.</p>
    pub fn get_address1(&self) -> &::std::option::Option<::std::string::String> {
        &self.address1
    }
    /// <p>The second line of a customer address.</p>
    pub fn address2(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.address2 = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The second line of a customer address.</p>
    pub fn set_address2(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.address2 = input; self
    }
    /// <p>The second line of a customer address.</p>
    pub fn get_address2(&self) -> &::std::option::Option<::std::string::String> {
        &self.address2
    }
    /// <p>The third line of a customer address.</p>
    pub fn address3(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.address3 = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The third line of a customer address.</p>
    pub fn set_address3(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.address3 = input; self
    }
    /// <p>The third line of a customer address.</p>
    pub fn get_address3(&self) -> &::std::option::Option<::std::string::String> {
        &self.address3
    }
    /// <p>The fourth line of a customer address.</p>
    pub fn address4(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.address4 = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The fourth line of a customer address.</p>
    pub fn set_address4(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.address4 = input; self
    }
    /// <p>The fourth line of a customer address.</p>
    pub fn get_address4(&self) -> &::std::option::Option<::std::string::String> {
        &self.address4
    }
    /// <p>The city in which a customer lives.</p>
    pub fn city(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.city = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The city in which a customer lives.</p>
    pub fn set_city(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.city = input; self
    }
    /// <p>The city in which a customer lives.</p>
    pub fn get_city(&self) -> &::std::option::Option<::std::string::String> {
        &self.city
    }
    /// <p>The county in which a customer lives.</p>
    pub fn county(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.county = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The county in which a customer lives.</p>
    pub fn set_county(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.county = input; self
    }
    /// <p>The county in which a customer lives.</p>
    pub fn get_county(&self) -> &::std::option::Option<::std::string::String> {
        &self.county
    }
    /// <p>The state in which a customer lives.</p>
    pub fn state(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.state = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The state in which a customer lives.</p>
    pub fn set_state(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.state = input; self
    }
    /// <p>The state in which a customer lives.</p>
    pub fn get_state(&self) -> &::std::option::Option<::std::string::String> {
        &self.state
    }
    /// <p>The province in which a customer lives.</p>
    pub fn province(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.province = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The province in which a customer lives.</p>
    pub fn set_province(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.province = input; self
    }
    /// <p>The province in which a customer lives.</p>
    pub fn get_province(&self) -> &::std::option::Option<::std::string::String> {
        &self.province
    }
    /// <p>The country in which a customer lives.</p>
    pub fn country(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.country = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The country in which a customer lives.</p>
    pub fn set_country(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.country = input; self
    }
    /// <p>The country in which a customer lives.</p>
    pub fn get_country(&self) -> &::std::option::Option<::std::string::String> {
        &self.country
    }
    /// <p>The postal code of a customer address.</p>
    pub fn postal_code(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.postal_code = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The postal code of a customer address.</p>
    pub fn set_postal_code(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.postal_code = input; self
    }
    /// <p>The postal code of a customer address.</p>
    pub fn get_postal_code(&self) -> &::std::option::Option<::std::string::String> {
        &self.postal_code
    }
    /// Consumes the builder and constructs a [`Address`](crate::types::Address).
    pub fn build(self) -> crate::types::Address {
        crate::types::Address {
            address1: self.address1
            ,
            address2: self.address2
            ,
            address3: self.address3
            ,
            address4: self.address4
            ,
            city: self.city
            ,
            county: self.county
            ,
            state: self.state
            ,
            province: self.province
            ,
            country: self.country
            ,
            postal_code: self.postal_code
            ,
        }
    }
}
impl ::std::fmt::Debug for AddressBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("AddressBuilder");
        formatter.field("address1", &"*** Sensitive Data Redacted ***");
        formatter.field("address2", &"*** Sensitive Data Redacted ***");
        formatter.field("address3", &"*** Sensitive Data Redacted ***");
        formatter.field("address4", &"*** Sensitive Data Redacted ***");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("county", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &"*** Sensitive Data Redacted ***");
        formatter.field("province", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

