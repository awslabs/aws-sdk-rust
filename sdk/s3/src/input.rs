// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
pub mod abort_multipart_upload_input {
    /// A builder for [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name to which the upload was taking place. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Key of the object for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Upload ID that identifies the multipart upload.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AbortMultipartUploadInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AbortMultipartUploadInput {
                bucket: self.bucket,
                key: self.key,
                upload_id: self.upload_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type AbortMultipartUploadInputOperationOutputAlias = crate::operation::AbortMultipartUpload;
#[doc(hidden)]
pub type AbortMultipartUploadInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AbortMultipartUploadInput {
    /// Consumes the builder and constructs an Operation<[`AbortMultipartUpload`](crate::operation::AbortMultipartUpload)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AbortMultipartUpload,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AbortMultipartUpload::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AbortMultipartUpload",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_1) = &self.request_payer {
            let formatted_2 = AsRef::<str>::as_ref(inner_1);
            if !formatted_2.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_2;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_3) = &self.expected_bucket_owner {
            let formatted_4 = AsRef::<str>::as_ref(inner_3);
            if !formatted_4.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_4;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "AbortMultipartUpload");
        if let Some(inner_5) = &self.upload_id {
            query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_5));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
    pub fn builder() -> crate::input::abort_multipart_upload_input::Builder {
        crate::input::abort_multipart_upload_input::Builder::default()
    }
}

/// See [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
pub mod complete_multipart_upload_input {
    /// A builder for [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) multipart_upload: std::option::Option<crate::model::CompletedMultipartUpload>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the bucket to which the multipart upload was initiated.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The container for the multipart upload request information.</p>
        pub fn multipart_upload(mut self, input: crate::model::CompletedMultipartUpload) -> Self {
            self.multipart_upload = Some(input);
            self
        }
        pub fn set_multipart_upload(
            mut self,
            input: std::option::Option<crate::model::CompletedMultipartUpload>,
        ) -> Self {
            self.multipart_upload = input;
            self
        }
        /// <p>ID for the initiated multipart upload.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CompleteMultipartUploadInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CompleteMultipartUploadInput {
                bucket: self.bucket,
                key: self.key,
                multipart_upload: self.multipart_upload,
                upload_id: self.upload_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type CompleteMultipartUploadInputOperationOutputAlias =
    crate::operation::CompleteMultipartUpload;
#[doc(hidden)]
pub type CompleteMultipartUploadInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CompleteMultipartUploadInput {
    /// Consumes the builder and constructs an Operation<[`CompleteMultipartUpload`](crate::operation::CompleteMultipartUpload)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CompleteMultipartUpload,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_complete_multipart_upload_input(
                &self.multipart_upload,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CompleteMultipartUpload::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CompleteMultipartUpload",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_6) = &self.request_payer {
            let formatted_7 = AsRef::<str>::as_ref(inner_6);
            if !formatted_7.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_7;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_8) = &self.expected_bucket_owner {
            let formatted_9 = AsRef::<str>::as_ref(inner_8);
            if !formatted_9.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_9;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "CompleteMultipartUpload");
        if let Some(inner_10) = &self.upload_id {
            query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_10));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
    pub fn builder() -> crate::input::complete_multipart_upload_input::Builder {
        crate::input::complete_multipart_upload_input::Builder::default()
    }
}

/// See [`CopyObjectInput`](crate::input::CopyObjectInput)
pub mod copy_object_input {
    /// A builder for [`CopyObjectInput`](crate::input::CopyObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) copy_source: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) copy_source_if_none_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) metadata_directive: std::option::Option<crate::model::MetadataDirective>,
        pub(crate) tagging_directive: std::option::Option<crate::model::TaggingDirective>,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) website_redirect_location: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) ssekms_encryption_context: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
        pub(crate) copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<std::string::String>,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) expected_source_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The name of the destination bucket.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>Specifies the source object for the copy operation. You specify the value in one of two
        /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
        /// <ul>
        /// <li>
        /// <p>For objects not accessed through an access point, specify the name of the source
        /// bucket and the key of the source object, separated by a slash (/). For example, to
        /// copy the object <code>reports/january.pdf</code> from the bucket
        /// <code>awsexamplebucket</code>, use
        /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
        /// encoded.</p>
        /// </li>
        /// <li>
        /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
        /// <note>
        /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
        /// </note>
        /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
        /// </li>
        /// </ul>
        /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
        /// to the value (for example,
        /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
        /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
        /// object.</p>
        pub fn copy_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source = Some(input.into());
            self
        }
        pub fn set_copy_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.copy_source = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
        pub fn copy_source_if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_match = input;
            self
        }
        /// <p>Copies the object if it has been modified since the specified time.</p>
        pub fn copy_source_if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_modified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_modified_since = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
        pub fn copy_source_if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_none_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_none_match = input;
            self
        }
        /// <p>Copies the object if it hasn't been modified since the specified time.</p>
        pub fn copy_source_if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_unmodified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_unmodified_since = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>The key of the destination object.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>Specifies whether the metadata is copied from the source object or replaced with
        /// metadata provided in the request.</p>
        pub fn metadata_directive(mut self, input: crate::model::MetadataDirective) -> Self {
            self.metadata_directive = Some(input);
            self
        }
        pub fn set_metadata_directive(
            mut self,
            input: std::option::Option<crate::model::MetadataDirective>,
        ) -> Self {
            self.metadata_directive = input;
            self
        }
        /// <p>Specifies whether the object tag-set are copied from the source object or replaced with
        /// tag-set provided in the request.</p>
        pub fn tagging_directive(mut self, input: crate::model::TaggingDirective) -> Self {
            self.tagging_directive = Some(input);
            self
        }
        pub fn set_tagging_directive(
            mut self,
            input: std::option::Option<crate::model::TaggingDirective>,
        ) -> Self {
            self.tagging_directive = input;
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata.</p>
        pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_redirect_location = Some(input.into());
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_redirect_location = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for
        /// an object protected by AWS KMS will fail if not made via SSL or using SigV4. For
        /// information about configuring using any of the officially supported AWS SDKs and AWS CLI,
        /// see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the
        /// Signature Version in Request Authentication</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_encryption_context = Some(input.into());
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_encryption_context = input;
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. </p>
        /// <p>Specifying this header with a COPY action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// <p>Specifies the algorithm to use when decrypting the source object (for example,
        /// AES256).</p>
        pub fn copy_source_sse_customer_algorithm(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
        /// object. The encryption key provided in this header must be one that was used when the
        /// source object was created.</p>
        pub fn copy_source_sse_customer_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn copy_source_sse_customer_key_md5(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The tag-set for the object destination object this value must be used in conjunction
        /// with the <code>TaggingDirective</code>. The tag-set must be encoded as URL Query
        /// parameters.</p>
        pub fn tagging(mut self, input: impl Into<std::string::String>) -> Self {
            self.tagging = Some(input.into());
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>The Object Lock mode that you want to apply to the copied object.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>The date and time when you want the copied object's Object Lock to expire.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>Specifies whether you want to apply a Legal Hold to the copied object.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_source_bucket_owner(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_source_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`CopyObjectInput`](crate::input::CopyObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CopyObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CopyObjectInput {
                acl: self.acl,
                bucket: self.bucket,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_type: self.content_type,
                copy_source: self.copy_source,
                copy_source_if_match: self.copy_source_if_match,
                copy_source_if_modified_since: self.copy_source_if_modified_since,
                copy_source_if_none_match: self.copy_source_if_none_match,
                copy_source_if_unmodified_since: self.copy_source_if_unmodified_since,
                expires: self.expires,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                metadata: self.metadata,
                metadata_directive: self.metadata_directive,
                tagging_directive: self.tagging_directive,
                server_side_encryption: self.server_side_encryption,
                storage_class: self.storage_class,
                website_redirect_location: self.website_redirect_location,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                ssekms_key_id: self.ssekms_key_id,
                ssekms_encryption_context: self.ssekms_encryption_context,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
                copy_source_sse_customer_algorithm: self.copy_source_sse_customer_algorithm,
                copy_source_sse_customer_key: self.copy_source_sse_customer_key,
                copy_source_sse_customer_key_md5: self.copy_source_sse_customer_key_md5,
                request_payer: self.request_payer,
                tagging: self.tagging,
                object_lock_mode: self.object_lock_mode,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                expected_bucket_owner: self.expected_bucket_owner,
                expected_source_bucket_owner: self.expected_source_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type CopyObjectInputOperationOutputAlias = crate::operation::CopyObject;
#[doc(hidden)]
pub type CopyObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CopyObjectInput {
    /// Consumes the builder and constructs an Operation<[`CopyObject`](crate::operation::CopyObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CopyObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CopyObject::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("CopyObject", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_11) = &self.acl {
            let formatted_12 = AsRef::<str>::as_ref(inner_11);
            if !formatted_12.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_12;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-acl", header_value);
            }
        }
        if let Some(inner_13) = &self.cache_control {
            let formatted_14 = AsRef::<str>::as_ref(inner_13);
            if !formatted_14.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_14;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Cache-Control", header_value);
            }
        }
        if let Some(inner_15) = &self.content_disposition {
            let formatted_16 = AsRef::<str>::as_ref(inner_15);
            if !formatted_16.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_16;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Disposition", header_value);
            }
        }
        if let Some(inner_17) = &self.content_encoding {
            let formatted_18 = AsRef::<str>::as_ref(inner_17);
            if !formatted_18.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_18;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Encoding", header_value);
            }
        }
        if let Some(inner_19) = &self.content_language {
            let formatted_20 = AsRef::<str>::as_ref(inner_19);
            if !formatted_20.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_20;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Language", header_value);
            }
        }
        if let Some(inner_21) = &self.content_type {
            let formatted_22 = AsRef::<str>::as_ref(inner_21);
            if !formatted_22.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_22;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Type", header_value);
            }
        }
        if let Some(inner_23) = &self.copy_source {
            let formatted_24 = AsRef::<str>::as_ref(inner_23);
            if !formatted_24.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_24;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source", header_value);
            }
        }
        if let Some(inner_25) = &self.copy_source_if_match {
            let formatted_26 = AsRef::<str>::as_ref(inner_25);
            if !formatted_26.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_26;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-match", header_value);
            }
        }
        if let Some(inner_27) = &self.copy_source_if_modified_since {
            let formatted_28 = inner_27.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_28.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_28;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-modified-since", header_value);
            }
        }
        if let Some(inner_29) = &self.copy_source_if_none_match {
            let formatted_30 = AsRef::<str>::as_ref(inner_29);
            if !formatted_30.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_30;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-none-match", header_value);
            }
        }
        if let Some(inner_31) = &self.copy_source_if_unmodified_since {
            let formatted_32 = inner_31.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_32.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_32;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-unmodified-since", header_value);
            }
        }
        if let Some(inner_33) = &self.expires {
            let formatted_34 = inner_33.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_34.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_34;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Expires", header_value);
            }
        }
        if let Some(inner_35) = &self.grant_full_control {
            let formatted_36 = AsRef::<str>::as_ref(inner_35);
            if !formatted_36.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_36;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-full-control", header_value);
            }
        }
        if let Some(inner_37) = &self.grant_read {
            let formatted_38 = AsRef::<str>::as_ref(inner_37);
            if !formatted_38.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_38;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read", header_value);
            }
        }
        if let Some(inner_39) = &self.grant_read_acp {
            let formatted_40 = AsRef::<str>::as_ref(inner_39);
            if !formatted_40.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_40;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read-acp", header_value);
            }
        }
        if let Some(inner_41) = &self.grant_write_acp {
            let formatted_42 = AsRef::<str>::as_ref(inner_41);
            if !formatted_42.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_42;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write-acp", header_value);
            }
        }
        if let Some(inner_43) = &self.metadata_directive {
            let formatted_44 = AsRef::<str>::as_ref(inner_43);
            if !formatted_44.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_44;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "metadata_directive",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-metadata-directive", header_value);
            }
        }
        if let Some(inner_45) = &self.tagging_directive {
            let formatted_46 = AsRef::<str>::as_ref(inner_45);
            if !formatted_46.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_46;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "tagging_directive",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-tagging-directive", header_value);
            }
        }
        if let Some(inner_47) = &self.server_side_encryption {
            let formatted_48 = AsRef::<str>::as_ref(inner_47);
            if !formatted_48.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_48;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_49) = &self.storage_class {
            let formatted_50 = AsRef::<str>::as_ref(inner_49);
            if !formatted_50.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_50;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-storage-class", header_value);
            }
        }
        if let Some(inner_51) = &self.website_redirect_location {
            let formatted_52 = AsRef::<str>::as_ref(inner_51);
            if !formatted_52.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_52;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "website_redirect_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-website-redirect-location", header_value);
            }
        }
        if let Some(inner_53) = &self.sse_customer_algorithm {
            let formatted_54 = AsRef::<str>::as_ref(inner_53);
            if !formatted_54.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_54;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_55) = &self.sse_customer_key {
            let formatted_56 = AsRef::<str>::as_ref(inner_55);
            if !formatted_56.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_56;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_57) = &self.sse_customer_key_md5 {
            let formatted_58 = AsRef::<str>::as_ref(inner_57);
            if !formatted_58.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_58;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_59) = &self.ssekms_key_id {
            let formatted_60 = AsRef::<str>::as_ref(inner_59);
            if !formatted_60.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_60;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder =
                    builder.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_61) = &self.ssekms_encryption_context {
            let formatted_62 = AsRef::<str>::as_ref(inner_61);
            if !formatted_62.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_62;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_encryption_context",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-context", header_value);
            }
        }
        if self.bucket_key_enabled {
            let formatted_63 = smithy_http::query::fmt_default(&&self.bucket_key_enabled);
            if !formatted_63.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_63;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_64) = &self.copy_source_sse_customer_algorithm {
            let formatted_65 = AsRef::<str>::as_ref(inner_64);
            if !formatted_65.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_65;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-copy-source-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_66) = &self.copy_source_sse_customer_key {
            let formatted_67 = AsRef::<str>::as_ref(inner_66);
            if !formatted_67.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_67;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-copy-source-server-side-encryption-customer-key",
                    header_value,
                );
            }
        }
        if let Some(inner_68) = &self.copy_source_sse_customer_key_md5 {
            let formatted_69 = AsRef::<str>::as_ref(inner_68);
            if !formatted_69.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_69;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-copy-source-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_70) = &self.request_payer {
            let formatted_71 = AsRef::<str>::as_ref(inner_70);
            if !formatted_71.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_71;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_72) = &self.tagging {
            let formatted_73 = AsRef::<str>::as_ref(inner_72);
            if !formatted_73.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_73;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "tagging",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-tagging", header_value);
            }
        }
        if let Some(inner_74) = &self.object_lock_mode {
            let formatted_75 = AsRef::<str>::as_ref(inner_74);
            if !formatted_75.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_75;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-mode", header_value);
            }
        }
        if let Some(inner_76) = &self.object_lock_retain_until_date {
            let formatted_77 = inner_76.fmt(smithy_types::instant::Format::DateTime);
            if !formatted_77.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_77;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-retain-until-date", header_value);
            }
        }
        if let Some(inner_78) = &self.object_lock_legal_hold_status {
            let formatted_79 = AsRef::<str>::as_ref(inner_78);
            if !formatted_79.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_79;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-legal-hold", header_value);
            }
        }
        if let Some(inner_80) = &self.expected_bucket_owner {
            let formatted_81 = AsRef::<str>::as_ref(inner_80);
            if !formatted_81.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_81;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_82) = &self.expected_source_bucket_owner {
            let formatted_83 = AsRef::<str>::as_ref(inner_82);
            if !formatted_83.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_83;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_source_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-source-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_84) = &self.metadata {
            for (k, v) in inner_84 {
                use std::str::FromStr;
                let header_name =
                    http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header name: {}", k, err),
                        })?;
                use std::convert::TryFrom;
                let header_value = AsRef::<str>::as_ref(v);
                let header_value =
                    http::header::HeaderValue::try_from(header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header value: {}", v, err),
                        }
                    })?;
                builder = builder.header(header_name, header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "CopyObject");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CopyObjectInput`](crate::input::CopyObjectInput)
    pub fn builder() -> crate::input::copy_object_input::Builder {
        crate::input::copy_object_input::Builder::default()
    }
}

/// See [`CreateBucketInput`](crate::input::CreateBucketInput)
pub mod create_bucket_input {
    /// A builder for [`CreateBucketInput`](crate::input::CreateBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::BucketCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) object_lock_enabled_for_bucket: std::option::Option<bool>,
        pub(crate) create_bucket_configuration:
            std::option::Option<crate::model::CreateBucketConfiguration>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the bucket.</p>
        pub fn acl(mut self, input: crate::model::BucketCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::BucketCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The name of the bucket to create.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write = Some(input.into());
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_write = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
        pub fn object_lock_enabled_for_bucket(mut self, input: bool) -> Self {
            self.object_lock_enabled_for_bucket = Some(input);
            self
        }
        pub fn set_object_lock_enabled_for_bucket(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.object_lock_enabled_for_bucket = input;
            self
        }
        /// <p>The configuration information for the bucket.</p>
        pub fn create_bucket_configuration(
            mut self,
            input: crate::model::CreateBucketConfiguration,
        ) -> Self {
            self.create_bucket_configuration = Some(input);
            self
        }
        pub fn set_create_bucket_configuration(
            mut self,
            input: std::option::Option<crate::model::CreateBucketConfiguration>,
        ) -> Self {
            self.create_bucket_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBucketInput`](crate::input::CreateBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateBucketInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateBucketInput {
                acl: self.acl,
                bucket: self.bucket,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write: self.grant_write,
                grant_write_acp: self.grant_write_acp,
                object_lock_enabled_for_bucket: self
                    .object_lock_enabled_for_bucket
                    .unwrap_or_default(),
                create_bucket_configuration: self.create_bucket_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBucketInputOperationOutputAlias = crate::operation::CreateBucket;
#[doc(hidden)]
pub type CreateBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBucketInput {
    /// Consumes the builder and constructs an Operation<[`CreateBucket`](crate::operation::CreateBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_create_bucket_input(
                &self.create_bucket_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateBucket::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("CreateBucket", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_85) = &self.acl {
            let formatted_86 = AsRef::<str>::as_ref(inner_85);
            if !formatted_86.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_86;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-acl", header_value);
            }
        }
        if let Some(inner_87) = &self.grant_full_control {
            let formatted_88 = AsRef::<str>::as_ref(inner_87);
            if !formatted_88.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_88;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-full-control", header_value);
            }
        }
        if let Some(inner_89) = &self.grant_read {
            let formatted_90 = AsRef::<str>::as_ref(inner_89);
            if !formatted_90.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_90;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read", header_value);
            }
        }
        if let Some(inner_91) = &self.grant_read_acp {
            let formatted_92 = AsRef::<str>::as_ref(inner_91);
            if !formatted_92.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_92;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read-acp", header_value);
            }
        }
        if let Some(inner_93) = &self.grant_write {
            let formatted_94 = AsRef::<str>::as_ref(inner_93);
            if !formatted_94.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_94;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write", header_value);
            }
        }
        if let Some(inner_95) = &self.grant_write_acp {
            let formatted_96 = AsRef::<str>::as_ref(inner_95);
            if !formatted_96.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_96;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write-acp", header_value);
            }
        }
        if self.object_lock_enabled_for_bucket {
            let formatted_97 =
                smithy_http::query::fmt_default(&&self.object_lock_enabled_for_bucket);
            if !formatted_97.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_97;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_enabled_for_bucket",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-bucket-object-lock-enabled", header_value);
            }
        }
        Ok(builder)
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBucketInput`](crate::input::CreateBucketInput)
    pub fn builder() -> crate::input::create_bucket_input::Builder {
        crate::input::create_bucket_input::Builder::default()
    }
}

/// See [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
pub mod create_multipart_upload_input {
    /// A builder for [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) website_redirect_location: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) ssekms_encryption_context: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<std::string::String>,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The name of the bucket to which to initiate the upload</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Object key for which the multipart upload is to be initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata.</p>
        pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_redirect_location = Some(input.into());
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_redirect_location = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Specifies the ID of the symmetric customer managed AWS KMS CMK to use for object
        /// encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not
        /// made via SSL or using SigV4. For information about configuring using any of the officially
        /// supported AWS SDKs and AWS CLI, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
        /// in the <i>Amazon S3 User Guide</i>.</p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_encryption_context = Some(input.into());
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_encryption_context = input;
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
        /// <p>Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
        pub fn tagging(mut self, input: impl Into<std::string::String>) -> Self {
            self.tagging = Some(input.into());
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMultipartUploadInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMultipartUploadInput {
                acl: self.acl,
                bucket: self.bucket,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_type: self.content_type,
                expires: self.expires,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                metadata: self.metadata,
                server_side_encryption: self.server_side_encryption,
                storage_class: self.storage_class,
                website_redirect_location: self.website_redirect_location,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                ssekms_key_id: self.ssekms_key_id,
                ssekms_encryption_context: self.ssekms_encryption_context,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
                request_payer: self.request_payer,
                tagging: self.tagging,
                object_lock_mode: self.object_lock_mode,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMultipartUploadInputOperationOutputAlias = crate::operation::CreateMultipartUpload;
#[doc(hidden)]
pub type CreateMultipartUploadInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateMultipartUploadInput {
    /// Consumes the builder and constructs an Operation<[`CreateMultipartUpload`](crate::operation::CreateMultipartUpload)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateMultipartUpload,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateMultipartUpload::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateMultipartUpload",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_98) = &self.acl {
            let formatted_99 = AsRef::<str>::as_ref(inner_98);
            if !formatted_99.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_99;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-acl", header_value);
            }
        }
        if let Some(inner_100) = &self.cache_control {
            let formatted_101 = AsRef::<str>::as_ref(inner_100);
            if !formatted_101.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_101;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Cache-Control", header_value);
            }
        }
        if let Some(inner_102) = &self.content_disposition {
            let formatted_103 = AsRef::<str>::as_ref(inner_102);
            if !formatted_103.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_103;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Disposition", header_value);
            }
        }
        if let Some(inner_104) = &self.content_encoding {
            let formatted_105 = AsRef::<str>::as_ref(inner_104);
            if !formatted_105.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_105;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Encoding", header_value);
            }
        }
        if let Some(inner_106) = &self.content_language {
            let formatted_107 = AsRef::<str>::as_ref(inner_106);
            if !formatted_107.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_107;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Language", header_value);
            }
        }
        if let Some(inner_108) = &self.content_type {
            let formatted_109 = AsRef::<str>::as_ref(inner_108);
            if !formatted_109.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_109;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Type", header_value);
            }
        }
        if let Some(inner_110) = &self.expires {
            let formatted_111 = inner_110.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_111.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_111;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Expires", header_value);
            }
        }
        if let Some(inner_112) = &self.grant_full_control {
            let formatted_113 = AsRef::<str>::as_ref(inner_112);
            if !formatted_113.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_113;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-full-control", header_value);
            }
        }
        if let Some(inner_114) = &self.grant_read {
            let formatted_115 = AsRef::<str>::as_ref(inner_114);
            if !formatted_115.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_115;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read", header_value);
            }
        }
        if let Some(inner_116) = &self.grant_read_acp {
            let formatted_117 = AsRef::<str>::as_ref(inner_116);
            if !formatted_117.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_117;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read-acp", header_value);
            }
        }
        if let Some(inner_118) = &self.grant_write_acp {
            let formatted_119 = AsRef::<str>::as_ref(inner_118);
            if !formatted_119.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_119;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write-acp", header_value);
            }
        }
        if let Some(inner_120) = &self.server_side_encryption {
            let formatted_121 = AsRef::<str>::as_ref(inner_120);
            if !formatted_121.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_121;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_122) = &self.storage_class {
            let formatted_123 = AsRef::<str>::as_ref(inner_122);
            if !formatted_123.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_123;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-storage-class", header_value);
            }
        }
        if let Some(inner_124) = &self.website_redirect_location {
            let formatted_125 = AsRef::<str>::as_ref(inner_124);
            if !formatted_125.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_125;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "website_redirect_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-website-redirect-location", header_value);
            }
        }
        if let Some(inner_126) = &self.sse_customer_algorithm {
            let formatted_127 = AsRef::<str>::as_ref(inner_126);
            if !formatted_127.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_127;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_128) = &self.sse_customer_key {
            let formatted_129 = AsRef::<str>::as_ref(inner_128);
            if !formatted_129.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_129;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_130) = &self.sse_customer_key_md5 {
            let formatted_131 = AsRef::<str>::as_ref(inner_130);
            if !formatted_131.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_131;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_132) = &self.ssekms_key_id {
            let formatted_133 = AsRef::<str>::as_ref(inner_132);
            if !formatted_133.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_133;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder =
                    builder.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_134) = &self.ssekms_encryption_context {
            let formatted_135 = AsRef::<str>::as_ref(inner_134);
            if !formatted_135.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_135;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_encryption_context",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-context", header_value);
            }
        }
        if self.bucket_key_enabled {
            let formatted_136 = smithy_http::query::fmt_default(&&self.bucket_key_enabled);
            if !formatted_136.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_136;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_137) = &self.request_payer {
            let formatted_138 = AsRef::<str>::as_ref(inner_137);
            if !formatted_138.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_138;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_139) = &self.tagging {
            let formatted_140 = AsRef::<str>::as_ref(inner_139);
            if !formatted_140.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_140;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "tagging",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-tagging", header_value);
            }
        }
        if let Some(inner_141) = &self.object_lock_mode {
            let formatted_142 = AsRef::<str>::as_ref(inner_141);
            if !formatted_142.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_142;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-mode", header_value);
            }
        }
        if let Some(inner_143) = &self.object_lock_retain_until_date {
            let formatted_144 = inner_143.fmt(smithy_types::instant::Format::DateTime);
            if !formatted_144.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_144;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-retain-until-date", header_value);
            }
        }
        if let Some(inner_145) = &self.object_lock_legal_hold_status {
            let formatted_146 = AsRef::<str>::as_ref(inner_145);
            if !formatted_146.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_146;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-legal-hold", header_value);
            }
        }
        if let Some(inner_147) = &self.expected_bucket_owner {
            let formatted_148 = AsRef::<str>::as_ref(inner_147);
            if !formatted_148.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_148;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_149) = &self.metadata {
            for (k, v) in inner_149 {
                use std::str::FromStr;
                let header_name =
                    http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header name: {}", k, err),
                        })?;
                use std::convert::TryFrom;
                let header_value = AsRef::<str>::as_ref(v);
                let header_value =
                    http::header::HeaderValue::try_from(header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header value: {}", v, err),
                        }
                    })?;
                builder = builder.header(header_name, header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("uploads");
        query.push_kv("x-id", "CreateMultipartUpload");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
    pub fn builder() -> crate::input::create_multipart_upload_input::Builder {
        crate::input::create_multipart_upload_input::Builder::default()
    }
}

/// See [`DeleteBucketInput`](crate::input::DeleteBucketInput)
pub mod delete_bucket_input {
    /// A builder for [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the bucket being deleted.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketInput`](crate::input::DeleteBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteBucketInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteBucketInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketInputOperationOutputAlias = crate::operation::DeleteBucket;
#[doc(hidden)]
pub type DeleteBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucket`](crate::operation::DeleteBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucket::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeleteBucket", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_150) = &self.expected_bucket_owner {
            let formatted_151 = AsRef::<str>::as_ref(inner_150);
            if !formatted_151.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_151;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    pub fn builder() -> crate::input::delete_bucket_input::Builder {
        crate::input::delete_bucket_input::Builder::default()
    }
}

/// See [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
pub mod delete_bucket_analytics_configuration_input {
    /// A builder for [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which an analytics configuration is deleted.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketAnalyticsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketAnalyticsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketAnalyticsConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketAnalyticsConfiguration;
#[doc(hidden)]
pub type DeleteBucketAnalyticsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketAnalyticsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketAnalyticsConfiguration`](crate::operation::DeleteBucketAnalyticsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketAnalyticsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketAnalyticsConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketAnalyticsConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_152) = &self.expected_bucket_owner {
            let formatted_153 = AsRef::<str>::as_ref(inner_152);
            if !formatted_153.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_153;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("analytics");
        if let Some(inner_154) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_154));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_analytics_configuration_input::Builder {
        crate::input::delete_bucket_analytics_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
pub mod delete_bucket_cors_input {
    /// A builder for [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the bucket whose <code>cors</code> configuration is being deleted.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketCorsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketCorsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketCorsInputOperationOutputAlias = crate::operation::DeleteBucketCors;
#[doc(hidden)]
pub type DeleteBucketCorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketCorsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketCors`](crate::operation::DeleteBucketCors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketCors,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketCors::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketCors",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_155) = &self.expected_bucket_owner {
            let formatted_156 = AsRef::<str>::as_ref(inner_155);
            if !formatted_156.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_156;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("cors");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
    pub fn builder() -> crate::input::delete_bucket_cors_input::Builder {
        crate::input::delete_bucket_cors_input::Builder::default()
    }
}

/// See [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
pub mod delete_bucket_encryption_input {
    /// A builder for [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the server-side encryption configuration to
        /// delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketEncryptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketEncryptionInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketEncryptionInputOperationOutputAlias = crate::operation::DeleteBucketEncryption;
#[doc(hidden)]
pub type DeleteBucketEncryptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketEncryption`](crate::operation::DeleteBucketEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketEncryption::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketEncryption",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_157) = &self.expected_bucket_owner {
            let formatted_158 = AsRef::<str>::as_ref(inner_157);
            if !formatted_158.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_158;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("encryption");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
    pub fn builder() -> crate::input::delete_bucket_encryption_input::Builder {
        crate::input::delete_bucket_encryption_input::Builder::default()
    }
}

/// See [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
pub mod delete_bucket_intelligent_tiering_configuration_input {
    /// A builder for [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketIntelligentTieringConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteBucketIntelligentTieringConfigurationInput {
                    bucket: self.bucket,
                    id: self.id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketIntelligentTieringConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketIntelligentTieringConfiguration;
#[doc(hidden)]
pub type DeleteBucketIntelligentTieringConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DeleteBucketIntelligentTieringConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketIntelligentTieringConfiguration`](crate::operation::DeleteBucketIntelligentTieringConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketIntelligentTieringConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketIntelligentTieringConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketIntelligentTieringConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("intelligent-tiering");
        if let Some(inner_159) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_159));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_intelligent_tiering_configuration_input::Builder
    {
        crate::input::delete_bucket_intelligent_tiering_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
pub mod delete_bucket_inventory_configuration_input {
    /// A builder for [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the inventory configuration to delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketInventoryConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketInventoryConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketInventoryConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketInventoryConfiguration;
#[doc(hidden)]
pub type DeleteBucketInventoryConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketInventoryConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketInventoryConfiguration`](crate::operation::DeleteBucketInventoryConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketInventoryConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketInventoryConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketInventoryConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_160) = &self.expected_bucket_owner {
            let formatted_161 = AsRef::<str>::as_ref(inner_160);
            if !formatted_161.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_161;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("inventory");
        if let Some(inner_162) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_162));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_inventory_configuration_input::Builder {
        crate::input::delete_bucket_inventory_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
pub mod delete_bucket_lifecycle_input {
    /// A builder for [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name of the lifecycle to delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketLifecycleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketLifecycleInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketLifecycleInputOperationOutputAlias = crate::operation::DeleteBucketLifecycle;
#[doc(hidden)]
pub type DeleteBucketLifecycleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketLifecycleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketLifecycle`](crate::operation::DeleteBucketLifecycle)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketLifecycle,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketLifecycle::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketLifecycle",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_163) = &self.expected_bucket_owner {
            let formatted_164 = AsRef::<str>::as_ref(inner_163);
            if !formatted_164.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_164;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("lifecycle");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
    pub fn builder() -> crate::input::delete_bucket_lifecycle_input::Builder {
        crate::input::delete_bucket_lifecycle_input::Builder::default()
    }
}

/// See [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
pub mod delete_bucket_metrics_configuration_input {
    /// A builder for [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the metrics configuration to delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketMetricsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketMetricsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketMetricsConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketMetricsConfiguration;
#[doc(hidden)]
pub type DeleteBucketMetricsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketMetricsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketMetricsConfiguration`](crate::operation::DeleteBucketMetricsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketMetricsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketMetricsConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketMetricsConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_165) = &self.expected_bucket_owner {
            let formatted_166 = AsRef::<str>::as_ref(inner_165);
            if !formatted_166.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_166;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("metrics");
        if let Some(inner_167) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_167));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_metrics_configuration_input::Builder {
        crate::input::delete_bucket_metrics_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
pub mod delete_bucket_ownership_controls_input {
    /// A builder for [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket whose <code>OwnershipControls</code> you want to delete. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketOwnershipControlsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketOwnershipControlsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketOwnershipControlsInputOperationOutputAlias =
    crate::operation::DeleteBucketOwnershipControls;
#[doc(hidden)]
pub type DeleteBucketOwnershipControlsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketOwnershipControlsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketOwnershipControls`](crate::operation::DeleteBucketOwnershipControls)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketOwnershipControls,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketOwnershipControls::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketOwnershipControls",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_168) = &self.expected_bucket_owner {
            let formatted_169 = AsRef::<str>::as_ref(inner_168);
            if !formatted_169.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_169;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("ownershipControls");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
    pub fn builder() -> crate::input::delete_bucket_ownership_controls_input::Builder {
        crate::input::delete_bucket_ownership_controls_input::Builder::default()
    }
}

/// See [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
pub mod delete_bucket_policy_input {
    /// A builder for [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketPolicyInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketPolicyInputOperationOutputAlias = crate::operation::DeleteBucketPolicy;
#[doc(hidden)]
pub type DeleteBucketPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketPolicy`](crate::operation::DeleteBucketPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketPolicy",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_170) = &self.expected_bucket_owner {
            let formatted_171 = AsRef::<str>::as_ref(inner_170);
            if !formatted_171.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_171;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("policy");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
    pub fn builder() -> crate::input::delete_bucket_policy_input::Builder {
        crate::input::delete_bucket_policy_input::Builder::default()
    }
}

/// See [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
pub mod delete_bucket_replication_input {
    /// A builder for [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The bucket name. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketReplicationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketReplicationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketReplicationInputOperationOutputAlias =
    crate::operation::DeleteBucketReplication;
#[doc(hidden)]
pub type DeleteBucketReplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketReplicationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketReplication`](crate::operation::DeleteBucketReplication)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketReplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketReplication::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketReplication",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_172) = &self.expected_bucket_owner {
            let formatted_173 = AsRef::<str>::as_ref(inner_172);
            if !formatted_173.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_173;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("replication");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
    pub fn builder() -> crate::input::delete_bucket_replication_input::Builder {
        crate::input::delete_bucket_replication_input::Builder::default()
    }
}

/// See [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
pub mod delete_bucket_tagging_input {
    /// A builder for [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket that has the tag set to be removed.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketTaggingInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketTaggingInputOperationOutputAlias = crate::operation::DeleteBucketTagging;
#[doc(hidden)]
pub type DeleteBucketTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketTaggingInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketTagging`](crate::operation::DeleteBucketTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketTagging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketTagging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_174) = &self.expected_bucket_owner {
            let formatted_175 = AsRef::<str>::as_ref(inner_174);
            if !formatted_175.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_175;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("tagging");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
    pub fn builder() -> crate::input::delete_bucket_tagging_input::Builder {
        crate::input::delete_bucket_tagging_input::Builder::default()
    }
}

/// See [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
pub mod delete_bucket_website_input {
    /// A builder for [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which you want to remove the website configuration. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketWebsiteInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketWebsiteInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketWebsiteInputOperationOutputAlias = crate::operation::DeleteBucketWebsite;
#[doc(hidden)]
pub type DeleteBucketWebsiteInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketWebsiteInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketWebsite`](crate::operation::DeleteBucketWebsite)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketWebsite,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBucketWebsite::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBucketWebsite",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_176) = &self.expected_bucket_owner {
            let formatted_177 = AsRef::<str>::as_ref(inner_176);
            if !formatted_177.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_177;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("website");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
    pub fn builder() -> crate::input::delete_bucket_website_input::Builder {
        crate::input::delete_bucket_website_input::Builder::default()
    }
}

/// See [`DeleteObjectInput`](crate::input::DeleteObjectInput)
pub mod delete_object_input {
    /// A builder for [`DeleteObjectInput`](crate::input::DeleteObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) mfa: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) bypass_governance_retention: std::option::Option<bool>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name of the bucket containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Key name of the object to delete.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device. Required to permanently delete a versioned
        /// object if versioning is configured with MFA delete enabled.</p>
        pub fn mfa(mut self, input: impl Into<std::string::String>) -> Self {
            self.mfa = Some(input.into());
            self
        }
        pub fn set_mfa(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mfa = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process
        /// this operation.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.bypass_governance_retention = Some(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.bypass_governance_retention = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectInput`](crate::input::DeleteObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteObjectInput {
                bucket: self.bucket,
                key: self.key,
                mfa: self.mfa,
                version_id: self.version_id,
                request_payer: self.request_payer,
                bypass_governance_retention: self.bypass_governance_retention.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteObjectInputOperationOutputAlias = crate::operation::DeleteObject;
#[doc(hidden)]
pub type DeleteObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteObjectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObject`](crate::operation::DeleteObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteObject::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeleteObject", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_178) = &self.mfa {
            let formatted_179 = AsRef::<str>::as_ref(inner_178);
            if !formatted_179.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_179;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "mfa",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-mfa", header_value);
            }
        }
        if let Some(inner_180) = &self.request_payer {
            let formatted_181 = AsRef::<str>::as_ref(inner_180);
            if !formatted_181.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_181;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if self.bypass_governance_retention {
            let formatted_182 = smithy_http::query::fmt_default(&&self.bypass_governance_retention);
            if !formatted_182.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_182;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bypass_governance_retention",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-bypass-governance-retention", header_value);
            }
        }
        if let Some(inner_183) = &self.expected_bucket_owner {
            let formatted_184 = AsRef::<str>::as_ref(inner_183);
            if !formatted_184.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_184;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "DeleteObject");
        if let Some(inner_185) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_185));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectInput`](crate::input::DeleteObjectInput)
    pub fn builder() -> crate::input::delete_object_input::Builder {
        crate::input::delete_object_input::Builder::default()
    }
}

/// See [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
pub mod delete_objects_input {
    /// A builder for [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) mfa: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) bypass_governance_retention: std::option::Option<bool>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) delete: std::option::Option<crate::model::Delete>,
    }
    impl Builder {
        /// <p>The bucket name containing the objects to delete. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device. Required to permanently delete a versioned
        /// object if versioning is configured with MFA delete enabled.</p>
        pub fn mfa(mut self, input: impl Into<std::string::String>) -> Self {
            self.mfa = Some(input.into());
            self
        }
        pub fn set_mfa(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mfa = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Specifies whether you want to delete this object even if it has a Governance-type Object
        /// Lock in place. You must have sufficient permissions to perform this operation.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.bypass_governance_retention = Some(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.bypass_governance_retention = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for the request.</p>
        pub fn delete(mut self, input: crate::model::Delete) -> Self {
            self.delete = Some(input);
            self
        }
        pub fn set_delete(mut self, input: std::option::Option<crate::model::Delete>) -> Self {
            self.delete = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteObjectsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteObjectsInput {
                bucket: self.bucket,
                mfa: self.mfa,
                request_payer: self.request_payer,
                bypass_governance_retention: self.bypass_governance_retention.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
                delete: self.delete,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteObjectsInputOperationOutputAlias = crate::operation::DeleteObjects;
#[doc(hidden)]
pub type DeleteObjectsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteObjectsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObjects`](crate::operation::DeleteObjects)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteObjects,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_delete_objects_input(&self.delete)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteObjects::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeleteObjects", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_186) = &self.mfa {
            let formatted_187 = AsRef::<str>::as_ref(inner_186);
            if !formatted_187.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_187;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "mfa",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-mfa", header_value);
            }
        }
        if let Some(inner_188) = &self.request_payer {
            let formatted_189 = AsRef::<str>::as_ref(inner_188);
            if !formatted_189.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_189;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if self.bypass_governance_retention {
            let formatted_190 = smithy_http::query::fmt_default(&&self.bypass_governance_retention);
            if !formatted_190.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_190;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bypass_governance_retention",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-bypass-governance-retention", header_value);
            }
        }
        if let Some(inner_191) = &self.expected_bucket_owner {
            let formatted_192 = AsRef::<str>::as_ref(inner_191);
            if !formatted_192.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_192;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("delete");
        query.push_kv("x-id", "DeleteObjects");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
    pub fn builder() -> crate::input::delete_objects_input::Builder {
        crate::input::delete_objects_input::Builder::default()
    }
}

/// See [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
pub mod delete_object_tagging_input {
    /// A builder for [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the objects from which to remove the tags. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key that identifies the object in the bucket from which to remove all tags.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The versionId of the object that the tag-set will be removed from.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteObjectTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteObjectTaggingInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteObjectTaggingInputOperationOutputAlias = crate::operation::DeleteObjectTagging;
#[doc(hidden)]
pub type DeleteObjectTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteObjectTaggingInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObjectTagging`](crate::operation::DeleteObjectTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteObjectTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteObjectTagging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteObjectTagging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_193) = &self.expected_bucket_owner {
            let formatted_194 = AsRef::<str>::as_ref(inner_193);
            if !formatted_194.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_194;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("tagging");
        if let Some(inner_195) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_195));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
    pub fn builder() -> crate::input::delete_object_tagging_input::Builder {
        crate::input::delete_object_tagging_input::Builder::default()
    }
}

/// See [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
pub mod delete_public_access_block_input {
    /// A builder for [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete.
        /// </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePublicAccessBlockInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePublicAccessBlockInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePublicAccessBlockInputOperationOutputAlias =
    crate::operation::DeletePublicAccessBlock;
#[doc(hidden)]
pub type DeletePublicAccessBlockInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePublicAccessBlockInput {
    /// Consumes the builder and constructs an Operation<[`DeletePublicAccessBlock`](crate::operation::DeletePublicAccessBlock)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePublicAccessBlock,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePublicAccessBlock::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeletePublicAccessBlock",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_196) = &self.expected_bucket_owner {
            let formatted_197 = AsRef::<str>::as_ref(inner_196);
            if !formatted_197.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_197;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("publicAccessBlock");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
    pub fn builder() -> crate::input::delete_public_access_block_input::Builder {
        crate::input::delete_public_access_block_input::Builder::default()
    }
}

/// See [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
pub mod get_bucket_accelerate_configuration_input {
    /// A builder for [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which the accelerate configuration is retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketAccelerateConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketAccelerateConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAccelerateConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketAccelerateConfiguration;
#[doc(hidden)]
pub type GetBucketAccelerateConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAccelerateConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAccelerateConfiguration`](crate::operation::GetBucketAccelerateConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketAccelerateConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketAccelerateConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketAccelerateConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_198) = &self.expected_bucket_owner {
            let formatted_199 = AsRef::<str>::as_ref(inner_198);
            if !formatted_199.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_199;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("accelerate");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_accelerate_configuration_input::Builder {
        crate::input::get_bucket_accelerate_configuration_input::Builder::default()
    }
}

/// See [`GetBucketAclInput`](crate::input::GetBucketAclInput)
pub mod get_bucket_acl_input {
    /// A builder for [`GetBucketAclInput`](crate::input::GetBucketAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the S3 bucket whose ACL is being requested.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAclInput`](crate::input::GetBucketAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetBucketAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetBucketAclInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAclInputOperationOutputAlias = crate::operation::GetBucketAcl;
#[doc(hidden)]
pub type GetBucketAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAclInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAcl`](crate::operation::GetBucketAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketAcl::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("GetBucketAcl", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_200) = &self.expected_bucket_owner {
            let formatted_201 = AsRef::<str>::as_ref(inner_200);
            if !formatted_201.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_201;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("acl");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAclInput`](crate::input::GetBucketAclInput)
    pub fn builder() -> crate::input::get_bucket_acl_input::Builder {
        crate::input::get_bucket_acl_input::Builder::default()
    }
}

/// See [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
pub mod get_bucket_analytics_configuration_input {
    /// A builder for [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which an analytics configuration is retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketAnalyticsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketAnalyticsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAnalyticsConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketAnalyticsConfiguration;
#[doc(hidden)]
pub type GetBucketAnalyticsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAnalyticsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAnalyticsConfiguration`](crate::operation::GetBucketAnalyticsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketAnalyticsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketAnalyticsConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketAnalyticsConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_202) = &self.expected_bucket_owner {
            let formatted_203 = AsRef::<str>::as_ref(inner_202);
            if !formatted_203.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_203;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("analytics");
        query.push_kv("x-id", "GetBucketAnalyticsConfiguration");
        if let Some(inner_204) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_204));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_analytics_configuration_input::Builder {
        crate::input::get_bucket_analytics_configuration_input::Builder::default()
    }
}

/// See [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
pub mod get_bucket_cors_input {
    /// A builder for [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the cors configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetBucketCorsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetBucketCorsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketCorsInputOperationOutputAlias = crate::operation::GetBucketCors;
#[doc(hidden)]
pub type GetBucketCorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketCorsInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketCors`](crate::operation::GetBucketCors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketCors,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketCors::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("GetBucketCors", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_205) = &self.expected_bucket_owner {
            let formatted_206 = AsRef::<str>::as_ref(inner_205);
            if !formatted_206.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_206;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("cors");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
    pub fn builder() -> crate::input::get_bucket_cors_input::Builder {
        crate::input::get_bucket_cors_input::Builder::default()
    }
}

/// See [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
pub mod get_bucket_encryption_input {
    /// A builder for [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which the server-side encryption configuration is
        /// retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketEncryptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketEncryptionInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketEncryptionInputOperationOutputAlias = crate::operation::GetBucketEncryption;
#[doc(hidden)]
pub type GetBucketEncryptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketEncryption`](crate::operation::GetBucketEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketEncryption::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketEncryption",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_207) = &self.expected_bucket_owner {
            let formatted_208 = AsRef::<str>::as_ref(inner_207);
            if !formatted_208.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_208;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("encryption");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
    pub fn builder() -> crate::input::get_bucket_encryption_input::Builder {
        crate::input::get_bucket_encryption_input::Builder::default()
    }
}

/// See [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
pub mod get_bucket_intelligent_tiering_configuration_input {
    /// A builder for [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketIntelligentTieringConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::GetBucketIntelligentTieringConfigurationInput {
                    bucket: self.bucket,
                    id: self.id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type GetBucketIntelligentTieringConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketIntelligentTieringConfiguration;
#[doc(hidden)]
pub type GetBucketIntelligentTieringConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl GetBucketIntelligentTieringConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketIntelligentTieringConfiguration`](crate::operation::GetBucketIntelligentTieringConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketIntelligentTieringConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketIntelligentTieringConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketIntelligentTieringConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("intelligent-tiering");
        query.push_kv("x-id", "GetBucketIntelligentTieringConfiguration");
        if let Some(inner_209) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_209));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_intelligent_tiering_configuration_input::Builder {
        crate::input::get_bucket_intelligent_tiering_configuration_input::Builder::default()
    }
}

/// See [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
pub mod get_bucket_inventory_configuration_input {
    /// A builder for [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the inventory configuration to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketInventoryConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketInventoryConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketInventoryConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketInventoryConfiguration;
#[doc(hidden)]
pub type GetBucketInventoryConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketInventoryConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketInventoryConfiguration`](crate::operation::GetBucketInventoryConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketInventoryConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketInventoryConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketInventoryConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_210) = &self.expected_bucket_owner {
            let formatted_211 = AsRef::<str>::as_ref(inner_210);
            if !formatted_211.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_211;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("inventory");
        query.push_kv("x-id", "GetBucketInventoryConfiguration");
        if let Some(inner_212) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_212));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_inventory_configuration_input::Builder {
        crate::input::get_bucket_inventory_configuration_input::Builder::default()
    }
}

/// See [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
pub mod get_bucket_lifecycle_configuration_input {
    /// A builder for [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the lifecycle information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketLifecycleConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketLifecycleConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketLifecycleConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketLifecycleConfiguration;
#[doc(hidden)]
pub type GetBucketLifecycleConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketLifecycleConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketLifecycleConfiguration`](crate::operation::GetBucketLifecycleConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketLifecycleConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketLifecycleConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketLifecycleConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_213) = &self.expected_bucket_owner {
            let formatted_214 = AsRef::<str>::as_ref(inner_213);
            if !formatted_214.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_214;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("lifecycle");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_lifecycle_configuration_input::Builder {
        crate::input::get_bucket_lifecycle_configuration_input::Builder::default()
    }
}

/// See [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
pub mod get_bucket_location_input {
    /// A builder for [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the location.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketLocationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketLocationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketLocationInputOperationOutputAlias = crate::operation::GetBucketLocation;
#[doc(hidden)]
pub type GetBucketLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketLocationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketLocation`](crate::operation::GetBucketLocation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketLocation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketLocation",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_215) = &self.expected_bucket_owner {
            let formatted_216 = AsRef::<str>::as_ref(inner_215);
            if !formatted_216.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_216;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("location");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
    pub fn builder() -> crate::input::get_bucket_location_input::Builder {
        crate::input::get_bucket_location_input::Builder::default()
    }
}

/// See [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
pub mod get_bucket_logging_input {
    /// A builder for [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the logging information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketLoggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketLoggingInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketLoggingInputOperationOutputAlias = crate::operation::GetBucketLogging;
#[doc(hidden)]
pub type GetBucketLoggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketLoggingInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketLogging`](crate::operation::GetBucketLogging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketLogging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketLogging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketLogging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_217) = &self.expected_bucket_owner {
            let formatted_218 = AsRef::<str>::as_ref(inner_217);
            if !formatted_218.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_218;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("logging");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
    pub fn builder() -> crate::input::get_bucket_logging_input::Builder {
        crate::input::get_bucket_logging_input::Builder::default()
    }
}

/// See [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
pub mod get_bucket_metrics_configuration_input {
    /// A builder for [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the metrics configuration to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketMetricsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketMetricsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketMetricsConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketMetricsConfiguration;
#[doc(hidden)]
pub type GetBucketMetricsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketMetricsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketMetricsConfiguration`](crate::operation::GetBucketMetricsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketMetricsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketMetricsConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketMetricsConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_219) = &self.expected_bucket_owner {
            let formatted_220 = AsRef::<str>::as_ref(inner_219);
            if !formatted_220.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_220;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("metrics");
        query.push_kv("x-id", "GetBucketMetricsConfiguration");
        if let Some(inner_221) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_221));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_metrics_configuration_input::Builder {
        crate::input::get_bucket_metrics_configuration_input::Builder::default()
    }
}

/// See [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
pub mod get_bucket_notification_configuration_input {
    /// A builder for [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the notification configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketNotificationConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketNotificationConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketNotificationConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketNotificationConfiguration;
#[doc(hidden)]
pub type GetBucketNotificationConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketNotificationConfiguration`](crate::operation::GetBucketNotificationConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketNotificationConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketNotificationConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketNotificationConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_222) = &self.expected_bucket_owner {
            let formatted_223 = AsRef::<str>::as_ref(inner_222);
            if !formatted_223.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_223;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("notification");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_notification_configuration_input::Builder {
        crate::input::get_bucket_notification_configuration_input::Builder::default()
    }
}

/// See [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
pub mod get_bucket_ownership_controls_input {
    /// A builder for [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to retrieve.
        /// </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketOwnershipControlsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketOwnershipControlsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketOwnershipControlsInputOperationOutputAlias =
    crate::operation::GetBucketOwnershipControls;
#[doc(hidden)]
pub type GetBucketOwnershipControlsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketOwnershipControlsInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketOwnershipControls`](crate::operation::GetBucketOwnershipControls)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketOwnershipControls,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketOwnershipControls::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketOwnershipControls",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_224) = &self.expected_bucket_owner {
            let formatted_225 = AsRef::<str>::as_ref(inner_224);
            if !formatted_225.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_225;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("ownershipControls");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
    pub fn builder() -> crate::input::get_bucket_ownership_controls_input::Builder {
        crate::input::get_bucket_ownership_controls_input::Builder::default()
    }
}

/// See [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
pub mod get_bucket_policy_input {
    /// A builder for [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the bucket policy.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketPolicyInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketPolicyInputOperationOutputAlias = crate::operation::GetBucketPolicy;
#[doc(hidden)]
pub type GetBucketPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketPolicy`](crate::operation::GetBucketPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketPolicy",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_226) = &self.expected_bucket_owner {
            let formatted_227 = AsRef::<str>::as_ref(inner_226);
            if !formatted_227.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_227;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("policy");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
    pub fn builder() -> crate::input::get_bucket_policy_input::Builder {
        crate::input::get_bucket_policy_input::Builder::default()
    }
}

/// See [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
pub mod get_bucket_policy_status_input {
    /// A builder for [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose policy status you want to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketPolicyStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketPolicyStatusInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketPolicyStatusInputOperationOutputAlias = crate::operation::GetBucketPolicyStatus;
#[doc(hidden)]
pub type GetBucketPolicyStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketPolicyStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketPolicyStatus`](crate::operation::GetBucketPolicyStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketPolicyStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketPolicyStatus::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketPolicyStatus",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_228) = &self.expected_bucket_owner {
            let formatted_229 = AsRef::<str>::as_ref(inner_228);
            if !formatted_229.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_229;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("policyStatus");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
    pub fn builder() -> crate::input::get_bucket_policy_status_input::Builder {
        crate::input::get_bucket_policy_status_input::Builder::default()
    }
}

/// See [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
pub mod get_bucket_replication_input {
    /// A builder for [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the replication information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketReplicationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketReplicationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketReplicationInputOperationOutputAlias = crate::operation::GetBucketReplication;
#[doc(hidden)]
pub type GetBucketReplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketReplicationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketReplication`](crate::operation::GetBucketReplication)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketReplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketReplication::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketReplication",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_230) = &self.expected_bucket_owner {
            let formatted_231 = AsRef::<str>::as_ref(inner_230);
            if !formatted_231.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_231;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("replication");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
    pub fn builder() -> crate::input::get_bucket_replication_input::Builder {
        crate::input::get_bucket_replication_input::Builder::default()
    }
}

/// See [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
pub mod get_bucket_request_payment_input {
    /// A builder for [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the payment request configuration</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketRequestPaymentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketRequestPaymentInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketRequestPaymentInputOperationOutputAlias =
    crate::operation::GetBucketRequestPayment;
#[doc(hidden)]
pub type GetBucketRequestPaymentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketRequestPaymentInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketRequestPayment`](crate::operation::GetBucketRequestPayment)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketRequestPayment,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketRequestPayment::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketRequestPayment",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_232) = &self.expected_bucket_owner {
            let formatted_233 = AsRef::<str>::as_ref(inner_232);
            if !formatted_233.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_233;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("requestPayment");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
    pub fn builder() -> crate::input::get_bucket_request_payment_input::Builder {
        crate::input::get_bucket_request_payment_input::Builder::default()
    }
}

/// See [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
pub mod get_bucket_tagging_input {
    /// A builder for [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the tagging information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketTaggingInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketTaggingInputOperationOutputAlias = crate::operation::GetBucketTagging;
#[doc(hidden)]
pub type GetBucketTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketTaggingInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketTagging`](crate::operation::GetBucketTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketTagging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketTagging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_234) = &self.expected_bucket_owner {
            let formatted_235 = AsRef::<str>::as_ref(inner_234);
            if !formatted_235.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_235;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("tagging");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
    pub fn builder() -> crate::input::get_bucket_tagging_input::Builder {
        crate::input::get_bucket_tagging_input::Builder::default()
    }
}

/// See [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
pub mod get_bucket_versioning_input {
    /// A builder for [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the versioning information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketVersioningInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketVersioningInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketVersioningInputOperationOutputAlias = crate::operation::GetBucketVersioning;
#[doc(hidden)]
pub type GetBucketVersioningInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketVersioningInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketVersioning`](crate::operation::GetBucketVersioning)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketVersioning,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketVersioning::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketVersioning",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_236) = &self.expected_bucket_owner {
            let formatted_237 = AsRef::<str>::as_ref(inner_236);
            if !formatted_237.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_237;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("versioning");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
    pub fn builder() -> crate::input::get_bucket_versioning_input::Builder {
        crate::input::get_bucket_versioning_input::Builder::default()
    }
}

/// See [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
pub mod get_bucket_website_input {
    /// A builder for [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the website configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketWebsiteInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketWebsiteInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketWebsiteInputOperationOutputAlias = crate::operation::GetBucketWebsite;
#[doc(hidden)]
pub type GetBucketWebsiteInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketWebsiteInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketWebsite`](crate::operation::GetBucketWebsite)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketWebsite,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBucketWebsite::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBucketWebsite",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_238) = &self.expected_bucket_owner {
            let formatted_239 = AsRef::<str>::as_ref(inner_238);
            if !formatted_239.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_239;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("website");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
    pub fn builder() -> crate::input::get_bucket_website_input::Builder {
        crate::input::get_bucket_website_input::Builder::default()
    }
}

/// See [`GetObjectInput`](crate::input::GetObjectInput)
pub mod get_object_input {
    /// A builder for [`GetObjectInput`](crate::input::GetObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) if_match: std::option::Option<std::string::String>,
        pub(crate) if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) if_none_match: std::option::Option<std::string::String>,
        pub(crate) if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) range: std::option::Option<std::string::String>,
        pub(crate) response_cache_control: std::option::Option<std::string::String>,
        pub(crate) response_content_disposition: std::option::Option<std::string::String>,
        pub(crate) response_content_encoding: std::option::Option<std::string::String>,
        pub(crate) response_content_language: std::option::Option<std::string::String>,
        pub(crate) response_content_type: std::option::Option<std::string::String>,
        pub(crate) response_expires: std::option::Option<smithy_types::Instant>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
        /// otherwise return a 412 (precondition failed).</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_match = Some(input.into());
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.if_match = input;
            self
        }
        /// <p>Return the object only if it has been modified since the specified time, otherwise
        /// return a 304 (not modified).</p>
        pub fn if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_modified_since = Some(input);
            self
        }
        pub fn set_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_modified_since = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
        /// otherwise return a 304 (not modified).</p>
        pub fn if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_none_match = Some(input.into());
            self
        }
        pub fn set_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.if_none_match = input;
            self
        }
        /// <p>Return the object only if it has not been modified since the specified time, otherwise
        /// return a 412 (precondition failed).</p>
        pub fn if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_unmodified_since = Some(input);
            self
        }
        pub fn set_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_unmodified_since = input;
            self
        }
        /// <p>Key of the object to get.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
        /// Range header, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
        /// <note>
        /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
        /// request.</p>
        /// </note>
        pub fn range(mut self, input: impl Into<std::string::String>) -> Self {
            self.range = Some(input.into());
            self
        }
        pub fn set_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.range = input;
            self
        }
        /// <p>Sets the <code>Cache-Control</code> header of the response.</p>
        pub fn response_cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_cache_control = Some(input.into());
            self
        }
        pub fn set_response_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_cache_control = input;
            self
        }
        /// <p>Sets the <code>Content-Disposition</code> header of the response</p>
        pub fn response_content_disposition(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.response_content_disposition = Some(input.into());
            self
        }
        pub fn set_response_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_disposition = input;
            self
        }
        /// <p>Sets the <code>Content-Encoding</code> header of the response.</p>
        pub fn response_content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_content_encoding = Some(input.into());
            self
        }
        pub fn set_response_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_encoding = input;
            self
        }
        /// <p>Sets the <code>Content-Language</code> header of the response.</p>
        pub fn response_content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_content_language = Some(input.into());
            self
        }
        pub fn set_response_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_language = input;
            self
        }
        /// <p>Sets the <code>Content-Type</code> header of the response.</p>
        pub fn response_content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_content_type = Some(input.into());
            self
        }
        pub fn set_response_content_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_type = input;
            self
        }
        /// <p>Sets the <code>Expires</code> header of the response.</p>
        pub fn response_expires(mut self, input: smithy_types::Instant) -> Self {
            self.response_expires = Some(input);
            self
        }
        pub fn set_response_expires(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.response_expires = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when decrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This
        /// value is used to decrypt the object when recovering it and must match the one used when
        /// storing the data. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
        /// Effectively performs a 'ranged' GET request for the part specified. Useful for downloading
        /// just a part of an object.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectInput`](crate::input::GetObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetObjectInput {
                bucket: self.bucket,
                if_match: self.if_match,
                if_modified_since: self.if_modified_since,
                if_none_match: self.if_none_match,
                if_unmodified_since: self.if_unmodified_since,
                key: self.key,
                range: self.range,
                response_cache_control: self.response_cache_control,
                response_content_disposition: self.response_content_disposition,
                response_content_encoding: self.response_content_encoding,
                response_content_language: self.response_content_language,
                response_content_type: self.response_content_type,
                response_expires: self.response_expires,
                version_id: self.version_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                request_payer: self.request_payer,
                part_number: self.part_number.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectInputOperationOutputAlias = crate::operation::GetObject;
#[doc(hidden)]
pub type GetObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectInput {
    /// Consumes the builder and constructs an Operation<[`GetObject`](crate::operation::GetObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetObject::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetObject", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_240) = &self.if_match {
            let formatted_241 = AsRef::<str>::as_ref(inner_240);
            if !formatted_241.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_241;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-Match", header_value);
            }
        }
        if let Some(inner_242) = &self.if_modified_since {
            let formatted_243 = inner_242.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_243.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_243;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-Modified-Since", header_value);
            }
        }
        if let Some(inner_244) = &self.if_none_match {
            let formatted_245 = AsRef::<str>::as_ref(inner_244);
            if !formatted_245.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_245;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-None-Match", header_value);
            }
        }
        if let Some(inner_246) = &self.if_unmodified_since {
            let formatted_247 = inner_246.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_247.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_247;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-Unmodified-Since", header_value);
            }
        }
        if let Some(inner_248) = &self.range {
            let formatted_249 = AsRef::<str>::as_ref(inner_248);
            if !formatted_249.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_249;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Range", header_value);
            }
        }
        if let Some(inner_250) = &self.sse_customer_algorithm {
            let formatted_251 = AsRef::<str>::as_ref(inner_250);
            if !formatted_251.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_251;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_252) = &self.sse_customer_key {
            let formatted_253 = AsRef::<str>::as_ref(inner_252);
            if !formatted_253.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_253;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_254) = &self.sse_customer_key_md5 {
            let formatted_255 = AsRef::<str>::as_ref(inner_254);
            if !formatted_255.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_255;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_256) = &self.request_payer {
            let formatted_257 = AsRef::<str>::as_ref(inner_256);
            if !formatted_257.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_257;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_258) = &self.expected_bucket_owner {
            let formatted_259 = AsRef::<str>::as_ref(inner_258);
            if !formatted_259.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_259;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "GetObject");
        if let Some(inner_260) = &self.response_cache_control {
            query.push_kv(
                "response-cache-control",
                &smithy_http::query::fmt_string(&inner_260),
            );
        }
        if let Some(inner_261) = &self.response_content_disposition {
            query.push_kv(
                "response-content-disposition",
                &smithy_http::query::fmt_string(&inner_261),
            );
        }
        if let Some(inner_262) = &self.response_content_encoding {
            query.push_kv(
                "response-content-encoding",
                &smithy_http::query::fmt_string(&inner_262),
            );
        }
        if let Some(inner_263) = &self.response_content_language {
            query.push_kv(
                "response-content-language",
                &smithy_http::query::fmt_string(&inner_263),
            );
        }
        if let Some(inner_264) = &self.response_content_type {
            query.push_kv(
                "response-content-type",
                &smithy_http::query::fmt_string(&inner_264),
            );
        }
        if let Some(inner_265) = &self.response_expires {
            query.push_kv(
                "response-expires",
                &smithy_http::query::fmt_timestamp(
                    inner_265,
                    smithy_types::instant::Format::HttpDate,
                ),
            );
        }
        if let Some(inner_266) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_266));
        }
        if self.part_number != 0 {
            query.push_kv(
                "partNumber",
                &smithy_http::query::fmt_default(&&self.part_number),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectInput`](crate::input::GetObjectInput)
    pub fn builder() -> crate::input::get_object_input::Builder {
        crate::input::get_object_input::Builder::default()
    }
}

/// See [`GetObjectAclInput`](crate::input::GetObjectAclInput)
pub mod get_object_acl_input {
    /// A builder for [`GetObjectAclInput`](crate::input::GetObjectAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name that contains the object for which to get the ACL information. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key of the object for which to get the ACL information.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectAclInput`](crate::input::GetObjectAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetObjectAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetObjectAclInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectAclInputOperationOutputAlias = crate::operation::GetObjectAcl;
#[doc(hidden)]
pub type GetObjectAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectAclInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectAcl`](crate::operation::GetObjectAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetObjectAcl::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("GetObjectAcl", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_267) = &self.request_payer {
            let formatted_268 = AsRef::<str>::as_ref(inner_267);
            if !formatted_268.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_268;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_269) = &self.expected_bucket_owner {
            let formatted_270 = AsRef::<str>::as_ref(inner_269);
            if !formatted_270.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_270;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("acl");
        if let Some(inner_271) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_271));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectAclInput`](crate::input::GetObjectAclInput)
    pub fn builder() -> crate::input::get_object_acl_input::Builder {
        crate::input::get_object_acl_input::Builder::default()
    }
}

/// See [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
pub mod get_object_legal_hold_input {
    /// A builder for [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object whose Legal Hold status you want to retrieve. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object whose Legal Hold status you want to retrieve.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The version ID of the object whose Legal Hold status you want to retrieve.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectLegalHoldInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectLegalHoldInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectLegalHoldInputOperationOutputAlias = crate::operation::GetObjectLegalHold;
#[doc(hidden)]
pub type GetObjectLegalHoldInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectLegalHoldInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectLegalHold`](crate::operation::GetObjectLegalHold)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectLegalHold,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetObjectLegalHold::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetObjectLegalHold",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_272) = &self.request_payer {
            let formatted_273 = AsRef::<str>::as_ref(inner_272);
            if !formatted_273.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_273;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_274) = &self.expected_bucket_owner {
            let formatted_275 = AsRef::<str>::as_ref(inner_274);
            if !formatted_275.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_275;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("legal-hold");
        if let Some(inner_276) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_276));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
    pub fn builder() -> crate::input::get_object_legal_hold_input::Builder {
        crate::input::get_object_legal_hold_input::Builder::default()
    }
}

/// See [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
pub mod get_object_lock_configuration_input {
    /// A builder for [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket whose Object Lock configuration you want to retrieve.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectLockConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectLockConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectLockConfigurationInputOperationOutputAlias =
    crate::operation::GetObjectLockConfiguration;
#[doc(hidden)]
pub type GetObjectLockConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectLockConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectLockConfiguration`](crate::operation::GetObjectLockConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectLockConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetObjectLockConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetObjectLockConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_277) = &self.expected_bucket_owner {
            let formatted_278 = AsRef::<str>::as_ref(inner_277);
            if !formatted_278.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_278;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("object-lock");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
    pub fn builder() -> crate::input::get_object_lock_configuration_input::Builder {
        crate::input::get_object_lock_configuration_input::Builder::default()
    }
}

/// See [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
pub mod get_object_retention_input {
    /// A builder for [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object whose retention settings you want to retrieve. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object whose retention settings you want to retrieve.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The version ID for the object whose retention settings you want to retrieve.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectRetentionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectRetentionInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectRetentionInputOperationOutputAlias = crate::operation::GetObjectRetention;
#[doc(hidden)]
pub type GetObjectRetentionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectRetentionInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectRetention`](crate::operation::GetObjectRetention)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectRetention,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetObjectRetention::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetObjectRetention",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_279) = &self.request_payer {
            let formatted_280 = AsRef::<str>::as_ref(inner_279);
            if !formatted_280.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_280;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_281) = &self.expected_bucket_owner {
            let formatted_282 = AsRef::<str>::as_ref(inner_281);
            if !formatted_282.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_282;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("retention");
        if let Some(inner_283) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_283));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
    pub fn builder() -> crate::input::get_object_retention_input::Builder {
        crate::input::get_object_retention_input::Builder::default()
    }
}

/// See [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
pub mod get_object_tagging_input {
    /// A builder for [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
    }
    impl Builder {
        /// <p>The bucket name containing the object for which to get the tagging information. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which to get the tagging information.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The versionId of the object for which to get the tagging information.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectTaggingInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                expected_bucket_owner: self.expected_bucket_owner,
                request_payer: self.request_payer,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectTaggingInputOperationOutputAlias = crate::operation::GetObjectTagging;
#[doc(hidden)]
pub type GetObjectTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectTaggingInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectTagging`](crate::operation::GetObjectTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetObjectTagging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetObjectTagging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_284) = &self.expected_bucket_owner {
            let formatted_285 = AsRef::<str>::as_ref(inner_284);
            if !formatted_285.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_285;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_286) = &self.request_payer {
            let formatted_287 = AsRef::<str>::as_ref(inner_286);
            if !formatted_287.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_287;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("tagging");
        if let Some(inner_288) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_288));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
    pub fn builder() -> crate::input::get_object_tagging_input::Builder {
        crate::input::get_object_tagging_input::Builder::default()
    }
}

/// See [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
pub mod get_object_torrent_input {
    /// A builder for [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the object for which to get the torrent files.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The object key for which to get the information.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectTorrentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectTorrentInput {
                bucket: self.bucket,
                key: self.key,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectTorrentInputOperationOutputAlias = crate::operation::GetObjectTorrent;
#[doc(hidden)]
pub type GetObjectTorrentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectTorrentInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectTorrent`](crate::operation::GetObjectTorrent)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectTorrent,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetObjectTorrent::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetObjectTorrent",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_289) = &self.request_payer {
            let formatted_290 = AsRef::<str>::as_ref(inner_289);
            if !formatted_290.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_290;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_291) = &self.expected_bucket_owner {
            let formatted_292 = AsRef::<str>::as_ref(inner_291);
            if !formatted_292.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_292;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("torrent");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
    pub fn builder() -> crate::input::get_object_torrent_input::Builder {
        crate::input::get_object_torrent_input::Builder::default()
    }
}

/// See [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
pub mod get_public_access_block_input {
    /// A builder for [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
        /// to retrieve. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPublicAccessBlockInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPublicAccessBlockInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPublicAccessBlockInputOperationOutputAlias = crate::operation::GetPublicAccessBlock;
#[doc(hidden)]
pub type GetPublicAccessBlockInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPublicAccessBlockInput {
    /// Consumes the builder and constructs an Operation<[`GetPublicAccessBlock`](crate::operation::GetPublicAccessBlock)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetPublicAccessBlock,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetPublicAccessBlock::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetPublicAccessBlock",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_293) = &self.expected_bucket_owner {
            let formatted_294 = AsRef::<str>::as_ref(inner_293);
            if !formatted_294.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_294;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("publicAccessBlock");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
    pub fn builder() -> crate::input::get_public_access_block_input::Builder {
        crate::input::get_public_access_block_input::Builder::default()
    }
}

/// See [`HeadBucketInput`](crate::input::HeadBucketInput)
pub mod head_bucket_input {
    /// A builder for [`HeadBucketInput`](crate::input::HeadBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`HeadBucketInput`](crate::input::HeadBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::HeadBucketInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::HeadBucketInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type HeadBucketInputOperationOutputAlias = crate::operation::HeadBucket;
#[doc(hidden)]
pub type HeadBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl HeadBucketInput {
    /// Consumes the builder and constructs an Operation<[`HeadBucket`](crate::operation::HeadBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::HeadBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::HeadBucket::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("HeadBucket", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_295) = &self.expected_bucket_owner {
            let formatted_296 = AsRef::<str>::as_ref(inner_295);
            if !formatted_296.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_296;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        let builder = self.add_headers(builder)?;
        Ok(builder.method("HEAD").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`HeadBucketInput`](crate::input::HeadBucketInput)
    pub fn builder() -> crate::input::head_bucket_input::Builder {
        crate::input::head_bucket_input::Builder::default()
    }
}

/// See [`HeadObjectInput`](crate::input::HeadObjectInput)
pub mod head_object_input {
    /// A builder for [`HeadObjectInput`](crate::input::HeadObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) if_match: std::option::Option<std::string::String>,
        pub(crate) if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) if_none_match: std::option::Option<std::string::String>,
        pub(crate) if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) range: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the object.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
        /// otherwise return a 412 (precondition failed).</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_match = Some(input.into());
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.if_match = input;
            self
        }
        /// <p>Return the object only if it has been modified since the specified time, otherwise
        /// return a 304 (not modified).</p>
        pub fn if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_modified_since = Some(input);
            self
        }
        pub fn set_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_modified_since = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
        /// otherwise return a 304 (not modified).</p>
        pub fn if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_none_match = Some(input.into());
            self
        }
        pub fn set_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.if_none_match = input;
            self
        }
        /// <p>Return the object only if it has not been modified since the specified time, otherwise
        /// return a 412 (precondition failed).</p>
        pub fn if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_unmodified_since = Some(input);
            self
        }
        pub fn set_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_unmodified_since = input;
            self
        }
        /// <p>The object key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
        /// Range header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
        /// <note>
        /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
        /// request.</p>
        /// </note>
        pub fn range(mut self, input: impl Into<std::string::String>) -> Self {
            self.range = Some(input.into());
            self
        }
        pub fn set_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.range = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
        /// Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about
        /// the size of the part and the number of parts in this object.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`HeadObjectInput`](crate::input::HeadObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::HeadObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::HeadObjectInput {
                bucket: self.bucket,
                if_match: self.if_match,
                if_modified_since: self.if_modified_since,
                if_none_match: self.if_none_match,
                if_unmodified_since: self.if_unmodified_since,
                key: self.key,
                range: self.range,
                version_id: self.version_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                request_payer: self.request_payer,
                part_number: self.part_number.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type HeadObjectInputOperationOutputAlias = crate::operation::HeadObject;
#[doc(hidden)]
pub type HeadObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl HeadObjectInput {
    /// Consumes the builder and constructs an Operation<[`HeadObject`](crate::operation::HeadObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::HeadObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::HeadObject::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("HeadObject", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_297) = &self.if_match {
            let formatted_298 = AsRef::<str>::as_ref(inner_297);
            if !formatted_298.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_298;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-Match", header_value);
            }
        }
        if let Some(inner_299) = &self.if_modified_since {
            let formatted_300 = inner_299.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_300.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_300;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-Modified-Since", header_value);
            }
        }
        if let Some(inner_301) = &self.if_none_match {
            let formatted_302 = AsRef::<str>::as_ref(inner_301);
            if !formatted_302.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_302;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-None-Match", header_value);
            }
        }
        if let Some(inner_303) = &self.if_unmodified_since {
            let formatted_304 = inner_303.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_304.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_304;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("If-Unmodified-Since", header_value);
            }
        }
        if let Some(inner_305) = &self.range {
            let formatted_306 = AsRef::<str>::as_ref(inner_305);
            if !formatted_306.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_306;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Range", header_value);
            }
        }
        if let Some(inner_307) = &self.sse_customer_algorithm {
            let formatted_308 = AsRef::<str>::as_ref(inner_307);
            if !formatted_308.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_308;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_309) = &self.sse_customer_key {
            let formatted_310 = AsRef::<str>::as_ref(inner_309);
            if !formatted_310.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_310;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_311) = &self.sse_customer_key_md5 {
            let formatted_312 = AsRef::<str>::as_ref(inner_311);
            if !formatted_312.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_312;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_313) = &self.request_payer {
            let formatted_314 = AsRef::<str>::as_ref(inner_313);
            if !formatted_314.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_314;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_315) = &self.expected_bucket_owner {
            let formatted_316 = AsRef::<str>::as_ref(inner_315);
            if !formatted_316.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_316;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_317) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_317));
        }
        if self.part_number != 0 {
            query.push_kv(
                "partNumber",
                &smithy_http::query::fmt_default(&&self.part_number),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("HEAD").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`HeadObjectInput`](crate::input::HeadObjectInput)
    pub fn builder() -> crate::input::head_object_input::Builder {
        crate::input::head_object_input::Builder::default()
    }
}

/// See [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
pub mod list_bucket_analytics_configurations_input {
    /// A builder for [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which analytics configurations are retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ContinuationToken that represents a placeholder from where this request should
        /// begin.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketAnalyticsConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBucketAnalyticsConfigurationsInput {
                bucket: self.bucket,
                continuation_token: self.continuation_token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBucketAnalyticsConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketAnalyticsConfigurations;
#[doc(hidden)]
pub type ListBucketAnalyticsConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketAnalyticsConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketAnalyticsConfigurations`](crate::operation::ListBucketAnalyticsConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketAnalyticsConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBucketAnalyticsConfigurations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBucketAnalyticsConfigurations",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_318) = &self.expected_bucket_owner {
            let formatted_319 = AsRef::<str>::as_ref(inner_318);
            if !formatted_319.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_319;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("analytics");
        query.push_kv("x-id", "ListBucketAnalyticsConfigurations");
        if let Some(inner_320) = &self.continuation_token {
            query.push_kv(
                "continuation-token",
                &smithy_http::query::fmt_string(&inner_320),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_analytics_configurations_input::Builder {
        crate::input::list_bucket_analytics_configurations_input::Builder::default()
    }
}

/// See [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
pub mod list_bucket_intelligent_tiering_configurations_input {
    /// A builder for [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ContinuationToken that represents a placeholder from where this request should
        /// begin.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketIntelligentTieringConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::ListBucketIntelligentTieringConfigurationsInput {
                    bucket: self.bucket,
                    continuation_token: self.continuation_token,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type ListBucketIntelligentTieringConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketIntelligentTieringConfigurations;
#[doc(hidden)]
pub type ListBucketIntelligentTieringConfigurationsInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl ListBucketIntelligentTieringConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketIntelligentTieringConfigurations`](crate::operation::ListBucketIntelligentTieringConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketIntelligentTieringConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBucketIntelligentTieringConfigurations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBucketIntelligentTieringConfigurations",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("intelligent-tiering");
        query.push_kv("x-id", "ListBucketIntelligentTieringConfigurations");
        if let Some(inner_321) = &self.continuation_token {
            query.push_kv(
                "continuation-token",
                &smithy_http::query::fmt_string(&inner_321),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_intelligent_tiering_configurations_input::Builder
    {
        crate::input::list_bucket_intelligent_tiering_configurations_input::Builder::default()
    }
}

/// See [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
pub mod list_bucket_inventory_configurations_input {
    /// A builder for [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the inventory configurations to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The marker used to continue an inventory configuration listing that has been truncated.
        /// Use the NextContinuationToken from a previously truncated list response to continue the
        /// listing. The continuation token is an opaque value that Amazon S3 understands.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketInventoryConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBucketInventoryConfigurationsInput {
                bucket: self.bucket,
                continuation_token: self.continuation_token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBucketInventoryConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketInventoryConfigurations;
#[doc(hidden)]
pub type ListBucketInventoryConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketInventoryConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketInventoryConfigurations`](crate::operation::ListBucketInventoryConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketInventoryConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBucketInventoryConfigurations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBucketInventoryConfigurations",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_322) = &self.expected_bucket_owner {
            let formatted_323 = AsRef::<str>::as_ref(inner_322);
            if !formatted_323.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_323;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("inventory");
        query.push_kv("x-id", "ListBucketInventoryConfigurations");
        if let Some(inner_324) = &self.continuation_token {
            query.push_kv(
                "continuation-token",
                &smithy_http::query::fmt_string(&inner_324),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_inventory_configurations_input::Builder {
        crate::input::list_bucket_inventory_configurations_input::Builder::default()
    }
}

/// See [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
pub mod list_bucket_metrics_configurations_input {
    /// A builder for [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the metrics configurations to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The marker that is used to continue a metrics configuration listing that has been
        /// truncated. Use the NextContinuationToken from a previously truncated list response to
        /// continue the listing. The continuation token is an opaque value that Amazon S3
        /// understands.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketMetricsConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBucketMetricsConfigurationsInput {
                bucket: self.bucket,
                continuation_token: self.continuation_token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBucketMetricsConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketMetricsConfigurations;
#[doc(hidden)]
pub type ListBucketMetricsConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketMetricsConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketMetricsConfigurations`](crate::operation::ListBucketMetricsConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketMetricsConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBucketMetricsConfigurations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBucketMetricsConfigurations",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_325) = &self.expected_bucket_owner {
            let formatted_326 = AsRef::<str>::as_ref(inner_325);
            if !formatted_326.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_326;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("metrics");
        query.push_kv("x-id", "ListBucketMetricsConfigurations");
        if let Some(inner_327) = &self.continuation_token {
            query.push_kv(
                "continuation-token",
                &smithy_http::query::fmt_string(&inner_327),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_metrics_configurations_input::Builder {
        crate::input::list_bucket_metrics_configurations_input::Builder::default()
    }
}

/// See [`ListBucketsInput`](crate::input::ListBucketsInput)
pub mod list_buckets_input {
    /// A builder for [`ListBucketsInput`](crate::input::ListBucketsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ListBucketsInput`](crate::input::ListBucketsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListBucketsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListBucketsInput {})
        }
    }
}
#[doc(hidden)]
pub type ListBucketsInputOperationOutputAlias = crate::operation::ListBuckets;
#[doc(hidden)]
pub type ListBucketsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketsInput {
    /// Consumes the builder and constructs an Operation<[`ListBuckets`](crate::operation::ListBuckets)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBuckets,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBuckets::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListBuckets", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketsInput`](crate::input::ListBucketsInput)
    pub fn builder() -> crate::input::list_buckets_input::Builder {
        crate::input::list_buckets_input::Builder::default()
    }
}

/// See [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
pub mod list_multipart_uploads_input {
    /// A builder for [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) key_marker: std::option::Option<std::string::String>,
        pub(crate) max_uploads: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) upload_id_marker: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket to which the multipart upload was initiated. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Character you use to group keys.</p>
        /// <p>All keys that contain the same string between the prefix, if specified, and the first
        /// occurrence of the delimiter after the prefix are grouped under a single result element,
        /// <code>CommonPrefixes</code>. If you don't specify the prefix parameter, then the
        /// substring starts at the beginning of the key. The keys that are grouped under
        /// <code>CommonPrefixes</code> result element are not returned elsewhere in the
        /// response.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Together with upload-id-marker, this parameter specifies the multipart upload after
        /// which listing should begin.</p>
        /// <p>If <code>upload-id-marker</code> is not specified, only the keys lexicographically
        /// greater than the specified <code>key-marker</code> will be included in the list.</p>
        /// <p>If <code>upload-id-marker</code> is specified, any multipart uploads for a key equal to
        /// the <code>key-marker</code> might also be included, provided those multipart uploads have
        /// upload IDs lexicographically greater than the specified
        /// <code>upload-id-marker</code>.</p>
        pub fn key_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_marker = Some(input.into());
            self
        }
        pub fn set_key_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_marker = input;
            self
        }
        /// <p>Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response
        /// body. 1,000 is the maximum number of uploads that can be returned in a response.</p>
        pub fn max_uploads(mut self, input: i32) -> Self {
            self.max_uploads = Some(input);
            self
        }
        pub fn set_max_uploads(mut self, input: std::option::Option<i32>) -> Self {
            self.max_uploads = input;
            self
        }
        /// <p>Lists in-progress uploads only for those keys that begin with the specified prefix. You
        /// can use prefixes to separate a bucket into different grouping of keys. (You can think of
        /// using prefix to make groups in the same way you'd use a folder in a file system.)</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Together with key-marker, specifies the multipart upload after which listing should
        /// begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
        /// Otherwise, any multipart uploads for a key equal to the key-marker might be included in the
        /// list only if they have an upload ID lexicographically greater than the specified
        /// <code>upload-id-marker</code>.</p>
        pub fn upload_id_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id_marker = Some(input.into());
            self
        }
        pub fn set_upload_id_marker(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upload_id_marker = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMultipartUploadsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMultipartUploadsInput {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                key_marker: self.key_marker,
                max_uploads: self.max_uploads.unwrap_or_default(),
                prefix: self.prefix,
                upload_id_marker: self.upload_id_marker,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMultipartUploadsInputOperationOutputAlias = crate::operation::ListMultipartUploads;
#[doc(hidden)]
pub type ListMultipartUploadsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMultipartUploadsInput {
    /// Consumes the builder and constructs an Operation<[`ListMultipartUploads`](crate::operation::ListMultipartUploads)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListMultipartUploads,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListMultipartUploads::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListMultipartUploads",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_328) = &self.expected_bucket_owner {
            let formatted_329 = AsRef::<str>::as_ref(inner_328);
            if !formatted_329.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_329;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("uploads");
        if let Some(inner_330) = &self.delimiter {
            query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_330));
        }
        if let Some(inner_331) = &self.encoding_type {
            query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_331));
        }
        if let Some(inner_332) = &self.key_marker {
            query.push_kv("key-marker", &smithy_http::query::fmt_string(&inner_332));
        }
        if self.max_uploads != 0 {
            query.push_kv(
                "max-uploads",
                &smithy_http::query::fmt_default(&&self.max_uploads),
            );
        }
        if let Some(inner_333) = &self.prefix {
            query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_333));
        }
        if let Some(inner_334) = &self.upload_id_marker {
            query.push_kv(
                "upload-id-marker",
                &smithy_http::query::fmt_string(&inner_334),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
    pub fn builder() -> crate::input::list_multipart_uploads_input::Builder {
        crate::input::list_multipart_uploads_input::Builder::default()
    }
}

/// See [`ListObjectsInput`](crate::input::ListObjectsInput)
pub mod list_objects_input {
    /// A builder for [`ListObjectsInput`](crate::input::ListObjectsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_keys: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the objects.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A delimiter is a character you use to group keys.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Specifies the key to start with when listing objects in a bucket.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain more.
        /// </p>
        pub fn max_keys(mut self, input: i32) -> Self {
            self.max_keys = Some(input);
            self
        }
        pub fn set_max_keys(mut self, input: std::option::Option<i32>) -> Self {
            self.max_keys = input;
            self
        }
        /// <p>Limits the response to keys that begin with the specified prefix.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Confirms that the requester knows that she or he will be charged for the list objects
        /// request. Bucket owners need not specify this parameter in their requests.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListObjectsInput`](crate::input::ListObjectsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListObjectsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListObjectsInput {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                marker: self.marker,
                max_keys: self.max_keys.unwrap_or_default(),
                prefix: self.prefix,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListObjectsInputOperationOutputAlias = crate::operation::ListObjects;
#[doc(hidden)]
pub type ListObjectsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListObjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListObjects`](crate::operation::ListObjects)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListObjects,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListObjects::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListObjects", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_335) = &self.request_payer {
            let formatted_336 = AsRef::<str>::as_ref(inner_335);
            if !formatted_336.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_336;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_337) = &self.expected_bucket_owner {
            let formatted_338 = AsRef::<str>::as_ref(inner_337);
            if !formatted_338.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_338;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_339) = &self.delimiter {
            query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_339));
        }
        if let Some(inner_340) = &self.encoding_type {
            query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_340));
        }
        if let Some(inner_341) = &self.marker {
            query.push_kv("marker", &smithy_http::query::fmt_string(&inner_341));
        }
        if self.max_keys != 0 {
            query.push_kv(
                "max-keys",
                &smithy_http::query::fmt_default(&&self.max_keys),
            );
        }
        if let Some(inner_342) = &self.prefix {
            query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_342));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListObjectsInput`](crate::input::ListObjectsInput)
    pub fn builder() -> crate::input::list_objects_input::Builder {
        crate::input::list_objects_input::Builder::default()
    }
}

/// See [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
pub mod list_objects_v2_input {
    /// A builder for [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) max_keys: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) fetch_owner: std::option::Option<bool>,
        pub(crate) start_after: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Bucket name to list. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A delimiter is a character you use to group keys.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain
        /// more.</p>
        pub fn max_keys(mut self, input: i32) -> Self {
            self.max_keys = Some(input);
            self
        }
        pub fn set_max_keys(mut self, input: std::option::Option<i32>) -> Self {
            self.max_keys = input;
            self
        }
        /// <p>Limits the response to keys that begin with the specified prefix.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a
        /// token. ContinuationToken is obfuscated and is not a real key.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The owner field is not present in listV2 by default, if you want to return owner field
        /// with each key in the result then set the fetch owner field to true.</p>
        pub fn fetch_owner(mut self, input: bool) -> Self {
            self.fetch_owner = Some(input);
            self
        }
        pub fn set_fetch_owner(mut self, input: std::option::Option<bool>) -> Self {
            self.fetch_owner = input;
            self
        }
        /// <p>StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this
        /// specified key. StartAfter can be any key in the bucket.</p>
        pub fn start_after(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_after = Some(input.into());
            self
        }
        pub fn set_start_after(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_after = input;
            self
        }
        /// <p>Confirms that the requester knows that she or he will be charged for the list objects
        /// request in V2 style. Bucket owners need not specify this parameter in their
        /// requests.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListObjectsV2Input, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListObjectsV2Input {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                max_keys: self.max_keys.unwrap_or_default(),
                prefix: self.prefix,
                continuation_token: self.continuation_token,
                fetch_owner: self.fetch_owner.unwrap_or_default(),
                start_after: self.start_after,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListObjectsV2InputOperationOutputAlias = crate::operation::ListObjectsV2;
#[doc(hidden)]
pub type ListObjectsV2InputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListObjectsV2Input {
    /// Consumes the builder and constructs an Operation<[`ListObjectsV2`](crate::operation::ListObjectsV2)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListObjectsV2,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListObjectsV2::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListObjectsV2", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_343) = &self.request_payer {
            let formatted_344 = AsRef::<str>::as_ref(inner_343);
            if !formatted_344.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_344;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_345) = &self.expected_bucket_owner {
            let formatted_346 = AsRef::<str>::as_ref(inner_345);
            if !formatted_346.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_346;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("list-type", "2");
        if let Some(inner_347) = &self.delimiter {
            query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_347));
        }
        if let Some(inner_348) = &self.encoding_type {
            query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_348));
        }
        if self.max_keys != 0 {
            query.push_kv(
                "max-keys",
                &smithy_http::query::fmt_default(&&self.max_keys),
            );
        }
        if let Some(inner_349) = &self.prefix {
            query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_349));
        }
        if let Some(inner_350) = &self.continuation_token {
            query.push_kv(
                "continuation-token",
                &smithy_http::query::fmt_string(&inner_350),
            );
        }
        if self.fetch_owner {
            query.push_kv(
                "fetch-owner",
                &smithy_http::query::fmt_default(&&self.fetch_owner),
            );
        }
        if let Some(inner_351) = &self.start_after {
            query.push_kv("start-after", &smithy_http::query::fmt_string(&inner_351));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
    pub fn builder() -> crate::input::list_objects_v2_input::Builder {
        crate::input::list_objects_v2_input::Builder::default()
    }
}

/// See [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
pub mod list_object_versions_input {
    /// A builder for [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) key_marker: std::option::Option<std::string::String>,
        pub(crate) max_keys: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) version_id_marker: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name that contains the objects. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
        /// same string between the <code>prefix</code> and the first occurrence of the delimiter are
        /// grouped under a single result element in CommonPrefixes. These groups are counted as one
        /// result against the max-keys limitation. These keys are not returned elsewhere in the
        /// response.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Specifies the key to start with when listing objects in a bucket.</p>
        pub fn key_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_marker = Some(input.into());
            self
        }
        pub fn set_key_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_marker = input;
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain more. If
        /// additional keys satisfy the search criteria, but were not returned because max-keys was
        /// exceeded, the response contains <isTruncated>true</isTruncated>. To return the
        /// additional keys, see key-marker and version-id-marker.</p>
        pub fn max_keys(mut self, input: i32) -> Self {
            self.max_keys = Some(input);
            self
        }
        pub fn set_max_keys(mut self, input: std::option::Option<i32>) -> Self {
            self.max_keys = input;
            self
        }
        /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
        /// can use prefixes to separate a bucket into different groupings of keys. (You can think of
        /// using prefix to make groups in the same way you'd use a folder in a file system.) You can
        /// use prefix with delimiter to roll up numerous objects into a single result under
        /// CommonPrefixes. </p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Specifies the object version you want to start listing from.</p>
        pub fn version_id_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id_marker = Some(input.into());
            self
        }
        pub fn set_version_id_marker(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.version_id_marker = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListObjectVersionsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListObjectVersionsInput {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                key_marker: self.key_marker,
                max_keys: self.max_keys.unwrap_or_default(),
                prefix: self.prefix,
                version_id_marker: self.version_id_marker,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListObjectVersionsInputOperationOutputAlias = crate::operation::ListObjectVersions;
#[doc(hidden)]
pub type ListObjectVersionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListObjectVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListObjectVersions`](crate::operation::ListObjectVersions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListObjectVersions,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListObjectVersions::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListObjectVersions",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_352) = &self.expected_bucket_owner {
            let formatted_353 = AsRef::<str>::as_ref(inner_352);
            if !formatted_353.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_353;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("versions");
        if let Some(inner_354) = &self.delimiter {
            query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_354));
        }
        if let Some(inner_355) = &self.encoding_type {
            query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_355));
        }
        if let Some(inner_356) = &self.key_marker {
            query.push_kv("key-marker", &smithy_http::query::fmt_string(&inner_356));
        }
        if self.max_keys != 0 {
            query.push_kv(
                "max-keys",
                &smithy_http::query::fmt_default(&&self.max_keys),
            );
        }
        if let Some(inner_357) = &self.prefix {
            query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_357));
        }
        if let Some(inner_358) = &self.version_id_marker {
            query.push_kv(
                "version-id-marker",
                &smithy_http::query::fmt_string(&inner_358),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
    pub fn builder() -> crate::input::list_object_versions_input::Builder {
        crate::input::list_object_versions_input::Builder::default()
    }
}

/// See [`ListPartsInput`](crate::input::ListPartsInput)
pub mod list_parts_input {
    /// A builder for [`ListPartsInput`](crate::input::ListPartsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) max_parts: std::option::Option<i32>,
        pub(crate) part_number_marker: std::option::Option<std::string::String>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket to which the parts are being uploaded. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Sets the maximum number of parts to return.</p>
        pub fn max_parts(mut self, input: i32) -> Self {
            self.max_parts = Some(input);
            self
        }
        pub fn set_max_parts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_parts = input;
            self
        }
        /// <p>Specifies the part after which listing should begin. Only parts with higher part numbers
        /// will be listed.</p>
        pub fn part_number_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.part_number_marker = Some(input.into());
            self
        }
        pub fn set_part_number_marker(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.part_number_marker = input;
            self
        }
        /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPartsInput`](crate::input::ListPartsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListPartsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListPartsInput {
                bucket: self.bucket,
                key: self.key,
                max_parts: self.max_parts.unwrap_or_default(),
                part_number_marker: self.part_number_marker,
                upload_id: self.upload_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPartsInputOperationOutputAlias = crate::operation::ListParts;
#[doc(hidden)]
pub type ListPartsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPartsInput {
    /// Consumes the builder and constructs an Operation<[`ListParts`](crate::operation::ListParts)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListParts,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::ListParts::new())
                    .with_metadata(smithy_http::operation::Metadata::new("ListParts", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_359) = &self.request_payer {
            let formatted_360 = AsRef::<str>::as_ref(inner_359);
            if !formatted_360.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_360;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_361) = &self.expected_bucket_owner {
            let formatted_362 = AsRef::<str>::as_ref(inner_361);
            if !formatted_362.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_362;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "ListParts");
        if self.max_parts != 0 {
            query.push_kv(
                "max-parts",
                &smithy_http::query::fmt_default(&&self.max_parts),
            );
        }
        if let Some(inner_363) = &self.part_number_marker {
            query.push_kv(
                "part-number-marker",
                &smithy_http::query::fmt_string(&inner_363),
            );
        }
        if let Some(inner_364) = &self.upload_id {
            query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_364));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPartsInput`](crate::input::ListPartsInput)
    pub fn builder() -> crate::input::list_parts_input::Builder {
        crate::input::list_parts_input::Builder::default()
    }
}

/// See [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
pub mod put_bucket_accelerate_configuration_input {
    /// A builder for [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) accelerate_configuration:
            std::option::Option<crate::model::AccelerateConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket for which the accelerate configuration is set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for setting the transfer acceleration state.</p>
        pub fn accelerate_configuration(
            mut self,
            input: crate::model::AccelerateConfiguration,
        ) -> Self {
            self.accelerate_configuration = Some(input);
            self
        }
        pub fn set_accelerate_configuration(
            mut self,
            input: std::option::Option<crate::model::AccelerateConfiguration>,
        ) -> Self {
            self.accelerate_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketAccelerateConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketAccelerateConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
                accelerate_configuration: self.accelerate_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketAccelerateConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketAccelerateConfiguration;
#[doc(hidden)]
pub type PutBucketAccelerateConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketAccelerateConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketAccelerateConfiguration`](crate::operation::PutBucketAccelerateConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketAccelerateConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_accelerate_configuration_input(
                &self.accelerate_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketAccelerateConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketAccelerateConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_365) = &self.expected_bucket_owner {
            let formatted_366 = AsRef::<str>::as_ref(inner_365);
            if !formatted_366.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_366;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("accelerate");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_accelerate_configuration_input::Builder {
        crate::input::put_bucket_accelerate_configuration_input::Builder::default()
    }
}

/// See [`PutBucketAclInput`](crate::input::PutBucketAclInput)
pub mod put_bucket_acl_input {
    /// A builder for [`PutBucketAclInput`](crate::input::PutBucketAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::BucketCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the bucket.</p>
        pub fn acl(mut self, input: crate::model::BucketCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::BucketCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The bucket to which to apply the ACL.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.</a>
        /// </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write = Some(input.into());
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_write = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
        pub fn access_control_policy(mut self, input: crate::model::AccessControlPolicy) -> Self {
            self.access_control_policy = Some(input);
            self
        }
        pub fn set_access_control_policy(
            mut self,
            input: std::option::Option<crate::model::AccessControlPolicy>,
        ) -> Self {
            self.access_control_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketAclInput`](crate::input::PutBucketAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutBucketAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutBucketAclInput {
                acl: self.acl,
                bucket: self.bucket,
                content_md5: self.content_md5,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write: self.grant_write,
                grant_write_acp: self.grant_write_acp,
                expected_bucket_owner: self.expected_bucket_owner,
                access_control_policy: self.access_control_policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketAclInputOperationOutputAlias = crate::operation::PutBucketAcl;
#[doc(hidden)]
pub type PutBucketAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketAclInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketAcl`](crate::operation::PutBucketAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_acl_input(
                &self.access_control_policy,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketAcl::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("PutBucketAcl", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_367) = &self.acl {
            let formatted_368 = AsRef::<str>::as_ref(inner_367);
            if !formatted_368.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_368;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-acl", header_value);
            }
        }
        if let Some(inner_369) = &self.content_md5 {
            let formatted_370 = AsRef::<str>::as_ref(inner_369);
            if !formatted_370.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_370;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_371) = &self.grant_full_control {
            let formatted_372 = AsRef::<str>::as_ref(inner_371);
            if !formatted_372.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_372;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-full-control", header_value);
            }
        }
        if let Some(inner_373) = &self.grant_read {
            let formatted_374 = AsRef::<str>::as_ref(inner_373);
            if !formatted_374.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_374;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read", header_value);
            }
        }
        if let Some(inner_375) = &self.grant_read_acp {
            let formatted_376 = AsRef::<str>::as_ref(inner_375);
            if !formatted_376.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_376;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read-acp", header_value);
            }
        }
        if let Some(inner_377) = &self.grant_write {
            let formatted_378 = AsRef::<str>::as_ref(inner_377);
            if !formatted_378.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_378;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write", header_value);
            }
        }
        if let Some(inner_379) = &self.grant_write_acp {
            let formatted_380 = AsRef::<str>::as_ref(inner_379);
            if !formatted_380.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_380;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write-acp", header_value);
            }
        }
        if let Some(inner_381) = &self.expected_bucket_owner {
            let formatted_382 = AsRef::<str>::as_ref(inner_381);
            if !formatted_382.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_382;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("acl");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketAclInput`](crate::input::PutBucketAclInput)
    pub fn builder() -> crate::input::put_bucket_acl_input::Builder {
        crate::input::put_bucket_acl_input::Builder::default()
    }
}

/// See [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
pub mod put_bucket_analytics_configuration_input {
    /// A builder for [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) analytics_configuration:
            std::option::Option<crate::model::AnalyticsConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket to which an analytics configuration is stored.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The configuration and any analyses for the analytics filter.</p>
        pub fn analytics_configuration(
            mut self,
            input: crate::model::AnalyticsConfiguration,
        ) -> Self {
            self.analytics_configuration = Some(input);
            self
        }
        pub fn set_analytics_configuration(
            mut self,
            input: std::option::Option<crate::model::AnalyticsConfiguration>,
        ) -> Self {
            self.analytics_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketAnalyticsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketAnalyticsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
                analytics_configuration: self.analytics_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketAnalyticsConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketAnalyticsConfiguration;
#[doc(hidden)]
pub type PutBucketAnalyticsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketAnalyticsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketAnalyticsConfiguration`](crate::operation::PutBucketAnalyticsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketAnalyticsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_analytics_configuration_input(
                &self.analytics_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketAnalyticsConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketAnalyticsConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_383) = &self.expected_bucket_owner {
            let formatted_384 = AsRef::<str>::as_ref(inner_383);
            if !formatted_384.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_384;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("analytics");
        if let Some(inner_385) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_385));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_analytics_configuration_input::Builder {
        crate::input::put_bucket_analytics_configuration_input::Builder::default()
    }
}

/// See [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
pub mod put_bucket_cors_input {
    /// A builder for [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) cors_configuration: std::option::Option<crate::model::CorsConfiguration>,
    }
    impl Builder {
        /// <p>Specifies the bucket impacted by the <code>cors</code>configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.</a>
        /// </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource
        /// Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn cors_configuration(mut self, input: crate::model::CorsConfiguration) -> Self {
            self.cors_configuration = Some(input);
            self
        }
        pub fn set_cors_configuration(
            mut self,
            input: std::option::Option<crate::model::CorsConfiguration>,
        ) -> Self {
            self.cors_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutBucketCorsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutBucketCorsInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                cors_configuration: self.cors_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketCorsInputOperationOutputAlias = crate::operation::PutBucketCors;
#[doc(hidden)]
pub type PutBucketCorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketCorsInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketCors`](crate::operation::PutBucketCors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketCors,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_put_bucket_cors_input(&self.cors_configuration)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketCors::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("PutBucketCors", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_386) = &self.content_md5 {
            let formatted_387 = AsRef::<str>::as_ref(inner_386);
            if !formatted_387.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_387;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_388) = &self.expected_bucket_owner {
            let formatted_389 = AsRef::<str>::as_ref(inner_388);
            if !formatted_389.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_389;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("cors");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
    pub fn builder() -> crate::input::put_bucket_cors_input::Builder {
        crate::input::put_bucket_cors_input::Builder::default()
    }
}

/// See [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
pub mod put_bucket_encryption_input {
    /// A builder for [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) server_side_encryption_configuration:
            std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
    }
    impl Builder {
        /// <p>Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed
        /// keys (SSE-S3) or customer master keys stored in AWS KMS (SSE-KMS). For information about
        /// the Amazon S3 default encryption feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html">Amazon S3 Default Bucket Encryption</a>
        /// in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the server-side encryption configuration.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Specifies the default server-side-encryption configuration.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            input: crate::model::ServerSideEncryptionConfiguration,
        ) -> Self {
            self.server_side_encryption_configuration = Some(input);
            self
        }
        pub fn set_server_side_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        ) -> Self {
            self.server_side_encryption_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketEncryptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketEncryptionInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                server_side_encryption_configuration: self.server_side_encryption_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketEncryptionInputOperationOutputAlias = crate::operation::PutBucketEncryption;
#[doc(hidden)]
pub type PutBucketEncryptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketEncryption`](crate::operation::PutBucketEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_encryption_input(
                &self.server_side_encryption_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketEncryption::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketEncryption",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_390) = &self.content_md5 {
            let formatted_391 = AsRef::<str>::as_ref(inner_390);
            if !formatted_391.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_391;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_392) = &self.expected_bucket_owner {
            let formatted_393 = AsRef::<str>::as_ref(inner_392);
            if !formatted_393.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_393;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("encryption");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
    pub fn builder() -> crate::input::put_bucket_encryption_input::Builder {
        crate::input::put_bucket_encryption_input::Builder::default()
    }
}

/// See [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
pub mod put_bucket_intelligent_tiering_configuration_input {
    /// A builder for [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) intelligent_tiering_configuration:
            std::option::Option<crate::model::IntelligentTieringConfiguration>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Container for S3 Intelligent-Tiering configuration.</p>
        pub fn intelligent_tiering_configuration(
            mut self,
            input: crate::model::IntelligentTieringConfiguration,
        ) -> Self {
            self.intelligent_tiering_configuration = Some(input);
            self
        }
        pub fn set_intelligent_tiering_configuration(
            mut self,
            input: std::option::Option<crate::model::IntelligentTieringConfiguration>,
        ) -> Self {
            self.intelligent_tiering_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketIntelligentTieringConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::PutBucketIntelligentTieringConfigurationInput {
                    bucket: self.bucket,
                    id: self.id,
                    intelligent_tiering_configuration: self.intelligent_tiering_configuration,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type PutBucketIntelligentTieringConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketIntelligentTieringConfiguration;
#[doc(hidden)]
pub type PutBucketIntelligentTieringConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl PutBucketIntelligentTieringConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketIntelligentTieringConfiguration`](crate::operation::PutBucketIntelligentTieringConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketIntelligentTieringConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_put_bucket_intelligent_tiering_configuration_input(& self.intelligent_tiering_configuration)?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketIntelligentTieringConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketIntelligentTieringConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("intelligent-tiering");
        if let Some(inner_394) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_394));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_intelligent_tiering_configuration_input::Builder {
        crate::input::put_bucket_intelligent_tiering_configuration_input::Builder::default()
    }
}

/// See [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
pub mod put_bucket_inventory_configuration_input {
    /// A builder for [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) inventory_configuration:
            std::option::Option<crate::model::InventoryConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket where the inventory configuration will be stored.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Specifies the inventory configuration.</p>
        pub fn inventory_configuration(
            mut self,
            input: crate::model::InventoryConfiguration,
        ) -> Self {
            self.inventory_configuration = Some(input);
            self
        }
        pub fn set_inventory_configuration(
            mut self,
            input: std::option::Option<crate::model::InventoryConfiguration>,
        ) -> Self {
            self.inventory_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketInventoryConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketInventoryConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
                inventory_configuration: self.inventory_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketInventoryConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketInventoryConfiguration;
#[doc(hidden)]
pub type PutBucketInventoryConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketInventoryConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketInventoryConfiguration`](crate::operation::PutBucketInventoryConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketInventoryConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_inventory_configuration_input(
                &self.inventory_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketInventoryConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketInventoryConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_395) = &self.expected_bucket_owner {
            let formatted_396 = AsRef::<str>::as_ref(inner_395);
            if !formatted_396.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_396;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("inventory");
        if let Some(inner_397) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_397));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_inventory_configuration_input::Builder {
        crate::input::put_bucket_inventory_configuration_input::Builder::default()
    }
}

/// See [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
pub mod put_bucket_lifecycle_configuration_input {
    /// A builder for [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) lifecycle_configuration:
            std::option::Option<crate::model::BucketLifecycleConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to set the configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
        pub fn lifecycle_configuration(
            mut self,
            input: crate::model::BucketLifecycleConfiguration,
        ) -> Self {
            self.lifecycle_configuration = Some(input);
            self
        }
        pub fn set_lifecycle_configuration(
            mut self,
            input: std::option::Option<crate::model::BucketLifecycleConfiguration>,
        ) -> Self {
            self.lifecycle_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketLifecycleConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketLifecycleConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
                lifecycle_configuration: self.lifecycle_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketLifecycleConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketLifecycleConfiguration;
#[doc(hidden)]
pub type PutBucketLifecycleConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketLifecycleConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketLifecycleConfiguration`](crate::operation::PutBucketLifecycleConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketLifecycleConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_lifecycle_configuration_input(
                &self.lifecycle_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketLifecycleConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketLifecycleConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_398) = &self.expected_bucket_owner {
            let formatted_399 = AsRef::<str>::as_ref(inner_398);
            if !formatted_399.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_399;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("lifecycle");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_lifecycle_configuration_input::Builder {
        crate::input::put_bucket_lifecycle_configuration_input::Builder::default()
    }
}

/// See [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
pub mod put_bucket_logging_input {
    /// A builder for [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) bucket_logging_status: std::option::Option<crate::model::BucketLoggingStatus>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to set the logging parameters.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the <code>PutBucketLogging</code> request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for logging status information.</p>
        pub fn bucket_logging_status(mut self, input: crate::model::BucketLoggingStatus) -> Self {
            self.bucket_logging_status = Some(input);
            self
        }
        pub fn set_bucket_logging_status(
            mut self,
            input: std::option::Option<crate::model::BucketLoggingStatus>,
        ) -> Self {
            self.bucket_logging_status = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketLoggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketLoggingInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                bucket_logging_status: self.bucket_logging_status,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketLoggingInputOperationOutputAlias = crate::operation::PutBucketLogging;
#[doc(hidden)]
pub type PutBucketLoggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketLoggingInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketLogging`](crate::operation::PutBucketLogging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketLogging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_logging_input(
                &self.bucket_logging_status,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketLogging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketLogging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_400) = &self.content_md5 {
            let formatted_401 = AsRef::<str>::as_ref(inner_400);
            if !formatted_401.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_401;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_402) = &self.expected_bucket_owner {
            let formatted_403 = AsRef::<str>::as_ref(inner_402);
            if !formatted_403.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_403;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("logging");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
    pub fn builder() -> crate::input::put_bucket_logging_input::Builder {
        crate::input::put_bucket_logging_input::Builder::default()
    }
}

/// See [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
pub mod put_bucket_metrics_configuration_input {
    /// A builder for [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) metrics_configuration: std::option::Option<crate::model::MetricsConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket for which the metrics configuration is set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Specifies the metrics configuration.</p>
        pub fn metrics_configuration(mut self, input: crate::model::MetricsConfiguration) -> Self {
            self.metrics_configuration = Some(input);
            self
        }
        pub fn set_metrics_configuration(
            mut self,
            input: std::option::Option<crate::model::MetricsConfiguration>,
        ) -> Self {
            self.metrics_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketMetricsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketMetricsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
                metrics_configuration: self.metrics_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketMetricsConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketMetricsConfiguration;
#[doc(hidden)]
pub type PutBucketMetricsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketMetricsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketMetricsConfiguration`](crate::operation::PutBucketMetricsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketMetricsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_metrics_configuration_input(
                &self.metrics_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketMetricsConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketMetricsConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_404) = &self.expected_bucket_owner {
            let formatted_405 = AsRef::<str>::as_ref(inner_404);
            if !formatted_405.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_405;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("metrics");
        if let Some(inner_406) = &self.id {
            query.push_kv("id", &smithy_http::query::fmt_string(&inner_406));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_metrics_configuration_input::Builder {
        crate::input::put_bucket_metrics_configuration_input::Builder::default()
    }
}

/// See [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
pub mod put_bucket_notification_configuration_input {
    /// A builder for [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) notification_configuration:
            std::option::Option<crate::model::NotificationConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>A container for specifying the notification configuration of the bucket. If this element
        /// is empty, notifications are turned off for the bucket.</p>
        pub fn notification_configuration(
            mut self,
            input: crate::model::NotificationConfiguration,
        ) -> Self {
            self.notification_configuration = Some(input);
            self
        }
        pub fn set_notification_configuration(
            mut self,
            input: std::option::Option<crate::model::NotificationConfiguration>,
        ) -> Self {
            self.notification_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketNotificationConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketNotificationConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
                notification_configuration: self.notification_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketNotificationConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketNotificationConfiguration;
#[doc(hidden)]
pub type PutBucketNotificationConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketNotificationConfiguration`](crate::operation::PutBucketNotificationConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketNotificationConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_put_bucket_notification_configuration_input(
                    &self.notification_configuration,
                )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketNotificationConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketNotificationConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_407) = &self.expected_bucket_owner {
            let formatted_408 = AsRef::<str>::as_ref(inner_407);
            if !formatted_408.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_408;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("notification");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_notification_configuration_input::Builder {
        crate::input::put_bucket_notification_configuration_input::Builder::default()
    }
}

/// See [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
pub mod put_bucket_ownership_controls_input {
    /// A builder for [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) ownership_controls: std::option::Option<crate::model::OwnershipControls>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the <code>OwnershipControls</code> request body. </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) that you want
        /// to apply to this Amazon S3 bucket.</p>
        pub fn ownership_controls(mut self, input: crate::model::OwnershipControls) -> Self {
            self.ownership_controls = Some(input);
            self
        }
        pub fn set_ownership_controls(
            mut self,
            input: std::option::Option<crate::model::OwnershipControls>,
        ) -> Self {
            self.ownership_controls = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketOwnershipControlsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketOwnershipControlsInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                ownership_controls: self.ownership_controls,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketOwnershipControlsInputOperationOutputAlias =
    crate::operation::PutBucketOwnershipControls;
#[doc(hidden)]
pub type PutBucketOwnershipControlsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketOwnershipControlsInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketOwnershipControls`](crate::operation::PutBucketOwnershipControls)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketOwnershipControls,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_ownership_controls_input(
                &self.ownership_controls,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketOwnershipControls::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketOwnershipControls",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_409) = &self.content_md5 {
            let formatted_410 = AsRef::<str>::as_ref(inner_409);
            if !formatted_410.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_410;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_411) = &self.expected_bucket_owner {
            let formatted_412 = AsRef::<str>::as_ref(inner_411);
            if !formatted_412.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_412;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("ownershipControls");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
    pub fn builder() -> crate::input::put_bucket_ownership_controls_input::Builder {
        crate::input::put_bucket_ownership_controls_input::Builder::default()
    }
}

/// See [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
pub mod put_bucket_policy_input {
    /// A builder for [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) confirm_remove_self_bucket_access: std::option::Option<bool>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Set this parameter to true to confirm that you want to remove your permissions to change
        /// this bucket policy in the future.</p>
        pub fn confirm_remove_self_bucket_access(mut self, input: bool) -> Self {
            self.confirm_remove_self_bucket_access = Some(input);
            self
        }
        pub fn set_confirm_remove_self_bucket_access(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.confirm_remove_self_bucket_access = input;
            self
        }
        /// <p>The bucket policy as a JSON document.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketPolicyInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                confirm_remove_self_bucket_access: self
                    .confirm_remove_self_bucket_access
                    .unwrap_or_default(),
                policy: self.policy,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketPolicyInputOperationOutputAlias = crate::operation::PutBucketPolicy;
#[doc(hidden)]
pub type PutBucketPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketPolicy`](crate::operation::PutBucketPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_policy_input(&self.policy)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketPolicy",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_413) = &self.content_md5 {
            let formatted_414 = AsRef::<str>::as_ref(inner_413);
            if !formatted_414.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_414;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if self.confirm_remove_self_bucket_access {
            let formatted_415 =
                smithy_http::query::fmt_default(&&self.confirm_remove_self_bucket_access);
            if !formatted_415.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_415;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "confirm_remove_self_bucket_access",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-confirm-remove-self-bucket-access", header_value);
            }
        }
        if let Some(inner_416) = &self.expected_bucket_owner {
            let formatted_417 = AsRef::<str>::as_ref(inner_416);
            if !formatted_417.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_417;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("policy");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(builder, "content-type", "text/plain");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
    pub fn builder() -> crate::input::put_bucket_policy_input::Builder {
        crate::input::put_bucket_policy_input::Builder::default()
    }
}

/// See [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
pub mod put_bucket_replication_input {
    /// A builder for [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) replication_configuration:
            std::option::Option<crate::model::ReplicationConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
        /// replication configuration is 2 MB.</p>
        pub fn replication_configuration(
            mut self,
            input: crate::model::ReplicationConfiguration,
        ) -> Self {
            self.replication_configuration = Some(input);
            self
        }
        pub fn set_replication_configuration(
            mut self,
            input: std::option::Option<crate::model::ReplicationConfiguration>,
        ) -> Self {
            self.replication_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketReplicationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketReplicationInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                token: self.token,
                expected_bucket_owner: self.expected_bucket_owner,
                replication_configuration: self.replication_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketReplicationInputOperationOutputAlias = crate::operation::PutBucketReplication;
#[doc(hidden)]
pub type PutBucketReplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketReplicationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketReplication`](crate::operation::PutBucketReplication)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketReplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_replication_input(
                &self.replication_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketReplication::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketReplication",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_418) = &self.content_md5 {
            let formatted_419 = AsRef::<str>::as_ref(inner_418);
            if !formatted_419.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_419;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_420) = &self.token {
            let formatted_421 = AsRef::<str>::as_ref(inner_420);
            if !formatted_421.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_421;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "token",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-bucket-object-lock-token", header_value);
            }
        }
        if let Some(inner_422) = &self.expected_bucket_owner {
            let formatted_423 = AsRef::<str>::as_ref(inner_422);
            if !formatted_423.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_423;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("replication");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
    pub fn builder() -> crate::input::put_bucket_replication_input::Builder {
        crate::input::put_bucket_replication_input::Builder::default()
    }
}

/// See [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
pub mod put_bucket_request_payment_input {
    /// A builder for [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) request_payment_configuration:
            std::option::Option<crate::model::RequestPaymentConfiguration>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
        /// message integrity check to verify that the request body was not corrupted in transit. For
        /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for Payer.</p>
        pub fn request_payment_configuration(
            mut self,
            input: crate::model::RequestPaymentConfiguration,
        ) -> Self {
            self.request_payment_configuration = Some(input);
            self
        }
        pub fn set_request_payment_configuration(
            mut self,
            input: std::option::Option<crate::model::RequestPaymentConfiguration>,
        ) -> Self {
            self.request_payment_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketRequestPaymentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketRequestPaymentInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                request_payment_configuration: self.request_payment_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketRequestPaymentInputOperationOutputAlias =
    crate::operation::PutBucketRequestPayment;
#[doc(hidden)]
pub type PutBucketRequestPaymentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketRequestPaymentInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketRequestPayment`](crate::operation::PutBucketRequestPayment)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketRequestPayment,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_request_payment_input(
                &self.request_payment_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketRequestPayment::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketRequestPayment",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_424) = &self.content_md5 {
            let formatted_425 = AsRef::<str>::as_ref(inner_424);
            if !formatted_425.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_425;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_426) = &self.expected_bucket_owner {
            let formatted_427 = AsRef::<str>::as_ref(inner_426);
            if !formatted_427.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_427;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("requestPayment");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
    pub fn builder() -> crate::input::put_bucket_request_payment_input::Builder {
        crate::input::put_bucket_request_payment_input::Builder::default()
    }
}

/// See [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
pub mod put_bucket_tagging_input {
    /// A builder for [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) tagging: std::option::Option<crate::model::Tagging>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements.</p>
        pub fn tagging(mut self, input: crate::model::Tagging) -> Self {
            self.tagging = Some(input);
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<crate::model::Tagging>) -> Self {
            self.tagging = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketTaggingInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                tagging: self.tagging,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketTaggingInputOperationOutputAlias = crate::operation::PutBucketTagging;
#[doc(hidden)]
pub type PutBucketTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketTaggingInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketTagging`](crate::operation::PutBucketTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_tagging_input(&self.tagging)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketTagging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketTagging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_428) = &self.content_md5 {
            let formatted_429 = AsRef::<str>::as_ref(inner_428);
            if !formatted_429.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_429;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_430) = &self.expected_bucket_owner {
            let formatted_431 = AsRef::<str>::as_ref(inner_430);
            if !formatted_431.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_431;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("tagging");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
    pub fn builder() -> crate::input::put_bucket_tagging_input::Builder {
        crate::input::put_bucket_tagging_input::Builder::default()
    }
}

/// See [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
pub mod put_bucket_versioning_input {
    /// A builder for [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) mfa: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) versioning_configuration:
            std::option::Option<crate::model::VersioningConfiguration>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
        /// message integrity check to verify that the request body was not corrupted in transit. For
        /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device.</p>
        pub fn mfa(mut self, input: impl Into<std::string::String>) -> Self {
            self.mfa = Some(input.into());
            self
        }
        pub fn set_mfa(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mfa = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for setting the versioning state.</p>
        pub fn versioning_configuration(
            mut self,
            input: crate::model::VersioningConfiguration,
        ) -> Self {
            self.versioning_configuration = Some(input);
            self
        }
        pub fn set_versioning_configuration(
            mut self,
            input: std::option::Option<crate::model::VersioningConfiguration>,
        ) -> Self {
            self.versioning_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketVersioningInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketVersioningInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                mfa: self.mfa,
                expected_bucket_owner: self.expected_bucket_owner,
                versioning_configuration: self.versioning_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketVersioningInputOperationOutputAlias = crate::operation::PutBucketVersioning;
#[doc(hidden)]
pub type PutBucketVersioningInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketVersioningInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketVersioning`](crate::operation::PutBucketVersioning)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketVersioning,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_versioning_input(
                &self.versioning_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketVersioning::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketVersioning",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_432) = &self.content_md5 {
            let formatted_433 = AsRef::<str>::as_ref(inner_432);
            if !formatted_433.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_433;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_434) = &self.mfa {
            let formatted_435 = AsRef::<str>::as_ref(inner_434);
            if !formatted_435.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_435;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "mfa",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-mfa", header_value);
            }
        }
        if let Some(inner_436) = &self.expected_bucket_owner {
            let formatted_437 = AsRef::<str>::as_ref(inner_436);
            if !formatted_437.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_437;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("versioning");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
    pub fn builder() -> crate::input::put_bucket_versioning_input::Builder {
        crate::input::put_bucket_versioning_input::Builder::default()
    }
}

/// See [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
pub mod put_bucket_website_input {
    /// A builder for [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) website_configuration: std::option::Option<crate::model::WebsiteConfiguration>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for the request.</p>
        pub fn website_configuration(mut self, input: crate::model::WebsiteConfiguration) -> Self {
            self.website_configuration = Some(input);
            self
        }
        pub fn set_website_configuration(
            mut self,
            input: std::option::Option<crate::model::WebsiteConfiguration>,
        ) -> Self {
            self.website_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketWebsiteInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketWebsiteInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                website_configuration: self.website_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketWebsiteInputOperationOutputAlias = crate::operation::PutBucketWebsite;
#[doc(hidden)]
pub type PutBucketWebsiteInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketWebsiteInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketWebsite`](crate::operation::PutBucketWebsite)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketWebsite,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_bucket_website_input(
                &self.website_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBucketWebsite::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBucketWebsite",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_438) = &self.content_md5 {
            let formatted_439 = AsRef::<str>::as_ref(inner_438);
            if !formatted_439.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_439;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_440) = &self.expected_bucket_owner {
            let formatted_441 = AsRef::<str>::as_ref(inner_440);
            if !formatted_441.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_441;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("website");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
    pub fn builder() -> crate::input::put_bucket_website_input::Builder {
        crate::input::put_bucket_website_input::Builder::default()
    }
}

/// See [`PutObjectInput`](crate::input::PutObjectInput)
pub mod put_object_input {
    /// A builder for [`PutObjectInput`](crate::input::PutObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) body: std::option::Option<smithy_http::byte_stream::ByteStream>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_length: std::option::Option<i64>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) website_redirect_location: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) ssekms_encryption_context: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<std::string::String>,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned
        /// ACL</a>.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>Object data.</p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.body = input;
            self
        }
        /// <p>The bucket name to which the PUT action was initiated. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p> Can be used to specify caching behavior along the request/reply chain. For more
        /// information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
        /// determined automatically. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the message (without the headers) according to
        /// RFC 1864. This header can be used as a message integrity check to verify that the data is
        /// the same data that was originally sent. Although it is optional, we recommend using the
        /// Content-MD5 mechanism as an end-to-end integrity check. For more information about REST
        /// request authentication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST
        /// Authentication</a>.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>A standard MIME type describing the format of the contents. For more information, see
        /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable. For more information, see
        /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21</a>.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Object key for which the PUT action was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata. For information about object metadata, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a>.</p>
        /// <p>In the following example, the request header sets the redirect to an object
        /// (anotherPage.html) in the same bucket:</p>
        /// <p>
        /// <code>x-amz-website-redirect-location: /anotherPage.html</code>
        /// </p>
        /// <p>In the following example, the request header sets the object redirect to another
        /// website:</p>
        /// <p>
        /// <code>x-amz-website-redirect-location: http://www.example.com/</code>
        /// </p>
        /// <p>For more information about website hosting in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">Hosting Websites on Amazon S3</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html">How to Configure Website Page
        /// Redirects</a>. </p>
        pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_redirect_location = Some(input.into());
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_redirect_location = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
        /// <code>aws:kms</code>, this header specifies the ID of the AWS Key Management Service
        /// (AWS KMS) symmetrical customer managed customer master key (CMK) that was used for the
        /// object. If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but do not
        /// provide<code> x-amz-server-side-encryption-aws-kms-key-id</code>, Amazon S3 uses the AWS
        /// managed CMK in AWS to protect the data. If the KMS key does not exist in the same account
        /// issuing the command, you must use the full ARN and not just the ID.
        /// </p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_encryption_context = Some(input.into());
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_encryption_context = input;
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
        /// <p>Specifying this header with a PUT action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For
        /// example, "Key1=Value1")</p>
        pub fn tagging(mut self, input: impl Into<std::string::String>) -> Self {
            self.tagging = Some(input.into());
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>The Object Lock mode that you want to apply to this object.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>The date and time when you want this object's Object Lock to expire. Must be formatted
        /// as a timestamp parameter.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>Specifies whether a legal hold will be applied to this object. For more information
        /// about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
        /// Lock</a>.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectInput`](crate::input::PutObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutObjectInput {
                acl: self.acl,
                body: self.body.unwrap_or_default(),
                bucket: self.bucket,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_length: self.content_length.unwrap_or_default(),
                content_md5: self.content_md5,
                content_type: self.content_type,
                expires: self.expires,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                metadata: self.metadata,
                server_side_encryption: self.server_side_encryption,
                storage_class: self.storage_class,
                website_redirect_location: self.website_redirect_location,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                ssekms_key_id: self.ssekms_key_id,
                ssekms_encryption_context: self.ssekms_encryption_context,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
                request_payer: self.request_payer,
                tagging: self.tagging,
                object_lock_mode: self.object_lock_mode,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectInputOperationOutputAlias = crate::operation::PutObject;
#[doc(hidden)]
pub type PutObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectInput {
    /// Consumes the builder and constructs an Operation<[`PutObject`](crate::operation::PutObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_object_input(self.body)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::PutObject::new())
                    .with_metadata(smithy_http::operation::Metadata::new("PutObject", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_442) = &self.acl {
            let formatted_443 = AsRef::<str>::as_ref(inner_442);
            if !formatted_443.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_443;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-acl", header_value);
            }
        }
        if let Some(inner_444) = &self.cache_control {
            let formatted_445 = AsRef::<str>::as_ref(inner_444);
            if !formatted_445.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_445;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Cache-Control", header_value);
            }
        }
        if let Some(inner_446) = &self.content_disposition {
            let formatted_447 = AsRef::<str>::as_ref(inner_446);
            if !formatted_447.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_447;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Disposition", header_value);
            }
        }
        if let Some(inner_448) = &self.content_encoding {
            let formatted_449 = AsRef::<str>::as_ref(inner_448);
            if !formatted_449.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_449;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Encoding", header_value);
            }
        }
        if let Some(inner_450) = &self.content_language {
            let formatted_451 = AsRef::<str>::as_ref(inner_450);
            if !formatted_451.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_451;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Language", header_value);
            }
        }
        if self.content_length != 0 {
            let formatted_452 = smithy_http::query::fmt_default(&&self.content_length);
            if !formatted_452.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_452;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_length",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Length", header_value);
            }
        }
        if let Some(inner_453) = &self.content_md5 {
            let formatted_454 = AsRef::<str>::as_ref(inner_453);
            if !formatted_454.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_454;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_455) = &self.content_type {
            let formatted_456 = AsRef::<str>::as_ref(inner_455);
            if !formatted_456.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_456;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Type", header_value);
            }
        }
        if let Some(inner_457) = &self.expires {
            let formatted_458 = inner_457.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_458.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_458;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Expires", header_value);
            }
        }
        if let Some(inner_459) = &self.grant_full_control {
            let formatted_460 = AsRef::<str>::as_ref(inner_459);
            if !formatted_460.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_460;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-full-control", header_value);
            }
        }
        if let Some(inner_461) = &self.grant_read {
            let formatted_462 = AsRef::<str>::as_ref(inner_461);
            if !formatted_462.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_462;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read", header_value);
            }
        }
        if let Some(inner_463) = &self.grant_read_acp {
            let formatted_464 = AsRef::<str>::as_ref(inner_463);
            if !formatted_464.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_464;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read-acp", header_value);
            }
        }
        if let Some(inner_465) = &self.grant_write_acp {
            let formatted_466 = AsRef::<str>::as_ref(inner_465);
            if !formatted_466.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_466;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write-acp", header_value);
            }
        }
        if let Some(inner_467) = &self.server_side_encryption {
            let formatted_468 = AsRef::<str>::as_ref(inner_467);
            if !formatted_468.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_468;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption", header_value);
            }
        }
        if let Some(inner_469) = &self.storage_class {
            let formatted_470 = AsRef::<str>::as_ref(inner_469);
            if !formatted_470.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_470;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-storage-class", header_value);
            }
        }
        if let Some(inner_471) = &self.website_redirect_location {
            let formatted_472 = AsRef::<str>::as_ref(inner_471);
            if !formatted_472.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_472;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "website_redirect_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-website-redirect-location", header_value);
            }
        }
        if let Some(inner_473) = &self.sse_customer_algorithm {
            let formatted_474 = AsRef::<str>::as_ref(inner_473);
            if !formatted_474.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_474;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_475) = &self.sse_customer_key {
            let formatted_476 = AsRef::<str>::as_ref(inner_475);
            if !formatted_476.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_476;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_477) = &self.sse_customer_key_md5 {
            let formatted_478 = AsRef::<str>::as_ref(inner_477);
            if !formatted_478.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_478;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_479) = &self.ssekms_key_id {
            let formatted_480 = AsRef::<str>::as_ref(inner_479);
            if !formatted_480.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_480;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder =
                    builder.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
            }
        }
        if let Some(inner_481) = &self.ssekms_encryption_context {
            let formatted_482 = AsRef::<str>::as_ref(inner_481);
            if !formatted_482.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_482;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_encryption_context",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-context", header_value);
            }
        }
        if self.bucket_key_enabled {
            let formatted_483 = smithy_http::query::fmt_default(&&self.bucket_key_enabled);
            if !formatted_483.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_483;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_484) = &self.request_payer {
            let formatted_485 = AsRef::<str>::as_ref(inner_484);
            if !formatted_485.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_485;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_486) = &self.tagging {
            let formatted_487 = AsRef::<str>::as_ref(inner_486);
            if !formatted_487.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_487;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "tagging",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-tagging", header_value);
            }
        }
        if let Some(inner_488) = &self.object_lock_mode {
            let formatted_489 = AsRef::<str>::as_ref(inner_488);
            if !formatted_489.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_489;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-mode", header_value);
            }
        }
        if let Some(inner_490) = &self.object_lock_retain_until_date {
            let formatted_491 = inner_490.fmt(smithy_types::instant::Format::DateTime);
            if !formatted_491.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_491;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-retain-until-date", header_value);
            }
        }
        if let Some(inner_492) = &self.object_lock_legal_hold_status {
            let formatted_493 = AsRef::<str>::as_ref(inner_492);
            if !formatted_493.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_493;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-object-lock-legal-hold", header_value);
            }
        }
        if let Some(inner_494) = &self.expected_bucket_owner {
            let formatted_495 = AsRef::<str>::as_ref(inner_494);
            if !formatted_495.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_495;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_496) = &self.metadata {
            for (k, v) in inner_496 {
                use std::str::FromStr;
                let header_name =
                    http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header name: {}", k, err),
                        })?;
                use std::convert::TryFrom;
                let header_value = AsRef::<str>::as_ref(v);
                let header_value =
                    http::header::HeaderValue::try_from(header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header value: {}", v, err),
                        }
                    })?;
                builder = builder.header(header_name, header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "PutObject");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/octet-stream",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectInput`](crate::input::PutObjectInput)
    pub fn builder() -> crate::input::put_object_input::Builder {
        crate::input::put_object_input::Builder::default()
    }
}

/// See [`PutObjectAclInput`](crate::input::PutObjectAclInput)
pub mod put_object_acl_input {
    /// A builder for [`PutObjectAclInput`](crate::input::PutObjectAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The bucket name that contains the object to which you want to attach the ACL. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.></a>
        /// </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to list the objects in the
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write = Some(input.into());
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_write = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Key for which the PUT action was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
        pub fn access_control_policy(mut self, input: crate::model::AccessControlPolicy) -> Self {
            self.access_control_policy = Some(input);
            self
        }
        pub fn set_access_control_policy(
            mut self,
            input: std::option::Option<crate::model::AccessControlPolicy>,
        ) -> Self {
            self.access_control_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectAclInput`](crate::input::PutObjectAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutObjectAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutObjectAclInput {
                acl: self.acl,
                bucket: self.bucket,
                content_md5: self.content_md5,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write: self.grant_write,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                request_payer: self.request_payer,
                version_id: self.version_id,
                expected_bucket_owner: self.expected_bucket_owner,
                access_control_policy: self.access_control_policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectAclInputOperationOutputAlias = crate::operation::PutObjectAcl;
#[doc(hidden)]
pub type PutObjectAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectAclInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectAcl`](crate::operation::PutObjectAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_object_acl_input(
                &self.access_control_policy,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutObjectAcl::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("PutObjectAcl", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_497) = &self.acl {
            let formatted_498 = AsRef::<str>::as_ref(inner_497);
            if !formatted_498.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_498;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-acl", header_value);
            }
        }
        if let Some(inner_499) = &self.content_md5 {
            let formatted_500 = AsRef::<str>::as_ref(inner_499);
            if !formatted_500.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_500;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_501) = &self.grant_full_control {
            let formatted_502 = AsRef::<str>::as_ref(inner_501);
            if !formatted_502.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_502;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-full-control", header_value);
            }
        }
        if let Some(inner_503) = &self.grant_read {
            let formatted_504 = AsRef::<str>::as_ref(inner_503);
            if !formatted_504.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_504;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read", header_value);
            }
        }
        if let Some(inner_505) = &self.grant_read_acp {
            let formatted_506 = AsRef::<str>::as_ref(inner_505);
            if !formatted_506.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_506;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-read-acp", header_value);
            }
        }
        if let Some(inner_507) = &self.grant_write {
            let formatted_508 = AsRef::<str>::as_ref(inner_507);
            if !formatted_508.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_508;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write", header_value);
            }
        }
        if let Some(inner_509) = &self.grant_write_acp {
            let formatted_510 = AsRef::<str>::as_ref(inner_509);
            if !formatted_510.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_510;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-grant-write-acp", header_value);
            }
        }
        if let Some(inner_511) = &self.request_payer {
            let formatted_512 = AsRef::<str>::as_ref(inner_511);
            if !formatted_512.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_512;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_513) = &self.expected_bucket_owner {
            let formatted_514 = AsRef::<str>::as_ref(inner_513);
            if !formatted_514.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_514;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("acl");
        if let Some(inner_515) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_515));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectAclInput`](crate::input::PutObjectAclInput)
    pub fn builder() -> crate::input::put_object_acl_input::Builder {
        crate::input::put_object_acl_input::Builder::default()
    }
}

/// See [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
pub mod put_object_legal_hold_input {
    /// A builder for [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) legal_hold: std::option::Option<crate::model::ObjectLockLegalHold>,
    }
    impl Builder {
        /// <p>The bucket name containing the object that you want to place a Legal Hold on. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object that you want to place a Legal Hold on.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The version ID of the object that you want to place a Legal Hold on.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container element for the Legal Hold configuration you want to apply to the specified
        /// object.</p>
        pub fn legal_hold(mut self, input: crate::model::ObjectLockLegalHold) -> Self {
            self.legal_hold = Some(input);
            self
        }
        pub fn set_legal_hold(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHold>,
        ) -> Self {
            self.legal_hold = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectLegalHoldInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectLegalHoldInput {
                bucket: self.bucket,
                key: self.key,
                request_payer: self.request_payer,
                version_id: self.version_id,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                legal_hold: self.legal_hold,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectLegalHoldInputOperationOutputAlias = crate::operation::PutObjectLegalHold;
#[doc(hidden)]
pub type PutObjectLegalHoldInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectLegalHoldInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectLegalHold`](crate::operation::PutObjectLegalHold)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectLegalHold,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_put_object_legal_hold_input(&self.legal_hold)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutObjectLegalHold::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutObjectLegalHold",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_516) = &self.request_payer {
            let formatted_517 = AsRef::<str>::as_ref(inner_516);
            if !formatted_517.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_517;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_518) = &self.content_md5 {
            let formatted_519 = AsRef::<str>::as_ref(inner_518);
            if !formatted_519.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_519;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_520) = &self.expected_bucket_owner {
            let formatted_521 = AsRef::<str>::as_ref(inner_520);
            if !formatted_521.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_521;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("legal-hold");
        if let Some(inner_522) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_522));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
    pub fn builder() -> crate::input::put_object_legal_hold_input::Builder {
        crate::input::put_object_legal_hold_input::Builder::default()
    }
}

/// See [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
pub mod put_object_lock_configuration_input {
    /// A builder for [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) token: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) object_lock_configuration:
            std::option::Option<crate::model::ObjectLockConfiguration>,
    }
    impl Builder {
        /// <p>The bucket whose Object Lock configuration you want to create or replace.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The Object Lock configuration that you want to apply to the specified bucket.</p>
        pub fn object_lock_configuration(
            mut self,
            input: crate::model::ObjectLockConfiguration,
        ) -> Self {
            self.object_lock_configuration = Some(input);
            self
        }
        pub fn set_object_lock_configuration(
            mut self,
            input: std::option::Option<crate::model::ObjectLockConfiguration>,
        ) -> Self {
            self.object_lock_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectLockConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectLockConfigurationInput {
                bucket: self.bucket,
                request_payer: self.request_payer,
                token: self.token,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                object_lock_configuration: self.object_lock_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectLockConfigurationInputOperationOutputAlias =
    crate::operation::PutObjectLockConfiguration;
#[doc(hidden)]
pub type PutObjectLockConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectLockConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectLockConfiguration`](crate::operation::PutObjectLockConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectLockConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_object_lock_configuration_input(
                &self.object_lock_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutObjectLockConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutObjectLockConfiguration",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_523) = &self.request_payer {
            let formatted_524 = AsRef::<str>::as_ref(inner_523);
            if !formatted_524.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_524;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_525) = &self.token {
            let formatted_526 = AsRef::<str>::as_ref(inner_525);
            if !formatted_526.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_526;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "token",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-bucket-object-lock-token", header_value);
            }
        }
        if let Some(inner_527) = &self.content_md5 {
            let formatted_528 = AsRef::<str>::as_ref(inner_527);
            if !formatted_528.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_528;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_529) = &self.expected_bucket_owner {
            let formatted_530 = AsRef::<str>::as_ref(inner_529);
            if !formatted_530.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_530;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("object-lock");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
    pub fn builder() -> crate::input::put_object_lock_configuration_input::Builder {
        crate::input::put_object_lock_configuration_input::Builder::default()
    }
}

/// See [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
pub mod put_object_retention_input {
    /// A builder for [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) bypass_governance_retention: std::option::Option<bool>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) retention: std::option::Option<crate::model::ObjectLockRetention>,
    }
    impl Builder {
        /// <p>The bucket name that contains the object you want to apply this Object Retention
        /// configuration to. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object that you want to apply this Object Retention configuration
        /// to.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The version ID for the object that you want to apply this Object Retention configuration
        /// to.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Indicates whether this action should bypass Governance-mode restrictions.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.bypass_governance_retention = Some(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.bypass_governance_retention = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The container element for the Object Retention configuration.</p>
        pub fn retention(mut self, input: crate::model::ObjectLockRetention) -> Self {
            self.retention = Some(input);
            self
        }
        pub fn set_retention(
            mut self,
            input: std::option::Option<crate::model::ObjectLockRetention>,
        ) -> Self {
            self.retention = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectRetentionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectRetentionInput {
                bucket: self.bucket,
                key: self.key,
                request_payer: self.request_payer,
                version_id: self.version_id,
                bypass_governance_retention: self.bypass_governance_retention.unwrap_or_default(),
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                retention: self.retention,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectRetentionInputOperationOutputAlias = crate::operation::PutObjectRetention;
#[doc(hidden)]
pub type PutObjectRetentionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectRetentionInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectRetention`](crate::operation::PutObjectRetention)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectRetention,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_put_object_retention_input(&self.retention)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutObjectRetention::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutObjectRetention",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_531) = &self.request_payer {
            let formatted_532 = AsRef::<str>::as_ref(inner_531);
            if !formatted_532.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_532;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if self.bypass_governance_retention {
            let formatted_533 = smithy_http::query::fmt_default(&&self.bypass_governance_retention);
            if !formatted_533.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_533;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bypass_governance_retention",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-bypass-governance-retention", header_value);
            }
        }
        if let Some(inner_534) = &self.content_md5 {
            let formatted_535 = AsRef::<str>::as_ref(inner_534);
            if !formatted_535.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_535;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_536) = &self.expected_bucket_owner {
            let formatted_537 = AsRef::<str>::as_ref(inner_536);
            if !formatted_537.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_537;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("retention");
        if let Some(inner_538) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_538));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
    pub fn builder() -> crate::input::put_object_retention_input::Builder {
        crate::input::put_object_retention_input::Builder::default()
    }
}

/// See [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
pub mod put_object_tagging_input {
    /// A builder for [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<crate::model::Tagging>,
    }
    impl Builder {
        /// <p>The bucket name containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Name of the object key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The versionId of the object that the tag-set will be added to.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements</p>
        pub fn tagging(mut self, input: crate::model::Tagging) -> Self {
            self.tagging = Some(input);
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<crate::model::Tagging>) -> Self {
            self.tagging = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectTaggingInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                request_payer: self.request_payer,
                tagging: self.tagging,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectTaggingInputOperationOutputAlias = crate::operation::PutObjectTagging;
#[doc(hidden)]
pub type PutObjectTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectTaggingInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectTagging`](crate::operation::PutObjectTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_object_tagging_input(&self.tagging)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutObjectTagging::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutObjectTagging",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_539) = &self.content_md5 {
            let formatted_540 = AsRef::<str>::as_ref(inner_539);
            if !formatted_540.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_540;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_541) = &self.expected_bucket_owner {
            let formatted_542 = AsRef::<str>::as_ref(inner_541);
            if !formatted_542.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_542;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_543) = &self.request_payer {
            let formatted_544 = AsRef::<str>::as_ref(inner_543);
            if !formatted_544.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_544;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("tagging");
        if let Some(inner_545) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_545));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
    pub fn builder() -> crate::input::put_object_tagging_input::Builder {
        crate::input::put_object_tagging_input::Builder::default()
    }
}

/// See [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
pub mod put_public_access_block_input {
    /// A builder for [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) public_access_block_configuration:
            std::option::Option<crate::model::PublicAccessBlockConfiguration>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
        /// to set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the <code>PutPublicAccessBlock</code> request body. </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3
        /// bucket. You can enable the configuration options in any combination. For more information
        /// about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn public_access_block_configuration(
            mut self,
            input: crate::model::PublicAccessBlockConfiguration,
        ) -> Self {
            self.public_access_block_configuration = Some(input);
            self
        }
        pub fn set_public_access_block_configuration(
            mut self,
            input: std::option::Option<crate::model::PublicAccessBlockConfiguration>,
        ) -> Self {
            self.public_access_block_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutPublicAccessBlockInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutPublicAccessBlockInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                public_access_block_configuration: self.public_access_block_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutPublicAccessBlockInputOperationOutputAlias = crate::operation::PutPublicAccessBlock;
#[doc(hidden)]
pub type PutPublicAccessBlockInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutPublicAccessBlockInput {
    /// Consumes the builder and constructs an Operation<[`PutPublicAccessBlock`](crate::operation::PutPublicAccessBlock)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutPublicAccessBlock,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_put_public_access_block_input(
                &self.public_access_block_configuration,
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request = request.augment(|mut req, _| {
                let data = req.body().bytes().ok_or_else(|| {
                    smithy_http::operation::BuildError::SerializationError(
                        "checksum can only be computed for non-streaming operations".into(),
                    )
                })?;
                let checksum = md5::compute(data);
                req.headers_mut().insert(
                    http::header::HeaderName::from_static("content-md5"),
                    format!("{:x}", checksum)
                        .parse()
                        .expect("checksum is valid header value"),
                );
                Result::<_, smithy_http::operation::BuildError>::Ok(req)
            })?;
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutPublicAccessBlock::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutPublicAccessBlock",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_546) = &self.content_md5 {
            let formatted_547 = AsRef::<str>::as_ref(inner_546);
            if !formatted_547.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_547;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_548) = &self.expected_bucket_owner {
            let formatted_549 = AsRef::<str>::as_ref(inner_548);
            if !formatted_549.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_549;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("publicAccessBlock");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
    pub fn builder() -> crate::input::put_public_access_block_input::Builder {
        crate::input::put_public_access_block_input::Builder::default()
    }
}

/// See [`RestoreObjectInput`](crate::input::RestoreObjectInput)
pub mod restore_object_input {
    /// A builder for [`RestoreObjectInput`](crate::input::RestoreObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) restore_request: std::option::Option<crate::model::RestoreRequest>,
    }
    impl Builder {
        /// <p>The bucket name containing the object to restore. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which the action was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Container for restore job parameters.</p>
        pub fn restore_request(mut self, input: crate::model::RestoreRequest) -> Self {
            self.restore_request = Some(input);
            self
        }
        pub fn set_restore_request(
            mut self,
            input: std::option::Option<crate::model::RestoreRequest>,
        ) -> Self {
            self.restore_request = input;
            self
        }
        /// Consumes the builder and constructs a [`RestoreObjectInput`](crate::input::RestoreObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::RestoreObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::RestoreObjectInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
                restore_request: self.restore_request,
            })
        }
    }
}
#[doc(hidden)]
pub type RestoreObjectInputOperationOutputAlias = crate::operation::RestoreObject;
#[doc(hidden)]
pub type RestoreObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RestoreObjectInput {
    /// Consumes the builder and constructs an Operation<[`RestoreObject`](crate::operation::RestoreObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::RestoreObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_restore_object_input(&self.restore_request)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RestoreObject::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("RestoreObject", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_550) = &self.request_payer {
            let formatted_551 = AsRef::<str>::as_ref(inner_550);
            if !formatted_551.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_551;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_552) = &self.expected_bucket_owner {
            let formatted_553 = AsRef::<str>::as_ref(inner_552);
            if !formatted_553.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_553;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_v("restore");
        query.push_kv("x-id", "RestoreObject");
        if let Some(inner_554) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_554));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RestoreObjectInput`](crate::input::RestoreObjectInput)
    pub fn builder() -> crate::input::restore_object_input::Builder {
        crate::input::restore_object_input::Builder::default()
    }
}

/// See [`UploadPartInput`](crate::input::UploadPartInput)
pub mod upload_part_input {
    /// A builder for [`UploadPartInput`](crate::input::UploadPartInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<smithy_http::byte_stream::ByteStream>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_length: std::option::Option<i64>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Object data.</p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.body = input;
            self
        }
        /// <p>The name of the bucket to which the multipart upload was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
        /// determined automatically.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated
        /// when using the command from the CLI. This parameter is required if object lock parameters
        /// are specified.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Part number of part being uploaded. This is a positive integer between 1 and
        /// 10,000.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>Upload ID identifying the multipart upload whose part is being uploaded.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm header</code>. This must be the
        /// same encryption key specified in the initiate multipart upload request.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadPartInput`](crate::input::UploadPartInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UploadPartInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UploadPartInput {
                body: self.body.unwrap_or_default(),
                bucket: self.bucket,
                content_length: self.content_length.unwrap_or_default(),
                content_md5: self.content_md5,
                key: self.key,
                part_number: self.part_number.unwrap_or_default(),
                upload_id: self.upload_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadPartInputOperationOutputAlias = crate::operation::UploadPart;
#[doc(hidden)]
pub type UploadPartInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadPartInput {
    /// Consumes the builder and constructs an Operation<[`UploadPart`](crate::operation::UploadPart)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UploadPart,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_upload_part_input(self.body)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UploadPart::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("UploadPart", "s3"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if self.content_length != 0 {
            let formatted_555 = smithy_http::query::fmt_default(&&self.content_length);
            if !formatted_555.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_555;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_length",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Length", header_value);
            }
        }
        if let Some(inner_556) = &self.content_md5 {
            let formatted_557 = AsRef::<str>::as_ref(inner_556);
            if !formatted_557.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_557;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-MD5", header_value);
            }
        }
        if let Some(inner_558) = &self.sse_customer_algorithm {
            let formatted_559 = AsRef::<str>::as_ref(inner_558);
            if !formatted_559.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_559;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_560) = &self.sse_customer_key {
            let formatted_561 = AsRef::<str>::as_ref(inner_560);
            if !formatted_561.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_561;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_562) = &self.sse_customer_key_md5 {
            let formatted_563 = AsRef::<str>::as_ref(inner_562);
            if !formatted_563.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_563;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_564) = &self.request_payer {
            let formatted_565 = AsRef::<str>::as_ref(inner_564);
            if !formatted_565.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_565;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_566) = &self.expected_bucket_owner {
            let formatted_567 = AsRef::<str>::as_ref(inner_566);
            if !formatted_567.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_567;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "UploadPart");
        if self.part_number != 0 {
            query.push_kv(
                "partNumber",
                &smithy_http::query::fmt_default(&&self.part_number),
            );
        }
        if let Some(inner_568) = &self.upload_id {
            query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_568));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/octet-stream",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadPartInput`](crate::input::UploadPartInput)
    pub fn builder() -> crate::input::upload_part_input::Builder {
        crate::input::upload_part_input::Builder::default()
    }
}

/// See [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
pub mod upload_part_copy_input {
    /// A builder for [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) copy_source: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) copy_source_if_none_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) copy_source_range: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) expected_source_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Specifies the source object for the copy operation. You specify the value in one of two
        /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
        /// <ul>
        /// <li>
        /// <p>For objects not accessed through an access point, specify the name of the source
        /// bucket and key of the source object, separated by a slash (/). For example, to copy
        /// the object <code>reports/january.pdf</code> from the bucket
        /// <code>awsexamplebucket</code>, use
        /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
        /// encoded.</p>
        /// </li>
        /// <li>
        /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
        /// <note>
        /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
        /// </note>
        /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
        /// </li>
        /// </ul>
        /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
        /// to the value (for example,
        /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
        /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
        /// object.</p>
        pub fn copy_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source = Some(input.into());
            self
        }
        pub fn set_copy_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.copy_source = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
        pub fn copy_source_if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_match = input;
            self
        }
        /// <p>Copies the object if it has been modified since the specified time.</p>
        pub fn copy_source_if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_modified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_modified_since = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
        pub fn copy_source_if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_none_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_none_match = input;
            self
        }
        /// <p>Copies the object if it hasn't been modified since the specified time.</p>
        pub fn copy_source_if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_unmodified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_unmodified_since = input;
            self
        }
        /// <p>The range of bytes to copy from the source object. The range value must use the form
        /// bytes=first-last, where the first and last are the zero-based byte offsets to copy. For
        /// example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You
        /// can copy a range only if the source object is greater than 5 MB.</p>
        pub fn copy_source_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_range = Some(input.into());
            self
        }
        pub fn set_copy_source_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_range = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Part number of part being copied. This is a positive integer between 1 and
        /// 10,000.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>Upload ID identifying the multipart upload whose part is being copied.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header. This must be the
        /// same encryption key specified in the initiate multipart upload request.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Specifies the algorithm to use when decrypting the source object (for example,
        /// AES256).</p>
        pub fn copy_source_sse_customer_algorithm(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
        /// object. The encryption key provided in this header must be one that was used when the
        /// source object was created.</p>
        pub fn copy_source_sse_customer_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn copy_source_sse_customer_key_md5(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_source_bucket_owner(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_source_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UploadPartCopyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UploadPartCopyInput {
                bucket: self.bucket,
                copy_source: self.copy_source,
                copy_source_if_match: self.copy_source_if_match,
                copy_source_if_modified_since: self.copy_source_if_modified_since,
                copy_source_if_none_match: self.copy_source_if_none_match,
                copy_source_if_unmodified_since: self.copy_source_if_unmodified_since,
                copy_source_range: self.copy_source_range,
                key: self.key,
                part_number: self.part_number.unwrap_or_default(),
                upload_id: self.upload_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                copy_source_sse_customer_algorithm: self.copy_source_sse_customer_algorithm,
                copy_source_sse_customer_key: self.copy_source_sse_customer_key,
                copy_source_sse_customer_key_md5: self.copy_source_sse_customer_key_md5,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
                expected_source_bucket_owner: self.expected_source_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadPartCopyInputOperationOutputAlias = crate::operation::UploadPartCopy;
#[doc(hidden)]
pub type UploadPartCopyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadPartCopyInput {
    /// Consumes the builder and constructs an Operation<[`UploadPartCopy`](crate::operation::UploadPartCopy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UploadPartCopy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UploadPartCopy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UploadPartCopy",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let bucket = {
            let input = &self.bucket;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, false);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        let key = {
            let input = &self.key;
            let input = input
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                })?;
            let formatted = smithy_http::label::fmt_string(input, true);
            if formatted.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            formatted
        };
        write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
            .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_569) = &self.copy_source {
            let formatted_570 = AsRef::<str>::as_ref(inner_569);
            if !formatted_570.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_570;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source", header_value);
            }
        }
        if let Some(inner_571) = &self.copy_source_if_match {
            let formatted_572 = AsRef::<str>::as_ref(inner_571);
            if !formatted_572.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_572;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-match", header_value);
            }
        }
        if let Some(inner_573) = &self.copy_source_if_modified_since {
            let formatted_574 = inner_573.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_574.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_574;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-modified-since", header_value);
            }
        }
        if let Some(inner_575) = &self.copy_source_if_none_match {
            let formatted_576 = AsRef::<str>::as_ref(inner_575);
            if !formatted_576.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_576;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-none-match", header_value);
            }
        }
        if let Some(inner_577) = &self.copy_source_if_unmodified_since {
            let formatted_578 = inner_577.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_578.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_578;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-if-unmodified-since", header_value);
            }
        }
        if let Some(inner_579) = &self.copy_source_range {
            let formatted_580 = AsRef::<str>::as_ref(inner_579);
            if !formatted_580.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_580;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-copy-source-range", header_value);
            }
        }
        if let Some(inner_581) = &self.sse_customer_algorithm {
            let formatted_582 = AsRef::<str>::as_ref(inner_581);
            if !formatted_582.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_582;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_583) = &self.sse_customer_key {
            let formatted_584 = AsRef::<str>::as_ref(inner_583);
            if !formatted_584.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_584;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-server-side-encryption-customer-key", header_value);
            }
        }
        if let Some(inner_585) = &self.sse_customer_key_md5 {
            let formatted_586 = AsRef::<str>::as_ref(inner_585);
            if !formatted_586.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_586;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_587) = &self.copy_source_sse_customer_algorithm {
            let formatted_588 = AsRef::<str>::as_ref(inner_587);
            if !formatted_588.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_588;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-copy-source-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_589) = &self.copy_source_sse_customer_key {
            let formatted_590 = AsRef::<str>::as_ref(inner_589);
            if !formatted_590.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_590;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-copy-source-server-side-encryption-customer-key",
                    header_value,
                );
            }
        }
        if let Some(inner_591) = &self.copy_source_sse_customer_key_md5 {
            let formatted_592 = AsRef::<str>::as_ref(inner_591);
            if !formatted_592.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_592;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-copy-source-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_593) = &self.request_payer {
            let formatted_594 = AsRef::<str>::as_ref(inner_593);
            if !formatted_594.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_594;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-payer", header_value);
            }
        }
        if let Some(inner_595) = &self.expected_bucket_owner {
            let formatted_596 = AsRef::<str>::as_ref(inner_595);
            if !formatted_596.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_596;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-expected-bucket-owner", header_value);
            }
        }
        if let Some(inner_597) = &self.expected_source_bucket_owner {
            let formatted_598 = AsRef::<str>::as_ref(inner_597);
            if !formatted_598.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_598;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expected_source_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-source-expected-bucket-owner", header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "UploadPartCopy");
        if self.part_number != 0 {
            query.push_kv(
                "partNumber",
                &smithy_http::query::fmt_default(&&self.part_number),
            );
        }
        if let Some(inner_599) = &self.upload_id {
            query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_599));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/xml");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
    pub fn builder() -> crate::input::upload_part_copy_input::Builder {
        crate::input::upload_part_copy_input::Builder::default()
    }
}

/// See [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
pub mod write_get_object_response_input {
    /// A builder for [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_route: std::option::Option<std::string::String>,
        pub(crate) request_token: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<smithy_http::byte_stream::ByteStream>,
        pub(crate) status_code: std::option::Option<i32>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) accept_ranges: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_length: std::option::Option<i64>,
        pub(crate) content_range: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) delete_marker: std::option::Option<bool>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) expiration: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<smithy_types::Instant>,
        pub(crate) missing_meta: std::option::Option<i32>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) parts_count: std::option::Option<i32>,
        pub(crate) replication_status: std::option::Option<crate::model::ReplicationStatus>,
        pub(crate) request_charged: std::option::Option<crate::model::RequestCharged>,
        pub(crate) restore: std::option::Option<std::string::String>,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) tag_count: std::option::Option<i32>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Route prefix to the HTTP URL generated.</p>
        pub fn request_route(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_route = Some(input.into());
            self
        }
        pub fn set_request_route(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.request_route = input;
            self
        }
        /// <p>A single use encrypted token that maps <code>WriteGetObjectResponse</code> to the end
        /// user <code>GetObject</code> request.</p>
        pub fn request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_token = Some(input.into());
            self
        }
        pub fn set_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.request_token = input;
            self
        }
        /// <p>The object data.</p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.body = input;
            self
        }
        /// <p>The integer status code for an HTTP response of a corresponding <code>GetObject</code>
        /// request.</p>
        /// <p class="title">
        /// <b>Status Codes</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>200 - OK</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>206 - Partial Content</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>304 - Not Modified</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>400 - Bad Request</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>401 - Unauthorized</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>403 - Forbidden</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>404 - Not Found</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>405 - Method Not Allowed</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>409 - Conflict</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>411 - Length Required</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>412 - Precondition Failed</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>416 - Range Not Satisfiable</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>500 - Internal Server Error</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>503 - Service Unavailable</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// <p>A string that uniquely identifies an error condition. Returned in the <Code> tag
        /// of the error XML response for a corresponding <code>GetObject</code> call. Cannot be used
        /// with a successful <code>StatusCode</code> header or when the transformed object is provided
        /// in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Contains a generic description of the error condition. Returned in the <Message>
        /// tag of the error XML response for a corresponding <code>GetObject</code> call. Cannot be
        /// used with a successful <code>StatusCode</code> header or when the transformed object is
        /// provided in body.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>Indicates that a range of bytes was specified.</p>
        pub fn accept_ranges(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept_ranges = Some(input.into());
            self
        }
        pub fn set_accept_ranges(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.accept_ranges = input;
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>The size of the content body in bytes.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// <p>The portion of the object returned in the response.</p>
        pub fn content_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_range = Some(input.into());
            self
        }
        pub fn set_content_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_range = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>Specifies whether an object stored in Amazon S3 is (<code>true</code>) or is not
        /// (<code>false</code>) a delete marker. </p>
        pub fn delete_marker(mut self, input: bool) -> Self {
            self.delete_marker = Some(input);
            self
        }
        pub fn set_delete_marker(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_marker = input;
            self
        }
        /// <p>An opaque identifier assigned by a web server to a specific version of a resource found
        /// at a URL. </p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded. </p>
        pub fn expiration(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiration = Some(input.into());
            self
        }
        pub fn set_expiration(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expiration = input;
            self
        }
        /// <p>The date and time that the object was last modified.</p>
        pub fn last_modified(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified = Some(input);
            self
        }
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>Set to the number of metadata entries not returned in <code>x-amz-meta</code> headers.
        /// This can happen if you create metadata using an API like SOAP that supports more flexible
        /// metadata than the REST API. For example, using SOAP, you can create metadata whose values
        /// are not legal HTTP headers.</p>
        pub fn missing_meta(mut self, input: i32) -> Self {
            self.missing_meta = Some(input);
            self
        }
        pub fn set_missing_meta(mut self, input: std::option::Option<i32>) -> Self {
            self.missing_meta = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more
        /// information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">Object Lock</a>.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>Indicates whether an object stored in Amazon S3 has an active legal hold.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The date and time when Object Lock is configured to expire.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>The count of parts this object has.</p>
        pub fn parts_count(mut self, input: i32) -> Self {
            self.parts_count = Some(input);
            self
        }
        pub fn set_parts_count(mut self, input: std::option::Option<i32>) -> Self {
            self.parts_count = input;
            self
        }
        /// <p>Indicates if request involves bucket that is either a source or destination in a Replication rule. For more
        /// information about S3 Replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html">Replication</a>.</p>
        pub fn replication_status(mut self, input: crate::model::ReplicationStatus) -> Self {
            self.replication_status = Some(input);
            self
        }
        pub fn set_replication_status(
            mut self,
            input: std::option::Option<crate::model::ReplicationStatus>,
        ) -> Self {
            self.replication_status = input;
            self
        }
        /// <p>If present, indicates that the requester was successfully charged for the
        /// request.</p>
        pub fn request_charged(mut self, input: crate::model::RequestCharged) -> Self {
            self.request_charged = Some(input);
            self
        }
        pub fn set_request_charged(
            mut self,
            input: std::option::Option<crate::model::RequestCharged>,
        ) -> Self {
            self.request_charged = input;
            self
        }
        /// <p>Provides information about object restoration operation and expiration time of the
        /// restored object copy.</p>
        pub fn restore(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore = Some(input.into());
            self
        }
        pub fn set_restore(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.restore = input;
            self
        }
        /// <p> The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p> If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric customer managed customer master key (CMK) that was used for stored in Amazon S3 object. </p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p> 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data
        /// stored in S3. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html">Protecting data
        /// using server-side encryption with customer-provided encryption keys
        /// (SSE-C)</a>.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p> The class of storage used to store object in Amazon S3.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>The number of tags, if any, on the object.</p>
        pub fn tag_count(mut self, input: i32) -> Self {
            self.tag_count = Some(input);
            self
        }
        pub fn set_tag_count(mut self, input: std::option::Option<i32>) -> Self {
            self.tag_count = input;
            self
        }
        /// <p>An ID used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p> Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side
        /// encryption with AWS KMS (SSE-KMS).</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::WriteGetObjectResponseInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::WriteGetObjectResponseInput {
                request_route: self.request_route,
                request_token: self.request_token,
                body: self.body.unwrap_or_default(),
                status_code: self.status_code.unwrap_or_default(),
                error_code: self.error_code,
                error_message: self.error_message,
                accept_ranges: self.accept_ranges,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_length: self.content_length.unwrap_or_default(),
                content_range: self.content_range,
                content_type: self.content_type,
                delete_marker: self.delete_marker.unwrap_or_default(),
                e_tag: self.e_tag,
                expires: self.expires,
                expiration: self.expiration,
                last_modified: self.last_modified,
                missing_meta: self.missing_meta.unwrap_or_default(),
                metadata: self.metadata,
                object_lock_mode: self.object_lock_mode,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                parts_count: self.parts_count.unwrap_or_default(),
                replication_status: self.replication_status,
                request_charged: self.request_charged,
                restore: self.restore,
                server_side_encryption: self.server_side_encryption,
                sse_customer_algorithm: self.sse_customer_algorithm,
                ssekms_key_id: self.ssekms_key_id,
                sse_customer_key_md5: self.sse_customer_key_md5,
                storage_class: self.storage_class,
                tag_count: self.tag_count.unwrap_or_default(),
                version_id: self.version_id,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type WriteGetObjectResponseInputOperationOutputAlias = crate::operation::WriteGetObjectResponse;
#[doc(hidden)]
pub type WriteGetObjectResponseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl WriteGetObjectResponseInput {
    /// Consumes the builder and constructs an Operation<[`WriteGetObjectResponse`](crate::operation::WriteGetObjectResponse)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::WriteGetObjectResponse,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::ser_payload_write_get_object_response_input(self.body)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            let endpoint_prefix = {
                let request_route = self.request_route.as_deref().unwrap_or_default();
                if request_route.is_empty() {
                    return Err(smithy_http::operation::BuildError::InvalidField { field: "request_route", details: "request_route was unset or empty but must be set as part of the endpoint prefix".to_string() });
                }
                smithy_http::endpoint::EndpointPrefix::new(format!(
                    "{RequestRoute}.",
                    RequestRoute = request_route
                ))
            };
            match endpoint_prefix {
                Ok(prefix) => {
                    request.config_mut().insert(prefix);
                }
                Err(err) => {
                    return Err(smithy_http::operation::BuildError::SerializationError(
                        err.into(),
                    ))
                }
            }
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            signing_config.signing_options.content_sha256_header = true;
            signing_config.signing_options.double_uri_encode = false;
            signing_config.signing_options.content_sha256_header = true;
            request
                .config_mut()
                .insert(aws_sig_auth::signer::SignableBody::UnsignedPayload);
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::WriteGetObjectResponse::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "WriteGetObjectResponse",
                "s3",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/WriteGetObjectResponse").expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_600) = &self.request_route {
            let formatted_601 = AsRef::<str>::as_ref(inner_600);
            if !formatted_601.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_601;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_route",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-route", header_value);
            }
        }
        if let Some(inner_602) = &self.request_token {
            let formatted_603 = AsRef::<str>::as_ref(inner_602);
            if !formatted_603.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_603;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_token",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-request-token", header_value);
            }
        }
        if self.status_code != 0 {
            let formatted_604 = smithy_http::query::fmt_default(&&self.status_code);
            if !formatted_604.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_604;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "status_code",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-status", header_value);
            }
        }
        if let Some(inner_605) = &self.error_code {
            let formatted_606 = AsRef::<str>::as_ref(inner_605);
            if !formatted_606.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_606;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "error_code",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-error-code", header_value);
            }
        }
        if let Some(inner_607) = &self.error_message {
            let formatted_608 = AsRef::<str>::as_ref(inner_607);
            if !formatted_608.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_608;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "error_message",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-error-message", header_value);
            }
        }
        if let Some(inner_609) = &self.accept_ranges {
            let formatted_610 = AsRef::<str>::as_ref(inner_609);
            if !formatted_610.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_610;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "accept_ranges",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-accept-ranges", header_value);
            }
        }
        if let Some(inner_611) = &self.cache_control {
            let formatted_612 = AsRef::<str>::as_ref(inner_611);
            if !formatted_612.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_612;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Cache-Control", header_value);
            }
        }
        if let Some(inner_613) = &self.content_disposition {
            let formatted_614 = AsRef::<str>::as_ref(inner_613);
            if !formatted_614.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_614;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Content-Disposition", header_value);
            }
        }
        if let Some(inner_615) = &self.content_encoding {
            let formatted_616 = AsRef::<str>::as_ref(inner_615);
            if !formatted_616.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_616;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Content-Encoding", header_value);
            }
        }
        if let Some(inner_617) = &self.content_language {
            let formatted_618 = AsRef::<str>::as_ref(inner_617);
            if !formatted_618.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_618;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Content-Language", header_value);
            }
        }
        if self.content_length != 0 {
            let formatted_619 = smithy_http::query::fmt_default(&&self.content_length);
            if !formatted_619.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_619;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_length",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Length", header_value);
            }
        }
        if let Some(inner_620) = &self.content_range {
            let formatted_621 = AsRef::<str>::as_ref(inner_620);
            if !formatted_621.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_621;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Content-Range", header_value);
            }
        }
        if let Some(inner_622) = &self.content_type {
            let formatted_623 = AsRef::<str>::as_ref(inner_622);
            if !formatted_623.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_623;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Content-Type", header_value);
            }
        }
        if self.delete_marker {
            let formatted_624 = smithy_http::query::fmt_default(&&self.delete_marker);
            if !formatted_624.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_624;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "delete_marker",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-delete-marker", header_value);
            }
        }
        if let Some(inner_625) = &self.e_tag {
            let formatted_626 = AsRef::<str>::as_ref(inner_625);
            if !formatted_626.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_626;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "e_tag",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-ETag", header_value);
            }
        }
        if let Some(inner_627) = &self.expires {
            let formatted_628 = inner_627.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_628.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_628;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Expires", header_value);
            }
        }
        if let Some(inner_629) = &self.expiration {
            let formatted_630 = AsRef::<str>::as_ref(inner_629);
            if !formatted_630.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_630;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "expiration",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-expiration", header_value);
            }
        }
        if let Some(inner_631) = &self.last_modified {
            let formatted_632 = inner_631.fmt(smithy_types::instant::Format::HttpDate);
            if !formatted_632.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_632;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "last_modified",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-Last-Modified", header_value);
            }
        }
        if self.missing_meta != 0 {
            let formatted_633 = smithy_http::query::fmt_default(&&self.missing_meta);
            if !formatted_633.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_633;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "missing_meta",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-missing-meta", header_value);
            }
        }
        if let Some(inner_634) = &self.object_lock_mode {
            let formatted_635 = AsRef::<str>::as_ref(inner_634);
            if !formatted_635.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_635;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-object-lock-mode", header_value);
            }
        }
        if let Some(inner_636) = &self.object_lock_legal_hold_status {
            let formatted_637 = AsRef::<str>::as_ref(inner_636);
            if !formatted_637.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_637;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-object-lock-legal-hold",
                    header_value,
                );
            }
        }
        if let Some(inner_638) = &self.object_lock_retain_until_date {
            let formatted_639 = inner_638.fmt(smithy_types::instant::Format::DateTime);
            if !formatted_639.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_639;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-object-lock-retain-until-date",
                    header_value,
                );
            }
        }
        if self.parts_count != 0 {
            let formatted_640 = smithy_http::query::fmt_default(&&self.parts_count);
            if !formatted_640.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_640;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "parts_count",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-mp-parts-count", header_value);
            }
        }
        if let Some(inner_641) = &self.replication_status {
            let formatted_642 = AsRef::<str>::as_ref(inner_641);
            if !formatted_642.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_642;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "replication_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-replication-status", header_value);
            }
        }
        if let Some(inner_643) = &self.request_charged {
            let formatted_644 = AsRef::<str>::as_ref(inner_643);
            if !formatted_644.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_644;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_charged",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-request-charged", header_value);
            }
        }
        if let Some(inner_645) = &self.restore {
            let formatted_646 = AsRef::<str>::as_ref(inner_645);
            if !formatted_646.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_646;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "restore",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-restore", header_value);
            }
        }
        if let Some(inner_647) = &self.server_side_encryption {
            let formatted_648 = AsRef::<str>::as_ref(inner_647);
            if !formatted_648.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_648;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-server-side-encryption",
                    header_value,
                );
            }
        }
        if let Some(inner_649) = &self.sse_customer_algorithm {
            let formatted_650 = AsRef::<str>::as_ref(inner_649);
            if !formatted_650.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_650;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm",
                    header_value,
                );
            }
        }
        if let Some(inner_651) = &self.ssekms_key_id {
            let formatted_652 = AsRef::<str>::as_ref(inner_651);
            if !formatted_652.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_652;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id",
                    header_value,
                );
            }
        }
        if let Some(inner_653) = &self.sse_customer_key_md5 {
            let formatted_654 = AsRef::<str>::as_ref(inner_653);
            if !formatted_654.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_654;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5",
                    header_value,
                );
            }
        }
        if let Some(inner_655) = &self.storage_class {
            let formatted_656 = AsRef::<str>::as_ref(inner_655);
            if !formatted_656.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_656;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-storage-class", header_value);
            }
        }
        if self.tag_count != 0 {
            let formatted_657 = smithy_http::query::fmt_default(&&self.tag_count);
            if !formatted_657.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_657;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "tag_count",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-tagging-count", header_value);
            }
        }
        if let Some(inner_658) = &self.version_id {
            let formatted_659 = AsRef::<str>::as_ref(inner_658);
            if !formatted_659.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_659;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "version_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("x-amz-fwd-header-x-amz-version-id", header_value);
            }
        }
        if self.bucket_key_enabled {
            let formatted_660 = smithy_http::query::fmt_default(&&self.bucket_key_enabled);
            if !formatted_660.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_660;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header(
                    "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled",
                    header_value,
                );
            }
        }
        if let Some(inner_661) = &self.metadata {
            for (k, v) in inner_661 {
                use std::str::FromStr;
                let header_name =
                    http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header name: {}", k, err),
                        })?;
                use std::convert::TryFrom;
                let header_value = AsRef::<str>::as_ref(v);
                let header_value =
                    http::header::HeaderValue::try_from(header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "metadata",
                            details: format!("`{}` cannot be used as a header value: {}", v, err),
                        }
                    })?;
                builder = builder.header(header_name, header_value);
            }
        }
        Ok(builder)
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        query.push_kv("x-id", "WriteGetObjectResponse");
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/octet-stream",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
    pub fn builder() -> crate::input::write_get_object_response_input::Builder {
        crate::input::write_get_object_response_input::Builder::default()
    }
}

#[non_exhaustive]
pub struct WriteGetObjectResponseInput {
    /// <p>Route prefix to the HTTP URL generated.</p>
    pub request_route: std::option::Option<std::string::String>,
    /// <p>A single use encrypted token that maps <code>WriteGetObjectResponse</code> to the end
    /// user <code>GetObject</code> request.</p>
    pub request_token: std::option::Option<std::string::String>,
    /// <p>The object data.</p>
    pub body: smithy_http::byte_stream::ByteStream,
    /// <p>The integer status code for an HTTP response of a corresponding <code>GetObject</code>
    /// request.</p>
    /// <p class="title">
    /// <b>Status Codes</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <i>200 - OK</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>206 - Partial Content</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>304 - Not Modified</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>400 - Bad Request</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>401 - Unauthorized</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>403 - Forbidden</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>404 - Not Found</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>405 - Method Not Allowed</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>409 - Conflict</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>411 - Length Required</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>412 - Precondition Failed</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>416 - Range Not Satisfiable</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>500 - Internal Server Error</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>503 - Service Unavailable</i>
    /// </p>
    /// </li>
    /// </ul>
    pub status_code: i32,
    /// <p>A string that uniquely identifies an error condition. Returned in the <Code> tag
    /// of the error XML response for a corresponding <code>GetObject</code> call. Cannot be used
    /// with a successful <code>StatusCode</code> header or when the transformed object is provided
    /// in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>Contains a generic description of the error condition. Returned in the <Message>
    /// tag of the error XML response for a corresponding <code>GetObject</code> call. Cannot be
    /// used with a successful <code>StatusCode</code> header or when the transformed object is
    /// provided in body.</p>
    pub error_message: std::option::Option<std::string::String>,
    /// <p>Indicates that a range of bytes was specified.</p>
    pub accept_ranges: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>The size of the content body in bytes.</p>
    pub content_length: i64,
    /// <p>The portion of the object returned in the response.</p>
    pub content_range: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>Specifies whether an object stored in Amazon S3 is (<code>true</code>) or is not
    /// (<code>false</code>) a delete marker. </p>
    pub delete_marker: bool,
    /// <p>An opaque identifier assigned by a web server to a specific version of a resource found
    /// at a URL. </p>
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded. </p>
    pub expiration: std::option::Option<std::string::String>,
    /// <p>The date and time that the object was last modified.</p>
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>Set to the number of metadata entries not returned in <code>x-amz-meta</code> headers.
    /// This can happen if you create metadata using an API like SOAP that supports more flexible
    /// metadata than the REST API. For example, using SOAP, you can create metadata whose values
    /// are not legal HTTP headers.</p>
    pub missing_meta: i32,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more
    /// information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">Object Lock</a>.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>Indicates whether an object stored in Amazon S3 has an active legal hold.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The date and time when Object Lock is configured to expire.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>The count of parts this object has.</p>
    pub parts_count: i32,
    /// <p>Indicates if request involves bucket that is either a source or destination in a Replication rule. For more
    /// information about S3 Replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html">Replication</a>.</p>
    pub replication_status: std::option::Option<crate::model::ReplicationStatus>,
    /// <p>If present, indicates that the requester was successfully charged for the
    /// request.</p>
    pub request_charged: std::option::Option<crate::model::RequestCharged>,
    /// <p>Provides information about object restoration operation and expiration time of the
    /// restored object copy.</p>
    pub restore: std::option::Option<std::string::String>,
    /// <p> The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p> If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric customer managed customer master key (CMK) that was used for stored in Amazon S3 object. </p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p> 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data
    /// stored in S3. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html">Protecting data
    /// using server-side encryption with customer-provided encryption keys
    /// (SSE-C)</a>.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p> The class of storage used to store object in Amazon S3.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>The number of tags, if any, on the object.</p>
    pub tag_count: i32,
    /// <p>An ID used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p> Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side
    /// encryption with AWS KMS (SSE-KMS).</p>
    pub bucket_key_enabled: bool,
}
impl std::fmt::Debug for WriteGetObjectResponseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteGetObjectResponseInput");
        formatter.field("request_route", &self.request_route);
        formatter.field("request_token", &self.request_token);
        formatter.field("body", &self.body);
        formatter.field("status_code", &self.status_code);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.field("accept_ranges", &self.accept_ranges);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_length", &self.content_length);
        formatter.field("content_range", &self.content_range);
        formatter.field("content_type", &self.content_type);
        formatter.field("delete_marker", &self.delete_marker);
        formatter.field("e_tag", &self.e_tag);
        formatter.field("expires", &self.expires);
        formatter.field("expiration", &self.expiration);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("missing_meta", &self.missing_meta);
        formatter.field("metadata", &self.metadata);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field("parts_count", &self.parts_count);
        formatter.field("replication_status", &self.replication_status);
        formatter.field("request_charged", &self.request_charged);
        formatter.field("restore", &self.restore);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("tag_count", &self.tag_count);
        formatter.field("version_id", &self.version_id);
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UploadPartCopyInput {
    /// <p>The bucket name.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Specifies the source object for the copy operation. You specify the value in one of two
    /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
    /// <ul>
    /// <li>
    /// <p>For objects not accessed through an access point, specify the name of the source
    /// bucket and key of the source object, separated by a slash (/). For example, to copy
    /// the object <code>reports/january.pdf</code> from the bucket
    /// <code>awsexamplebucket</code>, use
    /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
    /// encoded.</p>
    /// </li>
    /// <li>
    /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
    /// <note>
    /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
    /// </note>
    /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
    /// </li>
    /// </ul>
    /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
    /// to the value (for example,
    /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
    /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
    /// object.</p>
    pub copy_source: std::option::Option<std::string::String>,
    /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
    pub copy_source_if_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it has been modified since the specified time.</p>
    pub copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
    pub copy_source_if_none_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it hasn't been modified since the specified time.</p>
    pub copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>The range of bytes to copy from the source object. The range value must use the form
    /// bytes=first-last, where the first and last are the zero-based byte offsets to copy. For
    /// example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You
    /// can copy a range only if the source object is greater than 5 MB.</p>
    pub copy_source_range: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Part number of part being copied. This is a positive integer between 1 and
    /// 10,000.</p>
    pub part_number: i32,
    /// <p>Upload ID identifying the multipart upload whose part is being copied.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header. This must be the
    /// same encryption key specified in the initiate multipart upload request.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use when decrypting the source object (for example,
    /// AES256).</p>
    pub copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
    /// object. The encryption key provided in this header must be one that was used when the
    /// source object was created.</p>
    pub copy_source_sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_source_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UploadPartCopyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadPartCopyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("copy_source", &self.copy_source);
        formatter.field("copy_source_if_match", &self.copy_source_if_match);
        formatter.field(
            "copy_source_if_modified_since",
            &self.copy_source_if_modified_since,
        );
        formatter.field("copy_source_if_none_match", &self.copy_source_if_none_match);
        formatter.field(
            "copy_source_if_unmodified_since",
            &self.copy_source_if_unmodified_since,
        );
        formatter.field("copy_source_range", &self.copy_source_range);
        formatter.field("key", &self.key);
        formatter.field("part_number", &self.part_number);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field(
            "copy_source_sse_customer_algorithm",
            &self.copy_source_sse_customer_algorithm,
        );
        formatter.field(
            "copy_source_sse_customer_key",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field(
            "copy_source_sse_customer_key_md5",
            &self.copy_source_sse_customer_key_md5,
        );
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "expected_source_bucket_owner",
            &self.expected_source_bucket_owner,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
pub struct UploadPartInput {
    /// <p>Object data.</p>
    pub body: smithy_http::byte_stream::ByteStream,
    /// <p>The name of the bucket to which the multipart upload was initiated.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
    /// determined automatically.</p>
    pub content_length: i64,
    /// <p>The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated
    /// when using the command from the CLI. This parameter is required if object lock parameters
    /// are specified.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Part number of part being uploaded. This is a positive integer between 1 and
    /// 10,000.</p>
    pub part_number: i32,
    /// <p>Upload ID identifying the multipart upload whose part is being uploaded.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm header</code>. This must be the
    /// same encryption key specified in the initiate multipart upload request.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UploadPartInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadPartInput");
        formatter.field("body", &self.body);
        formatter.field("bucket", &self.bucket);
        formatter.field("content_length", &self.content_length);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("key", &self.key);
        formatter.field("part_number", &self.part_number);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreObjectInput {
    /// <p>The bucket name containing the object to restore. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which the action was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for restore job parameters.</p>
    pub restore_request: std::option::Option<crate::model::RestoreRequest>,
}
impl std::fmt::Debug for RestoreObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("restore_request", &self.restore_request);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPublicAccessBlockInput {
    /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
    /// to set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the <code>PutPublicAccessBlock</code> request body. </p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3
    /// bucket. You can enable the configuration options in any combination. For more information
    /// about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub public_access_block_configuration:
        std::option::Option<crate::model::PublicAccessBlockConfiguration>,
}
impl std::fmt::Debug for PutPublicAccessBlockInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPublicAccessBlockInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "public_access_block_configuration",
            &self.public_access_block_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectTaggingInput {
    /// <p>The bucket name containing the object. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Name of the object key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The versionId of the object that the tag-set will be added to.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements</p>
    pub tagging: std::option::Option<crate::model::Tagging>,
}
impl std::fmt::Debug for PutObjectTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectRetentionInput {
    /// <p>The bucket name that contains the object you want to apply this Object Retention
    /// configuration to. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object that you want to apply this Object Retention configuration
    /// to.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The version ID for the object that you want to apply this Object Retention configuration
    /// to.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether this action should bypass Governance-mode restrictions.</p>
    pub bypass_governance_retention: bool,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The container element for the Object Retention configuration.</p>
    pub retention: std::option::Option<crate::model::ObjectLockRetention>,
}
impl std::fmt::Debug for PutObjectRetentionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectRetentionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("version_id", &self.version_id);
        formatter.field(
            "bypass_governance_retention",
            &self.bypass_governance_retention,
        );
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("retention", &self.retention);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectLockConfigurationInput {
    /// <p>The bucket whose Object Lock configuration you want to create or replace.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
    pub token: std::option::Option<std::string::String>,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The Object Lock configuration that you want to apply to the specified bucket.</p>
    pub object_lock_configuration: std::option::Option<crate::model::ObjectLockConfiguration>,
}
impl std::fmt::Debug for PutObjectLockConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectLockConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("token", &self.token);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("object_lock_configuration", &self.object_lock_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectLegalHoldInput {
    /// <p>The bucket name containing the object that you want to place a Legal Hold on. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object that you want to place a Legal Hold on.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The version ID of the object that you want to place a Legal Hold on.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container element for the Legal Hold configuration you want to apply to the specified
    /// object.</p>
    pub legal_hold: std::option::Option<crate::model::ObjectLockLegalHold>,
}
impl std::fmt::Debug for PutObjectLegalHoldInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectLegalHoldInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("version_id", &self.version_id);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("legal_hold", &self.legal_hold);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectAclInput {
    /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>The bucket name that contains the object to which you want to attach the ACL. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864.></a>
    /// </p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    /// bucket.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to list the objects in the
    /// bucket.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the bucket ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to create new objects in the bucket.</p>
    /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    pub grant_write: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// bucket.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Key for which the PUT action was initiated.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
    pub access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
}
impl std::fmt::Debug for PutObjectAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectAclInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write", &self.grant_write);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("version_id", &self.version_id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("access_control_policy", &self.access_control_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
pub struct PutObjectInput {
    /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned
    /// ACL</a>.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>Object data.</p>
    pub body: smithy_http::byte_stream::ByteStream,
    /// <p>The bucket name to which the PUT action was initiated. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p> Can be used to specify caching behavior along the request/reply chain. For more
    /// information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
    /// determined automatically. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>.</p>
    pub content_length: i64,
    /// <p>The base64-encoded 128-bit MD5 digest of the message (without the headers) according to
    /// RFC 1864. This header can be used as a message integrity check to verify that the data is
    /// the same data that was originally sent. Although it is optional, we recommend using the
    /// Content-MD5 mechanism as an end-to-end integrity check. For more information about REST
    /// request authentication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST
    /// Authentication</a>.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the contents. For more information, see
    /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable. For more information, see
    /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21</a>.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object data and its
    /// metadata.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Object key for which the PUT action was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    /// AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    /// STANDARD storage class provides high durability and high availability. Depending on
    /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    /// <i>Amazon S3 User Guide</i>.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    /// the object metadata. For information about object metadata, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a>.</p>
    /// <p>In the following example, the request header sets the redirect to an object
    /// (anotherPage.html) in the same bucket:</p>
    /// <p>
    /// <code>x-amz-website-redirect-location: /anotherPage.html</code>
    /// </p>
    /// <p>In the following example, the request header sets the object redirect to another
    /// website:</p>
    /// <p>
    /// <code>x-amz-website-redirect-location: http://www.example.com/</code>
    /// </p>
    /// <p>For more information about website hosting in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">Hosting Websites on Amazon S3</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html">How to Configure Website Page
    /// Redirects</a>. </p>
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
    /// <code>aws:kms</code>, this header specifies the ID of the AWS Key Management Service
    /// (AWS KMS) symmetrical customer managed customer master key (CMK) that was used for the
    /// object. If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but do not
    /// provide<code> x-amz-server-side-encryption-aws-kms-key-id</code>, Amazon S3 uses the AWS
    /// managed CMK in AWS to protect the data. If the KMS key does not exist in the same account
    /// issuing the command, you must use the full ARN and not just the ID.
    /// </p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
    /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    /// pairs.</p>
    pub ssekms_encryption_context: std::option::Option<std::string::String>,
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    /// <p>Specifying this header with a PUT action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
    pub bucket_key_enabled: bool,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For
    /// example, "Key1=Value1")</p>
    pub tagging: std::option::Option<std::string::String>,
    /// <p>The Object Lock mode that you want to apply to this object.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>The date and time when you want this object's Object Lock to expire. Must be formatted
    /// as a timestamp parameter.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether a legal hold will be applied to this object. For more information
    /// about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
    /// Lock</a>.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectInput");
        formatter.field("acl", &self.acl);
        formatter.field("body", &self.body);
        formatter.field("bucket", &self.bucket);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_length", &self.content_length);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("content_type", &self.content_type);
        formatter.field("expires", &self.expires);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("metadata", &self.metadata);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ssekms_encryption_context",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketWebsiteInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for the request.</p>
    pub website_configuration: std::option::Option<crate::model::WebsiteConfiguration>,
}
impl std::fmt::Debug for PutBucketWebsiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketWebsiteInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("website_configuration", &self.website_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketVersioningInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
    /// message integrity check to verify that the request body was not corrupted in transit. For
    /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864</a>.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    /// that is displayed on your authentication device.</p>
    pub mfa: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for setting the versioning state.</p>
    pub versioning_configuration: std::option::Option<crate::model::VersioningConfiguration>,
}
impl std::fmt::Debug for PutBucketVersioningInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketVersioningInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("mfa", &self.mfa);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("versioning_configuration", &self.versioning_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketTaggingInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements.</p>
    pub tagging: std::option::Option<crate::model::Tagging>,
}
impl std::fmt::Debug for PutBucketTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("tagging", &self.tagging);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketRequestPaymentInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
    /// message integrity check to verify that the request body was not corrupted in transit. For
    /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864</a>.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for Payer.</p>
    pub request_payment_configuration:
        std::option::Option<crate::model::RequestPaymentConfiguration>,
}
impl std::fmt::Debug for PutBucketRequestPaymentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketRequestPaymentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "request_payment_configuration",
            &self.request_payment_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketReplicationInput {
    /// <p>The name of the bucket</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
    pub token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
    /// replication configuration is 2 MB.</p>
    pub replication_configuration: std::option::Option<crate::model::ReplicationConfiguration>,
}
impl std::fmt::Debug for PutBucketReplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketReplicationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("token", &self.token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("replication_configuration", &self.replication_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketPolicyInput {
    /// <p>The name of the bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the request body.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Set this parameter to true to confirm that you want to remove your permissions to change
    /// this bucket policy in the future.</p>
    pub confirm_remove_self_bucket_access: bool,
    /// <p>The bucket policy as a JSON document.</p>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketPolicyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field(
            "confirm_remove_self_bucket_access",
            &self.confirm_remove_self_bucket_access,
        );
        formatter.field("policy", &self.policy);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketOwnershipControlsInput {
    /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the <code>OwnershipControls</code> request body. </p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) that you want
    /// to apply to this Amazon S3 bucket.</p>
    pub ownership_controls: std::option::Option<crate::model::OwnershipControls>,
}
impl std::fmt::Debug for PutBucketOwnershipControlsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketOwnershipControlsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("ownership_controls", &self.ownership_controls);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketNotificationConfigurationInput {
    /// <p>The name of the bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>A container for specifying the notification configuration of the bucket. If this element
    /// is empty, notifications are turned off for the bucket.</p>
    pub notification_configuration: std::option::Option<crate::model::NotificationConfiguration>,
}
impl std::fmt::Debug for PutBucketNotificationConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketNotificationConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "notification_configuration",
            &self.notification_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketMetricsConfigurationInput {
    /// <p>The name of the bucket for which the metrics configuration is set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the metrics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Specifies the metrics configuration.</p>
    pub metrics_configuration: std::option::Option<crate::model::MetricsConfiguration>,
}
impl std::fmt::Debug for PutBucketMetricsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketMetricsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("metrics_configuration", &self.metrics_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketLoggingInput {
    /// <p>The name of the bucket for which to set the logging parameters.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the <code>PutBucketLogging</code> request body.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for logging status information.</p>
    pub bucket_logging_status: std::option::Option<crate::model::BucketLoggingStatus>,
}
impl std::fmt::Debug for PutBucketLoggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketLoggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("bucket_logging_status", &self.bucket_logging_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketLifecycleConfigurationInput {
    /// <p>The name of the bucket for which to set the configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
    pub lifecycle_configuration: std::option::Option<crate::model::BucketLifecycleConfiguration>,
}
impl std::fmt::Debug for PutBucketLifecycleConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketLifecycleConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("lifecycle_configuration", &self.lifecycle_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketInventoryConfigurationInput {
    /// <p>The name of the bucket where the inventory configuration will be stored.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the inventory configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Specifies the inventory configuration.</p>
    pub inventory_configuration: std::option::Option<crate::model::InventoryConfiguration>,
}
impl std::fmt::Debug for PutBucketInventoryConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketInventoryConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("inventory_configuration", &self.inventory_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketIntelligentTieringConfigurationInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Container for S3 Intelligent-Tiering configuration.</p>
    pub intelligent_tiering_configuration:
        std::option::Option<crate::model::IntelligentTieringConfiguration>,
}
impl std::fmt::Debug for PutBucketIntelligentTieringConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketIntelligentTieringConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field(
            "intelligent_tiering_configuration",
            &self.intelligent_tiering_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketEncryptionInput {
    /// <p>Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed
    /// keys (SSE-S3) or customer master keys stored in AWS KMS (SSE-KMS). For information about
    /// the Amazon S3 default encryption feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html">Amazon S3 Default Bucket Encryption</a>
    /// in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the server-side encryption configuration.</p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Specifies the default server-side-encryption configuration.</p>
    pub server_side_encryption_configuration:
        std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
}
impl std::fmt::Debug for PutBucketEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketEncryptionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "server_side_encryption_configuration",
            &self.server_side_encryption_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketCorsInput {
    /// <p>Specifies the bucket impacted by the <code>cors</code>configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864.</a>
    /// </p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource
    /// Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub cors_configuration: std::option::Option<crate::model::CorsConfiguration>,
}
impl std::fmt::Debug for PutBucketCorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketCorsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("cors_configuration", &self.cors_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketAnalyticsConfigurationInput {
    /// <p>The name of the bucket to which an analytics configuration is stored.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID that identifies the analytics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The configuration and any analyses for the analytics filter.</p>
    pub analytics_configuration: std::option::Option<crate::model::AnalyticsConfiguration>,
}
impl std::fmt::Debug for PutBucketAnalyticsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketAnalyticsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("analytics_configuration", &self.analytics_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketAclInput {
    /// <p>The canned ACL to apply to the bucket.</p>
    pub acl: std::option::Option<crate::model::BucketCannedAcl>,
    /// <p>The bucket to which to apply the ACL.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864.</a>
    /// </p>
    /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    /// bucket.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to list the objects in the bucket.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the bucket ACL.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to create new objects in the bucket.</p>
    /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    pub grant_write: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
    pub access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
}
impl std::fmt::Debug for PutBucketAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketAclInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write", &self.grant_write);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("access_control_policy", &self.access_control_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketAccelerateConfigurationInput {
    /// <p>The name of the bucket for which the accelerate configuration is set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for setting the transfer acceleration state.</p>
    pub accelerate_configuration: std::option::Option<crate::model::AccelerateConfiguration>,
}
impl std::fmt::Debug for PutBucketAccelerateConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketAccelerateConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("accelerate_configuration", &self.accelerate_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPartsInput {
    /// <p>The name of the bucket to which the parts are being uploaded. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of parts to return.</p>
    pub max_parts: i32,
    /// <p>Specifies the part after which listing should begin. Only parts with higher part numbers
    /// will be listed.</p>
    pub part_number_marker: std::option::Option<std::string::String>,
    /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPartsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPartsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("max_parts", &self.max_parts);
        formatter.field("part_number_marker", &self.part_number_marker);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListObjectVersionsInput {
    /// <p>The bucket name that contains the objects. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
    /// same string between the <code>prefix</code> and the first occurrence of the delimiter are
    /// grouped under a single result element in CommonPrefixes. These groups are counted as one
    /// result against the max-keys limitation. These keys are not returned elsewhere in the
    /// response.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    /// characters that are not supported in XML 1.0, you can add this parameter to request that
    /// Amazon S3 encode the keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Specifies the key to start with when listing objects in a bucket.</p>
    pub key_marker: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    /// to 1,000 key names. The response might contain fewer keys but will never contain more. If
    /// additional keys satisfy the search criteria, but were not returned because max-keys was
    /// exceeded, the response contains <isTruncated>true</isTruncated>. To return the
    /// additional keys, see key-marker and version-id-marker.</p>
    pub max_keys: i32,
    /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
    /// can use prefixes to separate a bucket into different groupings of keys. (You can think of
    /// using prefix to make groups in the same way you'd use a folder in a file system.) You can
    /// use prefix with delimiter to roll up numerous objects into a single result under
    /// CommonPrefixes. </p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Specifies the object version you want to start listing from.</p>
    pub version_id_marker: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListObjectVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListObjectVersionsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("key_marker", &self.key_marker);
        formatter.field("max_keys", &self.max_keys);
        formatter.field("prefix", &self.prefix);
        formatter.field("version_id_marker", &self.version_id_marker);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListObjectsV2Input {
    /// <p>Bucket name to list. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A delimiter is a character you use to group keys.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    /// to 1,000 key names. The response might contain fewer keys but will never contain
    /// more.</p>
    pub max_keys: i32,
    /// <p>Limits the response to keys that begin with the specified prefix.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a
    /// token. ContinuationToken is obfuscated and is not a real key.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The owner field is not present in listV2 by default, if you want to return owner field
    /// with each key in the result then set the fetch owner field to true.</p>
    pub fetch_owner: bool,
    /// <p>StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this
    /// specified key. StartAfter can be any key in the bucket.</p>
    pub start_after: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that she or he will be charged for the list objects
    /// request in V2 style. Bucket owners need not specify this parameter in their
    /// requests.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListObjectsV2Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListObjectsV2Input");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("max_keys", &self.max_keys);
        formatter.field("prefix", &self.prefix);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("fetch_owner", &self.fetch_owner);
        formatter.field("start_after", &self.start_after);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListObjectsInput {
    /// <p>The name of the bucket containing the objects.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A delimiter is a character you use to group keys.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    /// characters that are not supported in XML 1.0, you can add this parameter to request that
    /// Amazon S3 encode the keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Specifies the key to start with when listing objects in a bucket.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    /// to 1,000 key names. The response might contain fewer keys but will never contain more.
    /// </p>
    pub max_keys: i32,
    /// <p>Limits the response to keys that begin with the specified prefix.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that she or he will be charged for the list objects
    /// request. Bucket owners need not specify this parameter in their requests.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListObjectsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListObjectsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("marker", &self.marker);
        formatter.field("max_keys", &self.max_keys);
        formatter.field("prefix", &self.prefix);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMultipartUploadsInput {
    /// <p>The name of the bucket to which the multipart upload was initiated. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Character you use to group keys.</p>
    /// <p>All keys that contain the same string between the prefix, if specified, and the first
    /// occurrence of the delimiter after the prefix are grouped under a single result element,
    /// <code>CommonPrefixes</code>. If you don't specify the prefix parameter, then the
    /// substring starts at the beginning of the key. The keys that are grouped under
    /// <code>CommonPrefixes</code> result element are not returned elsewhere in the
    /// response.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    /// characters that are not supported in XML 1.0, you can add this parameter to request that
    /// Amazon S3 encode the keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Together with upload-id-marker, this parameter specifies the multipart upload after
    /// which listing should begin.</p>
    /// <p>If <code>upload-id-marker</code> is not specified, only the keys lexicographically
    /// greater than the specified <code>key-marker</code> will be included in the list.</p>
    /// <p>If <code>upload-id-marker</code> is specified, any multipart uploads for a key equal to
    /// the <code>key-marker</code> might also be included, provided those multipart uploads have
    /// upload IDs lexicographically greater than the specified
    /// <code>upload-id-marker</code>.</p>
    pub key_marker: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response
    /// body. 1,000 is the maximum number of uploads that can be returned in a response.</p>
    pub max_uploads: i32,
    /// <p>Lists in-progress uploads only for those keys that begin with the specified prefix. You
    /// can use prefixes to separate a bucket into different grouping of keys. (You can think of
    /// using prefix to make groups in the same way you'd use a folder in a file system.)</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Together with key-marker, specifies the multipart upload after which listing should
    /// begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
    /// Otherwise, any multipart uploads for a key equal to the key-marker might be included in the
    /// list only if they have an upload ID lexicographically greater than the specified
    /// <code>upload-id-marker</code>.</p>
    pub upload_id_marker: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMultipartUploadsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMultipartUploadsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("key_marker", &self.key_marker);
        formatter.field("max_uploads", &self.max_uploads);
        formatter.field("prefix", &self.prefix);
        formatter.field("upload_id_marker", &self.upload_id_marker);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketsInput {}
impl std::fmt::Debug for ListBucketsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketMetricsConfigurationsInput {
    /// <p>The name of the bucket containing the metrics configurations to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The marker that is used to continue a metrics configuration listing that has been
    /// truncated. Use the NextContinuationToken from a previously truncated list response to
    /// continue the listing. The continuation token is an opaque value that Amazon S3
    /// understands.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketMetricsConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketMetricsConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketInventoryConfigurationsInput {
    /// <p>The name of the bucket containing the inventory configurations to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The marker used to continue an inventory configuration listing that has been truncated.
    /// Use the NextContinuationToken from a previously truncated list response to continue the
    /// listing. The continuation token is an opaque value that Amazon S3 understands.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketInventoryConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketInventoryConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketIntelligentTieringConfigurationsInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    /// begin.</p>
    pub continuation_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketIntelligentTieringConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketIntelligentTieringConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketAnalyticsConfigurationsInput {
    /// <p>The name of the bucket from which analytics configurations are retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    /// begin.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketAnalyticsConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketAnalyticsConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HeadObjectInput {
    /// <p>The name of the bucket containing the object.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
    /// otherwise return a 412 (precondition failed).</p>
    pub if_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has been modified since the specified time, otherwise
    /// return a 304 (not modified).</p>
    pub if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
    /// otherwise return a 304 (not modified).</p>
    pub if_none_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has not been modified since the specified time, otherwise
    /// return a 412 (precondition failed).</p>
    pub if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>The object key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
    /// Range header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
    /// <note>
    /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
    /// request.</p>
    /// </note>
    pub range: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
    /// Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about
    /// the size of the part and the number of parts in this object.</p>
    pub part_number: i32,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HeadObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HeadObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("if_match", &self.if_match);
        formatter.field("if_modified_since", &self.if_modified_since);
        formatter.field("if_none_match", &self.if_none_match);
        formatter.field("if_unmodified_since", &self.if_unmodified_since);
        formatter.field("key", &self.key);
        formatter.field("range", &self.range);
        formatter.field("version_id", &self.version_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("part_number", &self.part_number);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HeadBucketInput {
    /// <p>The bucket name.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HeadBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HeadBucketInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPublicAccessBlockInput {
    /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
    /// to retrieve. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPublicAccessBlockInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPublicAccessBlockInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectTorrentInput {
    /// <p>The name of the bucket containing the object for which to get the torrent files.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The object key for which to get the information.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectTorrentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectTorrentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectTaggingInput {
    /// <p>The bucket name containing the object for which to get the tagging information. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which to get the tagging information.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The versionId of the object for which to get the tagging information.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
}
impl std::fmt::Debug for GetObjectTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("request_payer", &self.request_payer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectRetentionInput {
    /// <p>The bucket name containing the object whose retention settings you want to retrieve. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object whose retention settings you want to retrieve.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The version ID for the object whose retention settings you want to retrieve.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectRetentionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectRetentionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectLockConfigurationInput {
    /// <p>The bucket whose Object Lock configuration you want to retrieve.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectLockConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectLockConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectLegalHoldInput {
    /// <p>The bucket name containing the object whose Legal Hold status you want to retrieve. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object whose Legal Hold status you want to retrieve.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The version ID of the object whose Legal Hold status you want to retrieve.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectLegalHoldInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectLegalHoldInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectAclInput {
    /// <p>The bucket name that contains the object for which to get the ACL information. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key of the object for which to get the ACL information.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectAclInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectInput {
    /// <p>The bucket name containing the object. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
    /// otherwise return a 412 (precondition failed).</p>
    pub if_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has been modified since the specified time, otherwise
    /// return a 304 (not modified).</p>
    pub if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
    /// otherwise return a 304 (not modified).</p>
    pub if_none_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has not been modified since the specified time, otherwise
    /// return a 412 (precondition failed).</p>
    pub if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Key of the object to get.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
    /// Range header, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
    /// <note>
    /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
    /// request.</p>
    /// </note>
    pub range: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Cache-Control</code> header of the response.</p>
    pub response_cache_control: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Disposition</code> header of the response</p>
    pub response_content_disposition: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Encoding</code> header of the response.</p>
    pub response_content_encoding: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Language</code> header of the response.</p>
    pub response_content_language: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Type</code> header of the response.</p>
    pub response_content_type: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Expires</code> header of the response.</p>
    pub response_expires: std::option::Option<smithy_types::Instant>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when decrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This
    /// value is used to decrypt the object when recovering it and must match the one used when
    /// storing the data. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
    /// Effectively performs a 'ranged' GET request for the part specified. Useful for downloading
    /// just a part of an object.</p>
    pub part_number: i32,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("if_match", &self.if_match);
        formatter.field("if_modified_since", &self.if_modified_since);
        formatter.field("if_none_match", &self.if_none_match);
        formatter.field("if_unmodified_since", &self.if_unmodified_since);
        formatter.field("key", &self.key);
        formatter.field("range", &self.range);
        formatter.field("response_cache_control", &self.response_cache_control);
        formatter.field(
            "response_content_disposition",
            &self.response_content_disposition,
        );
        formatter.field("response_content_encoding", &self.response_content_encoding);
        formatter.field("response_content_language", &self.response_content_language);
        formatter.field("response_content_type", &self.response_content_type);
        formatter.field("response_expires", &self.response_expires);
        formatter.field("version_id", &self.version_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("part_number", &self.part_number);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketWebsiteInput {
    /// <p>The bucket name for which to get the website configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketWebsiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketWebsiteInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketVersioningInput {
    /// <p>The name of the bucket for which to get the versioning information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketVersioningInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketVersioningInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketTaggingInput {
    /// <p>The name of the bucket for which to get the tagging information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketRequestPaymentInput {
    /// <p>The name of the bucket for which to get the payment request configuration</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketRequestPaymentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketRequestPaymentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketReplicationInput {
    /// <p>The bucket name for which to get the replication information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketReplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketReplicationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketPolicyStatusInput {
    /// <p>The name of the Amazon S3 bucket whose policy status you want to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketPolicyStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketPolicyStatusInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketPolicyInput {
    /// <p>The bucket name for which to get the bucket policy.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketPolicyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketOwnershipControlsInput {
    /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to retrieve.
    /// </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketOwnershipControlsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketOwnershipControlsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketNotificationConfigurationInput {
    /// <p>The name of the bucket for which to get the notification configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketNotificationConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketNotificationConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketMetricsConfigurationInput {
    /// <p>The name of the bucket containing the metrics configuration to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the metrics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketMetricsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketMetricsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketLoggingInput {
    /// <p>The bucket name for which to get the logging information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketLoggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketLoggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketLocationInput {
    /// <p>The name of the bucket for which to get the location.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketLocationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketLifecycleConfigurationInput {
    /// <p>The name of the bucket for which to get the lifecycle information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketLifecycleConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketLifecycleConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketInventoryConfigurationInput {
    /// <p>The name of the bucket containing the inventory configuration to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the inventory configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketInventoryConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketInventoryConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketIntelligentTieringConfigurationInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketIntelligentTieringConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketIntelligentTieringConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketEncryptionInput {
    /// <p>The name of the bucket from which the server-side encryption configuration is
    /// retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketEncryptionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketCorsInput {
    /// <p>The bucket name for which to get the cors configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketCorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketCorsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAnalyticsConfigurationInput {
    /// <p>The name of the bucket from which an analytics configuration is retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID that identifies the analytics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketAnalyticsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAnalyticsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAclInput {
    /// <p>Specifies the S3 bucket whose ACL is being requested.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAclInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAccelerateConfigurationInput {
    /// <p>The name of the bucket for which the accelerate configuration is retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketAccelerateConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAccelerateConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePublicAccessBlockInput {
    /// <p>The Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete.
    /// </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePublicAccessBlockInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePublicAccessBlockInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteObjectTaggingInput {
    /// <p>The bucket name containing the objects from which to remove the tags. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key that identifies the object in the bucket from which to remove all tags.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The versionId of the object that the tag-set will be removed from.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteObjectTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteObjectTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteObjectsInput {
    /// <p>The bucket name containing the objects to delete. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    /// that is displayed on your authentication device. Required to permanently delete a versioned
    /// object if versioning is configured with MFA delete enabled.</p>
    pub mfa: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Specifies whether you want to delete this object even if it has a Governance-type Object
    /// Lock in place. You must have sufficient permissions to perform this operation.</p>
    pub bypass_governance_retention: bool,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Container for the request.</p>
    pub delete: std::option::Option<crate::model::Delete>,
}
impl std::fmt::Debug for DeleteObjectsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteObjectsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("mfa", &self.mfa);
        formatter.field("request_payer", &self.request_payer);
        formatter.field(
            "bypass_governance_retention",
            &self.bypass_governance_retention,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("delete", &self.delete);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteObjectInput {
    /// <p>The bucket name of the bucket containing the object. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Key name of the object to delete.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    /// that is displayed on your authentication device. Required to permanently delete a versioned
    /// object if versioning is configured with MFA delete enabled.</p>
    pub mfa: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process
    /// this operation.</p>
    pub bypass_governance_retention: bool,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("mfa", &self.mfa);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field(
            "bypass_governance_retention",
            &self.bypass_governance_retention,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketWebsiteInput {
    /// <p>The bucket name for which you want to remove the website configuration. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketWebsiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketWebsiteInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketTaggingInput {
    /// <p>The bucket that has the tag set to be removed.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketReplicationInput {
    /// <p> The bucket name. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketReplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketReplicationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketPolicyInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketPolicyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketOwnershipControlsInput {
    /// <p>The Amazon S3 bucket whose <code>OwnershipControls</code> you want to delete. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketOwnershipControlsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketOwnershipControlsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketMetricsConfigurationInput {
    /// <p>The name of the bucket containing the metrics configuration to delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the metrics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketMetricsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketMetricsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketLifecycleInput {
    /// <p>The bucket name of the lifecycle to delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketLifecycleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketLifecycleInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketInventoryConfigurationInput {
    /// <p>The name of the bucket containing the inventory configuration to delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the inventory configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketInventoryConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketInventoryConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketIntelligentTieringConfigurationInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketIntelligentTieringConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketIntelligentTieringConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketEncryptionInput {
    /// <p>The name of the bucket containing the server-side encryption configuration to
    /// delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketEncryptionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketCorsInput {
    /// <p>Specifies the bucket whose <code>cors</code> configuration is being deleted.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketCorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketCorsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketAnalyticsConfigurationInput {
    /// <p>The name of the bucket from which an analytics configuration is deleted.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID that identifies the analytics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketAnalyticsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketAnalyticsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketInput {
    /// <p>Specifies the bucket being deleted.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMultipartUploadInput {
    /// <p>The canned ACL to apply to the object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>The name of the bucket to which to initiate the upload</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object data and its
    /// metadata.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload is to be initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    /// AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    /// STANDARD storage class provides high durability and high availability. Depending on
    /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    /// <i>Amazon S3 User Guide</i>.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    /// the object metadata.</p>
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the ID of the symmetric customer managed AWS KMS CMK to use for object
    /// encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not
    /// made via SSL or using SigV4. For information about configuring using any of the officially
    /// supported AWS SDKs and AWS CLI, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
    /// in the <i>Amazon S3 User Guide</i>.</p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
    /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    /// pairs.</p>
    pub ssekms_encryption_context: std::option::Option<std::string::String>,
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    /// <p>Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
    pub bucket_key_enabled: bool,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
    pub tagging: std::option::Option<std::string::String>,
    /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateMultipartUploadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMultipartUploadInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_type", &self.content_type);
        formatter.field("expires", &self.expires);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("metadata", &self.metadata);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ssekms_encryption_context",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBucketInput {
    /// <p>The canned ACL to apply to the bucket.</p>
    pub acl: std::option::Option<crate::model::BucketCannedAcl>,
    /// <p>The name of the bucket to create.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    /// bucket.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to list the objects in the bucket.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the bucket ACL.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to create new objects in the bucket.</p>
    /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    pub grant_write: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
    pub object_lock_enabled_for_bucket: bool,
    /// <p>The configuration information for the bucket.</p>
    pub create_bucket_configuration: std::option::Option<crate::model::CreateBucketConfiguration>,
}
impl std::fmt::Debug for CreateBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBucketInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write", &self.grant_write);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field(
            "object_lock_enabled_for_bucket",
            &self.object_lock_enabled_for_bucket,
        );
        formatter.field(
            "create_bucket_configuration",
            &self.create_bucket_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CopyObjectInput {
    /// <p>The canned ACL to apply to the object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>The name of the destination bucket.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>Specifies the source object for the copy operation. You specify the value in one of two
    /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
    /// <ul>
    /// <li>
    /// <p>For objects not accessed through an access point, specify the name of the source
    /// bucket and the key of the source object, separated by a slash (/). For example, to
    /// copy the object <code>reports/january.pdf</code> from the bucket
    /// <code>awsexamplebucket</code>, use
    /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
    /// encoded.</p>
    /// </li>
    /// <li>
    /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
    /// <note>
    /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
    /// </note>
    /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
    /// </li>
    /// </ul>
    /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
    /// to the value (for example,
    /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
    /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
    /// object.</p>
    pub copy_source: std::option::Option<std::string::String>,
    /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
    pub copy_source_if_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it has been modified since the specified time.</p>
    pub copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
    pub copy_source_if_none_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it hasn't been modified since the specified time.</p>
    pub copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object data and its
    /// metadata.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>The key of the destination object.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies whether the metadata is copied from the source object or replaced with
    /// metadata provided in the request.</p>
    pub metadata_directive: std::option::Option<crate::model::MetadataDirective>,
    /// <p>Specifies whether the object tag-set are copied from the source object or replaced with
    /// tag-set provided in the request.</p>
    pub tagging_directive: std::option::Option<crate::model::TaggingDirective>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    /// AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    /// STANDARD storage class provides high durability and high availability. Depending on
    /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    /// <i>Amazon S3 User Guide</i>.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    /// the object metadata.</p>
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for
    /// an object protected by AWS KMS will fail if not made via SSL or using SigV4. For
    /// information about configuring using any of the officially supported AWS SDKs and AWS CLI,
    /// see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the
    /// Signature Version in Request Authentication</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
    /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    /// pairs.</p>
    pub ssekms_encryption_context: std::option::Option<std::string::String>,
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. </p>
    /// <p>Specifying this header with a COPY action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
    pub bucket_key_enabled: bool,
    /// <p>Specifies the algorithm to use when decrypting the source object (for example,
    /// AES256).</p>
    pub copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
    /// object. The encryption key provided in this header must be one that was used when the
    /// source object was created.</p>
    pub copy_source_sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The tag-set for the object destination object this value must be used in conjunction
    /// with the <code>TaggingDirective</code>. The tag-set must be encoded as URL Query
    /// parameters.</p>
    pub tagging: std::option::Option<std::string::String>,
    /// <p>The Object Lock mode that you want to apply to the copied object.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>The date and time when you want the copied object's Object Lock to expire.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether you want to apply a Legal Hold to the copied object.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_source_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CopyObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CopyObjectInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_type", &self.content_type);
        formatter.field("copy_source", &self.copy_source);
        formatter.field("copy_source_if_match", &self.copy_source_if_match);
        formatter.field(
            "copy_source_if_modified_since",
            &self.copy_source_if_modified_since,
        );
        formatter.field("copy_source_if_none_match", &self.copy_source_if_none_match);
        formatter.field(
            "copy_source_if_unmodified_since",
            &self.copy_source_if_unmodified_since,
        );
        formatter.field("expires", &self.expires);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("metadata", &self.metadata);
        formatter.field("metadata_directive", &self.metadata_directive);
        formatter.field("tagging_directive", &self.tagging_directive);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ssekms_encryption_context",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field(
            "copy_source_sse_customer_algorithm",
            &self.copy_source_sse_customer_algorithm,
        );
        formatter.field(
            "copy_source_sse_customer_key",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field(
            "copy_source_sse_customer_key_md5",
            &self.copy_source_sse_customer_key_md5,
        );
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "expected_source_bucket_owner",
            &self.expected_source_bucket_owner,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteMultipartUploadInput {
    /// <p>Name of the bucket to which the multipart upload was initiated.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The container for the multipart upload request information.</p>
    pub multipart_upload: std::option::Option<crate::model::CompletedMultipartUpload>,
    /// <p>ID for the initiated multipart upload.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CompleteMultipartUploadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompleteMultipartUploadInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("multipart_upload", &self.multipart_upload);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AbortMultipartUploadInput {
    /// <p>The bucket name to which the upload was taking place. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Key of the object for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Upload ID that identifies the multipart upload.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AbortMultipartUploadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AbortMultipartUploadInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}
