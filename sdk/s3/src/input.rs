// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
pub mod abort_multipart_upload_input {
    /// A builder for [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name to which the upload was taking place. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Key of the object for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Upload ID that identifies the multipart upload.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AbortMultipartUploadInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AbortMultipartUploadInput {
                bucket: self.bucket,
                key: self.key,
                upload_id: self.upload_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type AbortMultipartUploadInputOperationOutputAlias = crate::operation::AbortMultipartUpload;
#[doc(hidden)]
pub type AbortMultipartUploadInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AbortMultipartUploadInput {
    /// Consumes the builder and constructs an Operation<[`AbortMultipartUpload`](crate::operation::AbortMultipartUpload)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AbortMultipartUpload,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AbortMultipartUploadInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_1 = &_input.bucket;
            let input_1 =
                input_1
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_1, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_2 = &_input.key;
            let input_2 =
                input_2
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_2, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::AbortMultipartUploadInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_3) = &_input.request_payer {
                let formatted_4 = AsRef::<str>::as_ref(inner_3);
                if !formatted_4.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_4;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_5) = &_input.expected_bucket_owner {
                let formatted_6 = AsRef::<str>::as_ref(inner_5);
                if !formatted_6.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_6;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::AbortMultipartUploadInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "AbortMultipartUpload");
            if let Some(inner_7) = &_input.upload_id {
                query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_7));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AbortMultipartUploadInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AbortMultipartUploadInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::AbortMultipartUpload::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "AbortMultipartUpload",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AbortMultipartUploadInput`](crate::input::AbortMultipartUploadInput)
    pub fn builder() -> crate::input::abort_multipart_upload_input::Builder {
        crate::input::abort_multipart_upload_input::Builder::default()
    }
}

/// See [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
pub mod complete_multipart_upload_input {
    /// A builder for [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) multipart_upload: std::option::Option<crate::model::CompletedMultipartUpload>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the bucket to which the multipart upload was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The container for the multipart upload request information.</p>
        pub fn multipart_upload(mut self, input: crate::model::CompletedMultipartUpload) -> Self {
            self.multipart_upload = Some(input);
            self
        }
        pub fn set_multipart_upload(
            mut self,
            input: std::option::Option<crate::model::CompletedMultipartUpload>,
        ) -> Self {
            self.multipart_upload = input;
            self
        }
        /// <p>ID for the initiated multipart upload.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CompleteMultipartUploadInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CompleteMultipartUploadInput {
                bucket: self.bucket,
                key: self.key,
                multipart_upload: self.multipart_upload,
                upload_id: self.upload_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type CompleteMultipartUploadInputOperationOutputAlias =
    crate::operation::CompleteMultipartUpload;
#[doc(hidden)]
pub type CompleteMultipartUploadInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CompleteMultipartUploadInput {
    /// Consumes the builder and constructs an Operation<[`CompleteMultipartUpload`](crate::operation::CompleteMultipartUpload)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CompleteMultipartUpload,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CompleteMultipartUploadInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_8 = &_input.bucket;
            let input_8 =
                input_8
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_8, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_9 = &_input.key;
            let input_9 =
                input_9
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_9, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CompleteMultipartUploadInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_10) = &_input.request_payer {
                let formatted_11 = AsRef::<str>::as_ref(inner_10);
                if !formatted_11.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_11;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_12) = &_input.expected_bucket_owner {
                let formatted_13 = AsRef::<str>::as_ref(inner_12);
                if !formatted_13.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_13;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::CompleteMultipartUploadInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "CompleteMultipartUpload");
            if let Some(inner_14) = &_input.upload_id {
                query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_14));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CompleteMultipartUploadInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CompleteMultipartUploadInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_complete_multipart_upload_input(
            &self.multipart_upload,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CompleteMultipartUpload::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CompleteMultipartUpload",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CompleteMultipartUploadInput`](crate::input::CompleteMultipartUploadInput)
    pub fn builder() -> crate::input::complete_multipart_upload_input::Builder {
        crate::input::complete_multipart_upload_input::Builder::default()
    }
}

/// See [`CopyObjectInput`](crate::input::CopyObjectInput)
pub mod copy_object_input {
    /// A builder for [`CopyObjectInput`](crate::input::CopyObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) copy_source: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) copy_source_if_none_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) metadata_directive: std::option::Option<crate::model::MetadataDirective>,
        pub(crate) tagging_directive: std::option::Option<crate::model::TaggingDirective>,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) website_redirect_location: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) ssekms_encryption_context: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
        pub(crate) copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<std::string::String>,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) expected_source_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The name of the destination bucket.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>Specifies the source object for the copy operation. You specify the value in one of two
        /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
        /// <ul>
        /// <li>
        /// <p>For objects not accessed through an access point, specify the name of the source
        /// bucket and the key of the source object, separated by a slash (/). For example, to
        /// copy the object <code>reports/january.pdf</code> from the bucket
        /// <code>awsexamplebucket</code>, use
        /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
        /// encoded.</p>
        /// </li>
        /// <li>
        /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
        /// <note>
        /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same Amazon Web Services Region.</p>
        /// </note>
        /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
        /// </li>
        /// </ul>
        /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
        /// to the value (for example,
        /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
        /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
        /// object.</p>
        pub fn copy_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source = Some(input.into());
            self
        }
        pub fn set_copy_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.copy_source = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
        pub fn copy_source_if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_match = input;
            self
        }
        /// <p>Copies the object if it has been modified since the specified time.</p>
        pub fn copy_source_if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_modified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_modified_since = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
        pub fn copy_source_if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_none_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_none_match = input;
            self
        }
        /// <p>Copies the object if it hasn't been modified since the specified time.</p>
        pub fn copy_source_if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_unmodified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_unmodified_since = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>The key of the destination object.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>Specifies whether the metadata is copied from the source object or replaced with
        /// metadata provided in the request.</p>
        pub fn metadata_directive(mut self, input: crate::model::MetadataDirective) -> Self {
            self.metadata_directive = Some(input);
            self
        }
        pub fn set_metadata_directive(
            mut self,
            input: std::option::Option<crate::model::MetadataDirective>,
        ) -> Self {
            self.metadata_directive = input;
            self
        }
        /// <p>Specifies whether the object tag-set are copied from the source object or replaced with
        /// tag-set provided in the request.</p>
        pub fn tagging_directive(mut self, input: crate::model::TaggingDirective) -> Self {
            self.tagging_directive = Some(input);
            self
        }
        pub fn set_tagging_directive(
            mut self,
            input: std::option::Option<crate::model::TaggingDirective>,
        ) -> Self {
            self.tagging_directive = input;
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata.</p>
        pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_redirect_location = Some(input.into());
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_redirect_location = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Specifies the Amazon Web Services KMS key ID to use for object encryption. All GET and PUT requests for
        /// an object protected by Amazon Web Services KMS will fail if not made via SSL or using SigV4. For
        /// information about configuring using any of the officially supported Amazon Web Services SDKs and Amazon Web Services CLI,
        /// see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the
        /// Signature Version in Request Authentication</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p>Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_encryption_context = Some(input.into());
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_encryption_context = input;
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. </p>
        /// <p>Specifying this header with a COPY action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// <p>Specifies the algorithm to use when decrypting the source object (for example,
        /// AES256).</p>
        pub fn copy_source_sse_customer_algorithm(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
        /// object. The encryption key provided in this header must be one that was used when the
        /// source object was created.</p>
        pub fn copy_source_sse_customer_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn copy_source_sse_customer_key_md5(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The tag-set for the object destination object this value must be used in conjunction
        /// with the <code>TaggingDirective</code>. The tag-set must be encoded as URL Query
        /// parameters.</p>
        pub fn tagging(mut self, input: impl Into<std::string::String>) -> Self {
            self.tagging = Some(input.into());
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>The Object Lock mode that you want to apply to the copied object.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>The date and time when you want the copied object's Object Lock to expire.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>Specifies whether you want to apply a Legal Hold to the copied object.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_source_bucket_owner(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_source_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`CopyObjectInput`](crate::input::CopyObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CopyObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CopyObjectInput {
                acl: self.acl,
                bucket: self.bucket,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_type: self.content_type,
                copy_source: self.copy_source,
                copy_source_if_match: self.copy_source_if_match,
                copy_source_if_modified_since: self.copy_source_if_modified_since,
                copy_source_if_none_match: self.copy_source_if_none_match,
                copy_source_if_unmodified_since: self.copy_source_if_unmodified_since,
                expires: self.expires,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                metadata: self.metadata,
                metadata_directive: self.metadata_directive,
                tagging_directive: self.tagging_directive,
                server_side_encryption: self.server_side_encryption,
                storage_class: self.storage_class,
                website_redirect_location: self.website_redirect_location,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                ssekms_key_id: self.ssekms_key_id,
                ssekms_encryption_context: self.ssekms_encryption_context,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
                copy_source_sse_customer_algorithm: self.copy_source_sse_customer_algorithm,
                copy_source_sse_customer_key: self.copy_source_sse_customer_key,
                copy_source_sse_customer_key_md5: self.copy_source_sse_customer_key_md5,
                request_payer: self.request_payer,
                tagging: self.tagging,
                object_lock_mode: self.object_lock_mode,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                expected_bucket_owner: self.expected_bucket_owner,
                expected_source_bucket_owner: self.expected_source_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type CopyObjectInputOperationOutputAlias = crate::operation::CopyObject;
#[doc(hidden)]
pub type CopyObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CopyObjectInput {
    /// Consumes the builder and constructs an Operation<[`CopyObject`](crate::operation::CopyObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CopyObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CopyObjectInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_15 = &_input.bucket;
            let input_15 =
                input_15
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_15, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_16 = &_input.key;
            let input_16 =
                input_16
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_16, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CopyObjectInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_17) = &_input.acl {
                let formatted_18 = AsRef::<str>::as_ref(inner_17);
                if !formatted_18.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_18;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-acl", header_value);
                }
            }
            if let Some(inner_19) = &_input.cache_control {
                let formatted_20 = AsRef::<str>::as_ref(inner_19);
                if !formatted_20.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_20;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Cache-Control", header_value);
                }
            }
            if let Some(inner_21) = &_input.content_disposition {
                let formatted_22 = AsRef::<str>::as_ref(inner_21);
                if !formatted_22.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_22;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Disposition", header_value);
                }
            }
            if let Some(inner_23) = &_input.content_encoding {
                let formatted_24 = AsRef::<str>::as_ref(inner_23);
                if !formatted_24.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_24;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Encoding", header_value);
                }
            }
            if let Some(inner_25) = &_input.content_language {
                let formatted_26 = AsRef::<str>::as_ref(inner_25);
                if !formatted_26.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_26;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Language", header_value);
                }
            }
            if let Some(inner_27) = &_input.content_type {
                let formatted_28 = AsRef::<str>::as_ref(inner_27);
                if !formatted_28.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_28;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Type", header_value);
                }
            }
            if let Some(inner_29) = &_input.copy_source {
                let formatted_30 = AsRef::<str>::as_ref(inner_29);
                if !formatted_30.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_30;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source", header_value);
                }
            }
            if let Some(inner_31) = &_input.copy_source_if_match {
                let formatted_32 = AsRef::<str>::as_ref(inner_31);
                if !formatted_32.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_32;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-match", header_value);
                }
            }
            if let Some(inner_33) = &_input.copy_source_if_modified_since {
                let formatted_34 = inner_33.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_34.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_34;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-modified-since", header_value);
                }
            }
            if let Some(inner_35) = &_input.copy_source_if_none_match {
                let formatted_36 = AsRef::<str>::as_ref(inner_35);
                if !formatted_36.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_36;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-none-match", header_value);
                }
            }
            if let Some(inner_37) = &_input.copy_source_if_unmodified_since {
                let formatted_38 = inner_37.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_38.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_38;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-unmodified-since", header_value);
                }
            }
            if let Some(inner_39) = &_input.expires {
                let formatted_40 = inner_39.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_40.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_40;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Expires", header_value);
                }
            }
            if let Some(inner_41) = &_input.grant_full_control {
                let formatted_42 = AsRef::<str>::as_ref(inner_41);
                if !formatted_42.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_42;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-full-control", header_value);
                }
            }
            if let Some(inner_43) = &_input.grant_read {
                let formatted_44 = AsRef::<str>::as_ref(inner_43);
                if !formatted_44.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_44;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read", header_value);
                }
            }
            if let Some(inner_45) = &_input.grant_read_acp {
                let formatted_46 = AsRef::<str>::as_ref(inner_45);
                if !formatted_46.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_46;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read-acp", header_value);
                }
            }
            if let Some(inner_47) = &_input.grant_write_acp {
                let formatted_48 = AsRef::<str>::as_ref(inner_47);
                if !formatted_48.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_48;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write-acp", header_value);
                }
            }
            if let Some(inner_49) = &_input.metadata_directive {
                let formatted_50 = AsRef::<str>::as_ref(inner_49);
                if !formatted_50.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_50;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "metadata_directive",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-metadata-directive", header_value);
                }
            }
            if let Some(inner_51) = &_input.tagging_directive {
                let formatted_52 = AsRef::<str>::as_ref(inner_51);
                if !formatted_52.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_52;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "tagging_directive",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-tagging-directive", header_value);
                }
            }
            if let Some(inner_53) = &_input.server_side_encryption {
                let formatted_54 = AsRef::<str>::as_ref(inner_53);
                if !formatted_54.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_54;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-server-side-encryption", header_value);
                }
            }
            if let Some(inner_55) = &_input.storage_class {
                let formatted_56 = AsRef::<str>::as_ref(inner_55);
                if !formatted_56.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_56;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-storage-class", header_value);
                }
            }
            if let Some(inner_57) = &_input.website_redirect_location {
                let formatted_58 = AsRef::<str>::as_ref(inner_57);
                if !formatted_58.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_58;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "website_redirect_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-website-redirect-location", header_value);
                }
            }
            if let Some(inner_59) = &_input.sse_customer_algorithm {
                let formatted_60 = AsRef::<str>::as_ref(inner_59);
                if !formatted_60.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_60;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_61) = &_input.sse_customer_key {
                let formatted_62 = AsRef::<str>::as_ref(inner_61);
                if !formatted_62.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_62;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_63) = &_input.sse_customer_key_md5 {
                let formatted_64 = AsRef::<str>::as_ref(inner_63);
                if !formatted_64.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_64;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_65) = &_input.ssekms_key_id {
                let formatted_66 = AsRef::<str>::as_ref(inner_65);
                if !formatted_66.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_66;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
                }
            }
            if let Some(inner_67) = &_input.ssekms_encryption_context {
                let formatted_68 = AsRef::<str>::as_ref(inner_67);
                if !formatted_68.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_68;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_encryption_context",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder = builder.header("x-amz-server-side-encryption-context", header_value);
                }
            }
            if _input.bucket_key_enabled {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.bucket_key_enabled);
                let formatted_69 = encoder.encode();
                if !formatted_69.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_69;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-bucket-key-enabled",
                        header_value,
                    );
                }
            }
            if let Some(inner_70) = &_input.copy_source_sse_customer_algorithm {
                let formatted_71 = AsRef::<str>::as_ref(inner_70);
                if !formatted_71.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_71;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-copy-source-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_72) = &_input.copy_source_sse_customer_key {
                let formatted_73 = AsRef::<str>::as_ref(inner_72);
                if !formatted_73.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_73;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-copy-source-server-side-encryption-customer-key",
                        header_value,
                    );
                }
            }
            if let Some(inner_74) = &_input.copy_source_sse_customer_key_md5 {
                let formatted_75 = AsRef::<str>::as_ref(inner_74);
                if !formatted_75.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_75;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-copy-source-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_76) = &_input.request_payer {
                let formatted_77 = AsRef::<str>::as_ref(inner_76);
                if !formatted_77.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_77;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_78) = &_input.tagging {
                let formatted_79 = AsRef::<str>::as_ref(inner_78);
                if !formatted_79.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_79;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "tagging",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-tagging", header_value);
                }
            }
            if let Some(inner_80) = &_input.object_lock_mode {
                let formatted_81 = AsRef::<str>::as_ref(inner_80);
                if !formatted_81.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_81;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-mode", header_value);
                }
            }
            if let Some(inner_82) = &_input.object_lock_retain_until_date {
                let formatted_83 = inner_82.fmt(smithy_types::instant::Format::DateTime);
                if !formatted_83.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_83;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-retain-until-date", header_value);
                }
            }
            if let Some(inner_84) = &_input.object_lock_legal_hold_status {
                let formatted_85 = AsRef::<str>::as_ref(inner_84);
                if !formatted_85.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_85;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-legal-hold", header_value);
                }
            }
            if let Some(inner_86) = &_input.expected_bucket_owner {
                let formatted_87 = AsRef::<str>::as_ref(inner_86);
                if !formatted_87.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_87;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_88) = &_input.expected_source_bucket_owner {
                let formatted_89 = AsRef::<str>::as_ref(inner_88);
                if !formatted_89.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_89;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_source_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-source-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_90) = &_input.metadata {
                for (k, v) in inner_90 {
                    use std::str::FromStr;
                    let header_name =
                        http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                            .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header name: {}",
                                    k, err
                                ),
                            })?;
                    use std::convert::TryFrom;
                    let header_value = AsRef::<str>::as_ref(v);
                    let header_value =
                        http::header::HeaderValue::try_from(header_value).map_err(|err| {
                            smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header value: {}",
                                    v, err
                                ),
                            }
                        })?;
                    builder = builder.header(header_name, header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::CopyObjectInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "CopyObject");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CopyObjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CopyObjectInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::CopyObject::new())
                .with_metadata(smithy_http::operation::Metadata::new("CopyObject", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CopyObjectInput`](crate::input::CopyObjectInput)
    pub fn builder() -> crate::input::copy_object_input::Builder {
        crate::input::copy_object_input::Builder::default()
    }
}

/// See [`CreateBucketInput`](crate::input::CreateBucketInput)
pub mod create_bucket_input {
    /// A builder for [`CreateBucketInput`](crate::input::CreateBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::BucketCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) create_bucket_configuration:
            std::option::Option<crate::model::CreateBucketConfiguration>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) object_lock_enabled_for_bucket: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the bucket.</p>
        pub fn acl(mut self, input: crate::model::BucketCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::BucketCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The name of the bucket to create.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The configuration information for the bucket.</p>
        pub fn create_bucket_configuration(
            mut self,
            input: crate::model::CreateBucketConfiguration,
        ) -> Self {
            self.create_bucket_configuration = Some(input);
            self
        }
        pub fn set_create_bucket_configuration(
            mut self,
            input: std::option::Option<crate::model::CreateBucketConfiguration>,
        ) -> Self {
            self.create_bucket_configuration = input;
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write = Some(input.into());
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_write = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
        pub fn object_lock_enabled_for_bucket(mut self, input: bool) -> Self {
            self.object_lock_enabled_for_bucket = Some(input);
            self
        }
        pub fn set_object_lock_enabled_for_bucket(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.object_lock_enabled_for_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBucketInput`](crate::input::CreateBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateBucketInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateBucketInput {
                acl: self.acl,
                bucket: self.bucket,
                create_bucket_configuration: self.create_bucket_configuration,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write: self.grant_write,
                grant_write_acp: self.grant_write_acp,
                object_lock_enabled_for_bucket: self
                    .object_lock_enabled_for_bucket
                    .unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBucketInputOperationOutputAlias = crate::operation::CreateBucket;
#[doc(hidden)]
pub type CreateBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBucketInput {
    /// Consumes the builder and constructs an Operation<[`CreateBucket`](crate::operation::CreateBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateBucketInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_91 = &_input.bucket;
            let input_91 =
                input_91
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_91, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CreateBucketInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_92) = &_input.acl {
                let formatted_93 = AsRef::<str>::as_ref(inner_92);
                if !formatted_93.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_93;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-acl", header_value);
                }
            }
            if let Some(inner_94) = &_input.grant_full_control {
                let formatted_95 = AsRef::<str>::as_ref(inner_94);
                if !formatted_95.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_95;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-full-control", header_value);
                }
            }
            if let Some(inner_96) = &_input.grant_read {
                let formatted_97 = AsRef::<str>::as_ref(inner_96);
                if !formatted_97.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_97;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read", header_value);
                }
            }
            if let Some(inner_98) = &_input.grant_read_acp {
                let formatted_99 = AsRef::<str>::as_ref(inner_98);
                if !formatted_99.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_99;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read-acp", header_value);
                }
            }
            if let Some(inner_100) = &_input.grant_write {
                let formatted_101 = AsRef::<str>::as_ref(inner_100);
                if !formatted_101.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_101;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write", header_value);
                }
            }
            if let Some(inner_102) = &_input.grant_write_acp {
                let formatted_103 = AsRef::<str>::as_ref(inner_102);
                if !formatted_103.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_103;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write-acp", header_value);
                }
            }
            if _input.object_lock_enabled_for_bucket {
                let mut encoder =
                    smithy_types::primitive::Encoder::from(_input.object_lock_enabled_for_bucket);
                let formatted_104 = encoder.encode();
                if !formatted_104.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_104;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_enabled_for_bucket",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-bucket-object-lock-enabled", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateBucketInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_create_bucket_input(
            &self.create_bucket_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::CreateBucket::new())
                .with_metadata(smithy_http::operation::Metadata::new("CreateBucket", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBucketInput`](crate::input::CreateBucketInput)
    pub fn builder() -> crate::input::create_bucket_input::Builder {
        crate::input::create_bucket_input::Builder::default()
    }
}

/// See [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
pub mod create_multipart_upload_input {
    /// A builder for [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) website_redirect_location: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) ssekms_encryption_context: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<std::string::String>,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The name of the bucket to which to initiate the upload</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Object key for which the multipart upload is to be initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata.</p>
        pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_redirect_location = Some(input.into());
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_redirect_location = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Specifies the ID of the symmetric customer managed key to use for object
        /// encryption. All GET and PUT requests for an object protected by Amazon Web Services KMS will fail if not
        /// made via SSL or using SigV4. For information about configuring using any of the officially
        /// supported Amazon Web Services SDKs and Amazon Web Services CLI, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
        /// in the <i>Amazon S3 User Guide</i>.</p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p>Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_encryption_context = Some(input.into());
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_encryption_context = input;
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
        /// <p>Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
        pub fn tagging(mut self, input: impl Into<std::string::String>) -> Self {
            self.tagging = Some(input.into());
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMultipartUploadInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMultipartUploadInput {
                acl: self.acl,
                bucket: self.bucket,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_type: self.content_type,
                expires: self.expires,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                metadata: self.metadata,
                server_side_encryption: self.server_side_encryption,
                storage_class: self.storage_class,
                website_redirect_location: self.website_redirect_location,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                ssekms_key_id: self.ssekms_key_id,
                ssekms_encryption_context: self.ssekms_encryption_context,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
                request_payer: self.request_payer,
                tagging: self.tagging,
                object_lock_mode: self.object_lock_mode,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMultipartUploadInputOperationOutputAlias = crate::operation::CreateMultipartUpload;
#[doc(hidden)]
pub type CreateMultipartUploadInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateMultipartUploadInput {
    /// Consumes the builder and constructs an Operation<[`CreateMultipartUpload`](crate::operation::CreateMultipartUpload)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateMultipartUpload,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateMultipartUploadInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_105 = &_input.bucket;
            let input_105 =
                input_105
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_105, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_106 = &_input.key;
            let input_106 =
                input_106
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_106, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CreateMultipartUploadInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_107) = &_input.acl {
                let formatted_108 = AsRef::<str>::as_ref(inner_107);
                if !formatted_108.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_108;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-acl", header_value);
                }
            }
            if let Some(inner_109) = &_input.cache_control {
                let formatted_110 = AsRef::<str>::as_ref(inner_109);
                if !formatted_110.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_110;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Cache-Control", header_value);
                }
            }
            if let Some(inner_111) = &_input.content_disposition {
                let formatted_112 = AsRef::<str>::as_ref(inner_111);
                if !formatted_112.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_112;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Disposition", header_value);
                }
            }
            if let Some(inner_113) = &_input.content_encoding {
                let formatted_114 = AsRef::<str>::as_ref(inner_113);
                if !formatted_114.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_114;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Encoding", header_value);
                }
            }
            if let Some(inner_115) = &_input.content_language {
                let formatted_116 = AsRef::<str>::as_ref(inner_115);
                if !formatted_116.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_116;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Language", header_value);
                }
            }
            if let Some(inner_117) = &_input.content_type {
                let formatted_118 = AsRef::<str>::as_ref(inner_117);
                if !formatted_118.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_118;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Type", header_value);
                }
            }
            if let Some(inner_119) = &_input.expires {
                let formatted_120 = inner_119.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_120.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_120;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Expires", header_value);
                }
            }
            if let Some(inner_121) = &_input.grant_full_control {
                let formatted_122 = AsRef::<str>::as_ref(inner_121);
                if !formatted_122.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_122;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-full-control", header_value);
                }
            }
            if let Some(inner_123) = &_input.grant_read {
                let formatted_124 = AsRef::<str>::as_ref(inner_123);
                if !formatted_124.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_124;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read", header_value);
                }
            }
            if let Some(inner_125) = &_input.grant_read_acp {
                let formatted_126 = AsRef::<str>::as_ref(inner_125);
                if !formatted_126.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_126;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read-acp", header_value);
                }
            }
            if let Some(inner_127) = &_input.grant_write_acp {
                let formatted_128 = AsRef::<str>::as_ref(inner_127);
                if !formatted_128.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_128;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write-acp", header_value);
                }
            }
            if let Some(inner_129) = &_input.server_side_encryption {
                let formatted_130 = AsRef::<str>::as_ref(inner_129);
                if !formatted_130.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_130;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-server-side-encryption", header_value);
                }
            }
            if let Some(inner_131) = &_input.storage_class {
                let formatted_132 = AsRef::<str>::as_ref(inner_131);
                if !formatted_132.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_132;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-storage-class", header_value);
                }
            }
            if let Some(inner_133) = &_input.website_redirect_location {
                let formatted_134 = AsRef::<str>::as_ref(inner_133);
                if !formatted_134.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_134;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "website_redirect_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-website-redirect-location", header_value);
                }
            }
            if let Some(inner_135) = &_input.sse_customer_algorithm {
                let formatted_136 = AsRef::<str>::as_ref(inner_135);
                if !formatted_136.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_136;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_137) = &_input.sse_customer_key {
                let formatted_138 = AsRef::<str>::as_ref(inner_137);
                if !formatted_138.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_138;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_139) = &_input.sse_customer_key_md5 {
                let formatted_140 = AsRef::<str>::as_ref(inner_139);
                if !formatted_140.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_140;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_141) = &_input.ssekms_key_id {
                let formatted_142 = AsRef::<str>::as_ref(inner_141);
                if !formatted_142.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_142;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
                }
            }
            if let Some(inner_143) = &_input.ssekms_encryption_context {
                let formatted_144 = AsRef::<str>::as_ref(inner_143);
                if !formatted_144.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_144;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_encryption_context",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder = builder.header("x-amz-server-side-encryption-context", header_value);
                }
            }
            if _input.bucket_key_enabled {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.bucket_key_enabled);
                let formatted_145 = encoder.encode();
                if !formatted_145.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_145;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-bucket-key-enabled",
                        header_value,
                    );
                }
            }
            if let Some(inner_146) = &_input.request_payer {
                let formatted_147 = AsRef::<str>::as_ref(inner_146);
                if !formatted_147.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_147;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_148) = &_input.tagging {
                let formatted_149 = AsRef::<str>::as_ref(inner_148);
                if !formatted_149.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_149;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "tagging",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-tagging", header_value);
                }
            }
            if let Some(inner_150) = &_input.object_lock_mode {
                let formatted_151 = AsRef::<str>::as_ref(inner_150);
                if !formatted_151.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_151;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-mode", header_value);
                }
            }
            if let Some(inner_152) = &_input.object_lock_retain_until_date {
                let formatted_153 = inner_152.fmt(smithy_types::instant::Format::DateTime);
                if !formatted_153.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_153;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-retain-until-date", header_value);
                }
            }
            if let Some(inner_154) = &_input.object_lock_legal_hold_status {
                let formatted_155 = AsRef::<str>::as_ref(inner_154);
                if !formatted_155.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_155;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-legal-hold", header_value);
                }
            }
            if let Some(inner_156) = &_input.expected_bucket_owner {
                let formatted_157 = AsRef::<str>::as_ref(inner_156);
                if !formatted_157.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_157;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_158) = &_input.metadata {
                for (k, v) in inner_158 {
                    use std::str::FromStr;
                    let header_name =
                        http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                            .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header name: {}",
                                    k, err
                                ),
                            })?;
                    use std::convert::TryFrom;
                    let header_value = AsRef::<str>::as_ref(v);
                    let header_value =
                        http::header::HeaderValue::try_from(header_value).map_err(|err| {
                            smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header value: {}",
                                    v, err
                                ),
                            }
                        })?;
                    builder = builder.header(header_name, header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::CreateMultipartUploadInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("uploads");
            query.push_kv("x-id", "CreateMultipartUpload");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateMultipartUploadInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateMultipartUploadInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMultipartUpload::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateMultipartUpload",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateMultipartUploadInput`](crate::input::CreateMultipartUploadInput)
    pub fn builder() -> crate::input::create_multipart_upload_input::Builder {
        crate::input::create_multipart_upload_input::Builder::default()
    }
}

/// See [`DeleteBucketInput`](crate::input::DeleteBucketInput)
pub mod delete_bucket_input {
    /// A builder for [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the bucket being deleted.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketInput`](crate::input::DeleteBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteBucketInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteBucketInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketInputOperationOutputAlias = crate::operation::DeleteBucket;
#[doc(hidden)]
pub type DeleteBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucket`](crate::operation::DeleteBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_159 = &_input.bucket;
            let input_159 =
                input_159
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_159, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_160) = &_input.expected_bucket_owner {
                let formatted_161 = AsRef::<str>::as_ref(inner_160);
                if !formatted_161.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_161;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::DeleteBucket::new())
                .with_metadata(smithy_http::operation::Metadata::new("DeleteBucket", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    pub fn builder() -> crate::input::delete_bucket_input::Builder {
        crate::input::delete_bucket_input::Builder::default()
    }
}

/// See [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
pub mod delete_bucket_analytics_configuration_input {
    /// A builder for [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which an analytics configuration is deleted.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketAnalyticsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketAnalyticsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketAnalyticsConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketAnalyticsConfiguration;
#[doc(hidden)]
pub type DeleteBucketAnalyticsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketAnalyticsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketAnalyticsConfiguration`](crate::operation::DeleteBucketAnalyticsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketAnalyticsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketAnalyticsConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_162 = &_input.bucket;
            let input_162 =
                input_162
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_162, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketAnalyticsConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_163) = &_input.expected_bucket_owner {
                let formatted_164 = AsRef::<str>::as_ref(inner_163);
                if !formatted_164.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_164;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::DeleteBucketAnalyticsConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("analytics");
            if let Some(inner_165) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_165));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketAnalyticsConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketAnalyticsConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketAnalyticsConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketAnalyticsConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketAnalyticsConfigurationInput`](crate::input::DeleteBucketAnalyticsConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_analytics_configuration_input::Builder {
        crate::input::delete_bucket_analytics_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
pub mod delete_bucket_cors_input {
    /// A builder for [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the bucket whose <code>cors</code> configuration is being deleted.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketCorsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketCorsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketCorsInputOperationOutputAlias = crate::operation::DeleteBucketCors;
#[doc(hidden)]
pub type DeleteBucketCorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketCorsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketCors`](crate::operation::DeleteBucketCors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketCors,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketCorsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_166 = &_input.bucket;
            let input_166 =
                input_166
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_166, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketCorsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_167) = &_input.expected_bucket_owner {
                let formatted_168 = AsRef::<str>::as_ref(inner_167);
                if !formatted_168.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_168;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketCorsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("cors");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketCorsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketCorsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketCors::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketCors",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketCorsInput`](crate::input::DeleteBucketCorsInput)
    pub fn builder() -> crate::input::delete_bucket_cors_input::Builder {
        crate::input::delete_bucket_cors_input::Builder::default()
    }
}

/// See [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
pub mod delete_bucket_encryption_input {
    /// A builder for [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the server-side encryption configuration to
        /// delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketEncryptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketEncryptionInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketEncryptionInputOperationOutputAlias = crate::operation::DeleteBucketEncryption;
#[doc(hidden)]
pub type DeleteBucketEncryptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketEncryption`](crate::operation::DeleteBucketEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketEncryptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_169 = &_input.bucket;
            let input_169 =
                input_169
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_169, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketEncryptionInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_170) = &_input.expected_bucket_owner {
                let formatted_171 = AsRef::<str>::as_ref(inner_170);
                if !formatted_171.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_171;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketEncryptionInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("encryption");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketEncryptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketEncryptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketEncryption::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketEncryption",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketEncryptionInput`](crate::input::DeleteBucketEncryptionInput)
    pub fn builder() -> crate::input::delete_bucket_encryption_input::Builder {
        crate::input::delete_bucket_encryption_input::Builder::default()
    }
}

/// See [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
pub mod delete_bucket_intelligent_tiering_configuration_input {
    /// A builder for [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketIntelligentTieringConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteBucketIntelligentTieringConfigurationInput {
                    bucket: self.bucket,
                    id: self.id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketIntelligentTieringConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketIntelligentTieringConfiguration;
#[doc(hidden)]
pub type DeleteBucketIntelligentTieringConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DeleteBucketIntelligentTieringConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketIntelligentTieringConfiguration`](crate::operation::DeleteBucketIntelligentTieringConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketIntelligentTieringConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketIntelligentTieringConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_172 = &_input.bucket;
            let input_172 =
                input_172
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_172, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::DeleteBucketIntelligentTieringConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("intelligent-tiering");
            if let Some(inner_173) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_173));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketIntelligentTieringConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketIntelligentTieringConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketIntelligentTieringConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketIntelligentTieringConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketIntelligentTieringConfigurationInput`](crate::input::DeleteBucketIntelligentTieringConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_intelligent_tiering_configuration_input::Builder
    {
        crate::input::delete_bucket_intelligent_tiering_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
pub mod delete_bucket_inventory_configuration_input {
    /// A builder for [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the inventory configuration to delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketInventoryConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketInventoryConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketInventoryConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketInventoryConfiguration;
#[doc(hidden)]
pub type DeleteBucketInventoryConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketInventoryConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketInventoryConfiguration`](crate::operation::DeleteBucketInventoryConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketInventoryConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketInventoryConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_174 = &_input.bucket;
            let input_174 =
                input_174
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_174, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketInventoryConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_175) = &_input.expected_bucket_owner {
                let formatted_176 = AsRef::<str>::as_ref(inner_175);
                if !formatted_176.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_176;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::DeleteBucketInventoryConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("inventory");
            if let Some(inner_177) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_177));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketInventoryConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketInventoryConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketInventoryConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketInventoryConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketInventoryConfigurationInput`](crate::input::DeleteBucketInventoryConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_inventory_configuration_input::Builder {
        crate::input::delete_bucket_inventory_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
pub mod delete_bucket_lifecycle_input {
    /// A builder for [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name of the lifecycle to delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketLifecycleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketLifecycleInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketLifecycleInputOperationOutputAlias = crate::operation::DeleteBucketLifecycle;
#[doc(hidden)]
pub type DeleteBucketLifecycleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketLifecycleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketLifecycle`](crate::operation::DeleteBucketLifecycle)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketLifecycle,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketLifecycleInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_178 = &_input.bucket;
            let input_178 =
                input_178
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_178, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketLifecycleInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_179) = &_input.expected_bucket_owner {
                let formatted_180 = AsRef::<str>::as_ref(inner_179);
                if !formatted_180.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_180;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketLifecycleInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("lifecycle");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketLifecycleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketLifecycleInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketLifecycle::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketLifecycle",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketLifecycleInput`](crate::input::DeleteBucketLifecycleInput)
    pub fn builder() -> crate::input::delete_bucket_lifecycle_input::Builder {
        crate::input::delete_bucket_lifecycle_input::Builder::default()
    }
}

/// See [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
pub mod delete_bucket_metrics_configuration_input {
    /// A builder for [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the metrics configuration to delete.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketMetricsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketMetricsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketMetricsConfigurationInputOperationOutputAlias =
    crate::operation::DeleteBucketMetricsConfiguration;
#[doc(hidden)]
pub type DeleteBucketMetricsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketMetricsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketMetricsConfiguration`](crate::operation::DeleteBucketMetricsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketMetricsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketMetricsConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_181 = &_input.bucket;
            let input_181 =
                input_181
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_181, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketMetricsConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_182) = &_input.expected_bucket_owner {
                let formatted_183 = AsRef::<str>::as_ref(inner_182);
                if !formatted_183.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_183;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::DeleteBucketMetricsConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("metrics");
            if let Some(inner_184) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_184));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketMetricsConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketMetricsConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketMetricsConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketMetricsConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketMetricsConfigurationInput`](crate::input::DeleteBucketMetricsConfigurationInput)
    pub fn builder() -> crate::input::delete_bucket_metrics_configuration_input::Builder {
        crate::input::delete_bucket_metrics_configuration_input::Builder::default()
    }
}

/// See [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
pub mod delete_bucket_ownership_controls_input {
    /// A builder for [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket whose <code>OwnershipControls</code> you want to delete. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketOwnershipControlsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketOwnershipControlsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketOwnershipControlsInputOperationOutputAlias =
    crate::operation::DeleteBucketOwnershipControls;
#[doc(hidden)]
pub type DeleteBucketOwnershipControlsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketOwnershipControlsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketOwnershipControls`](crate::operation::DeleteBucketOwnershipControls)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketOwnershipControls,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketOwnershipControlsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_185 = &_input.bucket;
            let input_185 =
                input_185
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_185, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketOwnershipControlsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_186) = &_input.expected_bucket_owner {
                let formatted_187 = AsRef::<str>::as_ref(inner_186);
                if !formatted_187.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_187;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::DeleteBucketOwnershipControlsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("ownershipControls");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketOwnershipControlsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketOwnershipControlsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketOwnershipControls::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketOwnershipControls",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketOwnershipControlsInput`](crate::input::DeleteBucketOwnershipControlsInput)
    pub fn builder() -> crate::input::delete_bucket_ownership_controls_input::Builder {
        crate::input::delete_bucket_ownership_controls_input::Builder::default()
    }
}

/// See [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
pub mod delete_bucket_policy_input {
    /// A builder for [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketPolicyInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketPolicyInputOperationOutputAlias = crate::operation::DeleteBucketPolicy;
#[doc(hidden)]
pub type DeleteBucketPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketPolicy`](crate::operation::DeleteBucketPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketPolicyInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_188 = &_input.bucket;
            let input_188 =
                input_188
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_188, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketPolicyInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_189) = &_input.expected_bucket_owner {
                let formatted_190 = AsRef::<str>::as_ref(inner_189);
                if !formatted_190.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_190;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketPolicyInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("policy");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketPolicyInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketPolicy::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketPolicy",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketPolicyInput`](crate::input::DeleteBucketPolicyInput)
    pub fn builder() -> crate::input::delete_bucket_policy_input::Builder {
        crate::input::delete_bucket_policy_input::Builder::default()
    }
}

/// See [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
pub mod delete_bucket_replication_input {
    /// A builder for [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The bucket name. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketReplicationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketReplicationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketReplicationInputOperationOutputAlias =
    crate::operation::DeleteBucketReplication;
#[doc(hidden)]
pub type DeleteBucketReplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketReplicationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketReplication`](crate::operation::DeleteBucketReplication)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketReplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketReplicationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_191 = &_input.bucket;
            let input_191 =
                input_191
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_191, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketReplicationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_192) = &_input.expected_bucket_owner {
                let formatted_193 = AsRef::<str>::as_ref(inner_192);
                if !formatted_193.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_193;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketReplicationInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("replication");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketReplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketReplicationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketReplication::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketReplication",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketReplicationInput`](crate::input::DeleteBucketReplicationInput)
    pub fn builder() -> crate::input::delete_bucket_replication_input::Builder {
        crate::input::delete_bucket_replication_input::Builder::default()
    }
}

/// See [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
pub mod delete_bucket_tagging_input {
    /// A builder for [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket that has the tag set to be removed.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketTaggingInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketTaggingInputOperationOutputAlias = crate::operation::DeleteBucketTagging;
#[doc(hidden)]
pub type DeleteBucketTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketTaggingInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketTagging`](crate::operation::DeleteBucketTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketTaggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_194 = &_input.bucket;
            let input_194 =
                input_194
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_194, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketTaggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_195) = &_input.expected_bucket_owner {
                let formatted_196 = AsRef::<str>::as_ref(inner_195);
                if !formatted_196.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_196;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketTaggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("tagging");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketTaggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketTaggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketTagging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketTagging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketTaggingInput`](crate::input::DeleteBucketTaggingInput)
    pub fn builder() -> crate::input::delete_bucket_tagging_input::Builder {
        crate::input::delete_bucket_tagging_input::Builder::default()
    }
}

/// See [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
pub mod delete_bucket_website_input {
    /// A builder for [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which you want to remove the website configuration. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketWebsiteInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketWebsiteInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketWebsiteInputOperationOutputAlias = crate::operation::DeleteBucketWebsite;
#[doc(hidden)]
pub type DeleteBucketWebsiteInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketWebsiteInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketWebsite`](crate::operation::DeleteBucketWebsite)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBucketWebsite,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketWebsiteInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_197 = &_input.bucket;
            let input_197 =
                input_197
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_197, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteBucketWebsiteInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_198) = &_input.expected_bucket_owner {
                let formatted_199 = AsRef::<str>::as_ref(inner_198);
                if !formatted_199.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_199;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteBucketWebsiteInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("website");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketWebsiteInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketWebsiteInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketWebsite::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteBucketWebsite",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketWebsiteInput`](crate::input::DeleteBucketWebsiteInput)
    pub fn builder() -> crate::input::delete_bucket_website_input::Builder {
        crate::input::delete_bucket_website_input::Builder::default()
    }
}

/// See [`DeleteObjectInput`](crate::input::DeleteObjectInput)
pub mod delete_object_input {
    /// A builder for [`DeleteObjectInput`](crate::input::DeleteObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) mfa: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) bypass_governance_retention: std::option::Option<bool>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name of the bucket containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Key name of the object to delete.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device. Required to permanently delete a versioned
        /// object if versioning is configured with MFA delete enabled.</p>
        pub fn mfa(mut self, input: impl Into<std::string::String>) -> Self {
            self.mfa = Some(input.into());
            self
        }
        pub fn set_mfa(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mfa = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process
        /// this operation. To use this header, you must have the <code>s3:PutBucketPublicAccessBlock</code>
        /// permission.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.bypass_governance_retention = Some(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.bypass_governance_retention = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectInput`](crate::input::DeleteObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteObjectInput {
                bucket: self.bucket,
                key: self.key,
                mfa: self.mfa,
                version_id: self.version_id,
                request_payer: self.request_payer,
                bypass_governance_retention: self.bypass_governance_retention.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteObjectInputOperationOutputAlias = crate::operation::DeleteObject;
#[doc(hidden)]
pub type DeleteObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteObjectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObject`](crate::operation::DeleteObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteObjectInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_200 = &_input.bucket;
            let input_200 =
                input_200
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_200, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_201 = &_input.key;
            let input_201 =
                input_201
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_201, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteObjectInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_202) = &_input.mfa {
                let formatted_203 = AsRef::<str>::as_ref(inner_202);
                if !formatted_203.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_203;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "mfa",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-mfa", header_value);
                }
            }
            if let Some(inner_204) = &_input.request_payer {
                let formatted_205 = AsRef::<str>::as_ref(inner_204);
                if !formatted_205.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_205;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if _input.bypass_governance_retention {
                let mut encoder =
                    smithy_types::primitive::Encoder::from(_input.bypass_governance_retention);
                let formatted_206 = encoder.encode();
                if !formatted_206.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_206;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bypass_governance_retention",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-bypass-governance-retention", header_value);
                }
            }
            if let Some(inner_207) = &_input.expected_bucket_owner {
                let formatted_208 = AsRef::<str>::as_ref(inner_207);
                if !formatted_208.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_208;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteObjectInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "DeleteObject");
            if let Some(inner_209) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_209));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteObjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteObjectInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::DeleteObject::new())
                .with_metadata(smithy_http::operation::Metadata::new("DeleteObject", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectInput`](crate::input::DeleteObjectInput)
    pub fn builder() -> crate::input::delete_object_input::Builder {
        crate::input::delete_object_input::Builder::default()
    }
}

/// See [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
pub mod delete_objects_input {
    /// A builder for [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delete: std::option::Option<crate::model::Delete>,
        pub(crate) mfa: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) bypass_governance_retention: std::option::Option<bool>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the objects to delete. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Container for the request.</p>
        pub fn delete(mut self, input: crate::model::Delete) -> Self {
            self.delete = Some(input);
            self
        }
        pub fn set_delete(mut self, input: std::option::Option<crate::model::Delete>) -> Self {
            self.delete = input;
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device. Required to permanently delete a versioned
        /// object if versioning is configured with MFA delete enabled.</p>
        pub fn mfa(mut self, input: impl Into<std::string::String>) -> Self {
            self.mfa = Some(input.into());
            self
        }
        pub fn set_mfa(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mfa = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Specifies whether you want to delete this object even if it has a Governance-type Object
        /// Lock in place. To use this header, you must have the <code>s3:PutBucketPublicAccessBlock</code>
        /// permission.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.bypass_governance_retention = Some(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.bypass_governance_retention = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteObjectsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteObjectsInput {
                bucket: self.bucket,
                delete: self.delete,
                mfa: self.mfa,
                request_payer: self.request_payer,
                bypass_governance_retention: self.bypass_governance_retention.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteObjectsInputOperationOutputAlias = crate::operation::DeleteObjects;
#[doc(hidden)]
pub type DeleteObjectsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteObjectsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObjects`](crate::operation::DeleteObjects)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteObjects,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteObjectsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_210 = &_input.bucket;
            let input_210 =
                input_210
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_210, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteObjectsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_211) = &_input.mfa {
                let formatted_212 = AsRef::<str>::as_ref(inner_211);
                if !formatted_212.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_212;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "mfa",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-mfa", header_value);
                }
            }
            if let Some(inner_213) = &_input.request_payer {
                let formatted_214 = AsRef::<str>::as_ref(inner_213);
                if !formatted_214.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_214;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if _input.bypass_governance_retention {
                let mut encoder =
                    smithy_types::primitive::Encoder::from(_input.bypass_governance_retention);
                let formatted_215 = encoder.encode();
                if !formatted_215.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_215;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bypass_governance_retention",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-bypass-governance-retention", header_value);
                }
            }
            if let Some(inner_216) = &_input.expected_bucket_owner {
                let formatted_217 = AsRef::<str>::as_ref(inner_216);
                if !formatted_217.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_217;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteObjectsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("delete");
            query.push_kv("x-id", "DeleteObjects");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteObjectsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteObjectsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_delete_objects_input(&self.delete)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::DeleteObjects::new())
                .with_metadata(smithy_http::operation::Metadata::new("DeleteObjects", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectsInput`](crate::input::DeleteObjectsInput)
    pub fn builder() -> crate::input::delete_objects_input::Builder {
        crate::input::delete_objects_input::Builder::default()
    }
}

/// See [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
pub mod delete_object_tagging_input {
    /// A builder for [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the objects from which to remove the tags. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key that identifies the object in the bucket from which to remove all tags.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The versionId of the object that the tag-set will be removed from.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteObjectTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteObjectTaggingInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteObjectTaggingInputOperationOutputAlias = crate::operation::DeleteObjectTagging;
#[doc(hidden)]
pub type DeleteObjectTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteObjectTaggingInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObjectTagging`](crate::operation::DeleteObjectTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteObjectTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteObjectTaggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_218 = &_input.bucket;
            let input_218 =
                input_218
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_218, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_219 = &_input.key;
            let input_219 =
                input_219
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_219, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteObjectTaggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_220) = &_input.expected_bucket_owner {
                let formatted_221 = AsRef::<str>::as_ref(inner_220);
                if !formatted_221.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_221;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeleteObjectTaggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("tagging");
            if let Some(inner_222) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_222));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteObjectTaggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteObjectTaggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteObjectTagging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteObjectTagging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectTaggingInput`](crate::input::DeleteObjectTaggingInput)
    pub fn builder() -> crate::input::delete_object_tagging_input::Builder {
        crate::input::delete_object_tagging_input::Builder::default()
    }
}

/// See [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
pub mod delete_public_access_block_input {
    /// A builder for [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete.
        /// </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePublicAccessBlockInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePublicAccessBlockInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePublicAccessBlockInputOperationOutputAlias =
    crate::operation::DeletePublicAccessBlock;
#[doc(hidden)]
pub type DeletePublicAccessBlockInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePublicAccessBlockInput {
    /// Consumes the builder and constructs an Operation<[`DeletePublicAccessBlock`](crate::operation::DeletePublicAccessBlock)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePublicAccessBlock,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeletePublicAccessBlockInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_223 = &_input.bucket;
            let input_223 =
                input_223
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_223, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeletePublicAccessBlockInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_224) = &_input.expected_bucket_owner {
                let formatted_225 = AsRef::<str>::as_ref(inner_224);
                if !formatted_225.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_225;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::DeletePublicAccessBlockInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("publicAccessBlock");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeletePublicAccessBlockInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeletePublicAccessBlockInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePublicAccessBlock::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeletePublicAccessBlock",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePublicAccessBlockInput`](crate::input::DeletePublicAccessBlockInput)
    pub fn builder() -> crate::input::delete_public_access_block_input::Builder {
        crate::input::delete_public_access_block_input::Builder::default()
    }
}

/// See [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
pub mod get_bucket_accelerate_configuration_input {
    /// A builder for [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which the accelerate configuration is retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketAccelerateConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketAccelerateConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAccelerateConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketAccelerateConfiguration;
#[doc(hidden)]
pub type GetBucketAccelerateConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAccelerateConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAccelerateConfiguration`](crate::operation::GetBucketAccelerateConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketAccelerateConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketAccelerateConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_226 = &_input.bucket;
            let input_226 =
                input_226
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_226, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketAccelerateConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_227) = &_input.expected_bucket_owner {
                let formatted_228 = AsRef::<str>::as_ref(inner_227);
                if !formatted_228.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_228;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketAccelerateConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("accelerate");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketAccelerateConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketAccelerateConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketAccelerateConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketAccelerateConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAccelerateConfigurationInput`](crate::input::GetBucketAccelerateConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_accelerate_configuration_input::Builder {
        crate::input::get_bucket_accelerate_configuration_input::Builder::default()
    }
}

/// See [`GetBucketAclInput`](crate::input::GetBucketAclInput)
pub mod get_bucket_acl_input {
    /// A builder for [`GetBucketAclInput`](crate::input::GetBucketAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the S3 bucket whose ACL is being requested.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAclInput`](crate::input::GetBucketAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetBucketAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetBucketAclInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAclInputOperationOutputAlias = crate::operation::GetBucketAcl;
#[doc(hidden)]
pub type GetBucketAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAclInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAcl`](crate::operation::GetBucketAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketAclInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_229 = &_input.bucket;
            let input_229 =
                input_229
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_229, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketAclInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_230) = &_input.expected_bucket_owner {
                let formatted_231 = AsRef::<str>::as_ref(inner_230);
                if !formatted_231.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_231;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketAclInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("acl");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketAclInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketAclInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetBucketAcl::new())
                .with_metadata(smithy_http::operation::Metadata::new("GetBucketAcl", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAclInput`](crate::input::GetBucketAclInput)
    pub fn builder() -> crate::input::get_bucket_acl_input::Builder {
        crate::input::get_bucket_acl_input::Builder::default()
    }
}

/// See [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
pub mod get_bucket_analytics_configuration_input {
    /// A builder for [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which an analytics configuration is retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketAnalyticsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketAnalyticsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAnalyticsConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketAnalyticsConfiguration;
#[doc(hidden)]
pub type GetBucketAnalyticsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAnalyticsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAnalyticsConfiguration`](crate::operation::GetBucketAnalyticsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketAnalyticsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketAnalyticsConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_232 = &_input.bucket;
            let input_232 =
                input_232
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_232, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketAnalyticsConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_233) = &_input.expected_bucket_owner {
                let formatted_234 = AsRef::<str>::as_ref(inner_233);
                if !formatted_234.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_234;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketAnalyticsConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("analytics");
            query.push_kv("x-id", "GetBucketAnalyticsConfiguration");
            if let Some(inner_235) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_235));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketAnalyticsConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketAnalyticsConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketAnalyticsConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketAnalyticsConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAnalyticsConfigurationInput`](crate::input::GetBucketAnalyticsConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_analytics_configuration_input::Builder {
        crate::input::get_bucket_analytics_configuration_input::Builder::default()
    }
}

/// See [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
pub mod get_bucket_cors_input {
    /// A builder for [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the cors configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetBucketCorsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetBucketCorsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketCorsInputOperationOutputAlias = crate::operation::GetBucketCors;
#[doc(hidden)]
pub type GetBucketCorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketCorsInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketCors`](crate::operation::GetBucketCors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketCors,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketCorsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_236 = &_input.bucket;
            let input_236 =
                input_236
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_236, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketCorsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_237) = &_input.expected_bucket_owner {
                let formatted_238 = AsRef::<str>::as_ref(inner_237);
                if !formatted_238.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_238;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketCorsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("cors");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketCorsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketCorsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetBucketCors::new())
                .with_metadata(smithy_http::operation::Metadata::new("GetBucketCors", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketCorsInput`](crate::input::GetBucketCorsInput)
    pub fn builder() -> crate::input::get_bucket_cors_input::Builder {
        crate::input::get_bucket_cors_input::Builder::default()
    }
}

/// See [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
pub mod get_bucket_encryption_input {
    /// A builder for [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which the server-side encryption configuration is
        /// retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketEncryptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketEncryptionInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketEncryptionInputOperationOutputAlias = crate::operation::GetBucketEncryption;
#[doc(hidden)]
pub type GetBucketEncryptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketEncryption`](crate::operation::GetBucketEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketEncryptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_239 = &_input.bucket;
            let input_239 =
                input_239
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_239, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketEncryptionInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_240) = &_input.expected_bucket_owner {
                let formatted_241 = AsRef::<str>::as_ref(inner_240);
                if !formatted_241.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_241;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketEncryptionInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("encryption");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketEncryptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketEncryptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketEncryption::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketEncryption",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketEncryptionInput`](crate::input::GetBucketEncryptionInput)
    pub fn builder() -> crate::input::get_bucket_encryption_input::Builder {
        crate::input::get_bucket_encryption_input::Builder::default()
    }
}

/// See [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
pub mod get_bucket_intelligent_tiering_configuration_input {
    /// A builder for [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketIntelligentTieringConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::GetBucketIntelligentTieringConfigurationInput {
                    bucket: self.bucket,
                    id: self.id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type GetBucketIntelligentTieringConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketIntelligentTieringConfiguration;
#[doc(hidden)]
pub type GetBucketIntelligentTieringConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl GetBucketIntelligentTieringConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketIntelligentTieringConfiguration`](crate::operation::GetBucketIntelligentTieringConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketIntelligentTieringConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketIntelligentTieringConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_242 = &_input.bucket;
            let input_242 =
                input_242
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_242, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetBucketIntelligentTieringConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("intelligent-tiering");
            query.push_kv("x-id", "GetBucketIntelligentTieringConfiguration");
            if let Some(inner_243) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_243));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketIntelligentTieringConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketIntelligentTieringConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketIntelligentTieringConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketIntelligentTieringConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketIntelligentTieringConfigurationInput`](crate::input::GetBucketIntelligentTieringConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_intelligent_tiering_configuration_input::Builder {
        crate::input::get_bucket_intelligent_tiering_configuration_input::Builder::default()
    }
}

/// See [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
pub mod get_bucket_inventory_configuration_input {
    /// A builder for [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the inventory configuration to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketInventoryConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketInventoryConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketInventoryConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketInventoryConfiguration;
#[doc(hidden)]
pub type GetBucketInventoryConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketInventoryConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketInventoryConfiguration`](crate::operation::GetBucketInventoryConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketInventoryConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketInventoryConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_244 = &_input.bucket;
            let input_244 =
                input_244
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_244, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketInventoryConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_245) = &_input.expected_bucket_owner {
                let formatted_246 = AsRef::<str>::as_ref(inner_245);
                if !formatted_246.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_246;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketInventoryConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("inventory");
            query.push_kv("x-id", "GetBucketInventoryConfiguration");
            if let Some(inner_247) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_247));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketInventoryConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketInventoryConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketInventoryConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketInventoryConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketInventoryConfigurationInput`](crate::input::GetBucketInventoryConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_inventory_configuration_input::Builder {
        crate::input::get_bucket_inventory_configuration_input::Builder::default()
    }
}

/// See [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
pub mod get_bucket_lifecycle_configuration_input {
    /// A builder for [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the lifecycle information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketLifecycleConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketLifecycleConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketLifecycleConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketLifecycleConfiguration;
#[doc(hidden)]
pub type GetBucketLifecycleConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketLifecycleConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketLifecycleConfiguration`](crate::operation::GetBucketLifecycleConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketLifecycleConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketLifecycleConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_248 = &_input.bucket;
            let input_248 =
                input_248
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_248, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketLifecycleConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_249) = &_input.expected_bucket_owner {
                let formatted_250 = AsRef::<str>::as_ref(inner_249);
                if !formatted_250.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_250;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketLifecycleConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("lifecycle");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketLifecycleConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketLifecycleConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketLifecycleConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketLifecycleConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketLifecycleConfigurationInput`](crate::input::GetBucketLifecycleConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_lifecycle_configuration_input::Builder {
        crate::input::get_bucket_lifecycle_configuration_input::Builder::default()
    }
}

/// See [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
pub mod get_bucket_location_input {
    /// A builder for [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the location.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketLocationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketLocationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketLocationInputOperationOutputAlias = crate::operation::GetBucketLocation;
#[doc(hidden)]
pub type GetBucketLocationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketLocationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketLocation`](crate::operation::GetBucketLocation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketLocation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketLocationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_251 = &_input.bucket;
            let input_251 =
                input_251
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_251, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketLocationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_252) = &_input.expected_bucket_owner {
                let formatted_253 = AsRef::<str>::as_ref(inner_252);
                if !formatted_253.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_253;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketLocationInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("location");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketLocationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketLocationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketLocation::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketLocation",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketLocationInput`](crate::input::GetBucketLocationInput)
    pub fn builder() -> crate::input::get_bucket_location_input::Builder {
        crate::input::get_bucket_location_input::Builder::default()
    }
}

/// See [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
pub mod get_bucket_logging_input {
    /// A builder for [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the logging information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketLoggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketLoggingInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketLoggingInputOperationOutputAlias = crate::operation::GetBucketLogging;
#[doc(hidden)]
pub type GetBucketLoggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketLoggingInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketLogging`](crate::operation::GetBucketLogging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketLogging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketLoggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_254 = &_input.bucket;
            let input_254 =
                input_254
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_254, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketLoggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_255) = &_input.expected_bucket_owner {
                let formatted_256 = AsRef::<str>::as_ref(inner_255);
                if !formatted_256.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_256;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketLoggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("logging");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketLoggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketLoggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketLogging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketLogging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketLoggingInput`](crate::input::GetBucketLoggingInput)
    pub fn builder() -> crate::input::get_bucket_logging_input::Builder {
        crate::input::get_bucket_logging_input::Builder::default()
    }
}

/// See [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
pub mod get_bucket_metrics_configuration_input {
    /// A builder for [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the metrics configuration to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketMetricsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketMetricsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketMetricsConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketMetricsConfiguration;
#[doc(hidden)]
pub type GetBucketMetricsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketMetricsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketMetricsConfiguration`](crate::operation::GetBucketMetricsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketMetricsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketMetricsConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_257 = &_input.bucket;
            let input_257 =
                input_257
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_257, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketMetricsConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_258) = &_input.expected_bucket_owner {
                let formatted_259 = AsRef::<str>::as_ref(inner_258);
                if !formatted_259.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_259;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketMetricsConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("metrics");
            query.push_kv("x-id", "GetBucketMetricsConfiguration");
            if let Some(inner_260) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_260));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketMetricsConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketMetricsConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketMetricsConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketMetricsConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketMetricsConfigurationInput`](crate::input::GetBucketMetricsConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_metrics_configuration_input::Builder {
        crate::input::get_bucket_metrics_configuration_input::Builder::default()
    }
}

/// See [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
pub mod get_bucket_notification_configuration_input {
    /// A builder for [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the notification configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketNotificationConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketNotificationConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketNotificationConfigurationInputOperationOutputAlias =
    crate::operation::GetBucketNotificationConfiguration;
#[doc(hidden)]
pub type GetBucketNotificationConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketNotificationConfiguration`](crate::operation::GetBucketNotificationConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketNotificationConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketNotificationConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_261 = &_input.bucket;
            let input_261 =
                input_261
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_261, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketNotificationConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_262) = &_input.expected_bucket_owner {
                let formatted_263 = AsRef::<str>::as_ref(inner_262);
                if !formatted_263.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_263;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketNotificationConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("notification");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketNotificationConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketNotificationConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketNotificationConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketNotificationConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketNotificationConfigurationInput`](crate::input::GetBucketNotificationConfigurationInput)
    pub fn builder() -> crate::input::get_bucket_notification_configuration_input::Builder {
        crate::input::get_bucket_notification_configuration_input::Builder::default()
    }
}

/// See [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
pub mod get_bucket_ownership_controls_input {
    /// A builder for [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to retrieve.
        /// </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketOwnershipControlsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketOwnershipControlsInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketOwnershipControlsInputOperationOutputAlias =
    crate::operation::GetBucketOwnershipControls;
#[doc(hidden)]
pub type GetBucketOwnershipControlsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketOwnershipControlsInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketOwnershipControls`](crate::operation::GetBucketOwnershipControls)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketOwnershipControls,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketOwnershipControlsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_264 = &_input.bucket;
            let input_264 =
                input_264
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_264, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketOwnershipControlsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_265) = &_input.expected_bucket_owner {
                let formatted_266 = AsRef::<str>::as_ref(inner_265);
                if !formatted_266.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_266;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetBucketOwnershipControlsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("ownershipControls");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketOwnershipControlsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketOwnershipControlsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketOwnershipControls::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketOwnershipControls",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketOwnershipControlsInput`](crate::input::GetBucketOwnershipControlsInput)
    pub fn builder() -> crate::input::get_bucket_ownership_controls_input::Builder {
        crate::input::get_bucket_ownership_controls_input::Builder::default()
    }
}

/// See [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
pub mod get_bucket_policy_input {
    /// A builder for [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the bucket policy.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketPolicyInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketPolicyInputOperationOutputAlias = crate::operation::GetBucketPolicy;
#[doc(hidden)]
pub type GetBucketPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketPolicy`](crate::operation::GetBucketPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketPolicyInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_267 = &_input.bucket;
            let input_267 =
                input_267
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_267, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketPolicyInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_268) = &_input.expected_bucket_owner {
                let formatted_269 = AsRef::<str>::as_ref(inner_268);
                if !formatted_269.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_269;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketPolicyInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("policy");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketPolicyInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketPolicy::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketPolicy",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketPolicyInput`](crate::input::GetBucketPolicyInput)
    pub fn builder() -> crate::input::get_bucket_policy_input::Builder {
        crate::input::get_bucket_policy_input::Builder::default()
    }
}

/// See [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
pub mod get_bucket_policy_status_input {
    /// A builder for [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose policy status you want to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketPolicyStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketPolicyStatusInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketPolicyStatusInputOperationOutputAlias = crate::operation::GetBucketPolicyStatus;
#[doc(hidden)]
pub type GetBucketPolicyStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketPolicyStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketPolicyStatus`](crate::operation::GetBucketPolicyStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketPolicyStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketPolicyStatusInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_270 = &_input.bucket;
            let input_270 =
                input_270
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_270, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketPolicyStatusInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_271) = &_input.expected_bucket_owner {
                let formatted_272 = AsRef::<str>::as_ref(inner_271);
                if !formatted_272.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_272;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketPolicyStatusInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("policyStatus");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketPolicyStatusInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketPolicyStatusInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketPolicyStatus::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketPolicyStatus",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketPolicyStatusInput`](crate::input::GetBucketPolicyStatusInput)
    pub fn builder() -> crate::input::get_bucket_policy_status_input::Builder {
        crate::input::get_bucket_policy_status_input::Builder::default()
    }
}

/// See [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
pub mod get_bucket_replication_input {
    /// A builder for [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the replication information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketReplicationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketReplicationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketReplicationInputOperationOutputAlias = crate::operation::GetBucketReplication;
#[doc(hidden)]
pub type GetBucketReplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketReplicationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketReplication`](crate::operation::GetBucketReplication)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketReplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketReplicationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_273 = &_input.bucket;
            let input_273 =
                input_273
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_273, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketReplicationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_274) = &_input.expected_bucket_owner {
                let formatted_275 = AsRef::<str>::as_ref(inner_274);
                if !formatted_275.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_275;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketReplicationInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("replication");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketReplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketReplicationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketReplication::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketReplication",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketReplicationInput`](crate::input::GetBucketReplicationInput)
    pub fn builder() -> crate::input::get_bucket_replication_input::Builder {
        crate::input::get_bucket_replication_input::Builder::default()
    }
}

/// See [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
pub mod get_bucket_request_payment_input {
    /// A builder for [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the payment request configuration</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketRequestPaymentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketRequestPaymentInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketRequestPaymentInputOperationOutputAlias =
    crate::operation::GetBucketRequestPayment;
#[doc(hidden)]
pub type GetBucketRequestPaymentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketRequestPaymentInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketRequestPayment`](crate::operation::GetBucketRequestPayment)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketRequestPayment,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketRequestPaymentInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_276 = &_input.bucket;
            let input_276 =
                input_276
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_276, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketRequestPaymentInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_277) = &_input.expected_bucket_owner {
                let formatted_278 = AsRef::<str>::as_ref(inner_277);
                if !formatted_278.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_278;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketRequestPaymentInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("requestPayment");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketRequestPaymentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketRequestPaymentInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketRequestPayment::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketRequestPayment",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketRequestPaymentInput`](crate::input::GetBucketRequestPaymentInput)
    pub fn builder() -> crate::input::get_bucket_request_payment_input::Builder {
        crate::input::get_bucket_request_payment_input::Builder::default()
    }
}

/// See [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
pub mod get_bucket_tagging_input {
    /// A builder for [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the tagging information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketTaggingInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketTaggingInputOperationOutputAlias = crate::operation::GetBucketTagging;
#[doc(hidden)]
pub type GetBucketTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketTaggingInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketTagging`](crate::operation::GetBucketTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketTaggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_279 = &_input.bucket;
            let input_279 =
                input_279
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_279, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketTaggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_280) = &_input.expected_bucket_owner {
                let formatted_281 = AsRef::<str>::as_ref(inner_280);
                if !formatted_281.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_281;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketTaggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("tagging");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketTaggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketTaggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketTagging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketTagging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketTaggingInput`](crate::input::GetBucketTaggingInput)
    pub fn builder() -> crate::input::get_bucket_tagging_input::Builder {
        crate::input::get_bucket_tagging_input::Builder::default()
    }
}

/// See [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
pub mod get_bucket_versioning_input {
    /// A builder for [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get the versioning information.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketVersioningInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketVersioningInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketVersioningInputOperationOutputAlias = crate::operation::GetBucketVersioning;
#[doc(hidden)]
pub type GetBucketVersioningInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketVersioningInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketVersioning`](crate::operation::GetBucketVersioning)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketVersioning,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketVersioningInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_282 = &_input.bucket;
            let input_282 =
                input_282
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_282, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketVersioningInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_283) = &_input.expected_bucket_owner {
                let formatted_284 = AsRef::<str>::as_ref(inner_283);
                if !formatted_284.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_284;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketVersioningInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("versioning");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketVersioningInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketVersioningInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketVersioning::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketVersioning",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketVersioningInput`](crate::input::GetBucketVersioningInput)
    pub fn builder() -> crate::input::get_bucket_versioning_input::Builder {
        crate::input::get_bucket_versioning_input::Builder::default()
    }
}

/// See [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
pub mod get_bucket_website_input {
    /// A builder for [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name for which to get the website configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketWebsiteInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketWebsiteInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketWebsiteInputOperationOutputAlias = crate::operation::GetBucketWebsite;
#[doc(hidden)]
pub type GetBucketWebsiteInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketWebsiteInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketWebsite`](crate::operation::GetBucketWebsite)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBucketWebsite,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketWebsiteInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_285 = &_input.bucket;
            let input_285 =
                input_285
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_285, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetBucketWebsiteInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_286) = &_input.expected_bucket_owner {
                let formatted_287 = AsRef::<str>::as_ref(inner_286);
                if !formatted_287.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_287;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetBucketWebsiteInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("website");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketWebsiteInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketWebsiteInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketWebsite::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetBucketWebsite",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketWebsiteInput`](crate::input::GetBucketWebsiteInput)
    pub fn builder() -> crate::input::get_bucket_website_input::Builder {
        crate::input::get_bucket_website_input::Builder::default()
    }
}

/// See [`GetObjectInput`](crate::input::GetObjectInput)
pub mod get_object_input {
    /// A builder for [`GetObjectInput`](crate::input::GetObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) if_match: std::option::Option<std::string::String>,
        pub(crate) if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) if_none_match: std::option::Option<std::string::String>,
        pub(crate) if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) range: std::option::Option<std::string::String>,
        pub(crate) response_cache_control: std::option::Option<std::string::String>,
        pub(crate) response_content_disposition: std::option::Option<std::string::String>,
        pub(crate) response_content_encoding: std::option::Option<std::string::String>,
        pub(crate) response_content_language: std::option::Option<std::string::String>,
        pub(crate) response_content_type: std::option::Option<std::string::String>,
        pub(crate) response_expires: std::option::Option<smithy_types::Instant>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using an Object Lambda access point the hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-object-lambda.<i>Region</i>.amazonaws.com.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
        /// otherwise return a 412 (precondition failed).</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_match = Some(input.into());
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.if_match = input;
            self
        }
        /// <p>Return the object only if it has been modified since the specified time, otherwise
        /// return a 304 (not modified).</p>
        pub fn if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_modified_since = Some(input);
            self
        }
        pub fn set_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_modified_since = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
        /// otherwise return a 304 (not modified).</p>
        pub fn if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_none_match = Some(input.into());
            self
        }
        pub fn set_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.if_none_match = input;
            self
        }
        /// <p>Return the object only if it has not been modified since the specified time, otherwise
        /// return a 412 (precondition failed).</p>
        pub fn if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_unmodified_since = Some(input);
            self
        }
        pub fn set_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_unmodified_since = input;
            self
        }
        /// <p>Key of the object to get.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
        /// Range header, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
        /// <note>
        /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
        /// request.</p>
        /// </note>
        pub fn range(mut self, input: impl Into<std::string::String>) -> Self {
            self.range = Some(input.into());
            self
        }
        pub fn set_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.range = input;
            self
        }
        /// <p>Sets the <code>Cache-Control</code> header of the response.</p>
        pub fn response_cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_cache_control = Some(input.into());
            self
        }
        pub fn set_response_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_cache_control = input;
            self
        }
        /// <p>Sets the <code>Content-Disposition</code> header of the response</p>
        pub fn response_content_disposition(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.response_content_disposition = Some(input.into());
            self
        }
        pub fn set_response_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_disposition = input;
            self
        }
        /// <p>Sets the <code>Content-Encoding</code> header of the response.</p>
        pub fn response_content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_content_encoding = Some(input.into());
            self
        }
        pub fn set_response_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_encoding = input;
            self
        }
        /// <p>Sets the <code>Content-Language</code> header of the response.</p>
        pub fn response_content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_content_language = Some(input.into());
            self
        }
        pub fn set_response_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_language = input;
            self
        }
        /// <p>Sets the <code>Content-Type</code> header of the response.</p>
        pub fn response_content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.response_content_type = Some(input.into());
            self
        }
        pub fn set_response_content_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.response_content_type = input;
            self
        }
        /// <p>Sets the <code>Expires</code> header of the response.</p>
        pub fn response_expires(mut self, input: smithy_types::Instant) -> Self {
            self.response_expires = Some(input);
            self
        }
        pub fn set_response_expires(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.response_expires = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when decrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This
        /// value is used to decrypt the object when recovering it and must match the one used when
        /// storing the data. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
        /// Effectively performs a 'ranged' GET request for the part specified. Useful for downloading
        /// just a part of an object.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectInput`](crate::input::GetObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetObjectInput {
                bucket: self.bucket,
                if_match: self.if_match,
                if_modified_since: self.if_modified_since,
                if_none_match: self.if_none_match,
                if_unmodified_since: self.if_unmodified_since,
                key: self.key,
                range: self.range,
                response_cache_control: self.response_cache_control,
                response_content_disposition: self.response_content_disposition,
                response_content_encoding: self.response_content_encoding,
                response_content_language: self.response_content_language,
                response_content_type: self.response_content_type,
                response_expires: self.response_expires,
                version_id: self.version_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                request_payer: self.request_payer,
                part_number: self.part_number.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectInputOperationOutputAlias = crate::operation::GetObject;
#[doc(hidden)]
pub type GetObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectInput {
    /// Creates a presigned request for this operation. The credentials provider from the `config`
    /// will be used to generate the request's signature, and the `presigning_config` provides additional
    /// presigning-specific config values, such as the amount of time the request should be valid for after
    /// creation.
    ///
    /// Presigned requests can be given to other users or applications to access a resource or perform
    /// an operation without having access to the AWS security credentials.
    #[cfg(feature = "client")]
    pub async fn presigned(
        self,
        config: &crate::config::Config,
        presigning_config: crate::presigning::config::PresigningConfig,
    ) -> Result<
        crate::presigning::request::PresignedRequest,
        smithy_http::result::SdkError<crate::error::GetObjectError>,
    > {
        let (mut request, _) = self
            .make_operation(config)
            .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?
            .into_request_response();
        {
            // Change signature type to query params and wire up presigning config
            let mut props = request.properties_mut();
            props.insert(presigning_config.start_time());
            props.insert(aws_sigv4::http_request::SignableBody::UnsignedPayload);
            let mut config = props
                .get_mut::<aws_sig_auth::signer::OperationSigningConfig>()
                .expect("signing config added by make_operation()");
            config.signature_type = aws_sig_auth::signer::HttpSignatureType::HttpRequestQueryParams;
            config.expires_in = Some(presigning_config.expires());
        }
        let middleware = aws_hyper::AwsMiddleware::default();
        let mut svc = tower::builder::ServiceBuilder::new()
            .layer(&middleware)
            .service(crate::presigning::service::PresignedRequestService::new());

        use tower::{Service, ServiceExt};
        Ok(svc.ready().await?.call(request).await?)
    }
    /// Consumes the builder and constructs an Operation<[`GetObject`](crate::operation::GetObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_288 = &_input.bucket;
            let input_288 =
                input_288
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_288, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_289 = &_input.key;
            let input_289 =
                input_289
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_289, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_290) = &_input.if_match {
                let formatted_291 = AsRef::<str>::as_ref(inner_290);
                if !formatted_291.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_291;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-Match", header_value);
                }
            }
            if let Some(inner_292) = &_input.if_modified_since {
                let formatted_293 = inner_292.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_293.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_293;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-Modified-Since", header_value);
                }
            }
            if let Some(inner_294) = &_input.if_none_match {
                let formatted_295 = AsRef::<str>::as_ref(inner_294);
                if !formatted_295.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_295;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-None-Match", header_value);
                }
            }
            if let Some(inner_296) = &_input.if_unmodified_since {
                let formatted_297 = inner_296.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_297.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_297;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-Unmodified-Since", header_value);
                }
            }
            if let Some(inner_298) = &_input.range {
                let formatted_299 = AsRef::<str>::as_ref(inner_298);
                if !formatted_299.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_299;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Range", header_value);
                }
            }
            if let Some(inner_300) = &_input.sse_customer_algorithm {
                let formatted_301 = AsRef::<str>::as_ref(inner_300);
                if !formatted_301.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_301;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_302) = &_input.sse_customer_key {
                let formatted_303 = AsRef::<str>::as_ref(inner_302);
                if !formatted_303.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_303;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_304) = &_input.sse_customer_key_md5 {
                let formatted_305 = AsRef::<str>::as_ref(inner_304);
                if !formatted_305.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_305;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_306) = &_input.request_payer {
                let formatted_307 = AsRef::<str>::as_ref(inner_306);
                if !formatted_307.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_307;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_308) = &_input.expected_bucket_owner {
                let formatted_309 = AsRef::<str>::as_ref(inner_308);
                if !formatted_309.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_309;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetObjectInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "GetObject");
            if let Some(inner_310) = &_input.response_cache_control {
                query.push_kv(
                    "response-cache-control",
                    &smithy_http::query::fmt_string(&inner_310),
                );
            }
            if let Some(inner_311) = &_input.response_content_disposition {
                query.push_kv(
                    "response-content-disposition",
                    &smithy_http::query::fmt_string(&inner_311),
                );
            }
            if let Some(inner_312) = &_input.response_content_encoding {
                query.push_kv(
                    "response-content-encoding",
                    &smithy_http::query::fmt_string(&inner_312),
                );
            }
            if let Some(inner_313) = &_input.response_content_language {
                query.push_kv(
                    "response-content-language",
                    &smithy_http::query::fmt_string(&inner_313),
                );
            }
            if let Some(inner_314) = &_input.response_content_type {
                query.push_kv(
                    "response-content-type",
                    &smithy_http::query::fmt_string(&inner_314),
                );
            }
            if let Some(inner_315) = &_input.response_expires {
                query.push_kv(
                    "response-expires",
                    &smithy_http::query::fmt_timestamp(
                        inner_315,
                        smithy_types::instant::Format::HttpDate,
                    ),
                );
            }
            if let Some(inner_316) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_316));
            }
            if _input.part_number != 0 {
                query.push_kv(
                    "partNumber",
                    &smithy_types::primitive::Encoder::from(_input.part_number).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetObject::new())
                .with_metadata(smithy_http::operation::Metadata::new("GetObject", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectInput`](crate::input::GetObjectInput)
    pub fn builder() -> crate::input::get_object_input::Builder {
        crate::input::get_object_input::Builder::default()
    }
}

/// See [`GetObjectAclInput`](crate::input::GetObjectAclInput)
pub mod get_object_acl_input {
    /// A builder for [`GetObjectAclInput`](crate::input::GetObjectAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name that contains the object for which to get the ACL information. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key of the object for which to get the ACL information.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectAclInput`](crate::input::GetObjectAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetObjectAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetObjectAclInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectAclInputOperationOutputAlias = crate::operation::GetObjectAcl;
#[doc(hidden)]
pub type GetObjectAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectAclInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectAcl`](crate::operation::GetObjectAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectAclInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_317 = &_input.bucket;
            let input_317 =
                input_317
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_317, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_318 = &_input.key;
            let input_318 =
                input_318
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_318, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectAclInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_319) = &_input.request_payer {
                let formatted_320 = AsRef::<str>::as_ref(inner_319);
                if !formatted_320.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_320;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_321) = &_input.expected_bucket_owner {
                let formatted_322 = AsRef::<str>::as_ref(inner_321);
                if !formatted_322.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_322;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetObjectAclInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("acl");
            if let Some(inner_323) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_323));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectAclInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectAclInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetObjectAcl::new())
                .with_metadata(smithy_http::operation::Metadata::new("GetObjectAcl", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectAclInput`](crate::input::GetObjectAclInput)
    pub fn builder() -> crate::input::get_object_acl_input::Builder {
        crate::input::get_object_acl_input::Builder::default()
    }
}

/// See [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
pub mod get_object_legal_hold_input {
    /// A builder for [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object whose Legal Hold status you want to retrieve. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object whose Legal Hold status you want to retrieve.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The version ID of the object whose Legal Hold status you want to retrieve.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectLegalHoldInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectLegalHoldInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectLegalHoldInputOperationOutputAlias = crate::operation::GetObjectLegalHold;
#[doc(hidden)]
pub type GetObjectLegalHoldInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectLegalHoldInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectLegalHold`](crate::operation::GetObjectLegalHold)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectLegalHold,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectLegalHoldInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_324 = &_input.bucket;
            let input_324 =
                input_324
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_324, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_325 = &_input.key;
            let input_325 =
                input_325
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_325, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectLegalHoldInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_326) = &_input.request_payer {
                let formatted_327 = AsRef::<str>::as_ref(inner_326);
                if !formatted_327.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_327;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_328) = &_input.expected_bucket_owner {
                let formatted_329 = AsRef::<str>::as_ref(inner_328);
                if !formatted_329.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_329;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetObjectLegalHoldInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("legal-hold");
            if let Some(inner_330) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_330));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectLegalHoldInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectLegalHoldInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetObjectLegalHold::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetObjectLegalHold",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectLegalHoldInput`](crate::input::GetObjectLegalHoldInput)
    pub fn builder() -> crate::input::get_object_legal_hold_input::Builder {
        crate::input::get_object_legal_hold_input::Builder::default()
    }
}

/// See [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
pub mod get_object_lock_configuration_input {
    /// A builder for [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket whose Object Lock configuration you want to retrieve.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectLockConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectLockConfigurationInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectLockConfigurationInputOperationOutputAlias =
    crate::operation::GetObjectLockConfiguration;
#[doc(hidden)]
pub type GetObjectLockConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectLockConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectLockConfiguration`](crate::operation::GetObjectLockConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectLockConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectLockConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_331 = &_input.bucket;
            let input_331 =
                input_331
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_331, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectLockConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_332) = &_input.expected_bucket_owner {
                let formatted_333 = AsRef::<str>::as_ref(inner_332);
                if !formatted_333.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_333;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::GetObjectLockConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("object-lock");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectLockConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectLockConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetObjectLockConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetObjectLockConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectLockConfigurationInput`](crate::input::GetObjectLockConfigurationInput)
    pub fn builder() -> crate::input::get_object_lock_configuration_input::Builder {
        crate::input::get_object_lock_configuration_input::Builder::default()
    }
}

/// See [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
pub mod get_object_retention_input {
    /// A builder for [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object whose retention settings you want to retrieve. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object whose retention settings you want to retrieve.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The version ID for the object whose retention settings you want to retrieve.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectRetentionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectRetentionInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectRetentionInputOperationOutputAlias = crate::operation::GetObjectRetention;
#[doc(hidden)]
pub type GetObjectRetentionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectRetentionInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectRetention`](crate::operation::GetObjectRetention)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectRetention,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectRetentionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_334 = &_input.bucket;
            let input_334 =
                input_334
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_334, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_335 = &_input.key;
            let input_335 =
                input_335
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_335, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectRetentionInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_336) = &_input.request_payer {
                let formatted_337 = AsRef::<str>::as_ref(inner_336);
                if !formatted_337.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_337;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_338) = &_input.expected_bucket_owner {
                let formatted_339 = AsRef::<str>::as_ref(inner_338);
                if !formatted_339.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_339;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetObjectRetentionInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("retention");
            if let Some(inner_340) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_340));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectRetentionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectRetentionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetObjectRetention::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetObjectRetention",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectRetentionInput`](crate::input::GetObjectRetentionInput)
    pub fn builder() -> crate::input::get_object_retention_input::Builder {
        crate::input::get_object_retention_input::Builder::default()
    }
}

/// See [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
pub mod get_object_tagging_input {
    /// A builder for [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
    }
    impl Builder {
        /// <p>The bucket name containing the object for which to get the tagging information. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which to get the tagging information.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The versionId of the object for which to get the tagging information.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectTaggingInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                expected_bucket_owner: self.expected_bucket_owner,
                request_payer: self.request_payer,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectTaggingInputOperationOutputAlias = crate::operation::GetObjectTagging;
#[doc(hidden)]
pub type GetObjectTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectTaggingInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectTagging`](crate::operation::GetObjectTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectTaggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_341 = &_input.bucket;
            let input_341 =
                input_341
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_341, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_342 = &_input.key;
            let input_342 =
                input_342
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_342, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectTaggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_343) = &_input.expected_bucket_owner {
                let formatted_344 = AsRef::<str>::as_ref(inner_343);
                if !formatted_344.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_344;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_345) = &_input.request_payer {
                let formatted_346 = AsRef::<str>::as_ref(inner_345);
                if !formatted_346.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_346;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetObjectTaggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("tagging");
            if let Some(inner_347) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_347));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectTaggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectTaggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetObjectTagging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetObjectTagging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectTaggingInput`](crate::input::GetObjectTaggingInput)
    pub fn builder() -> crate::input::get_object_tagging_input::Builder {
        crate::input::get_object_tagging_input::Builder::default()
    }
}

/// See [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
pub mod get_object_torrent_input {
    /// A builder for [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the object for which to get the torrent files.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The object key for which to get the information.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetObjectTorrentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetObjectTorrentInput {
                bucket: self.bucket,
                key: self.key,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetObjectTorrentInputOperationOutputAlias = crate::operation::GetObjectTorrent;
#[doc(hidden)]
pub type GetObjectTorrentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetObjectTorrentInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectTorrent`](crate::operation::GetObjectTorrent)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetObjectTorrent,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetObjectTorrentInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_348 = &_input.bucket;
            let input_348 =
                input_348
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_348, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_349 = &_input.key;
            let input_349 =
                input_349
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_349, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetObjectTorrentInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_350) = &_input.request_payer {
                let formatted_351 = AsRef::<str>::as_ref(inner_350);
                if !formatted_351.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_351;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_352) = &_input.expected_bucket_owner {
                let formatted_353 = AsRef::<str>::as_ref(inner_352);
                if !formatted_353.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_353;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetObjectTorrentInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("torrent");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetObjectTorrentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetObjectTorrentInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetObjectTorrent::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetObjectTorrent",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetObjectTorrentInput`](crate::input::GetObjectTorrentInput)
    pub fn builder() -> crate::input::get_object_torrent_input::Builder {
        crate::input::get_object_torrent_input::Builder::default()
    }
}

/// See [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
pub mod get_public_access_block_input {
    /// A builder for [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
        /// to retrieve. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPublicAccessBlockInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPublicAccessBlockInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPublicAccessBlockInputOperationOutputAlias = crate::operation::GetPublicAccessBlock;
#[doc(hidden)]
pub type GetPublicAccessBlockInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPublicAccessBlockInput {
    /// Consumes the builder and constructs an Operation<[`GetPublicAccessBlock`](crate::operation::GetPublicAccessBlock)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetPublicAccessBlock,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetPublicAccessBlockInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_354 = &_input.bucket;
            let input_354 =
                input_354
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_354, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetPublicAccessBlockInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_355) = &_input.expected_bucket_owner {
                let formatted_356 = AsRef::<str>::as_ref(inner_355);
                if !formatted_356.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_356;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::GetPublicAccessBlockInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("publicAccessBlock");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetPublicAccessBlockInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetPublicAccessBlockInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPublicAccessBlock::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetPublicAccessBlock",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPublicAccessBlockInput`](crate::input::GetPublicAccessBlockInput)
    pub fn builder() -> crate::input::get_public_access_block_input::Builder {
        crate::input::get_public_access_block_input::Builder::default()
    }
}

/// See [`HeadBucketInput`](crate::input::HeadBucketInput)
pub mod head_bucket_input {
    /// A builder for [`HeadBucketInput`](crate::input::HeadBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`HeadBucketInput`](crate::input::HeadBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::HeadBucketInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::HeadBucketInput {
                bucket: self.bucket,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type HeadBucketInputOperationOutputAlias = crate::operation::HeadBucket;
#[doc(hidden)]
pub type HeadBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl HeadBucketInput {
    /// Consumes the builder and constructs an Operation<[`HeadBucket`](crate::operation::HeadBucket)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::HeadBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::HeadBucketInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_357 = &_input.bucket;
            let input_357 =
                input_357
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_357, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::HeadBucketInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_358) = &_input.expected_bucket_owner {
                let formatted_359 = AsRef::<str>::as_ref(inner_358);
                if !formatted_359.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_359;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::HeadBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("HEAD").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::HeadBucketInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::HeadBucket::new())
                .with_metadata(smithy_http::operation::Metadata::new("HeadBucket", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`HeadBucketInput`](crate::input::HeadBucketInput)
    pub fn builder() -> crate::input::head_bucket_input::Builder {
        crate::input::head_bucket_input::Builder::default()
    }
}

/// See [`HeadObjectInput`](crate::input::HeadObjectInput)
pub mod head_object_input {
    /// A builder for [`HeadObjectInput`](crate::input::HeadObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) if_match: std::option::Option<std::string::String>,
        pub(crate) if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) if_none_match: std::option::Option<std::string::String>,
        pub(crate) if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) range: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the object.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
        /// otherwise return a 412 (precondition failed).</p>
        pub fn if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_match = Some(input.into());
            self
        }
        pub fn set_if_match(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.if_match = input;
            self
        }
        /// <p>Return the object only if it has been modified since the specified time, otherwise
        /// return a 304 (not modified).</p>
        pub fn if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_modified_since = Some(input);
            self
        }
        pub fn set_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_modified_since = input;
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
        /// otherwise return a 304 (not modified).</p>
        pub fn if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.if_none_match = Some(input.into());
            self
        }
        pub fn set_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.if_none_match = input;
            self
        }
        /// <p>Return the object only if it has not been modified since the specified time, otherwise
        /// return a 412 (precondition failed).</p>
        pub fn if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.if_unmodified_since = Some(input);
            self
        }
        pub fn set_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.if_unmodified_since = input;
            self
        }
        /// <p>The object key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
        /// Range header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
        /// <note>
        /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
        /// request.</p>
        /// </note>
        pub fn range(mut self, input: impl Into<std::string::String>) -> Self {
            self.range = Some(input.into());
            self
        }
        pub fn set_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.range = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
        /// Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about
        /// the size of the part and the number of parts in this object.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`HeadObjectInput`](crate::input::HeadObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::HeadObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::HeadObjectInput {
                bucket: self.bucket,
                if_match: self.if_match,
                if_modified_since: self.if_modified_since,
                if_none_match: self.if_none_match,
                if_unmodified_since: self.if_unmodified_since,
                key: self.key,
                range: self.range,
                version_id: self.version_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                request_payer: self.request_payer,
                part_number: self.part_number.unwrap_or_default(),
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type HeadObjectInputOperationOutputAlias = crate::operation::HeadObject;
#[doc(hidden)]
pub type HeadObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl HeadObjectInput {
    /// Consumes the builder and constructs an Operation<[`HeadObject`](crate::operation::HeadObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::HeadObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::HeadObjectInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_360 = &_input.bucket;
            let input_360 =
                input_360
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_360, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_361 = &_input.key;
            let input_361 =
                input_361
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_361, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::HeadObjectInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_362) = &_input.if_match {
                let formatted_363 = AsRef::<str>::as_ref(inner_362);
                if !formatted_363.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_363;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-Match", header_value);
                }
            }
            if let Some(inner_364) = &_input.if_modified_since {
                let formatted_365 = inner_364.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_365.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_365;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-Modified-Since", header_value);
                }
            }
            if let Some(inner_366) = &_input.if_none_match {
                let formatted_367 = AsRef::<str>::as_ref(inner_366);
                if !formatted_367.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_367;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-None-Match", header_value);
                }
            }
            if let Some(inner_368) = &_input.if_unmodified_since {
                let formatted_369 = inner_368.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_369.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_369;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("If-Unmodified-Since", header_value);
                }
            }
            if let Some(inner_370) = &_input.range {
                let formatted_371 = AsRef::<str>::as_ref(inner_370);
                if !formatted_371.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_371;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Range", header_value);
                }
            }
            if let Some(inner_372) = &_input.sse_customer_algorithm {
                let formatted_373 = AsRef::<str>::as_ref(inner_372);
                if !formatted_373.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_373;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_374) = &_input.sse_customer_key {
                let formatted_375 = AsRef::<str>::as_ref(inner_374);
                if !formatted_375.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_375;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_376) = &_input.sse_customer_key_md5 {
                let formatted_377 = AsRef::<str>::as_ref(inner_376);
                if !formatted_377.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_377;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_378) = &_input.request_payer {
                let formatted_379 = AsRef::<str>::as_ref(inner_378);
                if !formatted_379.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_379;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_380) = &_input.expected_bucket_owner {
                let formatted_381 = AsRef::<str>::as_ref(inner_380);
                if !formatted_381.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_381;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::HeadObjectInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_382) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_382));
            }
            if _input.part_number != 0 {
                query.push_kv(
                    "partNumber",
                    &smithy_types::primitive::Encoder::from(_input.part_number).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::HeadObjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("HEAD").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::HeadObjectInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::HeadObject::new())
                .with_metadata(smithy_http::operation::Metadata::new("HeadObject", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`HeadObjectInput`](crate::input::HeadObjectInput)
    pub fn builder() -> crate::input::head_object_input::Builder {
        crate::input::head_object_input::Builder::default()
    }
}

/// See [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
pub mod list_bucket_analytics_configurations_input {
    /// A builder for [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket from which analytics configurations are retrieved.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ContinuationToken that represents a placeholder from where this request should
        /// begin.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketAnalyticsConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBucketAnalyticsConfigurationsInput {
                bucket: self.bucket,
                continuation_token: self.continuation_token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBucketAnalyticsConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketAnalyticsConfigurations;
#[doc(hidden)]
pub type ListBucketAnalyticsConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketAnalyticsConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketAnalyticsConfigurations`](crate::operation::ListBucketAnalyticsConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketAnalyticsConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListBucketAnalyticsConfigurationsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_383 = &_input.bucket;
            let input_383 =
                input_383
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_383, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListBucketAnalyticsConfigurationsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_384) = &_input.expected_bucket_owner {
                let formatted_385 = AsRef::<str>::as_ref(inner_384);
                if !formatted_385.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_385;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::ListBucketAnalyticsConfigurationsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("analytics");
            query.push_kv("x-id", "ListBucketAnalyticsConfigurations");
            if let Some(inner_386) = &_input.continuation_token {
                query.push_kv(
                    "continuation-token",
                    &smithy_http::query::fmt_string(&inner_386),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListBucketAnalyticsConfigurationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListBucketAnalyticsConfigurationsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListBucketAnalyticsConfigurations::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListBucketAnalyticsConfigurations",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketAnalyticsConfigurationsInput`](crate::input::ListBucketAnalyticsConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_analytics_configurations_input::Builder {
        crate::input::list_bucket_analytics_configurations_input::Builder::default()
    }
}

/// See [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
pub mod list_bucket_intelligent_tiering_configurations_input {
    /// A builder for [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ContinuationToken that represents a placeholder from where this request should
        /// begin.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketIntelligentTieringConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::ListBucketIntelligentTieringConfigurationsInput {
                    bucket: self.bucket,
                    continuation_token: self.continuation_token,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type ListBucketIntelligentTieringConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketIntelligentTieringConfigurations;
#[doc(hidden)]
pub type ListBucketIntelligentTieringConfigurationsInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl ListBucketIntelligentTieringConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketIntelligentTieringConfigurations`](crate::operation::ListBucketIntelligentTieringConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketIntelligentTieringConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListBucketIntelligentTieringConfigurationsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_387 = &_input.bucket;
            let input_387 =
                input_387
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_387, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListBucketIntelligentTieringConfigurationsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("intelligent-tiering");
            query.push_kv("x-id", "ListBucketIntelligentTieringConfigurations");
            if let Some(inner_388) = &_input.continuation_token {
                query.push_kv(
                    "continuation-token",
                    &smithy_http::query::fmt_string(&inner_388),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListBucketIntelligentTieringConfigurationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListBucketIntelligentTieringConfigurationsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListBucketIntelligentTieringConfigurations::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListBucketIntelligentTieringConfigurations",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketIntelligentTieringConfigurationsInput`](crate::input::ListBucketIntelligentTieringConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_intelligent_tiering_configurations_input::Builder
    {
        crate::input::list_bucket_intelligent_tiering_configurations_input::Builder::default()
    }
}

/// See [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
pub mod list_bucket_inventory_configurations_input {
    /// A builder for [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the inventory configurations to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The marker used to continue an inventory configuration listing that has been truncated.
        /// Use the NextContinuationToken from a previously truncated list response to continue the
        /// listing. The continuation token is an opaque value that Amazon S3 understands.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketInventoryConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBucketInventoryConfigurationsInput {
                bucket: self.bucket,
                continuation_token: self.continuation_token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBucketInventoryConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketInventoryConfigurations;
#[doc(hidden)]
pub type ListBucketInventoryConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketInventoryConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketInventoryConfigurations`](crate::operation::ListBucketInventoryConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketInventoryConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListBucketInventoryConfigurationsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_389 = &_input.bucket;
            let input_389 =
                input_389
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_389, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListBucketInventoryConfigurationsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_390) = &_input.expected_bucket_owner {
                let formatted_391 = AsRef::<str>::as_ref(inner_390);
                if !formatted_391.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_391;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::ListBucketInventoryConfigurationsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("inventory");
            query.push_kv("x-id", "ListBucketInventoryConfigurations");
            if let Some(inner_392) = &_input.continuation_token {
                query.push_kv(
                    "continuation-token",
                    &smithy_http::query::fmt_string(&inner_392),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListBucketInventoryConfigurationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListBucketInventoryConfigurationsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListBucketInventoryConfigurations::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListBucketInventoryConfigurations",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketInventoryConfigurationsInput`](crate::input::ListBucketInventoryConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_inventory_configurations_input::Builder {
        crate::input::list_bucket_inventory_configurations_input::Builder::default()
    }
}

/// See [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
pub mod list_bucket_metrics_configurations_input {
    /// A builder for [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the metrics configurations to retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The marker that is used to continue a metrics configuration listing that has been
        /// truncated. Use the NextContinuationToken from a previously truncated list response to
        /// continue the listing. The continuation token is an opaque value that Amazon S3
        /// understands.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBucketMetricsConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBucketMetricsConfigurationsInput {
                bucket: self.bucket,
                continuation_token: self.continuation_token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBucketMetricsConfigurationsInputOperationOutputAlias =
    crate::operation::ListBucketMetricsConfigurations;
#[doc(hidden)]
pub type ListBucketMetricsConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketMetricsConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListBucketMetricsConfigurations`](crate::operation::ListBucketMetricsConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBucketMetricsConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListBucketMetricsConfigurationsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_393 = &_input.bucket;
            let input_393 =
                input_393
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_393, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListBucketMetricsConfigurationsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_394) = &_input.expected_bucket_owner {
                let formatted_395 = AsRef::<str>::as_ref(inner_394);
                if !formatted_395.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_395;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::ListBucketMetricsConfigurationsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("metrics");
            query.push_kv("x-id", "ListBucketMetricsConfigurations");
            if let Some(inner_396) = &_input.continuation_token {
                query.push_kv(
                    "continuation-token",
                    &smithy_http::query::fmt_string(&inner_396),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListBucketMetricsConfigurationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListBucketMetricsConfigurationsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListBucketMetricsConfigurations::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListBucketMetricsConfigurations",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketMetricsConfigurationsInput`](crate::input::ListBucketMetricsConfigurationsInput)
    pub fn builder() -> crate::input::list_bucket_metrics_configurations_input::Builder {
        crate::input::list_bucket_metrics_configurations_input::Builder::default()
    }
}

/// See [`ListBucketsInput`](crate::input::ListBucketsInput)
pub mod list_buckets_input {
    /// A builder for [`ListBucketsInput`](crate::input::ListBucketsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ListBucketsInput`](crate::input::ListBucketsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListBucketsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListBucketsInput {})
        }
    }
}
#[doc(hidden)]
pub type ListBucketsInputOperationOutputAlias = crate::operation::ListBuckets;
#[doc(hidden)]
pub type ListBucketsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBucketsInput {
    /// Consumes the builder and constructs an Operation<[`ListBuckets`](crate::operation::ListBuckets)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBuckets,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListBucketsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListBucketsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListBucketsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListBuckets::new())
                .with_metadata(smithy_http::operation::Metadata::new("ListBuckets", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBucketsInput`](crate::input::ListBucketsInput)
    pub fn builder() -> crate::input::list_buckets_input::Builder {
        crate::input::list_buckets_input::Builder::default()
    }
}

/// See [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
pub mod list_multipart_uploads_input {
    /// A builder for [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) key_marker: std::option::Option<std::string::String>,
        pub(crate) max_uploads: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) upload_id_marker: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket to which the multipart upload was initiated. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Character you use to group keys.</p>
        /// <p>All keys that contain the same string between the prefix, if specified, and the first
        /// occurrence of the delimiter after the prefix are grouped under a single result element,
        /// <code>CommonPrefixes</code>. If you don't specify the prefix parameter, then the
        /// substring starts at the beginning of the key. The keys that are grouped under
        /// <code>CommonPrefixes</code> result element are not returned elsewhere in the
        /// response.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Together with upload-id-marker, this parameter specifies the multipart upload after
        /// which listing should begin.</p>
        /// <p>If <code>upload-id-marker</code> is not specified, only the keys lexicographically
        /// greater than the specified <code>key-marker</code> will be included in the list.</p>
        /// <p>If <code>upload-id-marker</code> is specified, any multipart uploads for a key equal to
        /// the <code>key-marker</code> might also be included, provided those multipart uploads have
        /// upload IDs lexicographically greater than the specified
        /// <code>upload-id-marker</code>.</p>
        pub fn key_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_marker = Some(input.into());
            self
        }
        pub fn set_key_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_marker = input;
            self
        }
        /// <p>Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response
        /// body. 1,000 is the maximum number of uploads that can be returned in a response.</p>
        pub fn max_uploads(mut self, input: i32) -> Self {
            self.max_uploads = Some(input);
            self
        }
        pub fn set_max_uploads(mut self, input: std::option::Option<i32>) -> Self {
            self.max_uploads = input;
            self
        }
        /// <p>Lists in-progress uploads only for those keys that begin with the specified prefix. You
        /// can use prefixes to separate a bucket into different grouping of keys. (You can think of
        /// using prefix to make groups in the same way you'd use a folder in a file system.)</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Together with key-marker, specifies the multipart upload after which listing should
        /// begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
        /// Otherwise, any multipart uploads for a key equal to the key-marker might be included in the
        /// list only if they have an upload ID lexicographically greater than the specified
        /// <code>upload-id-marker</code>.</p>
        pub fn upload_id_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id_marker = Some(input.into());
            self
        }
        pub fn set_upload_id_marker(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upload_id_marker = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMultipartUploadsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMultipartUploadsInput {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                key_marker: self.key_marker,
                max_uploads: self.max_uploads.unwrap_or_default(),
                prefix: self.prefix,
                upload_id_marker: self.upload_id_marker,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMultipartUploadsInputOperationOutputAlias = crate::operation::ListMultipartUploads;
#[doc(hidden)]
pub type ListMultipartUploadsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMultipartUploadsInput {
    /// Consumes the builder and constructs an Operation<[`ListMultipartUploads`](crate::operation::ListMultipartUploads)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListMultipartUploads,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListMultipartUploadsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_397 = &_input.bucket;
            let input_397 =
                input_397
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_397, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListMultipartUploadsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_398) = &_input.expected_bucket_owner {
                let formatted_399 = AsRef::<str>::as_ref(inner_398);
                if !formatted_399.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_399;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListMultipartUploadsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("uploads");
            if let Some(inner_400) = &_input.delimiter {
                query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_400));
            }
            if let Some(inner_401) = &_input.encoding_type {
                query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_401));
            }
            if let Some(inner_402) = &_input.key_marker {
                query.push_kv("key-marker", &smithy_http::query::fmt_string(&inner_402));
            }
            if _input.max_uploads != 0 {
                query.push_kv(
                    "max-uploads",
                    &smithy_types::primitive::Encoder::from(_input.max_uploads).encode(),
                );
            }
            if let Some(inner_403) = &_input.prefix {
                query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_403));
            }
            if let Some(inner_404) = &_input.upload_id_marker {
                query.push_kv(
                    "upload-id-marker",
                    &smithy_http::query::fmt_string(&inner_404),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListMultipartUploadsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListMultipartUploadsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMultipartUploads::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListMultipartUploads",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMultipartUploadsInput`](crate::input::ListMultipartUploadsInput)
    pub fn builder() -> crate::input::list_multipart_uploads_input::Builder {
        crate::input::list_multipart_uploads_input::Builder::default()
    }
}

/// See [`ListObjectsInput`](crate::input::ListObjectsInput)
pub mod list_objects_input {
    /// A builder for [`ListObjectsInput`](crate::input::ListObjectsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_keys: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket containing the objects.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A delimiter is a character you use to group keys.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Marker is where you want Amazon S3 to start listing from. Amazon S3 starts listing after
        /// this specified key. Marker can be any key in the bucket.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain more.
        /// </p>
        pub fn max_keys(mut self, input: i32) -> Self {
            self.max_keys = Some(input);
            self
        }
        pub fn set_max_keys(mut self, input: std::option::Option<i32>) -> Self {
            self.max_keys = input;
            self
        }
        /// <p>Limits the response to keys that begin with the specified prefix.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Confirms that the requester knows that she or he will be charged for the list objects
        /// request. Bucket owners need not specify this parameter in their requests.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListObjectsInput`](crate::input::ListObjectsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListObjectsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListObjectsInput {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                marker: self.marker,
                max_keys: self.max_keys.unwrap_or_default(),
                prefix: self.prefix,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListObjectsInputOperationOutputAlias = crate::operation::ListObjects;
#[doc(hidden)]
pub type ListObjectsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListObjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListObjects`](crate::operation::ListObjects)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListObjects,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListObjectsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_405 = &_input.bucket;
            let input_405 =
                input_405
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_405, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListObjectsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_406) = &_input.request_payer {
                let formatted_407 = AsRef::<str>::as_ref(inner_406);
                if !formatted_407.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_407;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_408) = &_input.expected_bucket_owner {
                let formatted_409 = AsRef::<str>::as_ref(inner_408);
                if !formatted_409.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_409;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListObjectsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_410) = &_input.delimiter {
                query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_410));
            }
            if let Some(inner_411) = &_input.encoding_type {
                query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_411));
            }
            if let Some(inner_412) = &_input.marker {
                query.push_kv("marker", &smithy_http::query::fmt_string(&inner_412));
            }
            if _input.max_keys != 0 {
                query.push_kv(
                    "max-keys",
                    &smithy_types::primitive::Encoder::from(_input.max_keys).encode(),
                );
            }
            if let Some(inner_413) = &_input.prefix {
                query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_413));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListObjectsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListObjectsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListObjects::new())
                .with_metadata(smithy_http::operation::Metadata::new("ListObjects", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListObjectsInput`](crate::input::ListObjectsInput)
    pub fn builder() -> crate::input::list_objects_input::Builder {
        crate::input::list_objects_input::Builder::default()
    }
}

/// See [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
pub mod list_objects_v2_input {
    /// A builder for [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) max_keys: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) continuation_token: std::option::Option<std::string::String>,
        pub(crate) fetch_owner: std::option::Option<bool>,
        pub(crate) start_after: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Bucket name to list. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A delimiter is a character you use to group keys.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain
        /// more.</p>
        pub fn max_keys(mut self, input: i32) -> Self {
            self.max_keys = Some(input);
            self
        }
        pub fn set_max_keys(mut self, input: std::option::Option<i32>) -> Self {
            self.max_keys = input;
            self
        }
        /// <p>Limits the response to keys that begin with the specified prefix.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a
        /// token. ContinuationToken is obfuscated and is not a real key.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.continuation_token = Some(input.into());
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.continuation_token = input;
            self
        }
        /// <p>The owner field is not present in listV2 by default, if you want to return owner field
        /// with each key in the result then set the fetch owner field to true.</p>
        pub fn fetch_owner(mut self, input: bool) -> Self {
            self.fetch_owner = Some(input);
            self
        }
        pub fn set_fetch_owner(mut self, input: std::option::Option<bool>) -> Self {
            self.fetch_owner = input;
            self
        }
        /// <p>StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this
        /// specified key. StartAfter can be any key in the bucket.</p>
        pub fn start_after(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_after = Some(input.into());
            self
        }
        pub fn set_start_after(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_after = input;
            self
        }
        /// <p>Confirms that the requester knows that she or he will be charged for the list objects
        /// request in V2 style. Bucket owners need not specify this parameter in their
        /// requests.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListObjectsV2Input, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListObjectsV2Input {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                max_keys: self.max_keys.unwrap_or_default(),
                prefix: self.prefix,
                continuation_token: self.continuation_token,
                fetch_owner: self.fetch_owner.unwrap_or_default(),
                start_after: self.start_after,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListObjectsV2InputOperationOutputAlias = crate::operation::ListObjectsV2;
#[doc(hidden)]
pub type ListObjectsV2InputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListObjectsV2Input {
    /// Consumes the builder and constructs an Operation<[`ListObjectsV2`](crate::operation::ListObjectsV2)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListObjectsV2,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListObjectsV2Input,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_414 = &_input.bucket;
            let input_414 =
                input_414
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_414, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListObjectsV2Input,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_415) = &_input.request_payer {
                let formatted_416 = AsRef::<str>::as_ref(inner_415);
                if !formatted_416.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_416;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_417) = &_input.expected_bucket_owner {
                let formatted_418 = AsRef::<str>::as_ref(inner_417);
                if !formatted_418.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_418;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListObjectsV2Input, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("list-type", "2");
            if let Some(inner_419) = &_input.delimiter {
                query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_419));
            }
            if let Some(inner_420) = &_input.encoding_type {
                query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_420));
            }
            if _input.max_keys != 0 {
                query.push_kv(
                    "max-keys",
                    &smithy_types::primitive::Encoder::from(_input.max_keys).encode(),
                );
            }
            if let Some(inner_421) = &_input.prefix {
                query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_421));
            }
            if let Some(inner_422) = &_input.continuation_token {
                query.push_kv(
                    "continuation-token",
                    &smithy_http::query::fmt_string(&inner_422),
                );
            }
            if _input.fetch_owner {
                query.push_kv(
                    "fetch-owner",
                    &smithy_types::primitive::Encoder::from(_input.fetch_owner).encode(),
                );
            }
            if let Some(inner_423) = &_input.start_after {
                query.push_kv("start-after", &smithy_http::query::fmt_string(&inner_423));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListObjectsV2Input,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListObjectsV2Input,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListObjectsV2::new())
                .with_metadata(smithy_http::operation::Metadata::new("ListObjectsV2", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListObjectsV2Input`](crate::input::ListObjectsV2Input)
    pub fn builder() -> crate::input::list_objects_v2_input::Builder {
        crate::input::list_objects_v2_input::Builder::default()
    }
}

/// See [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
pub mod list_object_versions_input {
    /// A builder for [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) encoding_type: std::option::Option<crate::model::EncodingType>,
        pub(crate) key_marker: std::option::Option<std::string::String>,
        pub(crate) max_keys: std::option::Option<i32>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) version_id_marker: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name that contains the objects. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
        /// same string between the <code>prefix</code> and the first occurrence of the delimiter are
        /// grouped under a single result element in CommonPrefixes. These groups are counted as one
        /// result against the max-keys limitation. These keys are not returned elsewhere in the
        /// response.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, input: crate::model::EncodingType) -> Self {
            self.encoding_type = Some(input);
            self
        }
        pub fn set_encoding_type(
            mut self,
            input: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding_type = input;
            self
        }
        /// <p>Specifies the key to start with when listing objects in a bucket.</p>
        pub fn key_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_marker = Some(input.into());
            self
        }
        pub fn set_key_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_marker = input;
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain more. If
        /// additional keys satisfy the search criteria, but were not returned because max-keys was
        /// exceeded, the response contains <isTruncated>true</isTruncated>. To return the
        /// additional keys, see key-marker and version-id-marker.</p>
        pub fn max_keys(mut self, input: i32) -> Self {
            self.max_keys = Some(input);
            self
        }
        pub fn set_max_keys(mut self, input: std::option::Option<i32>) -> Self {
            self.max_keys = input;
            self
        }
        /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
        /// can use prefixes to separate a bucket into different groupings of keys. (You can think of
        /// using prefix to make groups in the same way you'd use a folder in a file system.) You can
        /// use prefix with delimiter to roll up numerous objects into a single result under
        /// CommonPrefixes. </p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Specifies the object version you want to start listing from.</p>
        pub fn version_id_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id_marker = Some(input.into());
            self
        }
        pub fn set_version_id_marker(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.version_id_marker = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListObjectVersionsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListObjectVersionsInput {
                bucket: self.bucket,
                delimiter: self.delimiter,
                encoding_type: self.encoding_type,
                key_marker: self.key_marker,
                max_keys: self.max_keys.unwrap_or_default(),
                prefix: self.prefix,
                version_id_marker: self.version_id_marker,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListObjectVersionsInputOperationOutputAlias = crate::operation::ListObjectVersions;
#[doc(hidden)]
pub type ListObjectVersionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListObjectVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListObjectVersions`](crate::operation::ListObjectVersions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListObjectVersions,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListObjectVersionsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_424 = &_input.bucket;
            let input_424 =
                input_424
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_424, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListObjectVersionsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_425) = &_input.expected_bucket_owner {
                let formatted_426 = AsRef::<str>::as_ref(inner_425);
                if !formatted_426.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_426;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListObjectVersionsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("versions");
            if let Some(inner_427) = &_input.delimiter {
                query.push_kv("delimiter", &smithy_http::query::fmt_string(&inner_427));
            }
            if let Some(inner_428) = &_input.encoding_type {
                query.push_kv("encoding-type", &smithy_http::query::fmt_string(&inner_428));
            }
            if let Some(inner_429) = &_input.key_marker {
                query.push_kv("key-marker", &smithy_http::query::fmt_string(&inner_429));
            }
            if _input.max_keys != 0 {
                query.push_kv(
                    "max-keys",
                    &smithy_types::primitive::Encoder::from(_input.max_keys).encode(),
                );
            }
            if let Some(inner_430) = &_input.prefix {
                query.push_kv("prefix", &smithy_http::query::fmt_string(&inner_430));
            }
            if let Some(inner_431) = &_input.version_id_marker {
                query.push_kv(
                    "version-id-marker",
                    &smithy_http::query::fmt_string(&inner_431),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListObjectVersionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListObjectVersionsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListObjectVersions::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListObjectVersions",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListObjectVersionsInput`](crate::input::ListObjectVersionsInput)
    pub fn builder() -> crate::input::list_object_versions_input::Builder {
        crate::input::list_object_versions_input::Builder::default()
    }
}

/// See [`ListPartsInput`](crate::input::ListPartsInput)
pub mod list_parts_input {
    /// A builder for [`ListPartsInput`](crate::input::ListPartsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) max_parts: std::option::Option<i32>,
        pub(crate) part_number_marker: std::option::Option<std::string::String>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket to which the parts are being uploaded. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Sets the maximum number of parts to return.</p>
        pub fn max_parts(mut self, input: i32) -> Self {
            self.max_parts = Some(input);
            self
        }
        pub fn set_max_parts(mut self, input: std::option::Option<i32>) -> Self {
            self.max_parts = input;
            self
        }
        /// <p>Specifies the part after which listing should begin. Only parts with higher part numbers
        /// will be listed.</p>
        pub fn part_number_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.part_number_marker = Some(input.into());
            self
        }
        pub fn set_part_number_marker(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.part_number_marker = input;
            self
        }
        /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPartsInput`](crate::input::ListPartsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListPartsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListPartsInput {
                bucket: self.bucket,
                key: self.key,
                max_parts: self.max_parts.unwrap_or_default(),
                part_number_marker: self.part_number_marker,
                upload_id: self.upload_id,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPartsInputOperationOutputAlias = crate::operation::ListParts;
#[doc(hidden)]
pub type ListPartsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPartsInput {
    /// Consumes the builder and constructs an Operation<[`ListParts`](crate::operation::ListParts)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListParts,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListPartsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_432 = &_input.bucket;
            let input_432 =
                input_432
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_432, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_433 = &_input.key;
            let input_433 =
                input_433
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_433, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListPartsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_434) = &_input.request_payer {
                let formatted_435 = AsRef::<str>::as_ref(inner_434);
                if !formatted_435.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_435;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_436) = &_input.expected_bucket_owner {
                let formatted_437 = AsRef::<str>::as_ref(inner_436);
                if !formatted_437.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_437;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListPartsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "ListParts");
            if _input.max_parts != 0 {
                query.push_kv(
                    "max-parts",
                    &smithy_types::primitive::Encoder::from(_input.max_parts).encode(),
                );
            }
            if let Some(inner_438) = &_input.part_number_marker {
                query.push_kv(
                    "part-number-marker",
                    &smithy_http::query::fmt_string(&inner_438),
                );
            }
            if let Some(inner_439) = &_input.upload_id {
                query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_439));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListPartsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListPartsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListParts::new())
                .with_metadata(smithy_http::operation::Metadata::new("ListParts", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPartsInput`](crate::input::ListPartsInput)
    pub fn builder() -> crate::input::list_parts_input::Builder {
        crate::input::list_parts_input::Builder::default()
    }
}

/// See [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
pub mod put_bucket_accelerate_configuration_input {
    /// A builder for [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) accelerate_configuration:
            std::option::Option<crate::model::AccelerateConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which the accelerate configuration is set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Container for setting the transfer acceleration state.</p>
        pub fn accelerate_configuration(
            mut self,
            input: crate::model::AccelerateConfiguration,
        ) -> Self {
            self.accelerate_configuration = Some(input);
            self
        }
        pub fn set_accelerate_configuration(
            mut self,
            input: std::option::Option<crate::model::AccelerateConfiguration>,
        ) -> Self {
            self.accelerate_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketAccelerateConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketAccelerateConfigurationInput {
                bucket: self.bucket,
                accelerate_configuration: self.accelerate_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketAccelerateConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketAccelerateConfiguration;
#[doc(hidden)]
pub type PutBucketAccelerateConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketAccelerateConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketAccelerateConfiguration`](crate::operation::PutBucketAccelerateConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketAccelerateConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketAccelerateConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_440 = &_input.bucket;
            let input_440 =
                input_440
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_440, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketAccelerateConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_441) = &_input.expected_bucket_owner {
                let formatted_442 = AsRef::<str>::as_ref(inner_441);
                if !formatted_442.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_442;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketAccelerateConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("accelerate");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketAccelerateConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketAccelerateConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_accelerate_configuration_input(
            &self.accelerate_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketAccelerateConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketAccelerateConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketAccelerateConfigurationInput`](crate::input::PutBucketAccelerateConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_accelerate_configuration_input::Builder {
        crate::input::put_bucket_accelerate_configuration_input::Builder::default()
    }
}

/// See [`PutBucketAclInput`](crate::input::PutBucketAclInput)
pub mod put_bucket_acl_input {
    /// A builder for [`PutBucketAclInput`](crate::input::PutBucketAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::BucketCannedAcl>,
        pub(crate) access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the bucket.</p>
        pub fn acl(mut self, input: crate::model::BucketCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::BucketCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
        pub fn access_control_policy(mut self, input: crate::model::AccessControlPolicy) -> Self {
            self.access_control_policy = Some(input);
            self
        }
        pub fn set_access_control_policy(
            mut self,
            input: std::option::Option<crate::model::AccessControlPolicy>,
        ) -> Self {
            self.access_control_policy = input;
            self
        }
        /// <p>The bucket to which to apply the ACL.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.</a>
        /// </p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write = Some(input.into());
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_write = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketAclInput`](crate::input::PutBucketAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutBucketAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutBucketAclInput {
                acl: self.acl,
                access_control_policy: self.access_control_policy,
                bucket: self.bucket,
                content_md5: self.content_md5,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write: self.grant_write,
                grant_write_acp: self.grant_write_acp,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketAclInputOperationOutputAlias = crate::operation::PutBucketAcl;
#[doc(hidden)]
pub type PutBucketAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketAclInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketAcl`](crate::operation::PutBucketAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketAclInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_443 = &_input.bucket;
            let input_443 =
                input_443
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_443, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketAclInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_444) = &_input.acl {
                let formatted_445 = AsRef::<str>::as_ref(inner_444);
                if !formatted_445.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_445;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-acl", header_value);
                }
            }
            if let Some(inner_446) = &_input.content_md5 {
                let formatted_447 = AsRef::<str>::as_ref(inner_446);
                if !formatted_447.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_447;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_448) = &_input.grant_full_control {
                let formatted_449 = AsRef::<str>::as_ref(inner_448);
                if !formatted_449.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_449;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-full-control", header_value);
                }
            }
            if let Some(inner_450) = &_input.grant_read {
                let formatted_451 = AsRef::<str>::as_ref(inner_450);
                if !formatted_451.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_451;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read", header_value);
                }
            }
            if let Some(inner_452) = &_input.grant_read_acp {
                let formatted_453 = AsRef::<str>::as_ref(inner_452);
                if !formatted_453.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_453;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read-acp", header_value);
                }
            }
            if let Some(inner_454) = &_input.grant_write {
                let formatted_455 = AsRef::<str>::as_ref(inner_454);
                if !formatted_455.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_455;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write", header_value);
                }
            }
            if let Some(inner_456) = &_input.grant_write_acp {
                let formatted_457 = AsRef::<str>::as_ref(inner_456);
                if !formatted_457.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_457;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write-acp", header_value);
                }
            }
            if let Some(inner_458) = &_input.expected_bucket_owner {
                let formatted_459 = AsRef::<str>::as_ref(inner_458);
                if !formatted_459.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_459;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketAclInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("acl");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketAclInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketAclInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::ser_payload_put_bucket_acl_input(&self.access_control_policy)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::PutBucketAcl::new())
                .with_metadata(smithy_http::operation::Metadata::new("PutBucketAcl", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketAclInput`](crate::input::PutBucketAclInput)
    pub fn builder() -> crate::input::put_bucket_acl_input::Builder {
        crate::input::put_bucket_acl_input::Builder::default()
    }
}

/// See [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
pub mod put_bucket_analytics_configuration_input {
    /// A builder for [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) analytics_configuration:
            std::option::Option<crate::model::AnalyticsConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket to which an analytics configuration is stored.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The configuration and any analyses for the analytics filter.</p>
        pub fn analytics_configuration(
            mut self,
            input: crate::model::AnalyticsConfiguration,
        ) -> Self {
            self.analytics_configuration = Some(input);
            self
        }
        pub fn set_analytics_configuration(
            mut self,
            input: std::option::Option<crate::model::AnalyticsConfiguration>,
        ) -> Self {
            self.analytics_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketAnalyticsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketAnalyticsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                analytics_configuration: self.analytics_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketAnalyticsConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketAnalyticsConfiguration;
#[doc(hidden)]
pub type PutBucketAnalyticsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketAnalyticsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketAnalyticsConfiguration`](crate::operation::PutBucketAnalyticsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketAnalyticsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketAnalyticsConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_460 = &_input.bucket;
            let input_460 =
                input_460
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_460, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketAnalyticsConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_461) = &_input.expected_bucket_owner {
                let formatted_462 = AsRef::<str>::as_ref(inner_461);
                if !formatted_462.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_462;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketAnalyticsConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("analytics");
            if let Some(inner_463) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_463));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketAnalyticsConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketAnalyticsConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_analytics_configuration_input(
            &self.analytics_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketAnalyticsConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketAnalyticsConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketAnalyticsConfigurationInput`](crate::input::PutBucketAnalyticsConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_analytics_configuration_input::Builder {
        crate::input::put_bucket_analytics_configuration_input::Builder::default()
    }
}

/// See [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
pub mod put_bucket_cors_input {
    /// A builder for [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cors_configuration: std::option::Option<crate::model::CorsConfiguration>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the bucket impacted by the <code>cors</code>configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource
        /// Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn cors_configuration(mut self, input: crate::model::CorsConfiguration) -> Self {
            self.cors_configuration = Some(input);
            self
        }
        pub fn set_cors_configuration(
            mut self,
            input: std::option::Option<crate::model::CorsConfiguration>,
        ) -> Self {
            self.cors_configuration = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.</a>
        /// </p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutBucketCorsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutBucketCorsInput {
                bucket: self.bucket,
                cors_configuration: self.cors_configuration,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketCorsInputOperationOutputAlias = crate::operation::PutBucketCors;
#[doc(hidden)]
pub type PutBucketCorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketCorsInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketCors`](crate::operation::PutBucketCors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketCors,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketCorsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_464 = &_input.bucket;
            let input_464 =
                input_464
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_464, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketCorsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_465) = &_input.content_md5 {
                let formatted_466 = AsRef::<str>::as_ref(inner_465);
                if !formatted_466.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_466;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_467) = &_input.expected_bucket_owner {
                let formatted_468 = AsRef::<str>::as_ref(inner_467);
                if !formatted_468.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_468;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketCorsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("cors");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketCorsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketCorsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::ser_payload_put_bucket_cors_input(&self.cors_configuration)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::PutBucketCors::new())
                .with_metadata(smithy_http::operation::Metadata::new("PutBucketCors", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketCorsInput`](crate::input::PutBucketCorsInput)
    pub fn builder() -> crate::input::put_bucket_cors_input::Builder {
        crate::input::put_bucket_cors_input::Builder::default()
    }
}

/// See [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
pub mod put_bucket_encryption_input {
    /// A builder for [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) server_side_encryption_configuration:
            std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed
        /// keys (SSE-S3) or customer managed keys (SSE-KMS). For information about
        /// the Amazon S3 default encryption feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html">Amazon S3 Default Bucket Encryption</a>
        /// in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the server-side encryption configuration.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Specifies the default server-side-encryption configuration.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            input: crate::model::ServerSideEncryptionConfiguration,
        ) -> Self {
            self.server_side_encryption_configuration = Some(input);
            self
        }
        pub fn set_server_side_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        ) -> Self {
            self.server_side_encryption_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketEncryptionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketEncryptionInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                server_side_encryption_configuration: self.server_side_encryption_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketEncryptionInputOperationOutputAlias = crate::operation::PutBucketEncryption;
#[doc(hidden)]
pub type PutBucketEncryptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketEncryption`](crate::operation::PutBucketEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketEncryptionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_469 = &_input.bucket;
            let input_469 =
                input_469
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_469, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketEncryptionInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_470) = &_input.content_md5 {
                let formatted_471 = AsRef::<str>::as_ref(inner_470);
                if !formatted_471.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_471;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_472) = &_input.expected_bucket_owner {
                let formatted_473 = AsRef::<str>::as_ref(inner_472);
                if !formatted_473.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_473;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketEncryptionInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("encryption");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketEncryptionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketEncryptionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_encryption_input(
            &self.server_side_encryption_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketEncryption::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketEncryption",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketEncryptionInput`](crate::input::PutBucketEncryptionInput)
    pub fn builder() -> crate::input::put_bucket_encryption_input::Builder {
        crate::input::put_bucket_encryption_input::Builder::default()
    }
}

/// See [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
pub mod put_bucket_intelligent_tiering_configuration_input {
    /// A builder for [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) intelligent_tiering_configuration:
            std::option::Option<crate::model::IntelligentTieringConfiguration>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Container for S3 Intelligent-Tiering configuration.</p>
        pub fn intelligent_tiering_configuration(
            mut self,
            input: crate::model::IntelligentTieringConfiguration,
        ) -> Self {
            self.intelligent_tiering_configuration = Some(input);
            self
        }
        pub fn set_intelligent_tiering_configuration(
            mut self,
            input: std::option::Option<crate::model::IntelligentTieringConfiguration>,
        ) -> Self {
            self.intelligent_tiering_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketIntelligentTieringConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::PutBucketIntelligentTieringConfigurationInput {
                    bucket: self.bucket,
                    id: self.id,
                    intelligent_tiering_configuration: self.intelligent_tiering_configuration,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type PutBucketIntelligentTieringConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketIntelligentTieringConfiguration;
#[doc(hidden)]
pub type PutBucketIntelligentTieringConfigurationInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl PutBucketIntelligentTieringConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketIntelligentTieringConfiguration`](crate::operation::PutBucketIntelligentTieringConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketIntelligentTieringConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketIntelligentTieringConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_474 = &_input.bucket;
            let input_474 =
                input_474
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_474, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::PutBucketIntelligentTieringConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("intelligent-tiering");
            if let Some(inner_475) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_475));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketIntelligentTieringConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketIntelligentTieringConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::ser_payload_put_bucket_intelligent_tiering_configuration_input(
                &self.intelligent_tiering_configuration,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketIntelligentTieringConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketIntelligentTieringConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketIntelligentTieringConfigurationInput`](crate::input::PutBucketIntelligentTieringConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_intelligent_tiering_configuration_input::Builder {
        crate::input::put_bucket_intelligent_tiering_configuration_input::Builder::default()
    }
}

/// See [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
pub mod put_bucket_inventory_configuration_input {
    /// A builder for [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) inventory_configuration:
            std::option::Option<crate::model::InventoryConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket where the inventory configuration will be stored.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies the inventory configuration.</p>
        pub fn inventory_configuration(
            mut self,
            input: crate::model::InventoryConfiguration,
        ) -> Self {
            self.inventory_configuration = Some(input);
            self
        }
        pub fn set_inventory_configuration(
            mut self,
            input: std::option::Option<crate::model::InventoryConfiguration>,
        ) -> Self {
            self.inventory_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketInventoryConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketInventoryConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                inventory_configuration: self.inventory_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketInventoryConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketInventoryConfiguration;
#[doc(hidden)]
pub type PutBucketInventoryConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketInventoryConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketInventoryConfiguration`](crate::operation::PutBucketInventoryConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketInventoryConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketInventoryConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_476 = &_input.bucket;
            let input_476 =
                input_476
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_476, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketInventoryConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_477) = &_input.expected_bucket_owner {
                let formatted_478 = AsRef::<str>::as_ref(inner_477);
                if !formatted_478.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_478;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketInventoryConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("inventory");
            if let Some(inner_479) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_479));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketInventoryConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketInventoryConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_inventory_configuration_input(
            &self.inventory_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketInventoryConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketInventoryConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketInventoryConfigurationInput`](crate::input::PutBucketInventoryConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_inventory_configuration_input::Builder {
        crate::input::put_bucket_inventory_configuration_input::Builder::default()
    }
}

/// See [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
pub mod put_bucket_lifecycle_configuration_input {
    /// A builder for [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) lifecycle_configuration:
            std::option::Option<crate::model::BucketLifecycleConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to set the configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
        pub fn lifecycle_configuration(
            mut self,
            input: crate::model::BucketLifecycleConfiguration,
        ) -> Self {
            self.lifecycle_configuration = Some(input);
            self
        }
        pub fn set_lifecycle_configuration(
            mut self,
            input: std::option::Option<crate::model::BucketLifecycleConfiguration>,
        ) -> Self {
            self.lifecycle_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketLifecycleConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketLifecycleConfigurationInput {
                bucket: self.bucket,
                lifecycle_configuration: self.lifecycle_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketLifecycleConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketLifecycleConfiguration;
#[doc(hidden)]
pub type PutBucketLifecycleConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketLifecycleConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketLifecycleConfiguration`](crate::operation::PutBucketLifecycleConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketLifecycleConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketLifecycleConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_480 = &_input.bucket;
            let input_480 =
                input_480
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_480, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketLifecycleConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_481) = &_input.expected_bucket_owner {
                let formatted_482 = AsRef::<str>::as_ref(inner_481);
                if !formatted_482.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_482;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketLifecycleConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("lifecycle");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketLifecycleConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketLifecycleConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_lifecycle_configuration_input(
            &self.lifecycle_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketLifecycleConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketLifecycleConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketLifecycleConfigurationInput`](crate::input::PutBucketLifecycleConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_lifecycle_configuration_input::Builder {
        crate::input::put_bucket_lifecycle_configuration_input::Builder::default()
    }
}

/// See [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
pub mod put_bucket_logging_input {
    /// A builder for [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) bucket_logging_status: std::option::Option<crate::model::BucketLoggingStatus>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to set the logging parameters.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Container for logging status information.</p>
        pub fn bucket_logging_status(mut self, input: crate::model::BucketLoggingStatus) -> Self {
            self.bucket_logging_status = Some(input);
            self
        }
        pub fn set_bucket_logging_status(
            mut self,
            input: std::option::Option<crate::model::BucketLoggingStatus>,
        ) -> Self {
            self.bucket_logging_status = input;
            self
        }
        /// <p>The MD5 hash of the <code>PutBucketLogging</code> request body.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketLoggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketLoggingInput {
                bucket: self.bucket,
                bucket_logging_status: self.bucket_logging_status,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketLoggingInputOperationOutputAlias = crate::operation::PutBucketLogging;
#[doc(hidden)]
pub type PutBucketLoggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketLoggingInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketLogging`](crate::operation::PutBucketLogging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketLogging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketLoggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_483 = &_input.bucket;
            let input_483 =
                input_483
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_483, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketLoggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_484) = &_input.content_md5 {
                let formatted_485 = AsRef::<str>::as_ref(inner_484);
                if !formatted_485.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_485;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_486) = &_input.expected_bucket_owner {
                let formatted_487 = AsRef::<str>::as_ref(inner_486);
                if !formatted_487.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_487;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketLoggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("logging");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketLoggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketLoggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_logging_input(
            &self.bucket_logging_status,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketLogging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketLogging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketLoggingInput`](crate::input::PutBucketLoggingInput)
    pub fn builder() -> crate::input::put_bucket_logging_input::Builder {
        crate::input::put_bucket_logging_input::Builder::default()
    }
}

/// See [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
pub mod put_bucket_metrics_configuration_input {
    /// A builder for [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) metrics_configuration: std::option::Option<crate::model::MetricsConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which the metrics configuration is set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies the metrics configuration.</p>
        pub fn metrics_configuration(mut self, input: crate::model::MetricsConfiguration) -> Self {
            self.metrics_configuration = Some(input);
            self
        }
        pub fn set_metrics_configuration(
            mut self,
            input: std::option::Option<crate::model::MetricsConfiguration>,
        ) -> Self {
            self.metrics_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketMetricsConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketMetricsConfigurationInput {
                bucket: self.bucket,
                id: self.id,
                metrics_configuration: self.metrics_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketMetricsConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketMetricsConfiguration;
#[doc(hidden)]
pub type PutBucketMetricsConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketMetricsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketMetricsConfiguration`](crate::operation::PutBucketMetricsConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketMetricsConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketMetricsConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_488 = &_input.bucket;
            let input_488 =
                input_488
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_488, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketMetricsConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_489) = &_input.expected_bucket_owner {
                let formatted_490 = AsRef::<str>::as_ref(inner_489);
                if !formatted_490.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_490;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketMetricsConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("metrics");
            if let Some(inner_491) = &_input.id {
                query.push_kv("id", &smithy_http::query::fmt_string(&inner_491));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketMetricsConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketMetricsConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_metrics_configuration_input(
            &self.metrics_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketMetricsConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketMetricsConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketMetricsConfigurationInput`](crate::input::PutBucketMetricsConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_metrics_configuration_input::Builder {
        crate::input::put_bucket_metrics_configuration_input::Builder::default()
    }
}

/// See [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
pub mod put_bucket_notification_configuration_input {
    /// A builder for [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) notification_configuration:
            std::option::Option<crate::model::NotificationConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>A container for specifying the notification configuration of the bucket. If this element
        /// is empty, notifications are turned off for the bucket.</p>
        pub fn notification_configuration(
            mut self,
            input: crate::model::NotificationConfiguration,
        ) -> Self {
            self.notification_configuration = Some(input);
            self
        }
        pub fn set_notification_configuration(
            mut self,
            input: std::option::Option<crate::model::NotificationConfiguration>,
        ) -> Self {
            self.notification_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketNotificationConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketNotificationConfigurationInput {
                bucket: self.bucket,
                notification_configuration: self.notification_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketNotificationConfigurationInputOperationOutputAlias =
    crate::operation::PutBucketNotificationConfiguration;
#[doc(hidden)]
pub type PutBucketNotificationConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketNotificationConfiguration`](crate::operation::PutBucketNotificationConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketNotificationConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketNotificationConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_492 = &_input.bucket;
            let input_492 =
                input_492
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_492, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketNotificationConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_493) = &_input.expected_bucket_owner {
                let formatted_494 = AsRef::<str>::as_ref(inner_493);
                if !formatted_494.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_494;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketNotificationConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("notification");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketNotificationConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketNotificationConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_notification_configuration_input(
            &self.notification_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketNotificationConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketNotificationConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketNotificationConfigurationInput`](crate::input::PutBucketNotificationConfigurationInput)
    pub fn builder() -> crate::input::put_bucket_notification_configuration_input::Builder {
        crate::input::put_bucket_notification_configuration_input::Builder::default()
    }
}

/// See [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
pub mod put_bucket_ownership_controls_input {
    /// A builder for [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) ownership_controls: std::option::Option<crate::model::OwnershipControls>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the <code>OwnershipControls</code> request body. </p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) that you want
        /// to apply to this Amazon S3 bucket.</p>
        pub fn ownership_controls(mut self, input: crate::model::OwnershipControls) -> Self {
            self.ownership_controls = Some(input);
            self
        }
        pub fn set_ownership_controls(
            mut self,
            input: std::option::Option<crate::model::OwnershipControls>,
        ) -> Self {
            self.ownership_controls = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketOwnershipControlsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketOwnershipControlsInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
                ownership_controls: self.ownership_controls,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketOwnershipControlsInputOperationOutputAlias =
    crate::operation::PutBucketOwnershipControls;
#[doc(hidden)]
pub type PutBucketOwnershipControlsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketOwnershipControlsInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketOwnershipControls`](crate::operation::PutBucketOwnershipControls)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketOwnershipControls,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketOwnershipControlsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_495 = &_input.bucket;
            let input_495 =
                input_495
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_495, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketOwnershipControlsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_496) = &_input.content_md5 {
                let formatted_497 = AsRef::<str>::as_ref(inner_496);
                if !formatted_497.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_497;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_498) = &_input.expected_bucket_owner {
                let formatted_499 = AsRef::<str>::as_ref(inner_498);
                if !formatted_499.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_499;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutBucketOwnershipControlsInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("ownershipControls");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketOwnershipControlsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketOwnershipControlsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_ownership_controls_input(
            &self.ownership_controls,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketOwnershipControls::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketOwnershipControls",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketOwnershipControlsInput`](crate::input::PutBucketOwnershipControlsInput)
    pub fn builder() -> crate::input::put_bucket_ownership_controls_input::Builder {
        crate::input::put_bucket_ownership_controls_input::Builder::default()
    }
}

/// See [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
pub mod put_bucket_policy_input {
    /// A builder for [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) confirm_remove_self_bucket_access: std::option::Option<bool>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the request body.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Set this parameter to true to confirm that you want to remove your permissions to change
        /// this bucket policy in the future.</p>
        pub fn confirm_remove_self_bucket_access(mut self, input: bool) -> Self {
            self.confirm_remove_self_bucket_access = Some(input);
            self
        }
        pub fn set_confirm_remove_self_bucket_access(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.confirm_remove_self_bucket_access = input;
            self
        }
        /// <p>The bucket policy as a JSON document.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketPolicyInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                confirm_remove_self_bucket_access: self
                    .confirm_remove_self_bucket_access
                    .unwrap_or_default(),
                policy: self.policy,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketPolicyInputOperationOutputAlias = crate::operation::PutBucketPolicy;
#[doc(hidden)]
pub type PutBucketPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketPolicy`](crate::operation::PutBucketPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketPolicyInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_500 = &_input.bucket;
            let input_500 =
                input_500
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_500, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketPolicyInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_501) = &_input.content_md5 {
                let formatted_502 = AsRef::<str>::as_ref(inner_501);
                if !formatted_502.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_502;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if _input.confirm_remove_self_bucket_access {
                let mut encoder = smithy_types::primitive::Encoder::from(
                    _input.confirm_remove_self_bucket_access,
                );
                let formatted_503 = encoder.encode();
                if !formatted_503.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_503;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "confirm_remove_self_bucket_access",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-confirm-remove-self-bucket-access", header_value);
                }
            }
            if let Some(inner_504) = &_input.expected_bucket_owner {
                let formatted_505 = AsRef::<str>::as_ref(inner_504);
                if !formatted_505.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_505;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketPolicyInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("policy");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketPolicyInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "text/plain",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_policy_input(&self.policy)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketPolicy::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketPolicy",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketPolicyInput`](crate::input::PutBucketPolicyInput)
    pub fn builder() -> crate::input::put_bucket_policy_input::Builder {
        crate::input::put_bucket_policy_input::Builder::default()
    }
}

/// See [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
pub mod put_bucket_replication_input {
    /// A builder for [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) replication_configuration:
            std::option::Option<crate::model::ReplicationConfiguration>,
        pub(crate) token: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
        /// replication configuration is 2 MB.</p>
        pub fn replication_configuration(
            mut self,
            input: crate::model::ReplicationConfiguration,
        ) -> Self {
            self.replication_configuration = Some(input);
            self
        }
        pub fn set_replication_configuration(
            mut self,
            input: std::option::Option<crate::model::ReplicationConfiguration>,
        ) -> Self {
            self.replication_configuration = input;
            self
        }
        /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketReplicationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketReplicationInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                replication_configuration: self.replication_configuration,
                token: self.token,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketReplicationInputOperationOutputAlias = crate::operation::PutBucketReplication;
#[doc(hidden)]
pub type PutBucketReplicationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketReplicationInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketReplication`](crate::operation::PutBucketReplication)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketReplication,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketReplicationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_506 = &_input.bucket;
            let input_506 =
                input_506
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_506, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketReplicationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_507) = &_input.content_md5 {
                let formatted_508 = AsRef::<str>::as_ref(inner_507);
                if !formatted_508.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_508;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_509) = &_input.token {
                let formatted_510 = AsRef::<str>::as_ref(inner_509);
                if !formatted_510.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_510;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "token",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-bucket-object-lock-token", header_value);
                }
            }
            if let Some(inner_511) = &_input.expected_bucket_owner {
                let formatted_512 = AsRef::<str>::as_ref(inner_511);
                if !formatted_512.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_512;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketReplicationInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("replication");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketReplicationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketReplicationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_replication_input(
            &self.replication_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketReplication::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketReplication",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketReplicationInput`](crate::input::PutBucketReplicationInput)
    pub fn builder() -> crate::input::put_bucket_replication_input::Builder {
        crate::input::put_bucket_replication_input::Builder::default()
    }
}

/// See [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
pub mod put_bucket_request_payment_input {
    /// A builder for [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) request_payment_configuration:
            std::option::Option<crate::model::RequestPaymentConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
        /// message integrity check to verify that the request body was not corrupted in transit. For
        /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864</a>.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Container for Payer.</p>
        pub fn request_payment_configuration(
            mut self,
            input: crate::model::RequestPaymentConfiguration,
        ) -> Self {
            self.request_payment_configuration = Some(input);
            self
        }
        pub fn set_request_payment_configuration(
            mut self,
            input: std::option::Option<crate::model::RequestPaymentConfiguration>,
        ) -> Self {
            self.request_payment_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketRequestPaymentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketRequestPaymentInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                request_payment_configuration: self.request_payment_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketRequestPaymentInputOperationOutputAlias =
    crate::operation::PutBucketRequestPayment;
#[doc(hidden)]
pub type PutBucketRequestPaymentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketRequestPaymentInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketRequestPayment`](crate::operation::PutBucketRequestPayment)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketRequestPayment,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketRequestPaymentInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_513 = &_input.bucket;
            let input_513 =
                input_513
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_513, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketRequestPaymentInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_514) = &_input.content_md5 {
                let formatted_515 = AsRef::<str>::as_ref(inner_514);
                if !formatted_515.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_515;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_516) = &_input.expected_bucket_owner {
                let formatted_517 = AsRef::<str>::as_ref(inner_516);
                if !formatted_517.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_517;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketRequestPaymentInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("requestPayment");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketRequestPaymentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketRequestPaymentInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_request_payment_input(
            &self.request_payment_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketRequestPayment::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketRequestPayment",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketRequestPaymentInput`](crate::input::PutBucketRequestPaymentInput)
    pub fn builder() -> crate::input::put_bucket_request_payment_input::Builder {
        crate::input::put_bucket_request_payment_input::Builder::default()
    }
}

/// See [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
pub mod put_bucket_tagging_input {
    /// A builder for [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) tagging: std::option::Option<crate::model::Tagging>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements.</p>
        pub fn tagging(mut self, input: crate::model::Tagging) -> Self {
            self.tagging = Some(input);
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<crate::model::Tagging>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketTaggingInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                tagging: self.tagging,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketTaggingInputOperationOutputAlias = crate::operation::PutBucketTagging;
#[doc(hidden)]
pub type PutBucketTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketTaggingInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketTagging`](crate::operation::PutBucketTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketTaggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_518 = &_input.bucket;
            let input_518 =
                input_518
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_518, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketTaggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_519) = &_input.content_md5 {
                let formatted_520 = AsRef::<str>::as_ref(inner_519);
                if !formatted_520.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_520;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_521) = &_input.expected_bucket_owner {
                let formatted_522 = AsRef::<str>::as_ref(inner_521);
                if !formatted_522.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_522;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketTaggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("tagging");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketTaggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketTaggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_tagging_input(&self.tagging)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketTagging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketTagging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketTaggingInput`](crate::input::PutBucketTaggingInput)
    pub fn builder() -> crate::input::put_bucket_tagging_input::Builder {
        crate::input::put_bucket_tagging_input::Builder::default()
    }
}

/// See [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
pub mod put_bucket_versioning_input {
    /// A builder for [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) mfa: std::option::Option<std::string::String>,
        pub(crate) versioning_configuration:
            std::option::Option<crate::model::VersioningConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
        /// message integrity check to verify that the request body was not corrupted in transit. For
        /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864</a>.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device.</p>
        pub fn mfa(mut self, input: impl Into<std::string::String>) -> Self {
            self.mfa = Some(input.into());
            self
        }
        pub fn set_mfa(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mfa = input;
            self
        }
        /// <p>Container for setting the versioning state.</p>
        pub fn versioning_configuration(
            mut self,
            input: crate::model::VersioningConfiguration,
        ) -> Self {
            self.versioning_configuration = Some(input);
            self
        }
        pub fn set_versioning_configuration(
            mut self,
            input: std::option::Option<crate::model::VersioningConfiguration>,
        ) -> Self {
            self.versioning_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketVersioningInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketVersioningInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                mfa: self.mfa,
                versioning_configuration: self.versioning_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketVersioningInputOperationOutputAlias = crate::operation::PutBucketVersioning;
#[doc(hidden)]
pub type PutBucketVersioningInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketVersioningInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketVersioning`](crate::operation::PutBucketVersioning)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketVersioning,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketVersioningInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_523 = &_input.bucket;
            let input_523 =
                input_523
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_523, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketVersioningInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_524) = &_input.content_md5 {
                let formatted_525 = AsRef::<str>::as_ref(inner_524);
                if !formatted_525.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_525;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_526) = &_input.mfa {
                let formatted_527 = AsRef::<str>::as_ref(inner_526);
                if !formatted_527.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_527;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "mfa",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-mfa", header_value);
                }
            }
            if let Some(inner_528) = &_input.expected_bucket_owner {
                let formatted_529 = AsRef::<str>::as_ref(inner_528);
                if !formatted_529.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_529;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketVersioningInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("versioning");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketVersioningInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketVersioningInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_versioning_input(
            &self.versioning_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketVersioning::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketVersioning",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketVersioningInput`](crate::input::PutBucketVersioningInput)
    pub fn builder() -> crate::input::put_bucket_versioning_input::Builder {
        crate::input::put_bucket_versioning_input::Builder::default()
    }
}

/// See [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
pub mod put_bucket_website_input {
    /// A builder for [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) website_configuration: std::option::Option<crate::model::WebsiteConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Container for the request.</p>
        pub fn website_configuration(mut self, input: crate::model::WebsiteConfiguration) -> Self {
            self.website_configuration = Some(input);
            self
        }
        pub fn set_website_configuration(
            mut self,
            input: std::option::Option<crate::model::WebsiteConfiguration>,
        ) -> Self {
            self.website_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBucketWebsiteInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBucketWebsiteInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                website_configuration: self.website_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBucketWebsiteInputOperationOutputAlias = crate::operation::PutBucketWebsite;
#[doc(hidden)]
pub type PutBucketWebsiteInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBucketWebsiteInput {
    /// Consumes the builder and constructs an Operation<[`PutBucketWebsite`](crate::operation::PutBucketWebsite)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBucketWebsite,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutBucketWebsiteInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_530 = &_input.bucket;
            let input_530 =
                input_530
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_530, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutBucketWebsiteInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_531) = &_input.content_md5 {
                let formatted_532 = AsRef::<str>::as_ref(inner_531);
                if !formatted_532.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_532;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_533) = &_input.expected_bucket_owner {
                let formatted_534 = AsRef::<str>::as_ref(inner_533);
                if !formatted_534.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_534;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutBucketWebsiteInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("website");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutBucketWebsiteInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutBucketWebsiteInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_bucket_website_input(
            &self.website_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutBucketWebsite::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutBucketWebsite",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBucketWebsiteInput`](crate::input::PutBucketWebsiteInput)
    pub fn builder() -> crate::input::put_bucket_website_input::Builder {
        crate::input::put_bucket_website_input::Builder::default()
    }
}

/// See [`PutObjectInput`](crate::input::PutObjectInput)
pub mod put_object_input {
    /// A builder for [`PutObjectInput`](crate::input::PutObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) body: std::option::Option<smithy_http::byte_stream::ByteStream>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_length: std::option::Option<i64>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) website_redirect_location: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) ssekms_encryption_context: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) tagging: std::option::Option<std::string::String>,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned
        /// ACL</a>.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>Object data.</p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.body = input;
            self
        }
        /// <p>The bucket name to which the PUT action was initiated. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p> Can be used to specify caching behavior along the request/reply chain. For more
        /// information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
        /// determined automatically. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the message (without the headers) according to
        /// RFC 1864. This header can be used as a message integrity check to verify that the data is
        /// the same data that was originally sent. Although it is optional, we recommend using the
        /// Content-MD5 mechanism as an end-to-end integrity check. For more information about REST
        /// request authentication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST
        /// Authentication</a>.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>A standard MIME type describing the format of the contents. For more information, see
        /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable. For more information, see
        /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21</a>.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Object key for which the PUT action was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata. For information about object metadata, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a>.</p>
        /// <p>In the following example, the request header sets the redirect to an object
        /// (anotherPage.html) in the same bucket:</p>
        /// <p>
        /// <code>x-amz-website-redirect-location: /anotherPage.html</code>
        /// </p>
        /// <p>In the following example, the request header sets the object redirect to another
        /// website:</p>
        /// <p>
        /// <code>x-amz-website-redirect-location: http://www.example.com/</code>
        /// </p>
        /// <p>For more information about website hosting in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">Hosting Websites on Amazon S3</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html">How to Configure Website Page
        /// Redirects</a>. </p>
        pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_redirect_location = Some(input.into());
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_redirect_location = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
        /// <code>aws:kms</code>, this header specifies the ID of the Amazon Web Services Key Management Service
        /// (Amazon Web Services KMS) symmetrical customer managed key that was used for the
        /// object. If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but do not
        /// provide<code> x-amz-server-side-encryption-aws-kms-key-id</code>, Amazon S3 uses the Amazon Web Services
        /// managed key to protect the data. If the KMS key does not exist in the same account
        /// issuing the command, you must use the full ARN and not just the ID.
        /// </p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p>Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_encryption_context = Some(input.into());
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_encryption_context = input;
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
        /// <p>Specifying this header with a PUT action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For
        /// example, "Key1=Value1")</p>
        pub fn tagging(mut self, input: impl Into<std::string::String>) -> Self {
            self.tagging = Some(input.into());
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>The Object Lock mode that you want to apply to this object.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>The date and time when you want this object's Object Lock to expire. Must be formatted
        /// as a timestamp parameter.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>Specifies whether a legal hold will be applied to this object. For more information
        /// about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
        /// Lock</a>.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectInput`](crate::input::PutObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutObjectInput {
                acl: self.acl,
                body: self.body.unwrap_or_default(),
                bucket: self.bucket,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_length: self.content_length.unwrap_or_default(),
                content_md5: self.content_md5,
                content_type: self.content_type,
                expires: self.expires,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                metadata: self.metadata,
                server_side_encryption: self.server_side_encryption,
                storage_class: self.storage_class,
                website_redirect_location: self.website_redirect_location,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                ssekms_key_id: self.ssekms_key_id,
                ssekms_encryption_context: self.ssekms_encryption_context,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
                request_payer: self.request_payer,
                tagging: self.tagging,
                object_lock_mode: self.object_lock_mode,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectInputOperationOutputAlias = crate::operation::PutObject;
#[doc(hidden)]
pub type PutObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectInput {
    /// Creates a presigned request for this operation. The credentials provider from the `config`
    /// will be used to generate the request's signature, and the `presigning_config` provides additional
    /// presigning-specific config values, such as the amount of time the request should be valid for after
    /// creation.
    ///
    /// Presigned requests can be given to other users or applications to access a resource or perform
    /// an operation without having access to the AWS security credentials.
    #[cfg(feature = "client")]
    pub async fn presigned(
        self,
        config: &crate::config::Config,
        presigning_config: crate::presigning::config::PresigningConfig,
    ) -> Result<
        crate::presigning::request::PresignedRequest,
        smithy_http::result::SdkError<crate::error::PutObjectError>,
    > {
        let (mut request, _) = self
            .make_operation(config)
            .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?
            .into_request_response();
        {
            // Change signature type to query params and wire up presigning config
            let mut props = request.properties_mut();
            props.insert(presigning_config.start_time());
            props.insert(aws_sigv4::http_request::SignableBody::UnsignedPayload);
            let mut config = props
                .get_mut::<aws_sig_auth::signer::OperationSigningConfig>()
                .expect("signing config added by make_operation()");
            config.signature_type = aws_sig_auth::signer::HttpSignatureType::HttpRequestQueryParams;
            config.expires_in = Some(presigning_config.expires());
        }
        let middleware = aws_hyper::AwsMiddleware::default();
        let mut svc = tower::builder::ServiceBuilder::new()
            .layer(&middleware)
            .service(crate::presigning::service::PresignedRequestService::new());

        use tower::{Service, ServiceExt};
        Ok(svc.ready().await?.call(request).await?)
    }
    /// Consumes the builder and constructs an Operation<[`PutObject`](crate::operation::PutObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutObjectInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_535 = &_input.bucket;
            let input_535 =
                input_535
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_535, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_536 = &_input.key;
            let input_536 =
                input_536
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_536, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutObjectInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_537) = &_input.acl {
                let formatted_538 = AsRef::<str>::as_ref(inner_537);
                if !formatted_538.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_538;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-acl", header_value);
                }
            }
            if let Some(inner_539) = &_input.cache_control {
                let formatted_540 = AsRef::<str>::as_ref(inner_539);
                if !formatted_540.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_540;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Cache-Control", header_value);
                }
            }
            if let Some(inner_541) = &_input.content_disposition {
                let formatted_542 = AsRef::<str>::as_ref(inner_541);
                if !formatted_542.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_542;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Disposition", header_value);
                }
            }
            if let Some(inner_543) = &_input.content_encoding {
                let formatted_544 = AsRef::<str>::as_ref(inner_543);
                if !formatted_544.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_544;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Encoding", header_value);
                }
            }
            if let Some(inner_545) = &_input.content_language {
                let formatted_546 = AsRef::<str>::as_ref(inner_545);
                if !formatted_546.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_546;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Language", header_value);
                }
            }
            if _input.content_length != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.content_length);
                let formatted_547 = encoder.encode();
                if !formatted_547.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_547;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_length",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Length", header_value);
                }
            }
            if let Some(inner_548) = &_input.content_md5 {
                let formatted_549 = AsRef::<str>::as_ref(inner_548);
                if !formatted_549.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_549;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_550) = &_input.content_type {
                let formatted_551 = AsRef::<str>::as_ref(inner_550);
                if !formatted_551.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_551;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Type", header_value);
                }
            }
            if let Some(inner_552) = &_input.expires {
                let formatted_553 = inner_552.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_553.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_553;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Expires", header_value);
                }
            }
            if let Some(inner_554) = &_input.grant_full_control {
                let formatted_555 = AsRef::<str>::as_ref(inner_554);
                if !formatted_555.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_555;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-full-control", header_value);
                }
            }
            if let Some(inner_556) = &_input.grant_read {
                let formatted_557 = AsRef::<str>::as_ref(inner_556);
                if !formatted_557.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_557;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read", header_value);
                }
            }
            if let Some(inner_558) = &_input.grant_read_acp {
                let formatted_559 = AsRef::<str>::as_ref(inner_558);
                if !formatted_559.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_559;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read-acp", header_value);
                }
            }
            if let Some(inner_560) = &_input.grant_write_acp {
                let formatted_561 = AsRef::<str>::as_ref(inner_560);
                if !formatted_561.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_561;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write-acp", header_value);
                }
            }
            if let Some(inner_562) = &_input.server_side_encryption {
                let formatted_563 = AsRef::<str>::as_ref(inner_562);
                if !formatted_563.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_563;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-server-side-encryption", header_value);
                }
            }
            if let Some(inner_564) = &_input.storage_class {
                let formatted_565 = AsRef::<str>::as_ref(inner_564);
                if !formatted_565.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_565;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-storage-class", header_value);
                }
            }
            if let Some(inner_566) = &_input.website_redirect_location {
                let formatted_567 = AsRef::<str>::as_ref(inner_566);
                if !formatted_567.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_567;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "website_redirect_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-website-redirect-location", header_value);
                }
            }
            if let Some(inner_568) = &_input.sse_customer_algorithm {
                let formatted_569 = AsRef::<str>::as_ref(inner_568);
                if !formatted_569.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_569;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_570) = &_input.sse_customer_key {
                let formatted_571 = AsRef::<str>::as_ref(inner_570);
                if !formatted_571.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_571;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_572) = &_input.sse_customer_key_md5 {
                let formatted_573 = AsRef::<str>::as_ref(inner_572);
                if !formatted_573.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_573;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_574) = &_input.ssekms_key_id {
                let formatted_575 = AsRef::<str>::as_ref(inner_574);
                if !formatted_575.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_575;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-aws-kms-key-id", header_value);
                }
            }
            if let Some(inner_576) = &_input.ssekms_encryption_context {
                let formatted_577 = AsRef::<str>::as_ref(inner_576);
                if !formatted_577.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_577;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_encryption_context",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder = builder.header("x-amz-server-side-encryption-context", header_value);
                }
            }
            if _input.bucket_key_enabled {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.bucket_key_enabled);
                let formatted_578 = encoder.encode();
                if !formatted_578.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_578;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-bucket-key-enabled",
                        header_value,
                    );
                }
            }
            if let Some(inner_579) = &_input.request_payer {
                let formatted_580 = AsRef::<str>::as_ref(inner_579);
                if !formatted_580.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_580;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_581) = &_input.tagging {
                let formatted_582 = AsRef::<str>::as_ref(inner_581);
                if !formatted_582.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_582;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "tagging",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-tagging", header_value);
                }
            }
            if let Some(inner_583) = &_input.object_lock_mode {
                let formatted_584 = AsRef::<str>::as_ref(inner_583);
                if !formatted_584.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_584;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-mode", header_value);
                }
            }
            if let Some(inner_585) = &_input.object_lock_retain_until_date {
                let formatted_586 = inner_585.fmt(smithy_types::instant::Format::DateTime);
                if !formatted_586.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_586;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-retain-until-date", header_value);
                }
            }
            if let Some(inner_587) = &_input.object_lock_legal_hold_status {
                let formatted_588 = AsRef::<str>::as_ref(inner_587);
                if !formatted_588.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_588;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-object-lock-legal-hold", header_value);
                }
            }
            if let Some(inner_589) = &_input.expected_bucket_owner {
                let formatted_590 = AsRef::<str>::as_ref(inner_589);
                if !formatted_590.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_590;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_591) = &_input.metadata {
                for (k, v) in inner_591 {
                    use std::str::FromStr;
                    let header_name =
                        http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                            .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header name: {}",
                                    k, err
                                ),
                            })?;
                    use std::convert::TryFrom;
                    let header_value = AsRef::<str>::as_ref(v);
                    let header_value =
                        http::header::HeaderValue::try_from(header_value).map_err(|err| {
                            smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header value: {}",
                                    v, err
                                ),
                            }
                        })?;
                    builder = builder.header(header_name, header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutObjectInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "PutObject");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutObjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutObjectInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/octet-stream",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_object_input(self.body)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::PutObject::new())
                .with_metadata(smithy_http::operation::Metadata::new("PutObject", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectInput`](crate::input::PutObjectInput)
    pub fn builder() -> crate::input::put_object_input::Builder {
        crate::input::put_object_input::Builder::default()
    }
}

/// See [`PutObjectAclInput`](crate::input::PutObjectAclInput)
pub mod put_object_acl_input {
    /// A builder for [`PutObjectAclInput`](crate::input::PutObjectAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::ObjectCannedAcl>,
        pub(crate) access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) grant_full_control: std::option::Option<std::string::String>,
        pub(crate) grant_read: std::option::Option<std::string::String>,
        pub(crate) grant_read_acp: std::option::Option<std::string::String>,
        pub(crate) grant_write: std::option::Option<std::string::String>,
        pub(crate) grant_write_acp: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p>
        pub fn acl(mut self, input: crate::model::ObjectCannedAcl) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectCannedAcl>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
        pub fn access_control_policy(mut self, input: crate::model::AccessControlPolicy) -> Self {
            self.access_control_policy = Some(input);
            self
        }
        pub fn set_access_control_policy(
            mut self,
            input: std::option::Option<crate::model::AccessControlPolicy>,
        ) -> Self {
            self.access_control_policy = input;
            self
        }
        /// <p>The bucket name that contains the object to which you want to attach the ACL. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.></a>
        /// </p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_full_control = Some(input.into());
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_full_control = input;
            self
        }
        /// <p>Allows grantee to list the objects in the
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read = Some(input.into());
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_read = input;
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_read_acp = Some(input.into());
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_read_acp = input;
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write = Some(input.into());
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grant_write = input;
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.grant_write_acp = Some(input.into());
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.grant_write_acp = input;
            self
        }
        /// <p>Key for which the PUT action was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectAclInput`](crate::input::PutObjectAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutObjectAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutObjectAclInput {
                acl: self.acl,
                access_control_policy: self.access_control_policy,
                bucket: self.bucket,
                content_md5: self.content_md5,
                grant_full_control: self.grant_full_control,
                grant_read: self.grant_read,
                grant_read_acp: self.grant_read_acp,
                grant_write: self.grant_write,
                grant_write_acp: self.grant_write_acp,
                key: self.key,
                request_payer: self.request_payer,
                version_id: self.version_id,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectAclInputOperationOutputAlias = crate::operation::PutObjectAcl;
#[doc(hidden)]
pub type PutObjectAclInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectAclInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectAcl`](crate::operation::PutObjectAcl)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectAcl,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutObjectAclInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_592 = &_input.bucket;
            let input_592 =
                input_592
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_592, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_593 = &_input.key;
            let input_593 =
                input_593
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_593, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutObjectAclInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_594) = &_input.acl {
                let formatted_595 = AsRef::<str>::as_ref(inner_594);
                if !formatted_595.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_595;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "acl",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-acl", header_value);
                }
            }
            if let Some(inner_596) = &_input.content_md5 {
                let formatted_597 = AsRef::<str>::as_ref(inner_596);
                if !formatted_597.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_597;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_598) = &_input.grant_full_control {
                let formatted_599 = AsRef::<str>::as_ref(inner_598);
                if !formatted_599.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_599;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_full_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-full-control", header_value);
                }
            }
            if let Some(inner_600) = &_input.grant_read {
                let formatted_601 = AsRef::<str>::as_ref(inner_600);
                if !formatted_601.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_601;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read", header_value);
                }
            }
            if let Some(inner_602) = &_input.grant_read_acp {
                let formatted_603 = AsRef::<str>::as_ref(inner_602);
                if !formatted_603.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_603;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_read_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-read-acp", header_value);
                }
            }
            if let Some(inner_604) = &_input.grant_write {
                let formatted_605 = AsRef::<str>::as_ref(inner_604);
                if !formatted_605.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_605;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write", header_value);
                }
            }
            if let Some(inner_606) = &_input.grant_write_acp {
                let formatted_607 = AsRef::<str>::as_ref(inner_606);
                if !formatted_607.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_607;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "grant_write_acp",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-grant-write-acp", header_value);
                }
            }
            if let Some(inner_608) = &_input.request_payer {
                let formatted_609 = AsRef::<str>::as_ref(inner_608);
                if !formatted_609.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_609;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_610) = &_input.expected_bucket_owner {
                let formatted_611 = AsRef::<str>::as_ref(inner_610);
                if !formatted_611.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_611;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutObjectAclInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("acl");
            if let Some(inner_612) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_612));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutObjectAclInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutObjectAclInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::ser_payload_put_object_acl_input(&self.access_control_policy)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::PutObjectAcl::new())
                .with_metadata(smithy_http::operation::Metadata::new("PutObjectAcl", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectAclInput`](crate::input::PutObjectAclInput)
    pub fn builder() -> crate::input::put_object_acl_input::Builder {
        crate::input::put_object_acl_input::Builder::default()
    }
}

/// See [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
pub mod put_object_legal_hold_input {
    /// A builder for [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) legal_hold: std::option::Option<crate::model::ObjectLockLegalHold>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object that you want to place a Legal Hold on. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object that you want to place a Legal Hold on.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Container element for the Legal Hold configuration you want to apply to the specified
        /// object.</p>
        pub fn legal_hold(mut self, input: crate::model::ObjectLockLegalHold) -> Self {
            self.legal_hold = Some(input);
            self
        }
        pub fn set_legal_hold(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHold>,
        ) -> Self {
            self.legal_hold = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The version ID of the object that you want to place a Legal Hold on.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectLegalHoldInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectLegalHoldInput {
                bucket: self.bucket,
                key: self.key,
                legal_hold: self.legal_hold,
                request_payer: self.request_payer,
                version_id: self.version_id,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectLegalHoldInputOperationOutputAlias = crate::operation::PutObjectLegalHold;
#[doc(hidden)]
pub type PutObjectLegalHoldInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectLegalHoldInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectLegalHold`](crate::operation::PutObjectLegalHold)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectLegalHold,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutObjectLegalHoldInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_613 = &_input.bucket;
            let input_613 =
                input_613
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_613, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_614 = &_input.key;
            let input_614 =
                input_614
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_614, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutObjectLegalHoldInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_615) = &_input.request_payer {
                let formatted_616 = AsRef::<str>::as_ref(inner_615);
                if !formatted_616.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_616;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_617) = &_input.content_md5 {
                let formatted_618 = AsRef::<str>::as_ref(inner_617);
                if !formatted_618.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_618;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_619) = &_input.expected_bucket_owner {
                let formatted_620 = AsRef::<str>::as_ref(inner_619);
                if !formatted_620.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_620;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutObjectLegalHoldInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("legal-hold");
            if let Some(inner_621) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_621));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutObjectLegalHoldInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutObjectLegalHoldInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_object_legal_hold_input(&self.legal_hold)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutObjectLegalHold::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutObjectLegalHold",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectLegalHoldInput`](crate::input::PutObjectLegalHoldInput)
    pub fn builder() -> crate::input::put_object_legal_hold_input::Builder {
        crate::input::put_object_legal_hold_input::Builder::default()
    }
}

/// See [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
pub mod put_object_lock_configuration_input {
    /// A builder for [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) object_lock_configuration:
            std::option::Option<crate::model::ObjectLockConfiguration>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) token: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket whose Object Lock configuration you want to create or replace.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The Object Lock configuration that you want to apply to the specified bucket.</p>
        pub fn object_lock_configuration(
            mut self,
            input: crate::model::ObjectLockConfiguration,
        ) -> Self {
            self.object_lock_configuration = Some(input);
            self
        }
        pub fn set_object_lock_configuration(
            mut self,
            input: std::option::Option<crate::model::ObjectLockConfiguration>,
        ) -> Self {
            self.object_lock_configuration = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectLockConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectLockConfigurationInput {
                bucket: self.bucket,
                object_lock_configuration: self.object_lock_configuration,
                request_payer: self.request_payer,
                token: self.token,
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectLockConfigurationInputOperationOutputAlias =
    crate::operation::PutObjectLockConfiguration;
#[doc(hidden)]
pub type PutObjectLockConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectLockConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectLockConfiguration`](crate::operation::PutObjectLockConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectLockConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutObjectLockConfigurationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_622 = &_input.bucket;
            let input_622 =
                input_622
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_622, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutObjectLockConfigurationInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_623) = &_input.request_payer {
                let formatted_624 = AsRef::<str>::as_ref(inner_623);
                if !formatted_624.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_624;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_625) = &_input.token {
                let formatted_626 = AsRef::<str>::as_ref(inner_625);
                if !formatted_626.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_626;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "token",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-bucket-object-lock-token", header_value);
                }
            }
            if let Some(inner_627) = &_input.content_md5 {
                let formatted_628 = AsRef::<str>::as_ref(inner_627);
                if !formatted_628.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_628;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_629) = &_input.expected_bucket_owner {
                let formatted_630 = AsRef::<str>::as_ref(inner_629);
                if !formatted_630.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_630;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::PutObjectLockConfigurationInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("object-lock");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutObjectLockConfigurationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutObjectLockConfigurationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_object_lock_configuration_input(
            &self.object_lock_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutObjectLockConfiguration::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutObjectLockConfiguration",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectLockConfigurationInput`](crate::input::PutObjectLockConfigurationInput)
    pub fn builder() -> crate::input::put_object_lock_configuration_input::Builder {
        crate::input::put_object_lock_configuration_input::Builder::default()
    }
}

/// See [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
pub mod put_object_retention_input {
    /// A builder for [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) retention: std::option::Option<crate::model::ObjectLockRetention>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) bypass_governance_retention: std::option::Option<bool>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name that contains the object you want to apply this Object Retention
        /// configuration to. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key name for the object that you want to apply this Object Retention configuration
        /// to.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The container element for the Object Retention configuration.</p>
        pub fn retention(mut self, input: crate::model::ObjectLockRetention) -> Self {
            self.retention = Some(input);
            self
        }
        pub fn set_retention(
            mut self,
            input: std::option::Option<crate::model::ObjectLockRetention>,
        ) -> Self {
            self.retention = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The version ID for the object that you want to apply this Object Retention configuration
        /// to.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Indicates whether this action should bypass Governance-mode restrictions.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.bypass_governance_retention = Some(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.bypass_governance_retention = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectRetentionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectRetentionInput {
                bucket: self.bucket,
                key: self.key,
                retention: self.retention,
                request_payer: self.request_payer,
                version_id: self.version_id,
                bypass_governance_retention: self.bypass_governance_retention.unwrap_or_default(),
                content_md5: self.content_md5,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectRetentionInputOperationOutputAlias = crate::operation::PutObjectRetention;
#[doc(hidden)]
pub type PutObjectRetentionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectRetentionInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectRetention`](crate::operation::PutObjectRetention)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectRetention,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutObjectRetentionInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_631 = &_input.bucket;
            let input_631 =
                input_631
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_631, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_632 = &_input.key;
            let input_632 =
                input_632
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_632, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutObjectRetentionInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_633) = &_input.request_payer {
                let formatted_634 = AsRef::<str>::as_ref(inner_633);
                if !formatted_634.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_634;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if _input.bypass_governance_retention {
                let mut encoder =
                    smithy_types::primitive::Encoder::from(_input.bypass_governance_retention);
                let formatted_635 = encoder.encode();
                if !formatted_635.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_635;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bypass_governance_retention",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-bypass-governance-retention", header_value);
                }
            }
            if let Some(inner_636) = &_input.content_md5 {
                let formatted_637 = AsRef::<str>::as_ref(inner_636);
                if !formatted_637.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_637;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_638) = &_input.expected_bucket_owner {
                let formatted_639 = AsRef::<str>::as_ref(inner_638);
                if !formatted_639.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_639;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutObjectRetentionInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("retention");
            if let Some(inner_640) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_640));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutObjectRetentionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutObjectRetentionInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_object_retention_input(&self.retention)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutObjectRetention::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutObjectRetention",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectRetentionInput`](crate::input::PutObjectRetentionInput)
    pub fn builder() -> crate::input::put_object_retention_input::Builder {
        crate::input::put_object_retention_input::Builder::default()
    }
}

/// See [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
pub mod put_object_tagging_input {
    /// A builder for [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) tagging: std::option::Option<crate::model::Tagging>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
    }
    impl Builder {
        /// <p>The bucket name containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Name of the object key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The versionId of the object that the tag-set will be added to.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements</p>
        pub fn tagging(mut self, input: crate::model::Tagging) -> Self {
            self.tagging = Some(input);
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<crate::model::Tagging>) -> Self {
            self.tagging = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// Consumes the builder and constructs a [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutObjectTaggingInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutObjectTaggingInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                content_md5: self.content_md5,
                tagging: self.tagging,
                expected_bucket_owner: self.expected_bucket_owner,
                request_payer: self.request_payer,
            })
        }
    }
}
#[doc(hidden)]
pub type PutObjectTaggingInputOperationOutputAlias = crate::operation::PutObjectTagging;
#[doc(hidden)]
pub type PutObjectTaggingInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutObjectTaggingInput {
    /// Consumes the builder and constructs an Operation<[`PutObjectTagging`](crate::operation::PutObjectTagging)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutObjectTagging,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutObjectTaggingInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_641 = &_input.bucket;
            let input_641 =
                input_641
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_641, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_642 = &_input.key;
            let input_642 =
                input_642
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_642, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutObjectTaggingInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_643) = &_input.content_md5 {
                let formatted_644 = AsRef::<str>::as_ref(inner_643);
                if !formatted_644.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_644;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_645) = &_input.expected_bucket_owner {
                let formatted_646 = AsRef::<str>::as_ref(inner_645);
                if !formatted_646.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_646;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_647) = &_input.request_payer {
                let formatted_648 = AsRef::<str>::as_ref(inner_647);
                if !formatted_648.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_648;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutObjectTaggingInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("tagging");
            if let Some(inner_649) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_649));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutObjectTaggingInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutObjectTaggingInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_object_tagging_input(&self.tagging)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutObjectTagging::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutObjectTagging",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutObjectTaggingInput`](crate::input::PutObjectTaggingInput)
    pub fn builder() -> crate::input::put_object_tagging_input::Builder {
        crate::input::put_object_tagging_input::Builder::default()
    }
}

/// See [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
pub mod put_public_access_block_input {
    /// A builder for [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) public_access_block_configuration:
            std::option::Option<crate::model::PublicAccessBlockConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
        /// to set.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The MD5 hash of the <code>PutPublicAccessBlock</code> request body. </p>
        /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3
        /// bucket. You can enable the configuration options in any combination. For more information
        /// about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn public_access_block_configuration(
            mut self,
            input: crate::model::PublicAccessBlockConfiguration,
        ) -> Self {
            self.public_access_block_configuration = Some(input);
            self
        }
        pub fn set_public_access_block_configuration(
            mut self,
            input: std::option::Option<crate::model::PublicAccessBlockConfiguration>,
        ) -> Self {
            self.public_access_block_configuration = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutPublicAccessBlockInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutPublicAccessBlockInput {
                bucket: self.bucket,
                content_md5: self.content_md5,
                public_access_block_configuration: self.public_access_block_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type PutPublicAccessBlockInputOperationOutputAlias = crate::operation::PutPublicAccessBlock;
#[doc(hidden)]
pub type PutPublicAccessBlockInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutPublicAccessBlockInput {
    /// Consumes the builder and constructs an Operation<[`PutPublicAccessBlock`](crate::operation::PutPublicAccessBlock)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutPublicAccessBlock,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutPublicAccessBlockInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_650 = &_input.bucket;
            let input_650 =
                input_650
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_650, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}", Bucket = bucket).expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::PutPublicAccessBlockInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_651) = &_input.content_md5 {
                let formatted_652 = AsRef::<str>::as_ref(inner_651);
                if !formatted_652.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_652;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_653) = &_input.expected_bucket_owner {
                let formatted_654 = AsRef::<str>::as_ref(inner_653);
                if !formatted_654.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_654;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::PutPublicAccessBlockInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("publicAccessBlock");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutPublicAccessBlockInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutPublicAccessBlockInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_put_public_access_block_input(
            &self.public_access_block_configuration,
        )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request = request.augment(|mut req, _| {
            let data = req.body().bytes().ok_or_else(|| {
                smithy_http::operation::BuildError::SerializationError(
                    "checksum can only be computed for non-streaming operations".into(),
                )
            })?;
            let checksum = md5::compute(data);
            req.headers_mut().insert(
                http::header::HeaderName::from_static("content-md5"),
                smithy_types::base64::encode(&checksum[..])
                    .parse()
                    .expect("checksum is valid header value"),
            );
            Result::<_, smithy_http::operation::BuildError>::Ok(req)
        })?;
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::PutPublicAccessBlock::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "PutPublicAccessBlock",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutPublicAccessBlockInput`](crate::input::PutPublicAccessBlockInput)
    pub fn builder() -> crate::input::put_public_access_block_input::Builder {
        crate::input::put_public_access_block_input::Builder::default()
    }
}

/// See [`RestoreObjectInput`](crate::input::RestoreObjectInput)
pub mod restore_object_input {
    /// A builder for [`RestoreObjectInput`](crate::input::RestoreObjectInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) restore_request: std::option::Option<crate::model::RestoreRequest>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name containing the object to restore. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Object key for which the action was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p>Container for restore job parameters.</p>
        pub fn restore_request(mut self, input: crate::model::RestoreRequest) -> Self {
            self.restore_request = Some(input);
            self
        }
        pub fn set_restore_request(
            mut self,
            input: std::option::Option<crate::model::RestoreRequest>,
        ) -> Self {
            self.restore_request = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`RestoreObjectInput`](crate::input::RestoreObjectInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::RestoreObjectInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::RestoreObjectInput {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
                restore_request: self.restore_request,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type RestoreObjectInputOperationOutputAlias = crate::operation::RestoreObject;
#[doc(hidden)]
pub type RestoreObjectInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RestoreObjectInput {
    /// Consumes the builder and constructs an Operation<[`RestoreObject`](crate::operation::RestoreObject)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::RestoreObject,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RestoreObjectInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_655 = &_input.bucket;
            let input_655 =
                input_655
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_655, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_656 = &_input.key;
            let input_656 =
                input_656
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_656, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::RestoreObjectInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_657) = &_input.request_payer {
                let formatted_658 = AsRef::<str>::as_ref(inner_657);
                if !formatted_658.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_658;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_659) = &_input.expected_bucket_owner {
                let formatted_660 = AsRef::<str>::as_ref(inner_659);
                if !formatted_660.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_660;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::RestoreObjectInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("restore");
            query.push_kv("x-id", "RestoreObject");
            if let Some(inner_661) = &_input.version_id {
                query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_661));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RestoreObjectInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RestoreObjectInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_restore_object_input(&self.restore_request)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::RestoreObject::new())
                .with_metadata(smithy_http::operation::Metadata::new("RestoreObject", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RestoreObjectInput`](crate::input::RestoreObjectInput)
    pub fn builder() -> crate::input::restore_object_input::Builder {
        crate::input::restore_object_input::Builder::default()
    }
}

/// See [`SelectObjectContentInput`](crate::input::SelectObjectContentInput)
pub mod select_object_content_input {
    /// A builder for [`SelectObjectContentInput`](crate::input::SelectObjectContentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) expression_type: std::option::Option<crate::model::ExpressionType>,
        pub(crate) request_progress: std::option::Option<crate::model::RequestProgress>,
        pub(crate) input_serialization: std::option::Option<crate::model::InputSerialization>,
        pub(crate) output_serialization: std::option::Option<crate::model::OutputSerialization>,
        pub(crate) scan_range: std::option::Option<crate::model::ScanRange>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The object key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The SSE Algorithm used to encrypt the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption (Using Customer-Provided Encryption Keys</a>. </p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>The SSE Customer Key. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption
        /// (Using Customer-Provided Encryption Keys</a>. </p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>The SSE Customer Key MD5. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption
        /// (Using Customer-Provided Encryption Keys</a>. </p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>The expression that is used to query the object.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The type of the provided expression (for example, SQL).</p>
        pub fn expression_type(mut self, input: crate::model::ExpressionType) -> Self {
            self.expression_type = Some(input);
            self
        }
        pub fn set_expression_type(
            mut self,
            input: std::option::Option<crate::model::ExpressionType>,
        ) -> Self {
            self.expression_type = input;
            self
        }
        /// <p>Specifies if periodic request progress information should be enabled.</p>
        pub fn request_progress(mut self, input: crate::model::RequestProgress) -> Self {
            self.request_progress = Some(input);
            self
        }
        pub fn set_request_progress(
            mut self,
            input: std::option::Option<crate::model::RequestProgress>,
        ) -> Self {
            self.request_progress = input;
            self
        }
        /// <p>Describes the format of the data in the object that is being queried.</p>
        pub fn input_serialization(mut self, input: crate::model::InputSerialization) -> Self {
            self.input_serialization = Some(input);
            self
        }
        pub fn set_input_serialization(
            mut self,
            input: std::option::Option<crate::model::InputSerialization>,
        ) -> Self {
            self.input_serialization = input;
            self
        }
        /// <p>Describes the format of the data that you want Amazon S3 to return in response.</p>
        pub fn output_serialization(mut self, input: crate::model::OutputSerialization) -> Self {
            self.output_serialization = Some(input);
            self
        }
        pub fn set_output_serialization(
            mut self,
            input: std::option::Option<crate::model::OutputSerialization>,
        ) -> Self {
            self.output_serialization = input;
            self
        }
        /// <p>Specifies the byte range of the object to get the records from. A record is processed
        /// when its first byte is contained by the range. This parameter is optional, but when
        /// specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the
        /// start and end of the range.</p>
        /// <p>
        /// <code>ScanRange</code>may be used in the following ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code><scanrange><start>50</start><end>100</end></scanrange></code>
        /// - process only the records starting between the bytes 50 and 100 (inclusive, counting
        /// from zero)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code><scanrange><start>50</start></scanrange></code> -
        /// process only the records starting after the byte 50</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code><scanrange><end>50</end></scanrange></code> -
        /// process only the records within the last 50 bytes of the file.</p>
        /// </li>
        /// </ul>
        pub fn scan_range(mut self, input: crate::model::ScanRange) -> Self {
            self.scan_range = Some(input);
            self
        }
        pub fn set_scan_range(
            mut self,
            input: std::option::Option<crate::model::ScanRange>,
        ) -> Self {
            self.scan_range = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`SelectObjectContentInput`](crate::input::SelectObjectContentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SelectObjectContentInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SelectObjectContentInput {
                bucket: self.bucket,
                key: self.key,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                expression: self.expression,
                expression_type: self.expression_type,
                request_progress: self.request_progress,
                input_serialization: self.input_serialization,
                output_serialization: self.output_serialization,
                scan_range: self.scan_range,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type SelectObjectContentInputOperationOutputAlias = crate::operation::SelectObjectContent;
#[doc(hidden)]
pub type SelectObjectContentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SelectObjectContentInput {
    /// Consumes the builder and constructs an Operation<[`SelectObjectContent`](crate::operation::SelectObjectContent)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::SelectObjectContent,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SelectObjectContentInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_662 = &_input.bucket;
            let input_662 =
                input_662
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_662, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_663 = &_input.key;
            let input_663 =
                input_663
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_663, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::SelectObjectContentInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_664) = &_input.sse_customer_algorithm {
                let formatted_665 = AsRef::<str>::as_ref(inner_664);
                if !formatted_665.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_665;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_666) = &_input.sse_customer_key {
                let formatted_667 = AsRef::<str>::as_ref(inner_666);
                if !formatted_667.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_667;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_668) = &_input.sse_customer_key_md5 {
                let formatted_669 = AsRef::<str>::as_ref(inner_668);
                if !formatted_669.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_669;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_670) = &_input.expected_bucket_owner {
                let formatted_671 = AsRef::<str>::as_ref(inner_670);
                if !formatted_671.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_671;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::SelectObjectContentInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_v("select");
            query.push_kv("select-type", "2");
            query.push_kv("x-id", "SelectObjectContent");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SelectObjectContentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SelectObjectContentInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_select_object_content(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::SelectObjectContent::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "SelectObjectContent",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SelectObjectContentInput`](crate::input::SelectObjectContentInput)
    pub fn builder() -> crate::input::select_object_content_input::Builder {
        crate::input::select_object_content_input::Builder::default()
    }
}

/// See [`UploadPartInput`](crate::input::UploadPartInput)
pub mod upload_part_input {
    /// A builder for [`UploadPartInput`](crate::input::UploadPartInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<smithy_http::byte_stream::ByteStream>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) content_length: std::option::Option<i64>,
        pub(crate) content_md5: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Object data.</p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.body = input;
            self
        }
        /// <p>The name of the bucket to which the multipart upload was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
        /// determined automatically.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated
        /// when using the command from the CLI. This parameter is required if object lock parameters
        /// are specified.</p>
        pub fn content_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_md5 = Some(input.into());
            self
        }
        pub fn set_content_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_md5 = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Part number of part being uploaded. This is a positive integer between 1 and
        /// 10,000.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>Upload ID identifying the multipart upload whose part is being uploaded.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm header</code>. This must be the
        /// same encryption key specified in the initiate multipart upload request.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadPartInput`](crate::input::UploadPartInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UploadPartInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UploadPartInput {
                body: self.body.unwrap_or_default(),
                bucket: self.bucket,
                content_length: self.content_length.unwrap_or_default(),
                content_md5: self.content_md5,
                key: self.key,
                part_number: self.part_number.unwrap_or_default(),
                upload_id: self.upload_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadPartInputOperationOutputAlias = crate::operation::UploadPart;
#[doc(hidden)]
pub type UploadPartInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadPartInput {
    /// Consumes the builder and constructs an Operation<[`UploadPart`](crate::operation::UploadPart)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UploadPart,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UploadPartInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_672 = &_input.bucket;
            let input_672 =
                input_672
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_672, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_673 = &_input.key;
            let input_673 =
                input_673
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_673, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::UploadPartInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if _input.content_length != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.content_length);
                let formatted_674 = encoder.encode();
                if !formatted_674.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_674;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_length",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Length", header_value);
                }
            }
            if let Some(inner_675) = &_input.content_md5 {
                let formatted_676 = AsRef::<str>::as_ref(inner_675);
                if !formatted_676.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_676;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-MD5", header_value);
                }
            }
            if let Some(inner_677) = &_input.sse_customer_algorithm {
                let formatted_678 = AsRef::<str>::as_ref(inner_677);
                if !formatted_678.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_678;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_679) = &_input.sse_customer_key {
                let formatted_680 = AsRef::<str>::as_ref(inner_679);
                if !formatted_680.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_680;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_681) = &_input.sse_customer_key_md5 {
                let formatted_682 = AsRef::<str>::as_ref(inner_681);
                if !formatted_682.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_682;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_683) = &_input.request_payer {
                let formatted_684 = AsRef::<str>::as_ref(inner_683);
                if !formatted_684.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_684;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_685) = &_input.expected_bucket_owner {
                let formatted_686 = AsRef::<str>::as_ref(inner_685);
                if !formatted_686.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_686;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::UploadPartInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "UploadPart");
            if _input.part_number != 0 {
                query.push_kv(
                    "partNumber",
                    &smithy_types::primitive::Encoder::from(_input.part_number).encode(),
                );
            }
            if let Some(inner_687) = &_input.upload_id {
                query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_687));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UploadPartInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UploadPartInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/octet-stream",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_upload_part_input(self.body)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::UploadPart::new())
                .with_metadata(smithy_http::operation::Metadata::new("UploadPart", "s3"));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadPartInput`](crate::input::UploadPartInput)
    pub fn builder() -> crate::input::upload_part_input::Builder {
        crate::input::upload_part_input::Builder::default()
    }
}

/// See [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
pub mod upload_part_copy_input {
    /// A builder for [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) copy_source: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) copy_source_if_none_match: std::option::Option<std::string::String>,
        pub(crate) copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
        pub(crate) copy_source_range: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key: std::option::Option<std::string::String>,
        pub(crate) copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) request_payer: std::option::Option<crate::model::RequestPayer>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) expected_source_bucket_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket name.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Specifies the source object for the copy operation. You specify the value in one of two
        /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
        /// <ul>
        /// <li>
        /// <p>For objects not accessed through an access point, specify the name of the source
        /// bucket and key of the source object, separated by a slash (/). For example, to copy
        /// the object <code>reports/january.pdf</code> from the bucket
        /// <code>awsexamplebucket</code>, use
        /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
        /// encoded.</p>
        /// </li>
        /// <li>
        /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
        /// <note>
        /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same Amazon Web Services Region.</p>
        /// </note>
        /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
        /// </li>
        /// </ul>
        /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
        /// to the value (for example,
        /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
        /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
        /// object.</p>
        pub fn copy_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source = Some(input.into());
            self
        }
        pub fn set_copy_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.copy_source = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
        pub fn copy_source_if_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_match = input;
            self
        }
        /// <p>Copies the object if it has been modified since the specified time.</p>
        pub fn copy_source_if_modified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_modified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_modified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_modified_since = input;
            self
        }
        /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
        pub fn copy_source_if_none_match(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_if_none_match = Some(input.into());
            self
        }
        pub fn set_copy_source_if_none_match(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_if_none_match = input;
            self
        }
        /// <p>Copies the object if it hasn't been modified since the specified time.</p>
        pub fn copy_source_if_unmodified_since(mut self, input: smithy_types::Instant) -> Self {
            self.copy_source_if_unmodified_since = Some(input);
            self
        }
        pub fn set_copy_source_if_unmodified_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.copy_source_if_unmodified_since = input;
            self
        }
        /// <p>The range of bytes to copy from the source object. The range value must use the form
        /// bytes=first-last, where the first and last are the zero-based byte offsets to copy. For
        /// example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You
        /// can copy a range only if the source object is greater than 5 MB.</p>
        pub fn copy_source_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_range = Some(input.into());
            self
        }
        pub fn set_copy_source_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_range = input;
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Part number of part being copied. This is a positive integer between 1 and
        /// 10,000.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input;
            self
        }
        /// <p>Upload ID identifying the multipart upload whose part is being copied.</p>
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input;
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header. This must be the
        /// same encryption key specified in the initiate multipart upload request.</p>
        pub fn sse_customer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key = Some(input.into());
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p>Specifies the algorithm to use when decrypting the source object (for example,
        /// AES256).</p>
        pub fn copy_source_sse_customer_algorithm(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_algorithm = input;
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
        /// object. The encryption key provided in this header must be one that was used when the
        /// source object was created.</p>
        pub fn copy_source_sse_customer_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key = input;
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn copy_source_sse_customer_key_md5(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_copy_source_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_sse_customer_key_md5 = input;
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, input: crate::model::RequestPayer) -> Self {
            self.request_payer = Some(input);
            self
        }
        pub fn set_request_payer(
            mut self,
            input: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.request_payer = input;
            self
        }
        /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_source_bucket_owner(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = Some(input.into());
            self
        }
        pub fn set_expected_source_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_source_bucket_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UploadPartCopyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UploadPartCopyInput {
                bucket: self.bucket,
                copy_source: self.copy_source,
                copy_source_if_match: self.copy_source_if_match,
                copy_source_if_modified_since: self.copy_source_if_modified_since,
                copy_source_if_none_match: self.copy_source_if_none_match,
                copy_source_if_unmodified_since: self.copy_source_if_unmodified_since,
                copy_source_range: self.copy_source_range,
                key: self.key,
                part_number: self.part_number.unwrap_or_default(),
                upload_id: self.upload_id,
                sse_customer_algorithm: self.sse_customer_algorithm,
                sse_customer_key: self.sse_customer_key,
                sse_customer_key_md5: self.sse_customer_key_md5,
                copy_source_sse_customer_algorithm: self.copy_source_sse_customer_algorithm,
                copy_source_sse_customer_key: self.copy_source_sse_customer_key,
                copy_source_sse_customer_key_md5: self.copy_source_sse_customer_key_md5,
                request_payer: self.request_payer,
                expected_bucket_owner: self.expected_bucket_owner,
                expected_source_bucket_owner: self.expected_source_bucket_owner,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadPartCopyInputOperationOutputAlias = crate::operation::UploadPartCopy;
#[doc(hidden)]
pub type UploadPartCopyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadPartCopyInput {
    /// Consumes the builder and constructs an Operation<[`UploadPartCopy`](crate::operation::UploadPartCopy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UploadPartCopy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UploadPartCopyInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_688 = &_input.bucket;
            let input_688 =
                input_688
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "bucket",
                        details: "cannot be empty or unset",
                    })?;
            let bucket = smithy_http::label::fmt_string(input_688, false);
            if bucket.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "bucket",
                    details: "cannot be empty or unset",
                });
            }
            let input_689 = &_input.key;
            let input_689 =
                input_689
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "key",
                        details: "cannot be empty or unset",
                    })?;
            let key = smithy_http::label::fmt_string(input_689, true);
            if key.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "key",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/{Bucket}/{Key}", Bucket = bucket, Key = key)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::UploadPartCopyInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_690) = &_input.copy_source {
                let formatted_691 = AsRef::<str>::as_ref(inner_690);
                if !formatted_691.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_691;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source", header_value);
                }
            }
            if let Some(inner_692) = &_input.copy_source_if_match {
                let formatted_693 = AsRef::<str>::as_ref(inner_692);
                if !formatted_693.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_693;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-match", header_value);
                }
            }
            if let Some(inner_694) = &_input.copy_source_if_modified_since {
                let formatted_695 = inner_694.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_695.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_695;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_modified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-modified-since", header_value);
                }
            }
            if let Some(inner_696) = &_input.copy_source_if_none_match {
                let formatted_697 = AsRef::<str>::as_ref(inner_696);
                if !formatted_697.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_697;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_none_match",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-none-match", header_value);
                }
            }
            if let Some(inner_698) = &_input.copy_source_if_unmodified_since {
                let formatted_699 = inner_698.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_699.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_699;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_if_unmodified_since",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-if-unmodified-since", header_value);
                }
            }
            if let Some(inner_700) = &_input.copy_source_range {
                let formatted_701 = AsRef::<str>::as_ref(inner_700);
                if !formatted_701.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_701;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-copy-source-range", header_value);
                }
            }
            if let Some(inner_702) = &_input.sse_customer_algorithm {
                let formatted_703 = AsRef::<str>::as_ref(inner_702);
                if !formatted_703.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_703;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_704) = &_input.sse_customer_key {
                let formatted_705 = AsRef::<str>::as_ref(inner_704);
                if !formatted_705.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_705;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-server-side-encryption-customer-key", header_value);
                }
            }
            if let Some(inner_706) = &_input.sse_customer_key_md5 {
                let formatted_707 = AsRef::<str>::as_ref(inner_706);
                if !formatted_707.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_707;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_708) = &_input.copy_source_sse_customer_algorithm {
                let formatted_709 = AsRef::<str>::as_ref(inner_708);
                if !formatted_709.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_709;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-copy-source-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_710) = &_input.copy_source_sse_customer_key {
                let formatted_711 = AsRef::<str>::as_ref(inner_710);
                if !formatted_711.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_711;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-copy-source-server-side-encryption-customer-key",
                        header_value,
                    );
                }
            }
            if let Some(inner_712) = &_input.copy_source_sse_customer_key_md5 {
                let formatted_713 = AsRef::<str>::as_ref(inner_712);
                if !formatted_713.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_713;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "copy_source_sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-copy-source-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_714) = &_input.request_payer {
                let formatted_715 = AsRef::<str>::as_ref(inner_714);
                if !formatted_715.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_715;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_payer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-payer", header_value);
                }
            }
            if let Some(inner_716) = &_input.expected_bucket_owner {
                let formatted_717 = AsRef::<str>::as_ref(inner_716);
                if !formatted_717.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_717;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-expected-bucket-owner", header_value);
                }
            }
            if let Some(inner_718) = &_input.expected_source_bucket_owner {
                let formatted_719 = AsRef::<str>::as_ref(inner_718);
                if !formatted_719.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_719;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expected_source_bucket_owner",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-source-expected-bucket-owner", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::UploadPartCopyInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "UploadPartCopy");
            if _input.part_number != 0 {
                query.push_kv(
                    "partNumber",
                    &smithy_types::primitive::Encoder::from(_input.part_number).encode(),
                );
            }
            if let Some(inner_720) = &_input.upload_id {
                query.push_kv("uploadId", &smithy_http::query::fmt_string(&inner_720));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UploadPartCopyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UploadPartCopyInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/xml",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UploadPartCopy::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UploadPartCopy",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadPartCopyInput`](crate::input::UploadPartCopyInput)
    pub fn builder() -> crate::input::upload_part_copy_input::Builder {
        crate::input::upload_part_copy_input::Builder::default()
    }
}

/// See [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
pub mod write_get_object_response_input {
    /// A builder for [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_route: std::option::Option<std::string::String>,
        pub(crate) request_token: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<smithy_http::byte_stream::ByteStream>,
        pub(crate) status_code: std::option::Option<i32>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) accept_ranges: std::option::Option<std::string::String>,
        pub(crate) cache_control: std::option::Option<std::string::String>,
        pub(crate) content_disposition: std::option::Option<std::string::String>,
        pub(crate) content_encoding: std::option::Option<std::string::String>,
        pub(crate) content_language: std::option::Option<std::string::String>,
        pub(crate) content_length: std::option::Option<i64>,
        pub(crate) content_range: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) delete_marker: std::option::Option<bool>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) expires: std::option::Option<smithy_types::Instant>,
        pub(crate) expiration: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<smithy_types::Instant>,
        pub(crate) missing_meta: std::option::Option<i32>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
        pub(crate) object_lock_legal_hold_status:
            std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        pub(crate) object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
        pub(crate) parts_count: std::option::Option<i32>,
        pub(crate) replication_status: std::option::Option<crate::model::ReplicationStatus>,
        pub(crate) request_charged: std::option::Option<crate::model::RequestCharged>,
        pub(crate) restore: std::option::Option<std::string::String>,
        pub(crate) server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
        pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
        pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
        pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) tag_count: std::option::Option<i32>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) bucket_key_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Route prefix to the HTTP URL generated.</p>
        pub fn request_route(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_route = Some(input.into());
            self
        }
        pub fn set_request_route(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.request_route = input;
            self
        }
        /// <p>A single use encrypted token that maps <code>WriteGetObjectResponse</code> to the end
        /// user <code>GetObject</code> request.</p>
        pub fn request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_token = Some(input.into());
            self
        }
        pub fn set_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.request_token = input;
            self
        }
        /// <p>The object data.</p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.body = input;
            self
        }
        /// <p>The integer status code for an HTTP response of a corresponding <code>GetObject</code>
        /// request.</p>
        /// <p class="title">
        /// <b>Status Codes</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>200 - OK</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>206 - Partial Content</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>304 - Not Modified</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>400 - Bad Request</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>401 - Unauthorized</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>403 - Forbidden</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>404 - Not Found</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>405 - Method Not Allowed</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>409 - Conflict</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>411 - Length Required</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>412 - Precondition Failed</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>416 - Range Not Satisfiable</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>500 - Internal Server Error</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>503 - Service Unavailable</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// <p>A string that uniquely identifies an error condition. Returned in the <Code> tag
        /// of the error XML response for a corresponding <code>GetObject</code> call. Cannot be used
        /// with a successful <code>StatusCode</code> header or when the transformed object is provided
        /// in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Contains a generic description of the error condition. Returned in the <Message>
        /// tag of the error XML response for a corresponding <code>GetObject</code> call. Cannot be
        /// used with a successful <code>StatusCode</code> header or when the transformed object is
        /// provided in body.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>Indicates that a range of bytes was specified.</p>
        pub fn accept_ranges(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept_ranges = Some(input.into());
            self
        }
        pub fn set_accept_ranges(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.accept_ranges = input;
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.cache_control = Some(input.into());
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cache_control = input;
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_disposition = Some(input.into());
            self
        }
        pub fn set_content_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_disposition = input;
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_encoding = Some(input.into());
            self
        }
        pub fn set_content_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_encoding = input;
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_language = Some(input.into());
            self
        }
        pub fn set_content_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_language = input;
            self
        }
        /// <p>The size of the content body in bytes.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// <p>The portion of the object returned in the response.</p>
        pub fn content_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_range = Some(input.into());
            self
        }
        pub fn set_content_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_range = input;
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>Specifies whether an object stored in Amazon S3 is (<code>true</code>) or is not
        /// (<code>false</code>) a delete marker. </p>
        pub fn delete_marker(mut self, input: bool) -> Self {
            self.delete_marker = Some(input);
            self
        }
        pub fn set_delete_marker(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_marker = input;
            self
        }
        /// <p>An opaque identifier assigned by a web server to a specific version of a resource found
        /// at a URL. </p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, input: smithy_types::Instant) -> Self {
            self.expires = Some(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires = input;
            self
        }
        /// <p>If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded. </p>
        pub fn expiration(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiration = Some(input.into());
            self
        }
        pub fn set_expiration(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expiration = input;
            self
        }
        /// <p>The date and time that the object was last modified.</p>
        pub fn last_modified(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified = Some(input);
            self
        }
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>Set to the number of metadata entries not returned in <code>x-amz-meta</code> headers.
        /// This can happen if you create metadata using an API like SOAP that supports more flexible
        /// metadata than the REST API. For example, using SOAP, you can create metadata whose values
        /// are not legal HTTP headers.</p>
        pub fn missing_meta(mut self, input: i32) -> Self {
            self.missing_meta = Some(input);
            self
        }
        pub fn set_missing_meta(mut self, input: std::option::Option<i32>) -> Self {
            self.missing_meta = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more
        /// information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">Object Lock</a>.</p>
        pub fn object_lock_mode(mut self, input: crate::model::ObjectLockMode) -> Self {
            self.object_lock_mode = Some(input);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            input: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.object_lock_mode = input;
            self
        }
        /// <p>Indicates whether an object stored in Amazon S3 has an active legal hold.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            input: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.object_lock_legal_hold_status = Some(input);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            input: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.object_lock_legal_hold_status = input;
            self
        }
        /// <p>The date and time when Object Lock is configured to expire.</p>
        pub fn object_lock_retain_until_date(mut self, input: smithy_types::Instant) -> Self {
            self.object_lock_retain_until_date = Some(input);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.object_lock_retain_until_date = input;
            self
        }
        /// <p>The count of parts this object has.</p>
        pub fn parts_count(mut self, input: i32) -> Self {
            self.parts_count = Some(input);
            self
        }
        pub fn set_parts_count(mut self, input: std::option::Option<i32>) -> Self {
            self.parts_count = input;
            self
        }
        /// <p>Indicates if request involves bucket that is either a source or destination in a Replication rule. For more
        /// information about S3 Replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html">Replication</a>.</p>
        pub fn replication_status(mut self, input: crate::model::ReplicationStatus) -> Self {
            self.replication_status = Some(input);
            self
        }
        pub fn set_replication_status(
            mut self,
            input: std::option::Option<crate::model::ReplicationStatus>,
        ) -> Self {
            self.replication_status = input;
            self
        }
        /// <p>If present, indicates that the requester was successfully charged for the
        /// request.</p>
        pub fn request_charged(mut self, input: crate::model::RequestCharged) -> Self {
            self.request_charged = Some(input);
            self
        }
        pub fn set_request_charged(
            mut self,
            input: std::option::Option<crate::model::RequestCharged>,
        ) -> Self {
            self.request_charged = input;
            self
        }
        /// <p>Provides information about object restoration operation and expiration time of the
        /// restored object copy.</p>
        pub fn restore(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore = Some(input.into());
            self
        }
        pub fn set_restore(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.restore = input;
            self
        }
        /// <p> The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, input: crate::model::ServerSideEncryption) -> Self {
            self.server_side_encryption = Some(input);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.server_side_encryption = input;
            self
        }
        /// <p>Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.</p>
        pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_algorithm = Some(input.into());
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_algorithm = input;
            self
        }
        /// <p> If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for stored in Amazon S3 object. </p>
        pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssekms_key_id = Some(input.into());
            self
        }
        pub fn set_ssekms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssekms_key_id = input;
            self
        }
        /// <p> 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data
        /// stored in S3. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html">Protecting data
        /// using server-side encryption with customer-provided encryption keys
        /// (SSE-C)</a>.</p>
        pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_customer_key_md5 = Some(input.into());
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_customer_key_md5 = input;
            self
        }
        /// <p> The class of storage used to store object in Amazon S3.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>The number of tags, if any, on the object.</p>
        pub fn tag_count(mut self, input: i32) -> Self {
            self.tag_count = Some(input);
            self
        }
        pub fn set_tag_count(mut self, input: std::option::Option<i32>) -> Self {
            self.tag_count = input;
            self
        }
        /// <p>An ID used to reference a specific version of the object.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// <p> Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side
        /// encryption with Amazon Web Services KMS (SSE-KMS).</p>
        pub fn bucket_key_enabled(mut self, input: bool) -> Self {
            self.bucket_key_enabled = Some(input);
            self
        }
        pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.bucket_key_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::WriteGetObjectResponseInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::WriteGetObjectResponseInput {
                request_route: self.request_route,
                request_token: self.request_token,
                body: self.body.unwrap_or_default(),
                status_code: self.status_code.unwrap_or_default(),
                error_code: self.error_code,
                error_message: self.error_message,
                accept_ranges: self.accept_ranges,
                cache_control: self.cache_control,
                content_disposition: self.content_disposition,
                content_encoding: self.content_encoding,
                content_language: self.content_language,
                content_length: self.content_length.unwrap_or_default(),
                content_range: self.content_range,
                content_type: self.content_type,
                delete_marker: self.delete_marker.unwrap_or_default(),
                e_tag: self.e_tag,
                expires: self.expires,
                expiration: self.expiration,
                last_modified: self.last_modified,
                missing_meta: self.missing_meta.unwrap_or_default(),
                metadata: self.metadata,
                object_lock_mode: self.object_lock_mode,
                object_lock_legal_hold_status: self.object_lock_legal_hold_status,
                object_lock_retain_until_date: self.object_lock_retain_until_date,
                parts_count: self.parts_count.unwrap_or_default(),
                replication_status: self.replication_status,
                request_charged: self.request_charged,
                restore: self.restore,
                server_side_encryption: self.server_side_encryption,
                sse_customer_algorithm: self.sse_customer_algorithm,
                ssekms_key_id: self.ssekms_key_id,
                sse_customer_key_md5: self.sse_customer_key_md5,
                storage_class: self.storage_class,
                tag_count: self.tag_count.unwrap_or_default(),
                version_id: self.version_id,
                bucket_key_enabled: self.bucket_key_enabled.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type WriteGetObjectResponseInputOperationOutputAlias = crate::operation::WriteGetObjectResponse;
#[doc(hidden)]
pub type WriteGetObjectResponseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl WriteGetObjectResponseInput {
    /// Consumes the builder and constructs an Operation<[`WriteGetObjectResponse`](crate::operation::WriteGetObjectResponse)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::WriteGetObjectResponse,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::WriteGetObjectResponseInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/WriteGetObjectResponse").expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::WriteGetObjectResponseInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_721) = &_input.request_route {
                let formatted_722 = AsRef::<str>::as_ref(inner_721);
                if !formatted_722.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_722;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_route",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-route", header_value);
                }
            }
            if let Some(inner_723) = &_input.request_token {
                let formatted_724 = AsRef::<str>::as_ref(inner_723);
                if !formatted_724.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_724;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_token",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-request-token", header_value);
                }
            }
            if _input.status_code != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.status_code);
                let formatted_725 = encoder.encode();
                if !formatted_725.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_725;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "status_code",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-status", header_value);
                }
            }
            if let Some(inner_726) = &_input.error_code {
                let formatted_727 = AsRef::<str>::as_ref(inner_726);
                if !formatted_727.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_727;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "error_code",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-error-code", header_value);
                }
            }
            if let Some(inner_728) = &_input.error_message {
                let formatted_729 = AsRef::<str>::as_ref(inner_728);
                if !formatted_729.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_729;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "error_message",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-error-message", header_value);
                }
            }
            if let Some(inner_730) = &_input.accept_ranges {
                let formatted_731 = AsRef::<str>::as_ref(inner_730);
                if !formatted_731.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_731;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "accept_ranges",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-accept-ranges", header_value);
                }
            }
            if let Some(inner_732) = &_input.cache_control {
                let formatted_733 = AsRef::<str>::as_ref(inner_732);
                if !formatted_733.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_733;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "cache_control",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Cache-Control", header_value);
                }
            }
            if let Some(inner_734) = &_input.content_disposition {
                let formatted_735 = AsRef::<str>::as_ref(inner_734);
                if !formatted_735.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_735;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_disposition",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Content-Disposition", header_value);
                }
            }
            if let Some(inner_736) = &_input.content_encoding {
                let formatted_737 = AsRef::<str>::as_ref(inner_736);
                if !formatted_737.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_737;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_encoding",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Content-Encoding", header_value);
                }
            }
            if let Some(inner_738) = &_input.content_language {
                let formatted_739 = AsRef::<str>::as_ref(inner_738);
                if !formatted_739.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_739;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_language",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Content-Language", header_value);
                }
            }
            if _input.content_length != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.content_length);
                let formatted_740 = encoder.encode();
                if !formatted_740.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_740;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_length",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("Content-Length", header_value);
                }
            }
            if let Some(inner_741) = &_input.content_range {
                let formatted_742 = AsRef::<str>::as_ref(inner_741);
                if !formatted_742.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_742;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_range",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Content-Range", header_value);
                }
            }
            if let Some(inner_743) = &_input.content_type {
                let formatted_744 = AsRef::<str>::as_ref(inner_743);
                if !formatted_744.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_744;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Content-Type", header_value);
                }
            }
            if _input.delete_marker {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.delete_marker);
                let formatted_745 = encoder.encode();
                if !formatted_745.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_745;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "delete_marker",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-delete-marker", header_value);
                }
            }
            if let Some(inner_746) = &_input.e_tag {
                let formatted_747 = AsRef::<str>::as_ref(inner_746);
                if !formatted_747.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_747;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "e_tag",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-ETag", header_value);
                }
            }
            if let Some(inner_748) = &_input.expires {
                let formatted_749 = inner_748.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_749.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_749;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expires",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Expires", header_value);
                }
            }
            if let Some(inner_750) = &_input.expiration {
                let formatted_751 = AsRef::<str>::as_ref(inner_750);
                if !formatted_751.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_751;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "expiration",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-expiration", header_value);
                }
            }
            if let Some(inner_752) = &_input.last_modified {
                let formatted_753 = inner_752.fmt(smithy_types::instant::Format::HttpDate);
                if !formatted_753.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_753;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "last_modified",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-Last-Modified", header_value);
                }
            }
            if _input.missing_meta != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.missing_meta);
                let formatted_754 = encoder.encode();
                if !formatted_754.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_754;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "missing_meta",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-missing-meta", header_value);
                }
            }
            if let Some(inner_755) = &_input.object_lock_mode {
                let formatted_756 = AsRef::<str>::as_ref(inner_755);
                if !formatted_756.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_756;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_mode",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-fwd-header-x-amz-object-lock-mode", header_value);
                }
            }
            if let Some(inner_757) = &_input.object_lock_legal_hold_status {
                let formatted_758 = AsRef::<str>::as_ref(inner_757);
                if !formatted_758.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_758;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_legal_hold_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-object-lock-legal-hold",
                        header_value,
                    );
                }
            }
            if let Some(inner_759) = &_input.object_lock_retain_until_date {
                let formatted_760 = inner_759.fmt(smithy_types::instant::Format::DateTime);
                if !formatted_760.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_760;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "object_lock_retain_until_date",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-object-lock-retain-until-date",
                        header_value,
                    );
                }
            }
            if _input.parts_count != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.parts_count);
                let formatted_761 = encoder.encode();
                if !formatted_761.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_761;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "parts_count",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-mp-parts-count", header_value);
                }
            }
            if let Some(inner_762) = &_input.replication_status {
                let formatted_763 = AsRef::<str>::as_ref(inner_762);
                if !formatted_763.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_763;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "replication_status",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-fwd-header-x-amz-replication-status", header_value);
                }
            }
            if let Some(inner_764) = &_input.request_charged {
                let formatted_765 = AsRef::<str>::as_ref(inner_764);
                if !formatted_765.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_765;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "request_charged",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder =
                        builder.header("x-amz-fwd-header-x-amz-request-charged", header_value);
                }
            }
            if let Some(inner_766) = &_input.restore {
                let formatted_767 = AsRef::<str>::as_ref(inner_766);
                if !formatted_767.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_767;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "restore",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-restore", header_value);
                }
            }
            if let Some(inner_768) = &_input.server_side_encryption {
                let formatted_769 = AsRef::<str>::as_ref(inner_768);
                if !formatted_769.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_769;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "server_side_encryption",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-server-side-encryption",
                        header_value,
                    );
                }
            }
            if let Some(inner_770) = &_input.sse_customer_algorithm {
                let formatted_771 = AsRef::<str>::as_ref(inner_770);
                if !formatted_771.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_771;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_algorithm",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm",
                        header_value,
                    );
                }
            }
            if let Some(inner_772) = &_input.ssekms_key_id {
                let formatted_773 = AsRef::<str>::as_ref(inner_772);
                if !formatted_773.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_773;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "ssekms_key_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id",
                        header_value,
                    );
                }
            }
            if let Some(inner_774) = &_input.sse_customer_key_md5 {
                let formatted_775 = AsRef::<str>::as_ref(inner_774);
                if !formatted_775.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_775;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "sse_customer_key_md5",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5",
                        header_value,
                    );
                }
            }
            if let Some(inner_776) = &_input.storage_class {
                let formatted_777 = AsRef::<str>::as_ref(inner_776);
                if !formatted_777.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_777;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "storage_class",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-storage-class", header_value);
                }
            }
            if _input.tag_count != 0 {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.tag_count);
                let formatted_778 = encoder.encode();
                if !formatted_778.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_778;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "tag_count",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-tagging-count", header_value);
                }
            }
            if let Some(inner_779) = &_input.version_id {
                let formatted_780 = AsRef::<str>::as_ref(inner_779);
                if !formatted_780.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_780;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "version_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-fwd-header-x-amz-version-id", header_value);
                }
            }
            if _input.bucket_key_enabled {
                let mut encoder = smithy_types::primitive::Encoder::from(_input.bucket_key_enabled);
                let formatted_781 = encoder.encode();
                if !formatted_781.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_781;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "bucket_key_enabled",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header(
                        "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled",
                        header_value,
                    );
                }
            }
            if let Some(inner_782) = &_input.metadata {
                for (k, v) in inner_782 {
                    use std::str::FromStr;
                    let header_name =
                        http::header::HeaderName::from_str(&format!("{}{}", "x-amz-meta-", &k))
                            .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header name: {}",
                                    k, err
                                ),
                            })?;
                    use std::convert::TryFrom;
                    let header_value = AsRef::<str>::as_ref(v);
                    let header_value =
                        http::header::HeaderValue::try_from(header_value).map_err(|err| {
                            smithy_http::operation::BuildError::InvalidField {
                                field: "metadata",
                                details: format!(
                                    "`{}` cannot be used as a header value: {}",
                                    v, err
                                ),
                            }
                        })?;
                    builder = builder.header(header_name, header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::WriteGetObjectResponseInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("x-id", "WriteGetObjectResponse");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::WriteGetObjectResponseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::WriteGetObjectResponseInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/octet-stream",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::ser_payload_write_get_object_response_input(self.body)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        let endpoint_prefix = {
            let request_route = self.request_route.as_deref().unwrap_or_default();
            if request_route.is_empty() {
                return Err(smithy_http::operation::BuildError::InvalidField { field: "request_route", details: "request_route was unset or empty but must be set as part of the endpoint prefix".to_string() });
            }
            smithy_http::endpoint::EndpointPrefix::new(format!(
                "{RequestRoute}.",
                RequestRoute = request_route
            ))
        };
        match endpoint_prefix {
            Ok(prefix) => {
                request.properties_mut().insert(prefix);
            }
            Err(err) => {
                return Err(smithy_http::operation::BuildError::SerializationError(
                    err.into(),
                ))
            }
        }
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        signing_config.signing_options.double_uri_encode = false;
        signing_config.signing_options.content_sha256_header = true;
        request
            .properties_mut()
            .insert(aws_sig_auth::signer::SignableBody::UnsignedPayload);
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::WriteGetObjectResponse::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "WriteGetObjectResponse",
            "s3",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`WriteGetObjectResponseInput`](crate::input::WriteGetObjectResponseInput)
    pub fn builder() -> crate::input::write_get_object_response_input::Builder {
        crate::input::write_get_object_response_input::Builder::default()
    }
}

#[non_exhaustive]
pub struct WriteGetObjectResponseInput {
    /// <p>Route prefix to the HTTP URL generated.</p>
    pub request_route: std::option::Option<std::string::String>,
    /// <p>A single use encrypted token that maps <code>WriteGetObjectResponse</code> to the end
    /// user <code>GetObject</code> request.</p>
    pub request_token: std::option::Option<std::string::String>,
    /// <p>The object data.</p>
    pub body: smithy_http::byte_stream::ByteStream,
    /// <p>The integer status code for an HTTP response of a corresponding <code>GetObject</code>
    /// request.</p>
    /// <p class="title">
    /// <b>Status Codes</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <i>200 - OK</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>206 - Partial Content</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>304 - Not Modified</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>400 - Bad Request</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>401 - Unauthorized</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>403 - Forbidden</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>404 - Not Found</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>405 - Method Not Allowed</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>409 - Conflict</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>411 - Length Required</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>412 - Precondition Failed</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>416 - Range Not Satisfiable</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>500 - Internal Server Error</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>503 - Service Unavailable</i>
    /// </p>
    /// </li>
    /// </ul>
    pub status_code: i32,
    /// <p>A string that uniquely identifies an error condition. Returned in the <Code> tag
    /// of the error XML response for a corresponding <code>GetObject</code> call. Cannot be used
    /// with a successful <code>StatusCode</code> header or when the transformed object is provided
    /// in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>Contains a generic description of the error condition. Returned in the <Message>
    /// tag of the error XML response for a corresponding <code>GetObject</code> call. Cannot be
    /// used with a successful <code>StatusCode</code> header or when the transformed object is
    /// provided in body.</p>
    pub error_message: std::option::Option<std::string::String>,
    /// <p>Indicates that a range of bytes was specified.</p>
    pub accept_ranges: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>The size of the content body in bytes.</p>
    pub content_length: i64,
    /// <p>The portion of the object returned in the response.</p>
    pub content_range: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>Specifies whether an object stored in Amazon S3 is (<code>true</code>) or is not
    /// (<code>false</code>) a delete marker. </p>
    pub delete_marker: bool,
    /// <p>An opaque identifier assigned by a web server to a specific version of a resource found
    /// at a URL. </p>
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded. </p>
    pub expiration: std::option::Option<std::string::String>,
    /// <p>The date and time that the object was last modified.</p>
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>Set to the number of metadata entries not returned in <code>x-amz-meta</code> headers.
    /// This can happen if you create metadata using an API like SOAP that supports more flexible
    /// metadata than the REST API. For example, using SOAP, you can create metadata whose values
    /// are not legal HTTP headers.</p>
    pub missing_meta: i32,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more
    /// information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">Object Lock</a>.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>Indicates whether an object stored in Amazon S3 has an active legal hold.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The date and time when Object Lock is configured to expire.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>The count of parts this object has.</p>
    pub parts_count: i32,
    /// <p>Indicates if request involves bucket that is either a source or destination in a Replication rule. For more
    /// information about S3 Replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html">Replication</a>.</p>
    pub replication_status: std::option::Option<crate::model::ReplicationStatus>,
    /// <p>If present, indicates that the requester was successfully charged for the
    /// request.</p>
    pub request_charged: std::option::Option<crate::model::RequestCharged>,
    /// <p>Provides information about object restoration operation and expiration time of the
    /// restored object copy.</p>
    pub restore: std::option::Option<std::string::String>,
    /// <p> The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p> If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for stored in Amazon S3 object. </p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p> 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data
    /// stored in S3. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html">Protecting data
    /// using server-side encryption with customer-provided encryption keys
    /// (SSE-C)</a>.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p> The class of storage used to store object in Amazon S3.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>The number of tags, if any, on the object.</p>
    pub tag_count: i32,
    /// <p>An ID used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p> Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side
    /// encryption with Amazon Web Services KMS (SSE-KMS).</p>
    pub bucket_key_enabled: bool,
}
impl std::fmt::Debug for WriteGetObjectResponseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteGetObjectResponseInput");
        formatter.field("request_route", &self.request_route);
        formatter.field("request_token", &self.request_token);
        formatter.field("body", &self.body);
        formatter.field("status_code", &self.status_code);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.field("accept_ranges", &self.accept_ranges);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_length", &self.content_length);
        formatter.field("content_range", &self.content_range);
        formatter.field("content_type", &self.content_type);
        formatter.field("delete_marker", &self.delete_marker);
        formatter.field("e_tag", &self.e_tag);
        formatter.field("expires", &self.expires);
        formatter.field("expiration", &self.expiration);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("missing_meta", &self.missing_meta);
        formatter.field("metadata", &self.metadata);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field("parts_count", &self.parts_count);
        formatter.field("replication_status", &self.replication_status);
        formatter.field("request_charged", &self.request_charged);
        formatter.field("restore", &self.restore);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("tag_count", &self.tag_count);
        formatter.field("version_id", &self.version_id);
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UploadPartCopyInput {
    /// <p>The bucket name.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Specifies the source object for the copy operation. You specify the value in one of two
    /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
    /// <ul>
    /// <li>
    /// <p>For objects not accessed through an access point, specify the name of the source
    /// bucket and key of the source object, separated by a slash (/). For example, to copy
    /// the object <code>reports/january.pdf</code> from the bucket
    /// <code>awsexamplebucket</code>, use
    /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
    /// encoded.</p>
    /// </li>
    /// <li>
    /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
    /// <note>
    /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same Amazon Web Services Region.</p>
    /// </note>
    /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
    /// </li>
    /// </ul>
    /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
    /// to the value (for example,
    /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
    /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
    /// object.</p>
    pub copy_source: std::option::Option<std::string::String>,
    /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
    pub copy_source_if_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it has been modified since the specified time.</p>
    pub copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
    pub copy_source_if_none_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it hasn't been modified since the specified time.</p>
    pub copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>The range of bytes to copy from the source object. The range value must use the form
    /// bytes=first-last, where the first and last are the zero-based byte offsets to copy. For
    /// example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You
    /// can copy a range only if the source object is greater than 5 MB.</p>
    pub copy_source_range: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Part number of part being copied. This is a positive integer between 1 and
    /// 10,000.</p>
    pub part_number: i32,
    /// <p>Upload ID identifying the multipart upload whose part is being copied.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header. This must be the
    /// same encryption key specified in the initiate multipart upload request.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use when decrypting the source object (for example,
    /// AES256).</p>
    pub copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
    /// object. The encryption key provided in this header must be one that was used when the
    /// source object was created.</p>
    pub copy_source_sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_source_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UploadPartCopyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadPartCopyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("copy_source", &self.copy_source);
        formatter.field("copy_source_if_match", &self.copy_source_if_match);
        formatter.field(
            "copy_source_if_modified_since",
            &self.copy_source_if_modified_since,
        );
        formatter.field("copy_source_if_none_match", &self.copy_source_if_none_match);
        formatter.field(
            "copy_source_if_unmodified_since",
            &self.copy_source_if_unmodified_since,
        );
        formatter.field("copy_source_range", &self.copy_source_range);
        formatter.field("key", &self.key);
        formatter.field("part_number", &self.part_number);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field(
            "copy_source_sse_customer_algorithm",
            &self.copy_source_sse_customer_algorithm,
        );
        formatter.field(
            "copy_source_sse_customer_key",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field(
            "copy_source_sse_customer_key_md5",
            &self.copy_source_sse_customer_key_md5,
        );
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "expected_source_bucket_owner",
            &self.expected_source_bucket_owner,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
pub struct UploadPartInput {
    /// <p>Object data.</p>
    pub body: smithy_http::byte_stream::ByteStream,
    /// <p>The name of the bucket to which the multipart upload was initiated.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
    /// determined automatically.</p>
    pub content_length: i64,
    /// <p>The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated
    /// when using the command from the CLI. This parameter is required if object lock parameters
    /// are specified.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Part number of part being uploaded. This is a positive integer between 1 and
    /// 10,000.</p>
    pub part_number: i32,
    /// <p>Upload ID identifying the multipart upload whose part is being uploaded.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm header</code>. This must be the
    /// same encryption key specified in the initiate multipart upload request.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UploadPartInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadPartInput");
        formatter.field("body", &self.body);
        formatter.field("bucket", &self.bucket);
        formatter.field("content_length", &self.content_length);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("key", &self.key);
        formatter.field("part_number", &self.part_number);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

/// <p>Request to filter the contents of an Amazon S3 object based on a simple Structured Query
/// Language (SQL) statement. In the request, along with the SQL expression, you must specify a
/// data serialization format (JSON or CSV) of the object. Amazon S3 uses this to parse object data
/// into records. It returns only records that match the specified SQL expression. You must
/// also specify the data serialization format for the response. For more information, see
/// <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectSELECTContent.html">S3Select API Documentation</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SelectObjectContentInput {
    /// <p>The S3 bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The object key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The SSE Algorithm used to encrypt the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption (Using Customer-Provided Encryption Keys</a>. </p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>The SSE Customer Key. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption
    /// (Using Customer-Provided Encryption Keys</a>. </p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>The SSE Customer Key MD5. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html">Server-Side Encryption
    /// (Using Customer-Provided Encryption Keys</a>. </p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>The expression that is used to query the object.</p>
    pub expression: std::option::Option<std::string::String>,
    /// <p>The type of the provided expression (for example, SQL).</p>
    pub expression_type: std::option::Option<crate::model::ExpressionType>,
    /// <p>Specifies if periodic request progress information should be enabled.</p>
    pub request_progress: std::option::Option<crate::model::RequestProgress>,
    /// <p>Describes the format of the data in the object that is being queried.</p>
    pub input_serialization: std::option::Option<crate::model::InputSerialization>,
    /// <p>Describes the format of the data that you want Amazon S3 to return in response.</p>
    pub output_serialization: std::option::Option<crate::model::OutputSerialization>,
    /// <p>Specifies the byte range of the object to get the records from. A record is processed
    /// when its first byte is contained by the range. This parameter is optional, but when
    /// specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the
    /// start and end of the range.</p>
    /// <p>
    /// <code>ScanRange</code>may be used in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code><scanrange><start>50</start><end>100</end></scanrange></code>
    /// - process only the records starting between the bytes 50 and 100 (inclusive, counting
    /// from zero)</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code><scanrange><start>50</start></scanrange></code> -
    /// process only the records starting after the byte 50</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code><scanrange><end>50</end></scanrange></code> -
    /// process only the records within the last 50 bytes of the file.</p>
    /// </li>
    /// </ul>
    pub scan_range: std::option::Option<crate::model::ScanRange>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SelectObjectContentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SelectObjectContentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("expression", &self.expression);
        formatter.field("expression_type", &self.expression_type);
        formatter.field("request_progress", &self.request_progress);
        formatter.field("input_serialization", &self.input_serialization);
        formatter.field("output_serialization", &self.output_serialization);
        formatter.field("scan_range", &self.scan_range);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreObjectInput {
    /// <p>The bucket name containing the object to restore. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which the action was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Container for restore job parameters.</p>
    pub restore_request: std::option::Option<crate::model::RestoreRequest>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RestoreObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("restore_request", &self.restore_request);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPublicAccessBlockInput {
    /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
    /// to set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the <code>PutPublicAccessBlock</code> request body. </p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3
    /// bucket. You can enable the configuration options in any combination. For more information
    /// about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub public_access_block_configuration:
        std::option::Option<crate::model::PublicAccessBlockConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutPublicAccessBlockInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPublicAccessBlockInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field(
            "public_access_block_configuration",
            &self.public_access_block_configuration,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectTaggingInput {
    /// <p>The bucket name containing the object. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Name of the object key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The versionId of the object that the tag-set will be added to.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements</p>
    pub tagging: std::option::Option<crate::model::Tagging>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
}
impl std::fmt::Debug for PutObjectTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("tagging", &self.tagging);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("request_payer", &self.request_payer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectRetentionInput {
    /// <p>The bucket name that contains the object you want to apply this Object Retention
    /// configuration to. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object that you want to apply this Object Retention configuration
    /// to.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The container element for the Object Retention configuration.</p>
    pub retention: std::option::Option<crate::model::ObjectLockRetention>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The version ID for the object that you want to apply this Object Retention configuration
    /// to.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether this action should bypass Governance-mode restrictions.</p>
    pub bypass_governance_retention: bool,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutObjectRetentionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectRetentionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("retention", &self.retention);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("version_id", &self.version_id);
        formatter.field(
            "bypass_governance_retention",
            &self.bypass_governance_retention,
        );
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectLockConfigurationInput {
    /// <p>The bucket whose Object Lock configuration you want to create or replace.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The Object Lock configuration that you want to apply to the specified bucket.</p>
    pub object_lock_configuration: std::option::Option<crate::model::ObjectLockConfiguration>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
    pub token: std::option::Option<std::string::String>,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutObjectLockConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectLockConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("object_lock_configuration", &self.object_lock_configuration);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("token", &self.token);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectLegalHoldInput {
    /// <p>The bucket name containing the object that you want to place a Legal Hold on. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object that you want to place a Legal Hold on.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Container element for the Legal Hold configuration you want to apply to the specified
    /// object.</p>
    pub legal_hold: std::option::Option<crate::model::ObjectLockLegalHold>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The version ID of the object that you want to place a Legal Hold on.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The MD5 hash for the request body.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutObjectLegalHoldInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectLegalHoldInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("legal_hold", &self.legal_hold);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("version_id", &self.version_id);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutObjectAclInput {
    /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
    pub access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
    /// <p>The bucket name that contains the object to which you want to attach the ACL. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864.></a>
    /// </p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    /// bucket.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to list the objects in the
    /// bucket.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the bucket ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to create new objects in the bucket.</p>
    /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    pub grant_write: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// bucket.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Key for which the PUT action was initiated.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutObjectAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectAclInput");
        formatter.field("acl", &self.acl);
        formatter.field("access_control_policy", &self.access_control_policy);
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write", &self.grant_write);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("version_id", &self.version_id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
pub struct PutObjectInput {
    /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned
    /// ACL</a>.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>Object data.</p>
    pub body: smithy_http::byte_stream::ByteStream,
    /// <p>The bucket name to which the PUT action was initiated. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p> Can be used to specify caching behavior along the request/reply chain. For more
    /// information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
    /// determined automatically. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>.</p>
    pub content_length: i64,
    /// <p>The base64-encoded 128-bit MD5 digest of the message (without the headers) according to
    /// RFC 1864. This header can be used as a message integrity check to verify that the data is
    /// the same data that was originally sent. Although it is optional, we recommend using the
    /// Content-MD5 mechanism as an end-to-end integrity check. For more information about REST
    /// request authentication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST
    /// Authentication</a>.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the contents. For more information, see
    /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable. For more information, see
    /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21</a>.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object data and its
    /// metadata.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Object key for which the PUT action was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    /// AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    /// STANDARD storage class provides high durability and high availability. Depending on
    /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    /// <i>Amazon S3 User Guide</i>.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    /// the object metadata. For information about object metadata, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a>.</p>
    /// <p>In the following example, the request header sets the redirect to an object
    /// (anotherPage.html) in the same bucket:</p>
    /// <p>
    /// <code>x-amz-website-redirect-location: /anotherPage.html</code>
    /// </p>
    /// <p>In the following example, the request header sets the object redirect to another
    /// website:</p>
    /// <p>
    /// <code>x-amz-website-redirect-location: http://www.example.com/</code>
    /// </p>
    /// <p>For more information about website hosting in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">Hosting Websites on Amazon S3</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html">How to Configure Website Page
    /// Redirects</a>. </p>
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
    /// <code>aws:kms</code>, this header specifies the ID of the Amazon Web Services Key Management Service
    /// (Amazon Web Services KMS) symmetrical customer managed key that was used for the
    /// object. If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but do not
    /// provide<code> x-amz-server-side-encryption-aws-kms-key-id</code>, Amazon S3 uses the Amazon Web Services
    /// managed key to protect the data. If the KMS key does not exist in the same account
    /// issuing the command, you must use the full ARN and not just the ID.
    /// </p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this
    /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    /// pairs.</p>
    pub ssekms_encryption_context: std::option::Option<std::string::String>,
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    /// <p>Specifying this header with a PUT action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
    pub bucket_key_enabled: bool,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For
    /// example, "Key1=Value1")</p>
    pub tagging: std::option::Option<std::string::String>,
    /// <p>The Object Lock mode that you want to apply to this object.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>The date and time when you want this object's Object Lock to expire. Must be formatted
    /// as a timestamp parameter.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether a legal hold will be applied to this object. For more information
    /// about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
    /// Lock</a>.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutObjectInput");
        formatter.field("acl", &self.acl);
        formatter.field("body", &self.body);
        formatter.field("bucket", &self.bucket);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_length", &self.content_length);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("content_type", &self.content_type);
        formatter.field("expires", &self.expires);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("metadata", &self.metadata);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ssekms_encryption_context",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketWebsiteInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Container for the request.</p>
    pub website_configuration: std::option::Option<crate::model::WebsiteConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketWebsiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketWebsiteInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("website_configuration", &self.website_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketVersioningInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
    /// message integrity check to verify that the request body was not corrupted in transit. For
    /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864</a>.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    /// that is displayed on your authentication device.</p>
    pub mfa: std::option::Option<std::string::String>,
    /// <p>Container for setting the versioning state.</p>
    pub versioning_configuration: std::option::Option<crate::model::VersioningConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketVersioningInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketVersioningInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("mfa", &self.mfa);
        formatter.field("versioning_configuration", &self.versioning_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketTaggingInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements.</p>
    pub tagging: std::option::Option<crate::model::Tagging>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("tagging", &self.tagging);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketRequestPaymentInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
    /// message integrity check to verify that the request body was not corrupted in transit. For
    /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864</a>.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Container for Payer.</p>
    pub request_payment_configuration:
        std::option::Option<crate::model::RequestPaymentConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketRequestPaymentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketRequestPaymentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field(
            "request_payment_configuration",
            &self.request_payment_configuration,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketReplicationInput {
    /// <p>The name of the bucket</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
    /// replication configuration is 2 MB.</p>
    pub replication_configuration: std::option::Option<crate::model::ReplicationConfiguration>,
    /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
    pub token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketReplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketReplicationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("replication_configuration", &self.replication_configuration);
        formatter.field("token", &self.token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketPolicyInput {
    /// <p>The name of the bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the request body.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Set this parameter to true to confirm that you want to remove your permissions to change
    /// this bucket policy in the future.</p>
    pub confirm_remove_self_bucket_access: bool,
    /// <p>The bucket policy as a JSON document.</p>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketPolicyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field(
            "confirm_remove_self_bucket_access",
            &self.confirm_remove_self_bucket_access,
        );
        formatter.field("policy", &self.policy);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketOwnershipControlsInput {
    /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The MD5 hash of the <code>OwnershipControls</code> request body. </p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) that you want
    /// to apply to this Amazon S3 bucket.</p>
    pub ownership_controls: std::option::Option<crate::model::OwnershipControls>,
}
impl std::fmt::Debug for PutBucketOwnershipControlsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketOwnershipControlsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("ownership_controls", &self.ownership_controls);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketNotificationConfigurationInput {
    /// <p>The name of the bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A container for specifying the notification configuration of the bucket. If this element
    /// is empty, notifications are turned off for the bucket.</p>
    pub notification_configuration: std::option::Option<crate::model::NotificationConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketNotificationConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketNotificationConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field(
            "notification_configuration",
            &self.notification_configuration,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketMetricsConfigurationInput {
    /// <p>The name of the bucket for which the metrics configuration is set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the metrics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies the metrics configuration.</p>
    pub metrics_configuration: std::option::Option<crate::model::MetricsConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketMetricsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketMetricsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("metrics_configuration", &self.metrics_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketLoggingInput {
    /// <p>The name of the bucket for which to set the logging parameters.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Container for logging status information.</p>
    pub bucket_logging_status: std::option::Option<crate::model::BucketLoggingStatus>,
    /// <p>The MD5 hash of the <code>PutBucketLogging</code> request body.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketLoggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketLoggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("bucket_logging_status", &self.bucket_logging_status);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketLifecycleConfigurationInput {
    /// <p>The name of the bucket for which to set the configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
    pub lifecycle_configuration: std::option::Option<crate::model::BucketLifecycleConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketLifecycleConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketLifecycleConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("lifecycle_configuration", &self.lifecycle_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketInventoryConfigurationInput {
    /// <p>The name of the bucket where the inventory configuration will be stored.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the inventory configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies the inventory configuration.</p>
    pub inventory_configuration: std::option::Option<crate::model::InventoryConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketInventoryConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketInventoryConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("inventory_configuration", &self.inventory_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketIntelligentTieringConfigurationInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Container for S3 Intelligent-Tiering configuration.</p>
    pub intelligent_tiering_configuration:
        std::option::Option<crate::model::IntelligentTieringConfiguration>,
}
impl std::fmt::Debug for PutBucketIntelligentTieringConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketIntelligentTieringConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field(
            "intelligent_tiering_configuration",
            &self.intelligent_tiering_configuration,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketEncryptionInput {
    /// <p>Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed
    /// keys (SSE-S3) or customer managed keys (SSE-KMS). For information about
    /// the Amazon S3 default encryption feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html">Amazon S3 Default Bucket Encryption</a>
    /// in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the server-side encryption configuration.</p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the default server-side-encryption configuration.</p>
    pub server_side_encryption_configuration:
        std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketEncryptionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field(
            "server_side_encryption_configuration",
            &self.server_side_encryption_configuration,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketCorsInput {
    /// <p>Specifies the bucket impacted by the <code>cors</code>configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource
    /// Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub cors_configuration: std::option::Option<crate::model::CorsConfiguration>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864.</a>
    /// </p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketCorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketCorsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("cors_configuration", &self.cors_configuration);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketAnalyticsConfigurationInput {
    /// <p>The name of the bucket to which an analytics configuration is stored.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID that identifies the analytics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The configuration and any analyses for the analytics filter.</p>
    pub analytics_configuration: std::option::Option<crate::model::AnalyticsConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketAnalyticsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketAnalyticsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("analytics_configuration", &self.analytics_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketAclInput {
    /// <p>The canned ACL to apply to the bucket.</p>
    pub acl: std::option::Option<crate::model::BucketCannedAcl>,
    /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
    pub access_control_policy: std::option::Option<crate::model::AccessControlPolicy>,
    /// <p>The bucket to which to apply the ACL.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
    /// integrity check to verify that the request body was not corrupted in transit. For more
    /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
    /// 1864.</a>
    /// </p>
    /// <p>For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.</p>
    pub content_md5: std::option::Option<std::string::String>,
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    /// bucket.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to list the objects in the bucket.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the bucket ACL.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to create new objects in the bucket.</p>
    /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    pub grant_write: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketAclInput");
        formatter.field("acl", &self.acl);
        formatter.field("access_control_policy", &self.access_control_policy);
        formatter.field("bucket", &self.bucket);
        formatter.field("content_md5", &self.content_md5);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write", &self.grant_write);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBucketAccelerateConfigurationInput {
    /// <p>The name of the bucket for which the accelerate configuration is set.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Container for setting the transfer acceleration state.</p>
    pub accelerate_configuration: std::option::Option<crate::model::AccelerateConfiguration>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBucketAccelerateConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBucketAccelerateConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("accelerate_configuration", &self.accelerate_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPartsInput {
    /// <p>The name of the bucket to which the parts are being uploaded. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of parts to return.</p>
    pub max_parts: i32,
    /// <p>Specifies the part after which listing should begin. Only parts with higher part numbers
    /// will be listed.</p>
    pub part_number_marker: std::option::Option<std::string::String>,
    /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPartsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPartsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("max_parts", &self.max_parts);
        formatter.field("part_number_marker", &self.part_number_marker);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListObjectVersionsInput {
    /// <p>The bucket name that contains the objects. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
    /// same string between the <code>prefix</code> and the first occurrence of the delimiter are
    /// grouped under a single result element in CommonPrefixes. These groups are counted as one
    /// result against the max-keys limitation. These keys are not returned elsewhere in the
    /// response.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    /// characters that are not supported in XML 1.0, you can add this parameter to request that
    /// Amazon S3 encode the keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Specifies the key to start with when listing objects in a bucket.</p>
    pub key_marker: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    /// to 1,000 key names. The response might contain fewer keys but will never contain more. If
    /// additional keys satisfy the search criteria, but were not returned because max-keys was
    /// exceeded, the response contains <isTruncated>true</isTruncated>. To return the
    /// additional keys, see key-marker and version-id-marker.</p>
    pub max_keys: i32,
    /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
    /// can use prefixes to separate a bucket into different groupings of keys. (You can think of
    /// using prefix to make groups in the same way you'd use a folder in a file system.) You can
    /// use prefix with delimiter to roll up numerous objects into a single result under
    /// CommonPrefixes. </p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Specifies the object version you want to start listing from.</p>
    pub version_id_marker: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListObjectVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListObjectVersionsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("key_marker", &self.key_marker);
        formatter.field("max_keys", &self.max_keys);
        formatter.field("prefix", &self.prefix);
        formatter.field("version_id_marker", &self.version_id_marker);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListObjectsV2Input {
    /// <p>Bucket name to list. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A delimiter is a character you use to group keys.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    /// to 1,000 key names. The response might contain fewer keys but will never contain
    /// more.</p>
    pub max_keys: i32,
    /// <p>Limits the response to keys that begin with the specified prefix.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a
    /// token. ContinuationToken is obfuscated and is not a real key.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The owner field is not present in listV2 by default, if you want to return owner field
    /// with each key in the result then set the fetch owner field to true.</p>
    pub fetch_owner: bool,
    /// <p>StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this
    /// specified key. StartAfter can be any key in the bucket.</p>
    pub start_after: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that she or he will be charged for the list objects
    /// request in V2 style. Bucket owners need not specify this parameter in their
    /// requests.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListObjectsV2Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListObjectsV2Input");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("max_keys", &self.max_keys);
        formatter.field("prefix", &self.prefix);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("fetch_owner", &self.fetch_owner);
        formatter.field("start_after", &self.start_after);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListObjectsInput {
    /// <p>The name of the bucket containing the objects.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>A delimiter is a character you use to group keys.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    /// characters that are not supported in XML 1.0, you can add this parameter to request that
    /// Amazon S3 encode the keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Marker is where you want Amazon S3 to start listing from. Amazon S3 starts listing after
    /// this specified key. Marker can be any key in the bucket.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
    /// to 1,000 key names. The response might contain fewer keys but will never contain more.
    /// </p>
    pub max_keys: i32,
    /// <p>Limits the response to keys that begin with the specified prefix.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that she or he will be charged for the list objects
    /// request. Bucket owners need not specify this parameter in their requests.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListObjectsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListObjectsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("marker", &self.marker);
        formatter.field("max_keys", &self.max_keys);
        formatter.field("prefix", &self.prefix);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMultipartUploadsInput {
    /// <p>The name of the bucket to which the multipart upload was initiated. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Character you use to group keys.</p>
    /// <p>All keys that contain the same string between the prefix, if specified, and the first
    /// occurrence of the delimiter after the prefix are grouped under a single result element,
    /// <code>CommonPrefixes</code>. If you don't specify the prefix parameter, then the
    /// substring starts at the beginning of the key. The keys that are grouped under
    /// <code>CommonPrefixes</code> result element are not returned elsewhere in the
    /// response.</p>
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
    /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
    /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
    /// characters that are not supported in XML 1.0, you can add this parameter to request that
    /// Amazon S3 encode the keys in the response.</p>
    pub encoding_type: std::option::Option<crate::model::EncodingType>,
    /// <p>Together with upload-id-marker, this parameter specifies the multipart upload after
    /// which listing should begin.</p>
    /// <p>If <code>upload-id-marker</code> is not specified, only the keys lexicographically
    /// greater than the specified <code>key-marker</code> will be included in the list.</p>
    /// <p>If <code>upload-id-marker</code> is specified, any multipart uploads for a key equal to
    /// the <code>key-marker</code> might also be included, provided those multipart uploads have
    /// upload IDs lexicographically greater than the specified
    /// <code>upload-id-marker</code>.</p>
    pub key_marker: std::option::Option<std::string::String>,
    /// <p>Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response
    /// body. 1,000 is the maximum number of uploads that can be returned in a response.</p>
    pub max_uploads: i32,
    /// <p>Lists in-progress uploads only for those keys that begin with the specified prefix. You
    /// can use prefixes to separate a bucket into different grouping of keys. (You can think of
    /// using prefix to make groups in the same way you'd use a folder in a file system.)</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Together with key-marker, specifies the multipart upload after which listing should
    /// begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
    /// Otherwise, any multipart uploads for a key equal to the key-marker might be included in the
    /// list only if they have an upload ID lexicographically greater than the specified
    /// <code>upload-id-marker</code>.</p>
    pub upload_id_marker: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMultipartUploadsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMultipartUploadsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delimiter", &self.delimiter);
        formatter.field("encoding_type", &self.encoding_type);
        formatter.field("key_marker", &self.key_marker);
        formatter.field("max_uploads", &self.max_uploads);
        formatter.field("prefix", &self.prefix);
        formatter.field("upload_id_marker", &self.upload_id_marker);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketsInput {}
impl std::fmt::Debug for ListBucketsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketMetricsConfigurationsInput {
    /// <p>The name of the bucket containing the metrics configurations to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The marker that is used to continue a metrics configuration listing that has been
    /// truncated. Use the NextContinuationToken from a previously truncated list response to
    /// continue the listing. The continuation token is an opaque value that Amazon S3
    /// understands.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketMetricsConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketMetricsConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketInventoryConfigurationsInput {
    /// <p>The name of the bucket containing the inventory configurations to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The marker used to continue an inventory configuration listing that has been truncated.
    /// Use the NextContinuationToken from a previously truncated list response to continue the
    /// listing. The continuation token is an opaque value that Amazon S3 understands.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketInventoryConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketInventoryConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketIntelligentTieringConfigurationsInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    /// begin.</p>
    pub continuation_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketIntelligentTieringConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketIntelligentTieringConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBucketAnalyticsConfigurationsInput {
    /// <p>The name of the bucket from which analytics configurations are retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ContinuationToken that represents a placeholder from where this request should
    /// begin.</p>
    pub continuation_token: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBucketAnalyticsConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBucketAnalyticsConfigurationsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("continuation_token", &self.continuation_token);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HeadObjectInput {
    /// <p>The name of the bucket containing the object.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
    /// otherwise return a 412 (precondition failed).</p>
    pub if_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has been modified since the specified time, otherwise
    /// return a 304 (not modified).</p>
    pub if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
    /// otherwise return a 304 (not modified).</p>
    pub if_none_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has not been modified since the specified time, otherwise
    /// return a 412 (precondition failed).</p>
    pub if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>The object key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
    /// Range header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
    /// <note>
    /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
    /// request.</p>
    /// </note>
    pub range: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
    /// Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about
    /// the size of the part and the number of parts in this object.</p>
    pub part_number: i32,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HeadObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HeadObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("if_match", &self.if_match);
        formatter.field("if_modified_since", &self.if_modified_since);
        formatter.field("if_none_match", &self.if_none_match);
        formatter.field("if_unmodified_since", &self.if_unmodified_since);
        formatter.field("key", &self.key);
        formatter.field("range", &self.range);
        formatter.field("version_id", &self.version_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("part_number", &self.part_number);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HeadBucketInput {
    /// <p>The bucket name.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HeadBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HeadBucketInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPublicAccessBlockInput {
    /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
    /// to retrieve. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPublicAccessBlockInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPublicAccessBlockInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectTorrentInput {
    /// <p>The name of the bucket containing the object for which to get the torrent files.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The object key for which to get the information.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectTorrentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectTorrentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectTaggingInput {
    /// <p>The bucket name containing the object for which to get the tagging information. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which to get the tagging information.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The versionId of the object for which to get the tagging information.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
}
impl std::fmt::Debug for GetObjectTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("request_payer", &self.request_payer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectRetentionInput {
    /// <p>The bucket name containing the object whose retention settings you want to retrieve. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object whose retention settings you want to retrieve.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The version ID for the object whose retention settings you want to retrieve.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectRetentionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectRetentionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectLockConfigurationInput {
    /// <p>The bucket whose Object Lock configuration you want to retrieve.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectLockConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectLockConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectLegalHoldInput {
    /// <p>The bucket name containing the object whose Legal Hold status you want to retrieve. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key name for the object whose Legal Hold status you want to retrieve.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The version ID of the object whose Legal Hold status you want to retrieve.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectLegalHoldInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectLegalHoldInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectAclInput {
    /// <p>The bucket name that contains the object for which to get the ACL information. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key of the object for which to get the ACL information.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectAclInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetObjectInput {
    /// <p>The bucket name containing the object. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using an Object Lambda access point the hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-object-lambda.<i>Region</i>.amazonaws.com.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
    /// otherwise return a 412 (precondition failed).</p>
    pub if_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has been modified since the specified time, otherwise
    /// return a 304 (not modified).</p>
    pub if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
    /// otherwise return a 304 (not modified).</p>
    pub if_none_match: std::option::Option<std::string::String>,
    /// <p>Return the object only if it has not been modified since the specified time, otherwise
    /// return a 412 (precondition failed).</p>
    pub if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Key of the object to get.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
    /// Range header, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
    /// <note>
    /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
    /// request.</p>
    /// </note>
    pub range: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Cache-Control</code> header of the response.</p>
    pub response_cache_control: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Disposition</code> header of the response</p>
    pub response_content_disposition: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Encoding</code> header of the response.</p>
    pub response_content_encoding: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Language</code> header of the response.</p>
    pub response_content_language: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Content-Type</code> header of the response.</p>
    pub response_content_type: std::option::Option<std::string::String>,
    /// <p>Sets the <code>Expires</code> header of the response.</p>
    pub response_expires: std::option::Option<smithy_types::Instant>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when decrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This
    /// value is used to decrypt the object when recovering it and must match the one used when
    /// storing the data. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
    /// Effectively performs a 'ranged' GET request for the part specified. Useful for downloading
    /// just a part of an object.</p>
    pub part_number: i32,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("if_match", &self.if_match);
        formatter.field("if_modified_since", &self.if_modified_since);
        formatter.field("if_none_match", &self.if_none_match);
        formatter.field("if_unmodified_since", &self.if_unmodified_since);
        formatter.field("key", &self.key);
        formatter.field("range", &self.range);
        formatter.field("response_cache_control", &self.response_cache_control);
        formatter.field(
            "response_content_disposition",
            &self.response_content_disposition,
        );
        formatter.field("response_content_encoding", &self.response_content_encoding);
        formatter.field("response_content_language", &self.response_content_language);
        formatter.field("response_content_type", &self.response_content_type);
        formatter.field("response_expires", &self.response_expires);
        formatter.field("version_id", &self.version_id);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("part_number", &self.part_number);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketWebsiteInput {
    /// <p>The bucket name for which to get the website configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketWebsiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketWebsiteInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketVersioningInput {
    /// <p>The name of the bucket for which to get the versioning information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketVersioningInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketVersioningInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketTaggingInput {
    /// <p>The name of the bucket for which to get the tagging information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketRequestPaymentInput {
    /// <p>The name of the bucket for which to get the payment request configuration</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketRequestPaymentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketRequestPaymentInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketReplicationInput {
    /// <p>The bucket name for which to get the replication information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketReplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketReplicationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketPolicyStatusInput {
    /// <p>The name of the Amazon S3 bucket whose policy status you want to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketPolicyStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketPolicyStatusInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketPolicyInput {
    /// <p>The bucket name for which to get the bucket policy.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketPolicyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketOwnershipControlsInput {
    /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to retrieve.
    /// </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketOwnershipControlsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketOwnershipControlsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketNotificationConfigurationInput {
    /// <p>The name of the bucket for which to get the notification configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketNotificationConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketNotificationConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketMetricsConfigurationInput {
    /// <p>The name of the bucket containing the metrics configuration to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the metrics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketMetricsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketMetricsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketLoggingInput {
    /// <p>The bucket name for which to get the logging information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketLoggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketLoggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketLocationInput {
    /// <p>The name of the bucket for which to get the location.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketLocationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketLocationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketLifecycleConfigurationInput {
    /// <p>The name of the bucket for which to get the lifecycle information.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketLifecycleConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketLifecycleConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketInventoryConfigurationInput {
    /// <p>The name of the bucket containing the inventory configuration to retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the inventory configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketInventoryConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketInventoryConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketIntelligentTieringConfigurationInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketIntelligentTieringConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketIntelligentTieringConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketEncryptionInput {
    /// <p>The name of the bucket from which the server-side encryption configuration is
    /// retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketEncryptionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketCorsInput {
    /// <p>The bucket name for which to get the cors configuration.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketCorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketCorsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAnalyticsConfigurationInput {
    /// <p>The name of the bucket from which an analytics configuration is retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID that identifies the analytics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketAnalyticsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAnalyticsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAclInput {
    /// <p>Specifies the S3 bucket whose ACL is being requested.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAclInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAccelerateConfigurationInput {
    /// <p>The name of the bucket for which the accelerate configuration is retrieved.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBucketAccelerateConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAccelerateConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePublicAccessBlockInput {
    /// <p>The Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete.
    /// </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePublicAccessBlockInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePublicAccessBlockInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteObjectTaggingInput {
    /// <p>The bucket name containing the objects from which to remove the tags. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key that identifies the object in the bucket from which to remove all tags.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The versionId of the object that the tag-set will be removed from.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteObjectTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteObjectTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("version_id", &self.version_id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteObjectsInput {
    /// <p>The bucket name containing the objects to delete. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Container for the request.</p>
    pub delete: std::option::Option<crate::model::Delete>,
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    /// that is displayed on your authentication device. Required to permanently delete a versioned
    /// object if versioning is configured with MFA delete enabled.</p>
    pub mfa: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Specifies whether you want to delete this object even if it has a Governance-type Object
    /// Lock in place. To use this header, you must have the <code>s3:PutBucketPublicAccessBlock</code>
    /// permission.</p>
    pub bypass_governance_retention: bool,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteObjectsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteObjectsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("delete", &self.delete);
        formatter.field("mfa", &self.mfa);
        formatter.field("request_payer", &self.request_payer);
        formatter.field(
            "bypass_governance_retention",
            &self.bypass_governance_retention,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteObjectInput {
    /// <p>The bucket name of the bucket containing the object. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Key name of the object to delete.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The concatenation of the authentication device's serial number, a space, and the value
    /// that is displayed on your authentication device. Required to permanently delete a versioned
    /// object if versioning is configured with MFA delete enabled.</p>
    pub mfa: std::option::Option<std::string::String>,
    /// <p>VersionId used to reference a specific version of the object.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process
    /// this operation. To use this header, you must have the <code>s3:PutBucketPublicAccessBlock</code>
    /// permission.</p>
    pub bypass_governance_retention: bool,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteObjectInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("mfa", &self.mfa);
        formatter.field("version_id", &self.version_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field(
            "bypass_governance_retention",
            &self.bypass_governance_retention,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketWebsiteInput {
    /// <p>The bucket name for which you want to remove the website configuration. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketWebsiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketWebsiteInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketTaggingInput {
    /// <p>The bucket that has the tag set to be removed.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketTaggingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketTaggingInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketReplicationInput {
    /// <p> The bucket name. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketReplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketReplicationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketPolicyInput {
    /// <p>The bucket name.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketPolicyInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketOwnershipControlsInput {
    /// <p>The Amazon S3 bucket whose <code>OwnershipControls</code> you want to delete. </p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketOwnershipControlsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketOwnershipControlsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketMetricsConfigurationInput {
    /// <p>The name of the bucket containing the metrics configuration to delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the metrics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketMetricsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketMetricsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketLifecycleInput {
    /// <p>The bucket name of the lifecycle to delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketLifecycleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketLifecycleInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketInventoryConfigurationInput {
    /// <p>The name of the bucket containing the inventory configuration to delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the inventory configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketInventoryConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketInventoryConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketIntelligentTieringConfigurationInput {
    /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketIntelligentTieringConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketIntelligentTieringConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketEncryptionInput {
    /// <p>The name of the bucket containing the server-side encryption configuration to
    /// delete.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketEncryptionInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketCorsInput {
    /// <p>Specifies the bucket whose <code>cors</code> configuration is being deleted.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketCorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketCorsInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketAnalyticsConfigurationInput {
    /// <p>The name of the bucket from which an analytics configuration is deleted.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The ID that identifies the analytics configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketAnalyticsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketAnalyticsConfigurationInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("id", &self.id);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketInput {
    /// <p>Specifies the bucket being deleted.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMultipartUploadInput {
    /// <p>The canned ACL to apply to the object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>The name of the bucket to which to initiate the upload</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object data and its
    /// metadata.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload is to be initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    /// AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    /// STANDARD storage class provides high durability and high availability. Depending on
    /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    /// <i>Amazon S3 User Guide</i>.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    /// the object metadata.</p>
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the ID of the symmetric customer managed key to use for object
    /// encryption. All GET and PUT requests for an object protected by Amazon Web Services KMS will fail if not
    /// made via SSL or using SigV4. For information about configuring using any of the officially
    /// supported Amazon Web Services SDKs and Amazon Web Services CLI, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
    /// in the <i>Amazon S3 User Guide</i>.</p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this
    /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    /// pairs.</p>
    pub ssekms_encryption_context: std::option::Option<std::string::String>,
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    /// <p>Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
    pub bucket_key_enabled: bool,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
    pub tagging: std::option::Option<std::string::String>,
    /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateMultipartUploadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMultipartUploadInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_type", &self.content_type);
        formatter.field("expires", &self.expires);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("metadata", &self.metadata);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ssekms_encryption_context",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBucketInput {
    /// <p>The canned ACL to apply to the bucket.</p>
    pub acl: std::option::Option<crate::model::BucketCannedAcl>,
    /// <p>The name of the bucket to create.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The configuration information for the bucket.</p>
    pub create_bucket_configuration: std::option::Option<crate::model::CreateBucketConfiguration>,
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
    /// bucket.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to list the objects in the bucket.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the bucket ACL.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to create new objects in the bucket.</p>
    /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
    pub grant_write: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
    pub object_lock_enabled_for_bucket: bool,
}
impl std::fmt::Debug for CreateBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBucketInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field(
            "create_bucket_configuration",
            &self.create_bucket_configuration,
        );
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write", &self.grant_write);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field(
            "object_lock_enabled_for_bucket",
            &self.object_lock_enabled_for_bucket,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CopyObjectInput {
    /// <p>The canned ACL to apply to the object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub acl: std::option::Option<crate::model::ObjectCannedAcl>,
    /// <p>The name of the destination bucket.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding
    /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
    /// field.</p>
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    pub content_language: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>Specifies the source object for the copy operation. You specify the value in one of two
    /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
    /// <ul>
    /// <li>
    /// <p>For objects not accessed through an access point, specify the name of the source
    /// bucket and the key of the source object, separated by a slash (/). For example, to
    /// copy the object <code>reports/january.pdf</code> from the bucket
    /// <code>awsexamplebucket</code>, use
    /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
    /// encoded.</p>
    /// </li>
    /// <li>
    /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
    /// <note>
    /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same Amazon Web Services Region.</p>
    /// </note>
    /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
    /// </li>
    /// </ul>
    /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
    /// to the value (for example,
    /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
    /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
    /// object.</p>
    pub copy_source: std::option::Option<std::string::String>,
    /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
    pub copy_source_if_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it has been modified since the specified time.</p>
    pub copy_source_if_modified_since: std::option::Option<smithy_types::Instant>,
    /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
    pub copy_source_if_none_match: std::option::Option<std::string::String>,
    /// <p>Copies the object if it hasn't been modified since the specified time.</p>
    pub copy_source_if_unmodified_since: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub expires: std::option::Option<smithy_types::Instant>,
    /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_full_control: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object data and its
    /// metadata.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read: std::option::Option<std::string::String>,
    /// <p>Allows grantee to read the object ACL.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_read_acp: std::option::Option<std::string::String>,
    /// <p>Allows grantee to write the ACL for the applicable
    /// object.</p>
    /// <p>This action is not supported by Amazon S3 on Outposts.</p>
    pub grant_write_acp: std::option::Option<std::string::String>,
    /// <p>The key of the destination object.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A map of metadata to store with the object in S3.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies whether the metadata is copied from the source object or replaced with
    /// metadata provided in the request.</p>
    pub metadata_directive: std::option::Option<crate::model::MetadataDirective>,
    /// <p>Specifies whether the object tag-set are copied from the source object or replaced with
    /// tag-set provided in the request.</p>
    pub tagging_directive: std::option::Option<crate::model::TaggingDirective>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
    /// AES256, aws:kms).</p>
    pub server_side_encryption: std::option::Option<crate::model::ServerSideEncryption>,
    /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
    /// STANDARD storage class provides high durability and high availability. Depending on
    /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
    /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
    /// <i>Amazon S3 User Guide</i>.</p>
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another
    /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
    /// the object metadata.</p>
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>Specifies the algorithm to use to when encrypting the object (for example,
    /// AES256).</p>
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
    /// value is used to store the object and then it is discarded; Amazon S3 does not store the
    /// encryption key. The key must be appropriate for use with the algorithm specified in the
    /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
    pub sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Specifies the Amazon Web Services KMS key ID to use for object encryption. All GET and PUT requests for
    /// an object protected by Amazon Web Services KMS will fail if not made via SSL or using SigV4. For
    /// information about configuring using any of the officially supported Amazon Web Services SDKs and Amazon Web Services CLI,
    /// see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the
    /// Signature Version in Request Authentication</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this
    /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
    /// pairs.</p>
    pub ssekms_encryption_context: std::option::Option<std::string::String>,
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. </p>
    /// <p>Specifying this header with a COPY action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
    pub bucket_key_enabled: bool,
    /// <p>Specifies the algorithm to use when decrypting the source object (for example,
    /// AES256).</p>
    pub copy_source_sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
    /// object. The encryption key provided in this header must be one that was used when the
    /// source object was created.</p>
    pub copy_source_sse_customer_key: std::option::Option<std::string::String>,
    /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
    /// this header for a message integrity check to ensure that the encryption key was transmitted
    /// without error.</p>
    pub copy_source_sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The tag-set for the object destination object this value must be used in conjunction
    /// with the <code>TaggingDirective</code>. The tag-set must be encoded as URL Query
    /// parameters.</p>
    pub tagging: std::option::Option<std::string::String>,
    /// <p>The Object Lock mode that you want to apply to the copied object.</p>
    pub object_lock_mode: std::option::Option<crate::model::ObjectLockMode>,
    /// <p>The date and time when you want the copied object's Object Lock to expire.</p>
    pub object_lock_retain_until_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether you want to apply a Legal Hold to the copied object.</p>
    pub object_lock_legal_hold_status: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
    /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_source_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CopyObjectInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CopyObjectInput");
        formatter.field("acl", &self.acl);
        formatter.field("bucket", &self.bucket);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_type", &self.content_type);
        formatter.field("copy_source", &self.copy_source);
        formatter.field("copy_source_if_match", &self.copy_source_if_match);
        formatter.field(
            "copy_source_if_modified_since",
            &self.copy_source_if_modified_since,
        );
        formatter.field("copy_source_if_none_match", &self.copy_source_if_none_match);
        formatter.field(
            "copy_source_if_unmodified_since",
            &self.copy_source_if_unmodified_since,
        );
        formatter.field("expires", &self.expires);
        formatter.field("grant_full_control", &self.grant_full_control);
        formatter.field("grant_read", &self.grant_read);
        formatter.field("grant_read_acp", &self.grant_read_acp);
        formatter.field("grant_write_acp", &self.grant_write_acp);
        formatter.field("key", &self.key);
        formatter.field("metadata", &self.metadata);
        formatter.field("metadata_directive", &self.metadata_directive);
        formatter.field("tagging_directive", &self.tagging_directive);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key", &"*** Sensitive Data Redacted ***");
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ssekms_encryption_context",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field(
            "copy_source_sse_customer_algorithm",
            &self.copy_source_sse_customer_algorithm,
        );
        formatter.field(
            "copy_source_sse_customer_key",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field(
            "copy_source_sse_customer_key_md5",
            &self.copy_source_sse_customer_key_md5,
        );
        formatter.field("request_payer", &self.request_payer);
        formatter.field("tagging", &self.tagging);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field(
            "object_lock_retain_until_date",
            &self.object_lock_retain_until_date,
        );
        formatter.field(
            "object_lock_legal_hold_status",
            &self.object_lock_legal_hold_status,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "expected_source_bucket_owner",
            &self.expected_source_bucket_owner,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteMultipartUploadInput {
    /// <p>Name of the bucket to which the multipart upload was initiated.</p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Object key for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The container for the multipart upload request information.</p>
    pub multipart_upload: std::option::Option<crate::model::CompletedMultipartUpload>,
    /// <p>ID for the initiated multipart upload.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CompleteMultipartUploadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompleteMultipartUploadInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("multipart_upload", &self.multipart_upload);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AbortMultipartUploadInput {
    /// <p>The bucket name to which the upload was taking place. </p>
    /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the Amazon Web Services SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the Amazon Web Services SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Key of the object for which the multipart upload was initiated.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Upload ID that identifies the multipart upload.</p>
    pub upload_id: std::option::Option<std::string::String>,
    /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
    /// owners need not specify this parameter in their requests. For information about downloading
    /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
    /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub request_payer: std::option::Option<crate::model::RequestPayer>,
    /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AbortMultipartUploadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AbortMultipartUploadInput");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("upload_id", &self.upload_id);
        formatter.field("request_payer", &self.request_payer);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.finish()
    }
}
