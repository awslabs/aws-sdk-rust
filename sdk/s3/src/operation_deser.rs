// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_abort_multipart_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AbortMultipartUploadOutput, crate::error::AbortMultipartUploadError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AbortMultipartUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AbortMultipartUploadError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchUpload" => crate::error::AbortMultipartUploadError {
            meta: generic,
            kind: crate::error::AbortMultipartUploadErrorKind::NoSuchUpload({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_upload::Builder::default();
                let _ = response;
                output = crate::xml_deser::no_such_upload(response.body().as_ref(), output)
                    .map_err(crate::error::AbortMultipartUploadError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AbortMultipartUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_abort_multipart_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AbortMultipartUploadOutput, crate::error::AbortMultipartUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::abort_multipart_upload_output::Builder::default();
        let _ = response;
        output = output.set_request_charged(
            crate::http_serde::deser_header_abort_multipart_upload_request_charged(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::AbortMultipartUploadError::unhandled(
                    "Failed to parse RequestCharged from header `x-amz-request-charged",
                )
            })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_multipart_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CompleteMultipartUploadOutput, crate::error::CompleteMultipartUploadError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CompleteMultipartUploadError::unhandled)?;
    Err(crate::error::CompleteMultipartUploadError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_multipart_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CompleteMultipartUploadOutput, crate::error::CompleteMultipartUploadError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::complete_multipart_upload_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_complete_multipart_upload(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CompleteMultipartUploadError::unhandled)?;
        output = output.set_expiration(
            crate::http_serde::deser_header_complete_multipart_upload_expiration(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CompleteMultipartUploadError::unhandled(
                    "Failed to parse Expiration from header `x-amz-expiration",
                )
            })?,
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_complete_multipart_upload_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::CompleteMultipartUploadError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_version_id(
            crate::http_serde::deser_header_complete_multipart_upload_version_id(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CompleteMultipartUploadError::unhandled(
                    "Failed to parse VersionId from header `x-amz-version-id",
                )
            })?,
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_complete_multipart_upload_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::CompleteMultipartUploadError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_complete_multipart_upload_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::CompleteMultipartUploadError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_complete_multipart_upload_request_charged(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CompleteMultipartUploadError::unhandled(
                    "Failed to parse RequestCharged from header `x-amz-request-charged",
                )
            })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_object_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CopyObjectOutput, crate::error::CopyObjectError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CopyObjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyObjectError::unhandled(generic)),
    };
    Err(match error_code {
        "ObjectNotInActiveTierError" => crate::error::CopyObjectError {
            meta: generic,
            kind: crate::error::CopyObjectErrorKind::ObjectNotInActiveTierError({
                #[allow(unused_mut)]
                let mut output = crate::error::object_not_in_active_tier_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::object_not_in_active_tier_error(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CopyObjectError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CopyObjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_object_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CopyObjectOutput, crate::error::CopyObjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_object_output::Builder::default();
        let _ = response;
        output = output.set_copy_object_result(
            crate::http_serde::deser_payload_copy_object_copy_object_result(
                response.body().as_ref(),
            )?,
        );
        output = output.set_expiration(
            crate::http_serde::deser_header_copy_object_expiration(response.headers()).map_err(
                |_| {
                    crate::error::CopyObjectError::unhandled(
                        "Failed to parse Expiration from header `x-amz-expiration",
                    )
                },
            )?,
        );
        output = output.set_copy_source_version_id(
            crate::http_serde::deser_header_copy_object_copy_source_version_id(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse CopySourceVersionId from header `x-amz-copy-source-version-id"))?
        );
        output = output.set_version_id(
            crate::http_serde::deser_header_copy_object_version_id(response.headers()).map_err(
                |_| {
                    crate::error::CopyObjectError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                },
            )?,
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_copy_object_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_copy_object_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_copy_object_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_copy_object_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_ssekms_encryption_context(
            crate::http_serde::deser_header_copy_object_ssekms_encryption_context(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse SSEKMSEncryptionContext from header `x-amz-server-side-encryption-context"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_copy_object_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::CopyObjectError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_copy_object_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::CopyObjectError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_bucket_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateBucketOutput, crate::error::CreateBucketError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateBucketError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateBucketError::unhandled(generic)),
    };
    Err(match error_code {
        "BucketAlreadyOwnedByYou" => crate::error::CreateBucketError {
            meta: generic,
            kind: crate::error::CreateBucketErrorKind::BucketAlreadyOwnedByYou({
                #[allow(unused_mut)]
                let mut output = crate::error::bucket_already_owned_by_you::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::bucket_already_owned_by_you(response.body().as_ref(), output)
                        .map_err(crate::error::CreateBucketError::unhandled)?;
                output.build()
            }),
        },
        "BucketAlreadyExists" => crate::error::CreateBucketError {
            meta: generic,
            kind: crate::error::CreateBucketErrorKind::BucketAlreadyExists({
                #[allow(unused_mut)]
                let mut output = crate::error::bucket_already_exists::Builder::default();
                let _ = response;
                output = crate::xml_deser::bucket_already_exists(response.body().as_ref(), output)
                    .map_err(crate::error::CreateBucketError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateBucketError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_bucket_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateBucketOutput, crate::error::CreateBucketError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_bucket_output::Builder::default();
        let _ = response;
        output = output.set_location(
            crate::http_serde::deser_header_create_bucket_location(response.headers()).map_err(
                |_| {
                    crate::error::CreateBucketError::unhandled(
                        "Failed to parse Location from header `Location",
                    )
                },
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_multipart_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateMultipartUploadOutput, crate::error::CreateMultipartUploadError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateMultipartUploadError::unhandled)?;
    Err(crate::error::CreateMultipartUploadError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_multipart_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateMultipartUploadOutput, crate::error::CreateMultipartUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_multipart_upload_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_multipart_upload(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateMultipartUploadError::unhandled)?;
        output = output.set_abort_date(
            crate::http_serde::deser_header_create_multipart_upload_abort_date(response.headers())
                .map_err(|_| {
                    crate::error::CreateMultipartUploadError::unhandled(
                        "Failed to parse AbortDate from header `x-amz-abort-date",
                    )
                })?,
        );
        output = output.set_abort_rule_id(
            crate::http_serde::deser_header_create_multipart_upload_abort_rule_id(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateMultipartUploadError::unhandled(
                    "Failed to parse AbortRuleId from header `x-amz-abort-rule-id",
                )
            })?,
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_create_multipart_upload_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::CreateMultipartUploadError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_create_multipart_upload_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::CreateMultipartUploadError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_create_multipart_upload_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::CreateMultipartUploadError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_create_multipart_upload_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::CreateMultipartUploadError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_ssekms_encryption_context(
            crate::http_serde::deser_header_create_multipart_upload_ssekms_encryption_context(response.headers())
                                        .map_err(|_|crate::error::CreateMultipartUploadError::unhandled("Failed to parse SSEKMSEncryptionContext from header `x-amz-server-side-encryption-context"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_create_multipart_upload_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::CreateMultipartUploadError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_create_multipart_upload_request_charged(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateMultipartUploadError::unhandled(
                    "Failed to parse RequestCharged from header `x-amz-request-charged",
                )
            })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketOutput, crate::error::DeleteBucketError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketError::unhandled)?;
    Err(crate::error::DeleteBucketError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketOutput, crate::error::DeleteBucketError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_analytics_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketAnalyticsConfigurationOutput,
    crate::error::DeleteBucketAnalyticsConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketAnalyticsConfigurationError::unhandled)?;
    Err(crate::error::DeleteBucketAnalyticsConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_analytics_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketAnalyticsConfigurationOutput,
    crate::error::DeleteBucketAnalyticsConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_bucket_analytics_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_cors_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketCorsOutput, crate::error::DeleteBucketCorsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketCorsError::unhandled)?;
    Err(crate::error::DeleteBucketCorsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_cors_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketCorsOutput, crate::error::DeleteBucketCorsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_cors_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_encryption_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketEncryptionOutput, crate::error::DeleteBucketEncryptionError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketEncryptionError::unhandled)?;
    Err(crate::error::DeleteBucketEncryptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_encryption_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketEncryptionOutput, crate::error::DeleteBucketEncryptionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_encryption_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_intelligent_tiering_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
    crate::error::DeleteBucketIntelligentTieringConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketIntelligentTieringConfigurationError::unhandled)?;
    Err(crate::error::DeleteBucketIntelligentTieringConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_intelligent_tiering_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
    crate::error::DeleteBucketIntelligentTieringConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_bucket_intelligent_tiering_configuration_output::Builder::default(
            );
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_inventory_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketInventoryConfigurationOutput,
    crate::error::DeleteBucketInventoryConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketInventoryConfigurationError::unhandled)?;
    Err(crate::error::DeleteBucketInventoryConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_inventory_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketInventoryConfigurationOutput,
    crate::error::DeleteBucketInventoryConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_bucket_inventory_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_lifecycle_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketLifecycleOutput, crate::error::DeleteBucketLifecycleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketLifecycleError::unhandled)?;
    Err(crate::error::DeleteBucketLifecycleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_lifecycle_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketLifecycleOutput, crate::error::DeleteBucketLifecycleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_lifecycle_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_metrics_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketMetricsConfigurationOutput,
    crate::error::DeleteBucketMetricsConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketMetricsConfigurationError::unhandled)?;
    Err(crate::error::DeleteBucketMetricsConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_metrics_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketMetricsConfigurationOutput,
    crate::error::DeleteBucketMetricsConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_bucket_metrics_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_ownership_controls_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketOwnershipControlsOutput,
    crate::error::DeleteBucketOwnershipControlsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketOwnershipControlsError::unhandled)?;
    Err(crate::error::DeleteBucketOwnershipControlsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_ownership_controls_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteBucketOwnershipControlsOutput,
    crate::error::DeleteBucketOwnershipControlsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_ownership_controls_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketPolicyOutput, crate::error::DeleteBucketPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketPolicyError::unhandled)?;
    Err(crate::error::DeleteBucketPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketPolicyOutput, crate::error::DeleteBucketPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketReplicationOutput, crate::error::DeleteBucketReplicationError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketReplicationError::unhandled)?;
    Err(crate::error::DeleteBucketReplicationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketReplicationOutput, crate::error::DeleteBucketReplicationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_replication_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_tagging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketTaggingOutput, crate::error::DeleteBucketTaggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketTaggingError::unhandled)?;
    Err(crate::error::DeleteBucketTaggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_tagging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketTaggingOutput, crate::error::DeleteBucketTaggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_tagging_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_website_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketWebsiteOutput, crate::error::DeleteBucketWebsiteError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBucketWebsiteError::unhandled)?;
    Err(crate::error::DeleteBucketWebsiteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bucket_website_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteBucketWebsiteOutput, crate::error::DeleteBucketWebsiteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bucket_website_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_object_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteObjectOutput, crate::error::DeleteObjectError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteObjectError::unhandled)?;
    Err(crate::error::DeleteObjectError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_object_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteObjectOutput, crate::error::DeleteObjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_object_output::Builder::default();
        let _ = response;
        output = output.set_delete_marker(
            crate::http_serde::deser_header_delete_object_delete_marker(response.headers())
                .map_err(|_| {
                    crate::error::DeleteObjectError::unhandled(
                        "Failed to parse DeleteMarker from header `x-amz-delete-marker",
                    )
                })?,
        );
        output = output.set_version_id(
            crate::http_serde::deser_header_delete_object_version_id(response.headers()).map_err(
                |_| {
                    crate::error::DeleteObjectError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                },
            )?,
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_delete_object_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::DeleteObjectError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_objects_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteObjectsOutput, crate::error::DeleteObjectsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteObjectsError::unhandled)?;
    Err(crate::error::DeleteObjectsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_objects_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteObjectsOutput, crate::error::DeleteObjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_objects_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_objects(response.body().as_ref(), output)
            .map_err(crate::error::DeleteObjectsError::unhandled)?;
        output = output.set_request_charged(
            crate::http_serde::deser_header_delete_objects_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::DeleteObjectsError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_object_tagging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteObjectTaggingOutput, crate::error::DeleteObjectTaggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteObjectTaggingError::unhandled)?;
    Err(crate::error::DeleteObjectTaggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_object_tagging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteObjectTaggingOutput, crate::error::DeleteObjectTaggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_object_tagging_output::Builder::default();
        let _ = response;
        output = output.set_version_id(
            crate::http_serde::deser_header_delete_object_tagging_version_id(response.headers())
                .map_err(|_| {
                    crate::error::DeleteObjectTaggingError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_access_block_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeletePublicAccessBlockOutput, crate::error::DeletePublicAccessBlockError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeletePublicAccessBlockError::unhandled)?;
    Err(crate::error::DeletePublicAccessBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_access_block_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeletePublicAccessBlockOutput, crate::error::DeletePublicAccessBlockError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_public_access_block_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_accelerate_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketAccelerateConfigurationOutput,
    crate::error::GetBucketAccelerateConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketAccelerateConfigurationError::unhandled)?;
    Err(crate::error::GetBucketAccelerateConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_accelerate_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketAccelerateConfigurationOutput,
    crate::error::GetBucketAccelerateConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_bucket_accelerate_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_bucket_accelerate_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBucketAccelerateConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_acl_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketAclOutput, crate::error::GetBucketAclError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketAclError::unhandled)?;
    Err(crate::error::GetBucketAclError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_acl_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketAclOutput, crate::error::GetBucketAclError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_acl_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_bucket_acl(response.body().as_ref(), output)
            .map_err(crate::error::GetBucketAclError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_analytics_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketAnalyticsConfigurationOutput,
    crate::error::GetBucketAnalyticsConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketAnalyticsConfigurationError::unhandled)?;
    Err(crate::error::GetBucketAnalyticsConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_analytics_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketAnalyticsConfigurationOutput,
    crate::error::GetBucketAnalyticsConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_bucket_analytics_configuration_output::Builder::default();
        let _ = response;
        output = output.set_analytics_configuration(
            crate::http_serde::deser_payload_get_bucket_analytics_configuration_analytics_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_cors_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketCorsOutput, crate::error::GetBucketCorsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketCorsError::unhandled)?;
    Err(crate::error::GetBucketCorsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_cors_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketCorsOutput, crate::error::GetBucketCorsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_cors_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_bucket_cors(response.body().as_ref(), output)
                .map_err(crate::error::GetBucketCorsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_encryption_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketEncryptionOutput, crate::error::GetBucketEncryptionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketEncryptionError::unhandled)?;
    Err(crate::error::GetBucketEncryptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_encryption_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketEncryptionOutput, crate::error::GetBucketEncryptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_encryption_output::Builder::default();
        let _ = response;
        output = output.set_server_side_encryption_configuration(
            crate::http_serde::deser_payload_get_bucket_encryption_server_side_encryption_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_intelligent_tiering_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketIntelligentTieringConfigurationOutput,
    crate::error::GetBucketIntelligentTieringConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketIntelligentTieringConfigurationError::unhandled)?;
    Err(crate::error::GetBucketIntelligentTieringConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_intelligent_tiering_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketIntelligentTieringConfigurationOutput,
    crate::error::GetBucketIntelligentTieringConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_bucket_intelligent_tiering_configuration_output::Builder::default();
        let _ = response;
        output = output.set_intelligent_tiering_configuration(
            crate::http_serde::deser_payload_get_bucket_intelligent_tiering_configuration_intelligent_tiering_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_inventory_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketInventoryConfigurationOutput,
    crate::error::GetBucketInventoryConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketInventoryConfigurationError::unhandled)?;
    Err(crate::error::GetBucketInventoryConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_inventory_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketInventoryConfigurationOutput,
    crate::error::GetBucketInventoryConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_bucket_inventory_configuration_output::Builder::default();
        let _ = response;
        output = output.set_inventory_configuration(
            crate::http_serde::deser_payload_get_bucket_inventory_configuration_inventory_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_lifecycle_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketLifecycleConfigurationOutput,
    crate::error::GetBucketLifecycleConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketLifecycleConfigurationError::unhandled)?;
    Err(crate::error::GetBucketLifecycleConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_lifecycle_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketLifecycleConfigurationOutput,
    crate::error::GetBucketLifecycleConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_bucket_lifecycle_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_bucket_lifecycle_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBucketLifecycleConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_location_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketLocationOutput, crate::error::GetBucketLocationError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketLocationError::unhandled)?;
    Err(crate::error::GetBucketLocationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_location_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketLocationOutput, crate::error::GetBucketLocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_location_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_bucket_location(response.body().as_ref(), output)
                .map_err(crate::error::GetBucketLocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_logging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketLoggingOutput, crate::error::GetBucketLoggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketLoggingError::unhandled)?;
    Err(crate::error::GetBucketLoggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_logging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketLoggingOutput, crate::error::GetBucketLoggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_logging_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_bucket_logging(response.body().as_ref(), output)
                .map_err(crate::error::GetBucketLoggingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_metrics_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketMetricsConfigurationOutput,
    crate::error::GetBucketMetricsConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketMetricsConfigurationError::unhandled)?;
    Err(crate::error::GetBucketMetricsConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_metrics_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketMetricsConfigurationOutput,
    crate::error::GetBucketMetricsConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_metrics_configuration_output::Builder::default();
        let _ = response;
        output = output.set_metrics_configuration(
            crate::http_serde::deser_payload_get_bucket_metrics_configuration_metrics_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_notification_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketNotificationConfigurationOutput,
    crate::error::GetBucketNotificationConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketNotificationConfigurationError::unhandled)?;
    Err(crate::error::GetBucketNotificationConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_notification_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketNotificationConfigurationOutput,
    crate::error::GetBucketNotificationConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_bucket_notification_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_bucket_notification_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBucketNotificationConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_ownership_controls_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketOwnershipControlsOutput,
    crate::error::GetBucketOwnershipControlsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketOwnershipControlsError::unhandled)?;
    Err(crate::error::GetBucketOwnershipControlsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_ownership_controls_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetBucketOwnershipControlsOutput,
    crate::error::GetBucketOwnershipControlsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_ownership_controls_output::Builder::default();
        let _ = response;
        output = output.set_ownership_controls(
            crate::http_serde::deser_payload_get_bucket_ownership_controls_ownership_controls(
                response.body().as_ref(),
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketPolicyOutput, crate::error::GetBucketPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketPolicyError::unhandled)?;
    Err(crate::error::GetBucketPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketPolicyOutput, crate::error::GetBucketPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_policy_output::Builder::default();
        let _ = response;
        output = output.set_policy(crate::http_serde::deser_payload_get_bucket_policy_policy(
            response.body().as_ref(),
        )?);
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_policy_status_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketPolicyStatusOutput, crate::error::GetBucketPolicyStatusError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketPolicyStatusError::unhandled)?;
    Err(crate::error::GetBucketPolicyStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_policy_status_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketPolicyStatusOutput, crate::error::GetBucketPolicyStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_policy_status_output::Builder::default();
        let _ = response;
        output = output.set_policy_status(
            crate::http_serde::deser_payload_get_bucket_policy_status_policy_status(
                response.body().as_ref(),
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketReplicationOutput, crate::error::GetBucketReplicationError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketReplicationError::unhandled)?;
    Err(crate::error::GetBucketReplicationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketReplicationOutput, crate::error::GetBucketReplicationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_replication_output::Builder::default();
        let _ = response;
        output = output.set_replication_configuration(
            crate::http_serde::deser_payload_get_bucket_replication_replication_configuration(
                response.body().as_ref(),
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_request_payment_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketRequestPaymentOutput, crate::error::GetBucketRequestPaymentError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketRequestPaymentError::unhandled)?;
    Err(crate::error::GetBucketRequestPaymentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_request_payment_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketRequestPaymentOutput, crate::error::GetBucketRequestPaymentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_request_payment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_bucket_request_payment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBucketRequestPaymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_tagging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketTaggingOutput, crate::error::GetBucketTaggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketTaggingError::unhandled)?;
    Err(crate::error::GetBucketTaggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_tagging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketTaggingOutput, crate::error::GetBucketTaggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_tagging_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_bucket_tagging(response.body().as_ref(), output)
                .map_err(crate::error::GetBucketTaggingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_versioning_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketVersioningOutput, crate::error::GetBucketVersioningError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketVersioningError::unhandled)?;
    Err(crate::error::GetBucketVersioningError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_versioning_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketVersioningOutput, crate::error::GetBucketVersioningError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_versioning_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_bucket_versioning(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBucketVersioningError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_website_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketWebsiteOutput, crate::error::GetBucketWebsiteError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBucketWebsiteError::unhandled)?;
    Err(crate::error::GetBucketWebsiteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_bucket_website_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetBucketWebsiteOutput, crate::error::GetBucketWebsiteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_bucket_website_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_bucket_website(response.body().as_ref(), output)
                .map_err(crate::error::GetBucketWebsiteError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object(
    response: &mut http::Response<smithy_http::body::SdkBody>,
) -> Result<crate::output::GetObjectOutput, crate::error::GetObjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_output::Builder::default();
        let _ = response;
        output = output.set_body(crate::http_serde::deser_payload_get_object_body(
            response.body_mut(),
        )?);
        output = output.set_delete_marker(
            crate::http_serde::deser_header_get_object_delete_marker(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse DeleteMarker from header `x-amz-delete-marker",
                    )
                },
            )?,
        );
        output = output.set_accept_ranges(
            crate::http_serde::deser_header_get_object_accept_ranges(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse AcceptRanges from header `accept-ranges",
                    )
                },
            )?,
        );
        output = output.set_expiration(
            crate::http_serde::deser_header_get_object_expiration(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse Expiration from header `x-amz-expiration",
                    )
                },
            )?,
        );
        output = output.set_restore(
            crate::http_serde::deser_header_get_object_restore(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse Restore from header `x-amz-restore",
                    )
                },
            )?,
        );
        output = output.set_last_modified(
            crate::http_serde::deser_header_get_object_last_modified(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse LastModified from header `Last-Modified",
                    )
                },
            )?,
        );
        output = output.set_content_length(
            crate::http_serde::deser_header_get_object_content_length(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ContentLength from header `Content-Length",
                    )
                },
            )?,
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_get_object_e_tag(response.headers()).map_err(|_| {
                crate::error::GetObjectError::unhandled("Failed to parse ETag from header `ETag")
            })?,
        );
        output = output.set_missing_meta(
            crate::http_serde::deser_header_get_object_missing_meta(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse MissingMeta from header `x-amz-missing-meta",
                    )
                },
            )?,
        );
        output = output.set_version_id(
            crate::http_serde::deser_header_get_object_version_id(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                },
            )?,
        );
        output = output.set_cache_control(
            crate::http_serde::deser_header_get_object_cache_control(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse CacheControl from header `Cache-Control",
                    )
                },
            )?,
        );
        output = output.set_content_disposition(
            crate::http_serde::deser_header_get_object_content_disposition(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ContentDisposition from header `Content-Disposition",
                    )
                })?,
        );
        output = output.set_content_encoding(
            crate::http_serde::deser_header_get_object_content_encoding(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ContentEncoding from header `Content-Encoding",
                    )
                })?,
        );
        output = output.set_content_language(
            crate::http_serde::deser_header_get_object_content_language(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ContentLanguage from header `Content-Language",
                    )
                })?,
        );
        output = output.set_content_range(
            crate::http_serde::deser_header_get_object_content_range(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ContentRange from header `Content-Range",
                    )
                },
            )?,
        );
        output = output.set_content_type(
            crate::http_serde::deser_header_get_object_content_type(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ContentType from header `Content-Type",
                    )
                },
            )?,
        );
        output = output.set_expires(
            crate::http_serde::deser_header_get_object_expires(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse Expires from header `Expires",
                    )
                },
            )?,
        );
        output = output.set_website_redirect_location(
            crate::http_serde::deser_header_get_object_website_redirect_location(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse WebsiteRedirectLocation from header `x-amz-website-redirect-location"))?
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_get_object_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_metadata(
            crate::http_serde::deser_prefix_header_get_object_metadata(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse Metadata from prefix header `x-amz-meta-",
                    )
                })?,
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_get_object_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_get_object_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_get_object_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_get_object_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_storage_class(
            crate::http_serde::deser_header_get_object_storage_class(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse StorageClass from header `x-amz-storage-class",
                    )
                },
            )?,
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_get_object_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output = output.set_replication_status(
            crate::http_serde::deser_header_get_object_replication_status(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ReplicationStatus from header `x-amz-replication-status",
                    )
                })?,
        );
        output = output.set_parts_count(
            crate::http_serde::deser_header_get_object_parts_count(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse PartsCount from header `x-amz-mp-parts-count",
                    )
                },
            )?,
        );
        output = output.set_tag_count(
            crate::http_serde::deser_header_get_object_tag_count(response.headers()).map_err(
                |_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse TagCount from header `x-amz-tagging-count",
                    )
                },
            )?,
        );
        output = output.set_object_lock_mode(
            crate::http_serde::deser_header_get_object_object_lock_mode(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectError::unhandled(
                        "Failed to parse ObjectLockMode from header `x-amz-object-lock-mode",
                    )
                })?,
        );
        output = output.set_object_lock_retain_until_date(
            crate::http_serde::deser_header_get_object_object_lock_retain_until_date(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse ObjectLockRetainUntilDate from header `x-amz-object-lock-retain-until-date"))?
        );
        output = output.set_object_lock_legal_hold_status(
            crate::http_serde::deser_header_get_object_object_lock_legal_hold_status(response.headers())
                                        .map_err(|_|crate::error::GetObjectError::unhandled("Failed to parse ObjectLockLegalHoldStatus from header `x-amz-object-lock-legal-hold"))?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectOutput, crate::error::GetObjectError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetObjectError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchKey" => crate::error::GetObjectError {
            meta: generic,
            kind: crate::error::GetObjectErrorKind::NoSuchKey({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::no_such_key(response.body().as_ref(), output)
                    .map_err(crate::error::GetObjectError::unhandled)?;
                output.build()
            }),
        },
        "InvalidObjectState" => crate::error::GetObjectError {
            meta: generic,
            kind: crate::error::GetObjectErrorKind::InvalidObjectState({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_object_state::Builder::default();
                let _ = response;
                output = crate::xml_deser::invalid_object_state(response.body().as_ref(), output)
                    .map_err(crate::error::GetObjectError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetObjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_acl_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectAclOutput, crate::error::GetObjectAclError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectAclError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetObjectAclError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchKey" => crate::error::GetObjectAclError {
            meta: generic,
            kind: crate::error::GetObjectAclErrorKind::NoSuchKey({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::no_such_key(response.body().as_ref(), output)
                    .map_err(crate::error::GetObjectAclError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetObjectAclError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_acl_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectAclOutput, crate::error::GetObjectAclError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_acl_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_object_acl(response.body().as_ref(), output)
            .map_err(crate::error::GetObjectAclError::unhandled)?;
        output = output.set_request_charged(
            crate::http_serde::deser_header_get_object_acl_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectAclError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_legal_hold_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectLegalHoldOutput, crate::error::GetObjectLegalHoldError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectLegalHoldError::unhandled)?;
    Err(crate::error::GetObjectLegalHoldError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_legal_hold_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectLegalHoldOutput, crate::error::GetObjectLegalHoldError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_legal_hold_output::Builder::default();
        let _ = response;
        output = output.set_legal_hold(
            crate::http_serde::deser_payload_get_object_legal_hold_legal_hold(
                response.body().as_ref(),
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_lock_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetObjectLockConfigurationOutput,
    crate::error::GetObjectLockConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectLockConfigurationError::unhandled)?;
    Err(crate::error::GetObjectLockConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_lock_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetObjectLockConfigurationOutput,
    crate::error::GetObjectLockConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_lock_configuration_output::Builder::default();
        let _ = response;
        output = output.set_object_lock_configuration(
            crate::http_serde::deser_payload_get_object_lock_configuration_object_lock_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_retention_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectRetentionOutput, crate::error::GetObjectRetentionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectRetentionError::unhandled)?;
    Err(crate::error::GetObjectRetentionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_retention_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectRetentionOutput, crate::error::GetObjectRetentionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_retention_output::Builder::default();
        let _ = response;
        output = output.set_retention(
            crate::http_serde::deser_payload_get_object_retention_retention(
                response.body().as_ref(),
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_tagging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectTaggingOutput, crate::error::GetObjectTaggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectTaggingError::unhandled)?;
    Err(crate::error::GetObjectTaggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_tagging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectTaggingOutput, crate::error::GetObjectTaggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_tagging_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_object_tagging(response.body().as_ref(), output)
                .map_err(crate::error::GetObjectTaggingError::unhandled)?;
        output = output.set_version_id(
            crate::http_serde::deser_header_get_object_tagging_version_id(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectTaggingError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_torrent(
    response: &mut http::Response<smithy_http::body::SdkBody>,
) -> Result<crate::output::GetObjectTorrentOutput, crate::error::GetObjectTorrentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_object_torrent_output::Builder::default();
        let _ = response;
        output = output.set_body(crate::http_serde::deser_payload_get_object_torrent_body(
            response.body_mut(),
        )?);
        output = output.set_request_charged(
            crate::http_serde::deser_header_get_object_torrent_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::GetObjectTorrentError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_object_torrent_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetObjectTorrentOutput, crate::error::GetObjectTorrentError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetObjectTorrentError::unhandled)?;
    Err(crate::error::GetObjectTorrentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_public_access_block_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPublicAccessBlockOutput, crate::error::GetPublicAccessBlockError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetPublicAccessBlockError::unhandled)?;
    Err(crate::error::GetPublicAccessBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_public_access_block_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPublicAccessBlockOutput, crate::error::GetPublicAccessBlockError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_public_access_block_output::Builder::default();
        let _ = response;
        output = output.set_public_access_block_configuration(
            crate::http_serde::deser_payload_get_public_access_block_public_access_block_configuration(response.body().as_ref())?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_head_bucket_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::HeadBucketOutput, crate::error::HeadBucketError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::HeadBucketError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::HeadBucketError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFound" => crate::error::HeadBucketError {
            meta: generic,
            kind: crate::error::HeadBucketErrorKind::NotFound({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found::Builder::default();
                let _ = response;
                output = crate::xml_deser::not_found(response.body().as_ref(), output)
                    .map_err(crate::error::HeadBucketError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::HeadBucketError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_head_bucket_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::HeadBucketOutput, crate::error::HeadBucketError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::head_bucket_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_head_object_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::HeadObjectOutput, crate::error::HeadObjectError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::HeadObjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::HeadObjectError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFound" => crate::error::HeadObjectError {
            meta: generic,
            kind: crate::error::HeadObjectErrorKind::NotFound({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found::Builder::default();
                let _ = response;
                output = crate::xml_deser::not_found(response.body().as_ref(), output)
                    .map_err(crate::error::HeadObjectError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::HeadObjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_head_object_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::HeadObjectOutput, crate::error::HeadObjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::head_object_output::Builder::default();
        let _ = response;
        output = output.set_delete_marker(
            crate::http_serde::deser_header_head_object_delete_marker(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse DeleteMarker from header `x-amz-delete-marker",
                    )
                },
            )?,
        );
        output = output.set_accept_ranges(
            crate::http_serde::deser_header_head_object_accept_ranges(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse AcceptRanges from header `accept-ranges",
                    )
                },
            )?,
        );
        output = output.set_expiration(
            crate::http_serde::deser_header_head_object_expiration(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse Expiration from header `x-amz-expiration",
                    )
                },
            )?,
        );
        output = output.set_restore(
            crate::http_serde::deser_header_head_object_restore(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse Restore from header `x-amz-restore",
                    )
                },
            )?,
        );
        output = output.set_archive_status(
            crate::http_serde::deser_header_head_object_archive_status(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ArchiveStatus from header `x-amz-archive-status",
                    )
                })?,
        );
        output = output.set_last_modified(
            crate::http_serde::deser_header_head_object_last_modified(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse LastModified from header `Last-Modified",
                    )
                },
            )?,
        );
        output = output.set_content_length(
            crate::http_serde::deser_header_head_object_content_length(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ContentLength from header `Content-Length",
                    )
                })?,
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_head_object_e_tag(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ETag from header `ETag",
                    )
                },
            )?,
        );
        output = output.set_missing_meta(
            crate::http_serde::deser_header_head_object_missing_meta(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse MissingMeta from header `x-amz-missing-meta",
                    )
                },
            )?,
        );
        output = output.set_version_id(
            crate::http_serde::deser_header_head_object_version_id(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                },
            )?,
        );
        output = output.set_cache_control(
            crate::http_serde::deser_header_head_object_cache_control(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse CacheControl from header `Cache-Control",
                    )
                },
            )?,
        );
        output = output.set_content_disposition(
            crate::http_serde::deser_header_head_object_content_disposition(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ContentDisposition from header `Content-Disposition",
                    )
                })?,
        );
        output = output.set_content_encoding(
            crate::http_serde::deser_header_head_object_content_encoding(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ContentEncoding from header `Content-Encoding",
                    )
                })?,
        );
        output = output.set_content_language(
            crate::http_serde::deser_header_head_object_content_language(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ContentLanguage from header `Content-Language",
                    )
                })?,
        );
        output = output.set_content_type(
            crate::http_serde::deser_header_head_object_content_type(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ContentType from header `Content-Type",
                    )
                },
            )?,
        );
        output = output.set_expires(
            crate::http_serde::deser_header_head_object_expires(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse Expires from header `Expires",
                    )
                },
            )?,
        );
        output = output.set_website_redirect_location(
            crate::http_serde::deser_header_head_object_website_redirect_location(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse WebsiteRedirectLocation from header `x-amz-website-redirect-location"))?
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_head_object_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_metadata(
            crate::http_serde::deser_prefix_header_head_object_metadata(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse Metadata from prefix header `x-amz-meta-",
                    )
                })?,
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_head_object_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_head_object_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_head_object_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_head_object_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_storage_class(
            crate::http_serde::deser_header_head_object_storage_class(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse StorageClass from header `x-amz-storage-class",
                    )
                },
            )?,
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_head_object_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output = output.set_replication_status(
            crate::http_serde::deser_header_head_object_replication_status(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ReplicationStatus from header `x-amz-replication-status",
                    )
                })?,
        );
        output = output.set_parts_count(
            crate::http_serde::deser_header_head_object_parts_count(response.headers()).map_err(
                |_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse PartsCount from header `x-amz-mp-parts-count",
                    )
                },
            )?,
        );
        output = output.set_object_lock_mode(
            crate::http_serde::deser_header_head_object_object_lock_mode(response.headers())
                .map_err(|_| {
                    crate::error::HeadObjectError::unhandled(
                        "Failed to parse ObjectLockMode from header `x-amz-object-lock-mode",
                    )
                })?,
        );
        output = output.set_object_lock_retain_until_date(
            crate::http_serde::deser_header_head_object_object_lock_retain_until_date(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse ObjectLockRetainUntilDate from header `x-amz-object-lock-retain-until-date"))?
        );
        output = output.set_object_lock_legal_hold_status(
            crate::http_serde::deser_header_head_object_object_lock_legal_hold_status(response.headers())
                                        .map_err(|_|crate::error::HeadObjectError::unhandled("Failed to parse ObjectLockLegalHoldStatus from header `x-amz-object-lock-legal-hold"))?
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_analytics_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketAnalyticsConfigurationsOutput,
    crate::error::ListBucketAnalyticsConfigurationsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBucketAnalyticsConfigurationsError::unhandled)?;
    Err(crate::error::ListBucketAnalyticsConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_analytics_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketAnalyticsConfigurationsOutput,
    crate::error::ListBucketAnalyticsConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_bucket_analytics_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_bucket_analytics_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBucketAnalyticsConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_intelligent_tiering_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketIntelligentTieringConfigurationsOutput,
    crate::error::ListBucketIntelligentTieringConfigurationsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBucketIntelligentTieringConfigurationsError::unhandled)?;
    Err(crate::error::ListBucketIntelligentTieringConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_intelligent_tiering_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketIntelligentTieringConfigurationsOutput,
    crate::error::ListBucketIntelligentTieringConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_bucket_intelligent_tiering_configurations_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_list_bucket_intelligent_tiering_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBucketIntelligentTieringConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_inventory_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketInventoryConfigurationsOutput,
    crate::error::ListBucketInventoryConfigurationsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBucketInventoryConfigurationsError::unhandled)?;
    Err(crate::error::ListBucketInventoryConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_inventory_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketInventoryConfigurationsOutput,
    crate::error::ListBucketInventoryConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_bucket_inventory_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_bucket_inventory_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBucketInventoryConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_metrics_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketMetricsConfigurationsOutput,
    crate::error::ListBucketMetricsConfigurationsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBucketMetricsConfigurationsError::unhandled)?;
    Err(crate::error::ListBucketMetricsConfigurationsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bucket_metrics_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListBucketMetricsConfigurationsOutput,
    crate::error::ListBucketMetricsConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_bucket_metrics_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_bucket_metrics_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBucketMetricsConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_buckets_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListBucketsOutput, crate::error::ListBucketsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBucketsError::unhandled)?;
    Err(crate::error::ListBucketsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_buckets_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListBucketsOutput, crate::error::ListBucketsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_buckets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_buckets(response.body().as_ref(), output)
            .map_err(crate::error::ListBucketsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_multipart_uploads_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListMultipartUploadsOutput, crate::error::ListMultipartUploadsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListMultipartUploadsError::unhandled)?;
    Err(crate::error::ListMultipartUploadsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_multipart_uploads_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListMultipartUploadsOutput, crate::error::ListMultipartUploadsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_multipart_uploads_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_multipart_uploads(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMultipartUploadsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_objects_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListObjectsOutput, crate::error::ListObjectsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListObjectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListObjectsError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchBucket" => crate::error::ListObjectsError {
            meta: generic,
            kind: crate::error::ListObjectsErrorKind::NoSuchBucket({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_bucket::Builder::default();
                let _ = response;
                output = crate::xml_deser::no_such_bucket(response.body().as_ref(), output)
                    .map_err(crate::error::ListObjectsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListObjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_objects_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListObjectsOutput, crate::error::ListObjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_objects_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_objects(response.body().as_ref(), output)
            .map_err(crate::error::ListObjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_objects_v2_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListObjectsV2Output, crate::error::ListObjectsV2Error> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListObjectsV2Error::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListObjectsV2Error::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchBucket" => crate::error::ListObjectsV2Error {
            meta: generic,
            kind: crate::error::ListObjectsV2ErrorKind::NoSuchBucket({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_bucket::Builder::default();
                let _ = response;
                output = crate::xml_deser::no_such_bucket(response.body().as_ref(), output)
                    .map_err(crate::error::ListObjectsV2Error::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListObjectsV2Error::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_objects_v2_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListObjectsV2Output, crate::error::ListObjectsV2Error> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_objects_v2_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_objects_v2(response.body().as_ref(), output)
                .map_err(crate::error::ListObjectsV2Error::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_object_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListObjectVersionsOutput, crate::error::ListObjectVersionsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListObjectVersionsError::unhandled)?;
    Err(crate::error::ListObjectVersionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_object_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListObjectVersionsOutput, crate::error::ListObjectVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_object_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_object_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListObjectVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_parts_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPartsOutput, crate::error::ListPartsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListPartsError::unhandled)?;
    Err(crate::error::ListPartsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_parts_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPartsOutput, crate::error::ListPartsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_parts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_parts(response.body().as_ref(), output)
            .map_err(crate::error::ListPartsError::unhandled)?;
        output = output.set_abort_date(
            crate::http_serde::deser_header_list_parts_abort_date(response.headers()).map_err(
                |_| {
                    crate::error::ListPartsError::unhandled(
                        "Failed to parse AbortDate from header `x-amz-abort-date",
                    )
                },
            )?,
        );
        output = output.set_abort_rule_id(
            crate::http_serde::deser_header_list_parts_abort_rule_id(response.headers()).map_err(
                |_| {
                    crate::error::ListPartsError::unhandled(
                        "Failed to parse AbortRuleId from header `x-amz-abort-rule-id",
                    )
                },
            )?,
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_list_parts_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::ListPartsError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_accelerate_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketAccelerateConfigurationOutput,
    crate::error::PutBucketAccelerateConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketAccelerateConfigurationError::unhandled)?;
    Err(crate::error::PutBucketAccelerateConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_accelerate_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketAccelerateConfigurationOutput,
    crate::error::PutBucketAccelerateConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_bucket_accelerate_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_acl_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketAclOutput, crate::error::PutBucketAclError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketAclError::unhandled)?;
    Err(crate::error::PutBucketAclError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_acl_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketAclOutput, crate::error::PutBucketAclError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_acl_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_analytics_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketAnalyticsConfigurationOutput,
    crate::error::PutBucketAnalyticsConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketAnalyticsConfigurationError::unhandled)?;
    Err(crate::error::PutBucketAnalyticsConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_analytics_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketAnalyticsConfigurationOutput,
    crate::error::PutBucketAnalyticsConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_bucket_analytics_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_cors_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketCorsOutput, crate::error::PutBucketCorsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketCorsError::unhandled)?;
    Err(crate::error::PutBucketCorsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_cors_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketCorsOutput, crate::error::PutBucketCorsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_cors_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_encryption_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketEncryptionOutput, crate::error::PutBucketEncryptionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketEncryptionError::unhandled)?;
    Err(crate::error::PutBucketEncryptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_encryption_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketEncryptionOutput, crate::error::PutBucketEncryptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_encryption_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_intelligent_tiering_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketIntelligentTieringConfigurationOutput,
    crate::error::PutBucketIntelligentTieringConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketIntelligentTieringConfigurationError::unhandled)?;
    Err(crate::error::PutBucketIntelligentTieringConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_intelligent_tiering_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketIntelligentTieringConfigurationOutput,
    crate::error::PutBucketIntelligentTieringConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_bucket_intelligent_tiering_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_inventory_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketInventoryConfigurationOutput,
    crate::error::PutBucketInventoryConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketInventoryConfigurationError::unhandled)?;
    Err(crate::error::PutBucketInventoryConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_inventory_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketInventoryConfigurationOutput,
    crate::error::PutBucketInventoryConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_bucket_inventory_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_lifecycle_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketLifecycleConfigurationOutput,
    crate::error::PutBucketLifecycleConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketLifecycleConfigurationError::unhandled)?;
    Err(crate::error::PutBucketLifecycleConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_lifecycle_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketLifecycleConfigurationOutput,
    crate::error::PutBucketLifecycleConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_bucket_lifecycle_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_logging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketLoggingOutput, crate::error::PutBucketLoggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketLoggingError::unhandled)?;
    Err(crate::error::PutBucketLoggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_logging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketLoggingOutput, crate::error::PutBucketLoggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_logging_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_metrics_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketMetricsConfigurationOutput,
    crate::error::PutBucketMetricsConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketMetricsConfigurationError::unhandled)?;
    Err(crate::error::PutBucketMetricsConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_metrics_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketMetricsConfigurationOutput,
    crate::error::PutBucketMetricsConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_metrics_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_notification_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketNotificationConfigurationOutput,
    crate::error::PutBucketNotificationConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketNotificationConfigurationError::unhandled)?;
    Err(crate::error::PutBucketNotificationConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_notification_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketNotificationConfigurationOutput,
    crate::error::PutBucketNotificationConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_bucket_notification_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_ownership_controls_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketOwnershipControlsOutput,
    crate::error::PutBucketOwnershipControlsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketOwnershipControlsError::unhandled)?;
    Err(crate::error::PutBucketOwnershipControlsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_ownership_controls_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutBucketOwnershipControlsOutput,
    crate::error::PutBucketOwnershipControlsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_ownership_controls_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketPolicyOutput, crate::error::PutBucketPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketPolicyError::unhandled)?;
    Err(crate::error::PutBucketPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketPolicyOutput, crate::error::PutBucketPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_replication_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketReplicationOutput, crate::error::PutBucketReplicationError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketReplicationError::unhandled)?;
    Err(crate::error::PutBucketReplicationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_replication_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketReplicationOutput, crate::error::PutBucketReplicationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_replication_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_request_payment_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketRequestPaymentOutput, crate::error::PutBucketRequestPaymentError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketRequestPaymentError::unhandled)?;
    Err(crate::error::PutBucketRequestPaymentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_request_payment_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketRequestPaymentOutput, crate::error::PutBucketRequestPaymentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_request_payment_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_tagging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketTaggingOutput, crate::error::PutBucketTaggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketTaggingError::unhandled)?;
    Err(crate::error::PutBucketTaggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_tagging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketTaggingOutput, crate::error::PutBucketTaggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_tagging_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_versioning_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketVersioningOutput, crate::error::PutBucketVersioningError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketVersioningError::unhandled)?;
    Err(crate::error::PutBucketVersioningError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_versioning_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketVersioningOutput, crate::error::PutBucketVersioningError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_versioning_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_website_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketWebsiteOutput, crate::error::PutBucketWebsiteError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBucketWebsiteError::unhandled)?;
    Err(crate::error::PutBucketWebsiteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_bucket_website_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutBucketWebsiteOutput, crate::error::PutBucketWebsiteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_bucket_website_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectOutput, crate::error::PutObjectError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutObjectError::unhandled)?;
    Err(crate::error::PutObjectError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectOutput, crate::error::PutObjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_object_output::Builder::default();
        let _ = response;
        output = output.set_expiration(
            crate::http_serde::deser_header_put_object_expiration(response.headers()).map_err(
                |_| {
                    crate::error::PutObjectError::unhandled(
                        "Failed to parse Expiration from header `x-amz-expiration",
                    )
                },
            )?,
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_put_object_e_tag(response.headers()).map_err(|_| {
                crate::error::PutObjectError::unhandled("Failed to parse ETag from header `ETag")
            })?,
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_put_object_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::PutObjectError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_version_id(
            crate::http_serde::deser_header_put_object_version_id(response.headers()).map_err(
                |_| {
                    crate::error::PutObjectError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                },
            )?,
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_put_object_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::PutObjectError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_put_object_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::PutObjectError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_put_object_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::PutObjectError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_ssekms_encryption_context(
            crate::http_serde::deser_header_put_object_ssekms_encryption_context(response.headers())
                                        .map_err(|_|crate::error::PutObjectError::unhandled("Failed to parse SSEKMSEncryptionContext from header `x-amz-server-side-encryption-context"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_put_object_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::PutObjectError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_put_object_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::PutObjectError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_acl_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectAclOutput, crate::error::PutObjectAclError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutObjectAclError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutObjectAclError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchKey" => crate::error::PutObjectAclError {
            meta: generic,
            kind: crate::error::PutObjectAclErrorKind::NoSuchKey({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_key::Builder::default();
                let _ = response;
                output = crate::xml_deser::no_such_key(response.body().as_ref(), output)
                    .map_err(crate::error::PutObjectAclError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutObjectAclError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_acl_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectAclOutput, crate::error::PutObjectAclError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_object_acl_output::Builder::default();
        let _ = response;
        output = output.set_request_charged(
            crate::http_serde::deser_header_put_object_acl_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::PutObjectAclError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_legal_hold_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectLegalHoldOutput, crate::error::PutObjectLegalHoldError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutObjectLegalHoldError::unhandled)?;
    Err(crate::error::PutObjectLegalHoldError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_legal_hold_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectLegalHoldOutput, crate::error::PutObjectLegalHoldError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_object_legal_hold_output::Builder::default();
        let _ = response;
        output = output.set_request_charged(
            crate::http_serde::deser_header_put_object_legal_hold_request_charged(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::PutObjectLegalHoldError::unhandled(
                    "Failed to parse RequestCharged from header `x-amz-request-charged",
                )
            })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_lock_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutObjectLockConfigurationOutput,
    crate::error::PutObjectLockConfigurationError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutObjectLockConfigurationError::unhandled)?;
    Err(crate::error::PutObjectLockConfigurationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_lock_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutObjectLockConfigurationOutput,
    crate::error::PutObjectLockConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_object_lock_configuration_output::Builder::default();
        let _ = response;
        output = output.set_request_charged(
            crate::http_serde::deser_header_put_object_lock_configuration_request_charged(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::PutObjectLockConfigurationError::unhandled(
                    "Failed to parse RequestCharged from header `x-amz-request-charged",
                )
            })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_retention_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectRetentionOutput, crate::error::PutObjectRetentionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutObjectRetentionError::unhandled)?;
    Err(crate::error::PutObjectRetentionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_retention_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectRetentionOutput, crate::error::PutObjectRetentionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_object_retention_output::Builder::default();
        let _ = response;
        output = output.set_request_charged(
            crate::http_serde::deser_header_put_object_retention_request_charged(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::PutObjectRetentionError::unhandled(
                    "Failed to parse RequestCharged from header `x-amz-request-charged",
                )
            })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_tagging_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectTaggingOutput, crate::error::PutObjectTaggingError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutObjectTaggingError::unhandled)?;
    Err(crate::error::PutObjectTaggingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_object_tagging_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutObjectTaggingOutput, crate::error::PutObjectTaggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_object_tagging_output::Builder::default();
        let _ = response;
        output = output.set_version_id(
            crate::http_serde::deser_header_put_object_tagging_version_id(response.headers())
                .map_err(|_| {
                    crate::error::PutObjectTaggingError::unhandled(
                        "Failed to parse VersionId from header `x-amz-version-id",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_public_access_block_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutPublicAccessBlockOutput, crate::error::PutPublicAccessBlockError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutPublicAccessBlockError::unhandled)?;
    Err(crate::error::PutPublicAccessBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_public_access_block_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutPublicAccessBlockOutput, crate::error::PutPublicAccessBlockError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_public_access_block_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_object_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::RestoreObjectOutput, crate::error::RestoreObjectError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RestoreObjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RestoreObjectError::unhandled(generic)),
    };
    Err(match error_code {
        "ObjectAlreadyInActiveTierError" => crate::error::RestoreObjectError {
            meta: generic,
            kind: crate::error::RestoreObjectErrorKind::ObjectAlreadyInActiveTierError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::object_already_in_active_tier_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::object_already_in_active_tier_error(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RestoreObjectError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RestoreObjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_object_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::RestoreObjectOutput, crate::error::RestoreObjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_object_output::Builder::default();
        let _ = response;
        output = output.set_request_charged(
            crate::http_serde::deser_header_restore_object_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::RestoreObjectError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output = output.set_restore_output_path(
            crate::http_serde::deser_header_restore_object_restore_output_path(response.headers())
                .map_err(|_| {
                    crate::error::RestoreObjectError::unhandled(
                        "Failed to parse RestoreOutputPath from header `x-amz-restore-output-path",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_part_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadPartOutput, crate::error::UploadPartError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UploadPartError::unhandled)?;
    Err(crate::error::UploadPartError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_part_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadPartOutput, crate::error::UploadPartError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_part_output::Builder::default();
        let _ = response;
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_upload_part_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::UploadPartError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_e_tag(
            crate::http_serde::deser_header_upload_part_e_tag(response.headers()).map_err(
                |_| {
                    crate::error::UploadPartError::unhandled(
                        "Failed to parse ETag from header `ETag",
                    )
                },
            )?,
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_upload_part_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::UploadPartError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_upload_part_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::UploadPartError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_upload_part_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::UploadPartError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_upload_part_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::UploadPartError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_upload_part_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::UploadPartError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_part_copy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadPartCopyOutput, crate::error::UploadPartCopyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UploadPartCopyError::unhandled)?;
    Err(crate::error::UploadPartCopyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_part_copy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadPartCopyOutput, crate::error::UploadPartCopyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_part_copy_output::Builder::default();
        let _ = response;
        output = output.set_copy_source_version_id(
            crate::http_serde::deser_header_upload_part_copy_copy_source_version_id(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::UploadPartCopyError::unhandled(
                    "Failed to parse CopySourceVersionId from header `x-amz-copy-source-version-id",
                )
            })?,
        );
        output = output.set_copy_part_result(
            crate::http_serde::deser_payload_upload_part_copy_copy_part_result(
                response.body().as_ref(),
            )?,
        );
        output = output.set_server_side_encryption(
            crate::http_serde::deser_header_upload_part_copy_server_side_encryption(response.headers())
                                        .map_err(|_|crate::error::UploadPartCopyError::unhandled("Failed to parse ServerSideEncryption from header `x-amz-server-side-encryption"))?
        );
        output = output.set_sse_customer_algorithm(
            crate::http_serde::deser_header_upload_part_copy_sse_customer_algorithm(response.headers())
                                        .map_err(|_|crate::error::UploadPartCopyError::unhandled("Failed to parse SSECustomerAlgorithm from header `x-amz-server-side-encryption-customer-algorithm"))?
        );
        output = output.set_sse_customer_key_md5(
            crate::http_serde::deser_header_upload_part_copy_sse_customer_key_md5(response.headers())
                                        .map_err(|_|crate::error::UploadPartCopyError::unhandled("Failed to parse SSECustomerKeyMD5 from header `x-amz-server-side-encryption-customer-key-MD5"))?
        );
        output = output.set_ssekms_key_id(
            crate::http_serde::deser_header_upload_part_copy_ssekms_key_id(response.headers())
                                        .map_err(|_|crate::error::UploadPartCopyError::unhandled("Failed to parse SSEKMSKeyId from header `x-amz-server-side-encryption-aws-kms-key-id"))?
        );
        output = output.set_bucket_key_enabled(
            crate::http_serde::deser_header_upload_part_copy_bucket_key_enabled(response.headers())
                                        .map_err(|_|crate::error::UploadPartCopyError::unhandled("Failed to parse BucketKeyEnabled from header `x-amz-server-side-encryption-bucket-key-enabled"))?
        );
        output = output.set_request_charged(
            crate::http_serde::deser_header_upload_part_copy_request_charged(response.headers())
                .map_err(|_| {
                    crate::error::UploadPartCopyError::unhandled(
                        "Failed to parse RequestCharged from header `x-amz-request-charged",
                    )
                })?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_write_get_object_response_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::WriteGetObjectResponseOutput, crate::error::WriteGetObjectResponseError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::WriteGetObjectResponseError::unhandled)?;
    Err(crate::error::WriteGetObjectResponseError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_write_get_object_response_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::WriteGetObjectResponseOutput, crate::error::WriteGetObjectResponseError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::write_get_object_response_output::Builder::default();
        let _ = response;
        output.build()
    })
}
