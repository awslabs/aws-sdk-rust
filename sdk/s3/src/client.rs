// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn abort_multipart_upload(&self) -> fluent_builders::AbortMultipartUpload<C> {
        fluent_builders::AbortMultipartUpload::new(self.handle.clone())
    }
    pub fn complete_multipart_upload(&self) -> fluent_builders::CompleteMultipartUpload<C> {
        fluent_builders::CompleteMultipartUpload::new(self.handle.clone())
    }
    pub fn copy_object(&self) -> fluent_builders::CopyObject<C> {
        fluent_builders::CopyObject::new(self.handle.clone())
    }
    pub fn create_bucket(&self) -> fluent_builders::CreateBucket<C> {
        fluent_builders::CreateBucket::new(self.handle.clone())
    }
    pub fn create_multipart_upload(&self) -> fluent_builders::CreateMultipartUpload<C> {
        fluent_builders::CreateMultipartUpload::new(self.handle.clone())
    }
    pub fn delete_bucket(&self) -> fluent_builders::DeleteBucket<C> {
        fluent_builders::DeleteBucket::new(self.handle.clone())
    }
    pub fn delete_bucket_analytics_configuration(
        &self,
    ) -> fluent_builders::DeleteBucketAnalyticsConfiguration<C> {
        fluent_builders::DeleteBucketAnalyticsConfiguration::new(self.handle.clone())
    }
    pub fn delete_bucket_cors(&self) -> fluent_builders::DeleteBucketCors<C> {
        fluent_builders::DeleteBucketCors::new(self.handle.clone())
    }
    pub fn delete_bucket_encryption(&self) -> fluent_builders::DeleteBucketEncryption<C> {
        fluent_builders::DeleteBucketEncryption::new(self.handle.clone())
    }
    pub fn delete_bucket_intelligent_tiering_configuration(
        &self,
    ) -> fluent_builders::DeleteBucketIntelligentTieringConfiguration<C> {
        fluent_builders::DeleteBucketIntelligentTieringConfiguration::new(self.handle.clone())
    }
    pub fn delete_bucket_inventory_configuration(
        &self,
    ) -> fluent_builders::DeleteBucketInventoryConfiguration<C> {
        fluent_builders::DeleteBucketInventoryConfiguration::new(self.handle.clone())
    }
    pub fn delete_bucket_lifecycle(&self) -> fluent_builders::DeleteBucketLifecycle<C> {
        fluent_builders::DeleteBucketLifecycle::new(self.handle.clone())
    }
    pub fn delete_bucket_metrics_configuration(
        &self,
    ) -> fluent_builders::DeleteBucketMetricsConfiguration<C> {
        fluent_builders::DeleteBucketMetricsConfiguration::new(self.handle.clone())
    }
    pub fn delete_bucket_ownership_controls(
        &self,
    ) -> fluent_builders::DeleteBucketOwnershipControls<C> {
        fluent_builders::DeleteBucketOwnershipControls::new(self.handle.clone())
    }
    pub fn delete_bucket_policy(&self) -> fluent_builders::DeleteBucketPolicy<C> {
        fluent_builders::DeleteBucketPolicy::new(self.handle.clone())
    }
    pub fn delete_bucket_replication(&self) -> fluent_builders::DeleteBucketReplication<C> {
        fluent_builders::DeleteBucketReplication::new(self.handle.clone())
    }
    pub fn delete_bucket_tagging(&self) -> fluent_builders::DeleteBucketTagging<C> {
        fluent_builders::DeleteBucketTagging::new(self.handle.clone())
    }
    pub fn delete_bucket_website(&self) -> fluent_builders::DeleteBucketWebsite<C> {
        fluent_builders::DeleteBucketWebsite::new(self.handle.clone())
    }
    pub fn delete_object(&self) -> fluent_builders::DeleteObject<C> {
        fluent_builders::DeleteObject::new(self.handle.clone())
    }
    pub fn delete_objects(&self) -> fluent_builders::DeleteObjects<C> {
        fluent_builders::DeleteObjects::new(self.handle.clone())
    }
    pub fn delete_object_tagging(&self) -> fluent_builders::DeleteObjectTagging<C> {
        fluent_builders::DeleteObjectTagging::new(self.handle.clone())
    }
    pub fn delete_public_access_block(&self) -> fluent_builders::DeletePublicAccessBlock<C> {
        fluent_builders::DeletePublicAccessBlock::new(self.handle.clone())
    }
    pub fn get_bucket_accelerate_configuration(
        &self,
    ) -> fluent_builders::GetBucketAccelerateConfiguration<C> {
        fluent_builders::GetBucketAccelerateConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_acl(&self) -> fluent_builders::GetBucketAcl<C> {
        fluent_builders::GetBucketAcl::new(self.handle.clone())
    }
    pub fn get_bucket_analytics_configuration(
        &self,
    ) -> fluent_builders::GetBucketAnalyticsConfiguration<C> {
        fluent_builders::GetBucketAnalyticsConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_cors(&self) -> fluent_builders::GetBucketCors<C> {
        fluent_builders::GetBucketCors::new(self.handle.clone())
    }
    pub fn get_bucket_encryption(&self) -> fluent_builders::GetBucketEncryption<C> {
        fluent_builders::GetBucketEncryption::new(self.handle.clone())
    }
    pub fn get_bucket_intelligent_tiering_configuration(
        &self,
    ) -> fluent_builders::GetBucketIntelligentTieringConfiguration<C> {
        fluent_builders::GetBucketIntelligentTieringConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_inventory_configuration(
        &self,
    ) -> fluent_builders::GetBucketInventoryConfiguration<C> {
        fluent_builders::GetBucketInventoryConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_lifecycle_configuration(
        &self,
    ) -> fluent_builders::GetBucketLifecycleConfiguration<C> {
        fluent_builders::GetBucketLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_location(&self) -> fluent_builders::GetBucketLocation<C> {
        fluent_builders::GetBucketLocation::new(self.handle.clone())
    }
    pub fn get_bucket_logging(&self) -> fluent_builders::GetBucketLogging<C> {
        fluent_builders::GetBucketLogging::new(self.handle.clone())
    }
    pub fn get_bucket_metrics_configuration(
        &self,
    ) -> fluent_builders::GetBucketMetricsConfiguration<C> {
        fluent_builders::GetBucketMetricsConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_notification_configuration(
        &self,
    ) -> fluent_builders::GetBucketNotificationConfiguration<C> {
        fluent_builders::GetBucketNotificationConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_ownership_controls(&self) -> fluent_builders::GetBucketOwnershipControls<C> {
        fluent_builders::GetBucketOwnershipControls::new(self.handle.clone())
    }
    pub fn get_bucket_policy(&self) -> fluent_builders::GetBucketPolicy<C> {
        fluent_builders::GetBucketPolicy::new(self.handle.clone())
    }
    pub fn get_bucket_policy_status(&self) -> fluent_builders::GetBucketPolicyStatus<C> {
        fluent_builders::GetBucketPolicyStatus::new(self.handle.clone())
    }
    pub fn get_bucket_replication(&self) -> fluent_builders::GetBucketReplication<C> {
        fluent_builders::GetBucketReplication::new(self.handle.clone())
    }
    pub fn get_bucket_request_payment(&self) -> fluent_builders::GetBucketRequestPayment<C> {
        fluent_builders::GetBucketRequestPayment::new(self.handle.clone())
    }
    pub fn get_bucket_tagging(&self) -> fluent_builders::GetBucketTagging<C> {
        fluent_builders::GetBucketTagging::new(self.handle.clone())
    }
    pub fn get_bucket_versioning(&self) -> fluent_builders::GetBucketVersioning<C> {
        fluent_builders::GetBucketVersioning::new(self.handle.clone())
    }
    pub fn get_bucket_website(&self) -> fluent_builders::GetBucketWebsite<C> {
        fluent_builders::GetBucketWebsite::new(self.handle.clone())
    }
    pub fn get_object(&self) -> fluent_builders::GetObject<C> {
        fluent_builders::GetObject::new(self.handle.clone())
    }
    pub fn get_object_acl(&self) -> fluent_builders::GetObjectAcl<C> {
        fluent_builders::GetObjectAcl::new(self.handle.clone())
    }
    pub fn get_object_legal_hold(&self) -> fluent_builders::GetObjectLegalHold<C> {
        fluent_builders::GetObjectLegalHold::new(self.handle.clone())
    }
    pub fn get_object_lock_configuration(&self) -> fluent_builders::GetObjectLockConfiguration<C> {
        fluent_builders::GetObjectLockConfiguration::new(self.handle.clone())
    }
    pub fn get_object_retention(&self) -> fluent_builders::GetObjectRetention<C> {
        fluent_builders::GetObjectRetention::new(self.handle.clone())
    }
    pub fn get_object_tagging(&self) -> fluent_builders::GetObjectTagging<C> {
        fluent_builders::GetObjectTagging::new(self.handle.clone())
    }
    pub fn get_object_torrent(&self) -> fluent_builders::GetObjectTorrent<C> {
        fluent_builders::GetObjectTorrent::new(self.handle.clone())
    }
    pub fn get_public_access_block(&self) -> fluent_builders::GetPublicAccessBlock<C> {
        fluent_builders::GetPublicAccessBlock::new(self.handle.clone())
    }
    pub fn head_bucket(&self) -> fluent_builders::HeadBucket<C> {
        fluent_builders::HeadBucket::new(self.handle.clone())
    }
    pub fn head_object(&self) -> fluent_builders::HeadObject<C> {
        fluent_builders::HeadObject::new(self.handle.clone())
    }
    pub fn list_bucket_analytics_configurations(
        &self,
    ) -> fluent_builders::ListBucketAnalyticsConfigurations<C> {
        fluent_builders::ListBucketAnalyticsConfigurations::new(self.handle.clone())
    }
    pub fn list_bucket_intelligent_tiering_configurations(
        &self,
    ) -> fluent_builders::ListBucketIntelligentTieringConfigurations<C> {
        fluent_builders::ListBucketIntelligentTieringConfigurations::new(self.handle.clone())
    }
    pub fn list_bucket_inventory_configurations(
        &self,
    ) -> fluent_builders::ListBucketInventoryConfigurations<C> {
        fluent_builders::ListBucketInventoryConfigurations::new(self.handle.clone())
    }
    pub fn list_bucket_metrics_configurations(
        &self,
    ) -> fluent_builders::ListBucketMetricsConfigurations<C> {
        fluent_builders::ListBucketMetricsConfigurations::new(self.handle.clone())
    }
    pub fn list_buckets(&self) -> fluent_builders::ListBuckets<C> {
        fluent_builders::ListBuckets::new(self.handle.clone())
    }
    pub fn list_multipart_uploads(&self) -> fluent_builders::ListMultipartUploads<C> {
        fluent_builders::ListMultipartUploads::new(self.handle.clone())
    }
    pub fn list_objects(&self) -> fluent_builders::ListObjects<C> {
        fluent_builders::ListObjects::new(self.handle.clone())
    }
    pub fn list_objects_v2(&self) -> fluent_builders::ListObjectsV2<C> {
        fluent_builders::ListObjectsV2::new(self.handle.clone())
    }
    pub fn list_object_versions(&self) -> fluent_builders::ListObjectVersions<C> {
        fluent_builders::ListObjectVersions::new(self.handle.clone())
    }
    pub fn list_parts(&self) -> fluent_builders::ListParts<C> {
        fluent_builders::ListParts::new(self.handle.clone())
    }
    pub fn put_bucket_accelerate_configuration(
        &self,
    ) -> fluent_builders::PutBucketAccelerateConfiguration<C> {
        fluent_builders::PutBucketAccelerateConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_acl(&self) -> fluent_builders::PutBucketAcl<C> {
        fluent_builders::PutBucketAcl::new(self.handle.clone())
    }
    pub fn put_bucket_analytics_configuration(
        &self,
    ) -> fluent_builders::PutBucketAnalyticsConfiguration<C> {
        fluent_builders::PutBucketAnalyticsConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_cors(&self) -> fluent_builders::PutBucketCors<C> {
        fluent_builders::PutBucketCors::new(self.handle.clone())
    }
    pub fn put_bucket_encryption(&self) -> fluent_builders::PutBucketEncryption<C> {
        fluent_builders::PutBucketEncryption::new(self.handle.clone())
    }
    pub fn put_bucket_intelligent_tiering_configuration(
        &self,
    ) -> fluent_builders::PutBucketIntelligentTieringConfiguration<C> {
        fluent_builders::PutBucketIntelligentTieringConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_inventory_configuration(
        &self,
    ) -> fluent_builders::PutBucketInventoryConfiguration<C> {
        fluent_builders::PutBucketInventoryConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_lifecycle_configuration(
        &self,
    ) -> fluent_builders::PutBucketLifecycleConfiguration<C> {
        fluent_builders::PutBucketLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_logging(&self) -> fluent_builders::PutBucketLogging<C> {
        fluent_builders::PutBucketLogging::new(self.handle.clone())
    }
    pub fn put_bucket_metrics_configuration(
        &self,
    ) -> fluent_builders::PutBucketMetricsConfiguration<C> {
        fluent_builders::PutBucketMetricsConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_notification_configuration(
        &self,
    ) -> fluent_builders::PutBucketNotificationConfiguration<C> {
        fluent_builders::PutBucketNotificationConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_ownership_controls(&self) -> fluent_builders::PutBucketOwnershipControls<C> {
        fluent_builders::PutBucketOwnershipControls::new(self.handle.clone())
    }
    pub fn put_bucket_policy(&self) -> fluent_builders::PutBucketPolicy<C> {
        fluent_builders::PutBucketPolicy::new(self.handle.clone())
    }
    pub fn put_bucket_replication(&self) -> fluent_builders::PutBucketReplication<C> {
        fluent_builders::PutBucketReplication::new(self.handle.clone())
    }
    pub fn put_bucket_request_payment(&self) -> fluent_builders::PutBucketRequestPayment<C> {
        fluent_builders::PutBucketRequestPayment::new(self.handle.clone())
    }
    pub fn put_bucket_tagging(&self) -> fluent_builders::PutBucketTagging<C> {
        fluent_builders::PutBucketTagging::new(self.handle.clone())
    }
    pub fn put_bucket_versioning(&self) -> fluent_builders::PutBucketVersioning<C> {
        fluent_builders::PutBucketVersioning::new(self.handle.clone())
    }
    pub fn put_bucket_website(&self) -> fluent_builders::PutBucketWebsite<C> {
        fluent_builders::PutBucketWebsite::new(self.handle.clone())
    }
    pub fn put_object(&self) -> fluent_builders::PutObject<C> {
        fluent_builders::PutObject::new(self.handle.clone())
    }
    pub fn put_object_acl(&self) -> fluent_builders::PutObjectAcl<C> {
        fluent_builders::PutObjectAcl::new(self.handle.clone())
    }
    pub fn put_object_legal_hold(&self) -> fluent_builders::PutObjectLegalHold<C> {
        fluent_builders::PutObjectLegalHold::new(self.handle.clone())
    }
    pub fn put_object_lock_configuration(&self) -> fluent_builders::PutObjectLockConfiguration<C> {
        fluent_builders::PutObjectLockConfiguration::new(self.handle.clone())
    }
    pub fn put_object_retention(&self) -> fluent_builders::PutObjectRetention<C> {
        fluent_builders::PutObjectRetention::new(self.handle.clone())
    }
    pub fn put_object_tagging(&self) -> fluent_builders::PutObjectTagging<C> {
        fluent_builders::PutObjectTagging::new(self.handle.clone())
    }
    pub fn put_public_access_block(&self) -> fluent_builders::PutPublicAccessBlock<C> {
        fluent_builders::PutPublicAccessBlock::new(self.handle.clone())
    }
    pub fn restore_object(&self) -> fluent_builders::RestoreObject<C> {
        fluent_builders::RestoreObject::new(self.handle.clone())
    }
    pub fn upload_part(&self) -> fluent_builders::UploadPart<C> {
        fluent_builders::UploadPart::new(self.handle.clone())
    }
    pub fn upload_part_copy(&self) -> fluent_builders::UploadPartCopy<C> {
        fluent_builders::UploadPartCopy::new(self.handle.clone())
    }
    pub fn write_get_object_response(&self) -> fluent_builders::WriteGetObjectResponse<C> {
        fluent_builders::WriteGetObjectResponse::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AbortMultipartUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::abort_multipart_upload_input::Builder,
    }
    impl<C> AbortMultipartUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AbortMultipartUploadOutput,
            smithy_http::result::SdkError<crate::error::AbortMultipartUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name to which the upload was taking place. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Key of the object for which the multipart upload was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Upload ID that identifies the multipart upload.</p>
        pub fn upload_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.upload_id(inp);
            self
        }
        pub fn set_upload_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_upload_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CompleteMultipartUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::complete_multipart_upload_input::Builder,
    }
    impl<C> CompleteMultipartUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CompleteMultipartUploadOutput,
            smithy_http::result::SdkError<crate::error::CompleteMultipartUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the bucket to which the multipart upload was initiated.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The container for the multipart upload request information.</p>
        pub fn multipart_upload(mut self, inp: crate::model::CompletedMultipartUpload) -> Self {
            self.inner = self.inner.multipart_upload(inp);
            self
        }
        pub fn set_multipart_upload(
            mut self,
            inp: std::option::Option<crate::model::CompletedMultipartUpload>,
        ) -> Self {
            self.inner = self.inner.set_multipart_upload(inp);
            self
        }
        /// <p>ID for the initiated multipart upload.</p>
        pub fn upload_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.upload_id(inp);
            self
        }
        pub fn set_upload_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_upload_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CopyObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_object_input::Builder,
    }
    impl<C> CopyObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CopyObjectOutput,
            smithy_http::result::SdkError<crate::error::CopyObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, inp: crate::model::ObjectCannedAcl) -> Self {
            self.inner = self.inner.acl(inp);
            self
        }
        pub fn set_acl(mut self, inp: std::option::Option<crate::model::ObjectCannedAcl>) -> Self {
            self.inner = self.inner.set_acl(inp);
            self
        }
        /// <p>The name of the destination bucket.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_control(inp);
            self
        }
        pub fn set_cache_control(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cache_control(inp);
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_disposition(inp);
            self
        }
        pub fn set_content_disposition(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_disposition(inp);
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_encoding(inp);
            self
        }
        pub fn set_content_encoding(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_encoding(inp);
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_language(inp);
            self
        }
        pub fn set_content_language(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_language(inp);
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(inp);
            self
        }
        pub fn set_content_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(inp);
            self
        }
        /// <p>Specifies the source object for the copy operation. You specify the value in one of two
        /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
        /// <ul>
        /// <li>
        /// <p>For objects not accessed through an access point, specify the name of the source
        /// bucket and the key of the source object, separated by a slash (/). For example, to
        /// copy the object <code>reports/january.pdf</code> from the bucket
        /// <code>awsexamplebucket</code>, use
        /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
        /// encoded.</p>
        /// </li>
        /// <li>
        /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
        /// <note>
        /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
        /// </note>
        /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
        /// </li>
        /// </ul>
        /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
        /// to the value (for example,
        /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
        /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
        /// object.</p>
        pub fn copy_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source(inp);
            self
        }
        pub fn set_copy_source(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_copy_source(inp);
            self
        }
        /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
        pub fn copy_source_if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_if_match(inp);
            self
        }
        pub fn set_copy_source_if_match(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_match(inp);
            self
        }
        /// <p>Copies the object if it has been modified since the specified time.</p>
        pub fn copy_source_if_modified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.copy_source_if_modified_since(inp);
            self
        }
        pub fn set_copy_source_if_modified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_modified_since(inp);
            self
        }
        /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
        pub fn copy_source_if_none_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_if_none_match(inp);
            self
        }
        pub fn set_copy_source_if_none_match(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_none_match(inp);
            self
        }
        /// <p>Copies the object if it hasn't been modified since the specified time.</p>
        pub fn copy_source_if_unmodified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.copy_source_if_unmodified_since(inp);
            self
        }
        pub fn set_copy_source_if_unmodified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_unmodified_since(inp);
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.expires(inp);
            self
        }
        pub fn set_expires(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_expires(inp);
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(inp);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(inp);
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(inp);
            self
        }
        pub fn set_grant_read(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(inp);
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(inp);
            self
        }
        pub fn set_grant_read_acp(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read_acp(inp);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(inp);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(inp);
            self
        }
        /// <p>The key of the destination object.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>A map of metadata to store with the object in S3.</p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(inp);
            self
        }
        /// <p>Specifies whether the metadata is copied from the source object or replaced with
        /// metadata provided in the request.</p>
        pub fn metadata_directive(mut self, inp: crate::model::MetadataDirective) -> Self {
            self.inner = self.inner.metadata_directive(inp);
            self
        }
        pub fn set_metadata_directive(
            mut self,
            inp: std::option::Option<crate::model::MetadataDirective>,
        ) -> Self {
            self.inner = self.inner.set_metadata_directive(inp);
            self
        }
        /// <p>Specifies whether the object tag-set are copied from the source object or replaced with
        /// tag-set provided in the request.</p>
        pub fn tagging_directive(mut self, inp: crate::model::TaggingDirective) -> Self {
            self.inner = self.inner.tagging_directive(inp);
            self
        }
        pub fn set_tagging_directive(
            mut self,
            inp: std::option::Option<crate::model::TaggingDirective>,
        ) -> Self {
            self.inner = self.inner.set_tagging_directive(inp);
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, inp: crate::model::ServerSideEncryption) -> Self {
            self.inner = self.inner.server_side_encryption(inp);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            inp: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.inner = self.inner.set_server_side_encryption(inp);
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, inp: crate::model::StorageClass) -> Self {
            self.inner = self.inner.storage_class(inp);
            self
        }
        pub fn set_storage_class(
            mut self,
            inp: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.inner = self.inner.set_storage_class(inp);
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata.</p>
        pub fn website_redirect_location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.website_redirect_location(inp);
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_website_redirect_location(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for
        /// an object protected by AWS KMS will fail if not made via SSL or using SigV4. For
        /// information about configuring using any of the officially supported AWS SDKs and AWS CLI,
        /// see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the
        /// Signature Version in Request Authentication</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn ssekms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_key_id(inp);
            self
        }
        pub fn set_ssekms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssekms_key_id(inp);
            self
        }
        /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_encryption_context(inp);
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssekms_encryption_context(inp);
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. </p>
        /// <p>Specifying this header with a COPY action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.bucket_key_enabled(inp);
            self
        }
        pub fn set_bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bucket_key_enabled(inp);
            self
        }
        /// <p>Specifies the algorithm to use when decrypting the source object (for example,
        /// AES256).</p>
        pub fn copy_source_sse_customer_algorithm(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.copy_source_sse_customer_algorithm(inp);
            self
        }
        pub fn set_copy_source_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
        /// object. The encryption key provided in this header must be one that was used when the
        /// source object was created.</p>
        pub fn copy_source_sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_sse_customer_key(inp);
            self
        }
        pub fn set_copy_source_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn copy_source_sse_customer_key_md5(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.copy_source_sse_customer_key_md5(inp);
            self
        }
        pub fn set_copy_source_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_sse_customer_key_md5(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The tag-set for the object destination object this value must be used in conjunction
        /// with the <code>TaggingDirective</code>. The tag-set must be encoded as URL Query
        /// parameters.</p>
        pub fn tagging(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tagging(inp);
            self
        }
        pub fn set_tagging(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tagging(inp);
            self
        }
        /// <p>The Object Lock mode that you want to apply to the copied object.</p>
        pub fn object_lock_mode(mut self, inp: crate::model::ObjectLockMode) -> Self {
            self.inner = self.inner.object_lock_mode(inp);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_mode(inp);
            self
        }
        /// <p>The date and time when you want the copied object's Object Lock to expire.</p>
        pub fn object_lock_retain_until_date(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.object_lock_retain_until_date(inp);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_retain_until_date(inp);
            self
        }
        /// <p>Specifies whether you want to apply a Legal Hold to the copied object.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            inp: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.inner = self.inner.object_lock_legal_hold_status(inp);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_legal_hold_status(inp);
            self
        }
        /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_source_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_source_bucket_owner(inp);
            self
        }
        pub fn set_expected_source_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_source_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBucket<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_bucket_input::Builder,
    }
    impl<C> CreateBucket<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateBucketOutput,
            smithy_http::result::SdkError<crate::error::CreateBucketError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the bucket.</p>
        pub fn acl(mut self, inp: crate::model::BucketCannedAcl) -> Self {
            self.inner = self.inner.acl(inp);
            self
        }
        pub fn set_acl(mut self, inp: std::option::Option<crate::model::BucketCannedAcl>) -> Self {
            self.inner = self.inner.set_acl(inp);
            self
        }
        /// <p>The name of the bucket to create.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        pub fn grant_full_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(inp);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(inp);
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        pub fn grant_read(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(inp);
            self
        }
        pub fn set_grant_read(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(inp);
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        pub fn grant_read_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(inp);
            self
        }
        pub fn set_grant_read_acp(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read_acp(inp);
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write(inp);
            self
        }
        pub fn set_grant_write(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_write(inp);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        pub fn grant_write_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(inp);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(inp);
            self
        }
        /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
        pub fn object_lock_enabled_for_bucket(mut self, inp: bool) -> Self {
            self.inner = self.inner.object_lock_enabled_for_bucket(inp);
            self
        }
        pub fn set_object_lock_enabled_for_bucket(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_object_lock_enabled_for_bucket(inp);
            self
        }
        /// <p>The configuration information for the bucket.</p>
        pub fn create_bucket_configuration(
            mut self,
            inp: crate::model::CreateBucketConfiguration,
        ) -> Self {
            self.inner = self.inner.create_bucket_configuration(inp);
            self
        }
        pub fn set_create_bucket_configuration(
            mut self,
            inp: std::option::Option<crate::model::CreateBucketConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_create_bucket_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMultipartUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_multipart_upload_input::Builder,
    }
    impl<C> CreateMultipartUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateMultipartUploadOutput,
            smithy_http::result::SdkError<crate::error::CreateMultipartUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, inp: crate::model::ObjectCannedAcl) -> Self {
            self.inner = self.inner.acl(inp);
            self
        }
        pub fn set_acl(mut self, inp: std::option::Option<crate::model::ObjectCannedAcl>) -> Self {
            self.inner = self.inner.set_acl(inp);
            self
        }
        /// <p>The name of the bucket to which to initiate the upload</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_control(inp);
            self
        }
        pub fn set_cache_control(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cache_control(inp);
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_disposition(inp);
            self
        }
        pub fn set_content_disposition(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_disposition(inp);
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_encoding(inp);
            self
        }
        pub fn set_content_encoding(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_encoding(inp);
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_language(inp);
            self
        }
        pub fn set_content_language(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_language(inp);
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(inp);
            self
        }
        pub fn set_content_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(inp);
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.expires(inp);
            self
        }
        pub fn set_expires(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_expires(inp);
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(inp);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(inp);
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(inp);
            self
        }
        pub fn set_grant_read(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(inp);
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(inp);
            self
        }
        pub fn set_grant_read_acp(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read_acp(inp);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(inp);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(inp);
            self
        }
        /// <p>Object key for which the multipart upload is to be initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>A map of metadata to store with the object in S3.</p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(inp);
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, inp: crate::model::ServerSideEncryption) -> Self {
            self.inner = self.inner.server_side_encryption(inp);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            inp: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.inner = self.inner.set_server_side_encryption(inp);
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, inp: crate::model::StorageClass) -> Self {
            self.inner = self.inner.storage_class(inp);
            self
        }
        pub fn set_storage_class(
            mut self,
            inp: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.inner = self.inner.set_storage_class(inp);
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata.</p>
        pub fn website_redirect_location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.website_redirect_location(inp);
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_website_redirect_location(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>Specifies the ID of the symmetric customer managed AWS KMS CMK to use for object
        /// encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not
        /// made via SSL or using SigV4. For information about configuring using any of the officially
        /// supported AWS SDKs and AWS CLI, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
        /// in the <i>Amazon S3 User Guide</i>.</p>
        pub fn ssekms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_key_id(inp);
            self
        }
        pub fn set_ssekms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssekms_key_id(inp);
            self
        }
        /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_encryption_context(inp);
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssekms_encryption_context(inp);
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
        /// <p>Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.bucket_key_enabled(inp);
            self
        }
        pub fn set_bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bucket_key_enabled(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
        pub fn tagging(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tagging(inp);
            self
        }
        pub fn set_tagging(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tagging(inp);
            self
        }
        /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
        pub fn object_lock_mode(mut self, inp: crate::model::ObjectLockMode) -> Self {
            self.inner = self.inner.object_lock_mode(inp);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_mode(inp);
            self
        }
        /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
        pub fn object_lock_retain_until_date(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.object_lock_retain_until_date(inp);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_retain_until_date(inp);
            self
        }
        /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            inp: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.inner = self.inner.object_lock_legal_hold_status(inp);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_legal_hold_status(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucket<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_input::Builder,
    }
    impl<C> DeleteBucket<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the bucket being deleted.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketAnalyticsConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_analytics_configuration_input::Builder,
    }
    impl<C> DeleteBucketAnalyticsConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketAnalyticsConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketAnalyticsConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket from which an analytics configuration is deleted.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketCors<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_cors_input::Builder,
    }
    impl<C> DeleteBucketCors<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketCorsOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketCorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the bucket whose <code>cors</code> configuration is being deleted.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_encryption_input::Builder,
    }
    impl<C> DeleteBucketEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketEncryptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the server-side encryption configuration to
        /// delete.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketIntelligentTieringConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_intelligent_tiering_configuration_input::Builder,
    }
    impl<C> DeleteBucketIntelligentTieringConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketIntelligentTieringConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteBucketIntelligentTieringConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketInventoryConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_inventory_configuration_input::Builder,
    }
    impl<C> DeleteBucketInventoryConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketInventoryConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketInventoryConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the inventory configuration to delete.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketLifecycle<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_lifecycle_input::Builder,
    }
    impl<C> DeleteBucketLifecycle<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketLifecycleOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketLifecycleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name of the lifecycle to delete.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketMetricsConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_metrics_configuration_input::Builder,
    }
    impl<C> DeleteBucketMetricsConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketMetricsConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketMetricsConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the metrics configuration to delete.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketOwnershipControls<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_ownership_controls_input::Builder,
    }
    impl<C> DeleteBucketOwnershipControls<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketOwnershipControlsOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketOwnershipControlsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon S3 bucket whose <code>OwnershipControls</code> you want to delete. </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_policy_input::Builder,
    }
    impl<C> DeleteBucketPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketReplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_replication_input::Builder,
    }
    impl<C> DeleteBucketReplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketReplicationOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketReplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The bucket name. </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_tagging_input::Builder,
    }
    impl<C> DeleteBucketTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketTaggingOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket that has the tag set to be removed.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketWebsite<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_website_input::Builder,
    }
    impl<C> DeleteBucketWebsite<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteBucketWebsiteOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketWebsiteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name for which you want to remove the website configuration. </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_object_input::Builder,
    }
    impl<C> DeleteObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteObjectOutput,
            smithy_http::result::SdkError<crate::error::DeleteObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name of the bucket containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Key name of the object to delete.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device. Required to permanently delete a versioned
        /// object if versioning is configured with MFA delete enabled.</p>
        pub fn mfa(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mfa(inp);
            self
        }
        pub fn set_mfa(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_mfa(inp);
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process
        /// this operation.</p>
        pub fn bypass_governance_retention(mut self, inp: bool) -> Self {
            self.inner = self.inner.bypass_governance_retention(inp);
            self
        }
        pub fn set_bypass_governance_retention(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bypass_governance_retention(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteObjects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_objects_input::Builder,
    }
    impl<C> DeleteObjects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteObjectsOutput,
            smithy_http::result::SdkError<crate::error::DeleteObjectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the objects to delete. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device. Required to permanently delete a versioned
        /// object if versioning is configured with MFA delete enabled.</p>
        pub fn mfa(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mfa(inp);
            self
        }
        pub fn set_mfa(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_mfa(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>Specifies whether you want to delete this object even if it has a Governance-type Object
        /// Lock in place. You must have sufficient permissions to perform this operation.</p>
        pub fn bypass_governance_retention(mut self, inp: bool) -> Self {
            self.inner = self.inner.bypass_governance_retention(inp);
            self
        }
        pub fn set_bypass_governance_retention(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bypass_governance_retention(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for the request.</p>
        pub fn delete(mut self, inp: crate::model::Delete) -> Self {
            self.inner = self.inner.delete(inp);
            self
        }
        pub fn set_delete(mut self, inp: std::option::Option<crate::model::Delete>) -> Self {
            self.inner = self.inner.set_delete(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteObjectTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_object_tagging_input::Builder,
    }
    impl<C> DeleteObjectTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteObjectTaggingOutput,
            smithy_http::result::SdkError<crate::error::DeleteObjectTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the objects from which to remove the tags. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The key that identifies the object in the bucket from which to remove all tags.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The versionId of the object that the tag-set will be removed from.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePublicAccessBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_public_access_block_input::Builder,
    }
    impl<C> DeletePublicAccessBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeletePublicAccessBlockOutput,
            smithy_http::result::SdkError<crate::error::DeletePublicAccessBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete.
        /// </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketAccelerateConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_accelerate_configuration_input::Builder,
    }
    impl<C> GetBucketAccelerateConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketAccelerateConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketAccelerateConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which the accelerate configuration is retrieved.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketAcl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_acl_input::Builder,
    }
    impl<C> GetBucketAcl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketAclOutput,
            smithy_http::result::SdkError<crate::error::GetBucketAclError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the S3 bucket whose ACL is being requested.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketAnalyticsConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_analytics_configuration_input::Builder,
    }
    impl<C> GetBucketAnalyticsConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketAnalyticsConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketAnalyticsConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket from which an analytics configuration is retrieved.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketCors<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_cors_input::Builder,
    }
    impl<C> GetBucketCors<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketCorsOutput,
            smithy_http::result::SdkError<crate::error::GetBucketCorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name for which to get the cors configuration.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_encryption_input::Builder,
    }
    impl<C> GetBucketEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketEncryptionOutput,
            smithy_http::result::SdkError<crate::error::GetBucketEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket from which the server-side encryption configuration is
        /// retrieved.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketIntelligentTieringConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_intelligent_tiering_configuration_input::Builder,
    }
    impl<C> GetBucketIntelligentTieringConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketIntelligentTieringConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::GetBucketIntelligentTieringConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketInventoryConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_inventory_configuration_input::Builder,
    }
    impl<C> GetBucketInventoryConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketInventoryConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketInventoryConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the inventory configuration to retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_lifecycle_configuration_input::Builder,
    }
    impl<C> GetBucketLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to get the lifecycle information.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketLocation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_location_input::Builder,
    }
    impl<C> GetBucketLocation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketLocationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketLocationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to get the location.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketLogging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_logging_input::Builder,
    }
    impl<C> GetBucketLogging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketLoggingOutput,
            smithy_http::result::SdkError<crate::error::GetBucketLoggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name for which to get the logging information.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketMetricsConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_metrics_configuration_input::Builder,
    }
    impl<C> GetBucketMetricsConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketMetricsConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketMetricsConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the metrics configuration to retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketNotificationConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_notification_configuration_input::Builder,
    }
    impl<C> GetBucketNotificationConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketNotificationConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketNotificationConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to get the notification configuration.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketOwnershipControls<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_ownership_controls_input::Builder,
    }
    impl<C> GetBucketOwnershipControls<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketOwnershipControlsOutput,
            smithy_http::result::SdkError<crate::error::GetBucketOwnershipControlsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to retrieve.
        /// </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_policy_input::Builder,
    }
    impl<C> GetBucketPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetBucketPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name for which to get the bucket policy.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketPolicyStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_policy_status_input::Builder,
    }
    impl<C> GetBucketPolicyStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketPolicyStatusOutput,
            smithy_http::result::SdkError<crate::error::GetBucketPolicyStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose policy status you want to retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketReplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_replication_input::Builder,
    }
    impl<C> GetBucketReplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketReplicationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketReplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name for which to get the replication information.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketRequestPayment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_request_payment_input::Builder,
    }
    impl<C> GetBucketRequestPayment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketRequestPaymentOutput,
            smithy_http::result::SdkError<crate::error::GetBucketRequestPaymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to get the payment request configuration</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_tagging_input::Builder,
    }
    impl<C> GetBucketTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketTaggingOutput,
            smithy_http::result::SdkError<crate::error::GetBucketTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to get the tagging information.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketVersioning<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_versioning_input::Builder,
    }
    impl<C> GetBucketVersioning<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketVersioningOutput,
            smithy_http::result::SdkError<crate::error::GetBucketVersioningError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to get the versioning information.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketWebsite<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_website_input::Builder,
    }
    impl<C> GetBucketWebsite<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBucketWebsiteOutput,
            smithy_http::result::SdkError<crate::error::GetBucketWebsiteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name for which to get the website configuration.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_input::Builder,
    }
    impl<C> GetObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectOutput,
            smithy_http::result::SdkError<crate::error::GetObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
        /// otherwise return a 412 (precondition failed).</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(inp);
            self
        }
        /// <p>Return the object only if it has been modified since the specified time, otherwise
        /// return a 304 (not modified).</p>
        pub fn if_modified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.if_modified_since(inp);
            self
        }
        pub fn set_if_modified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_if_modified_since(inp);
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
        /// otherwise return a 304 (not modified).</p>
        pub fn if_none_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_none_match(inp);
            self
        }
        pub fn set_if_none_match(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_none_match(inp);
            self
        }
        /// <p>Return the object only if it has not been modified since the specified time, otherwise
        /// return a 412 (precondition failed).</p>
        pub fn if_unmodified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.if_unmodified_since(inp);
            self
        }
        pub fn set_if_unmodified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_if_unmodified_since(inp);
            self
        }
        /// <p>Key of the object to get.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
        /// Range header, see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
        /// <note>
        /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
        /// request.</p>
        /// </note>
        pub fn range(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.range(inp);
            self
        }
        pub fn set_range(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_range(inp);
            self
        }
        /// <p>Sets the <code>Cache-Control</code> header of the response.</p>
        pub fn response_cache_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_cache_control(inp);
            self
        }
        pub fn set_response_cache_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_cache_control(inp);
            self
        }
        /// <p>Sets the <code>Content-Disposition</code> header of the response</p>
        pub fn response_content_disposition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_content_disposition(inp);
            self
        }
        pub fn set_response_content_disposition(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_content_disposition(inp);
            self
        }
        /// <p>Sets the <code>Content-Encoding</code> header of the response.</p>
        pub fn response_content_encoding(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_content_encoding(inp);
            self
        }
        pub fn set_response_content_encoding(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_content_encoding(inp);
            self
        }
        /// <p>Sets the <code>Content-Language</code> header of the response.</p>
        pub fn response_content_language(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_content_language(inp);
            self
        }
        pub fn set_response_content_language(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_content_language(inp);
            self
        }
        /// <p>Sets the <code>Content-Type</code> header of the response.</p>
        pub fn response_content_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_content_type(inp);
            self
        }
        pub fn set_response_content_type(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_content_type(inp);
            self
        }
        /// <p>Sets the <code>Expires</code> header of the response.</p>
        pub fn response_expires(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.response_expires(inp);
            self
        }
        pub fn set_response_expires(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_response_expires(inp);
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when decrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 used to encrypt the data. This
        /// value is used to decrypt the object when recovering it and must match the one used when
        /// storing the data. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
        /// Effectively performs a 'ranged' GET request for the part specified. Useful for downloading
        /// just a part of an object.</p>
        pub fn part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.part_number(inp);
            self
        }
        pub fn set_part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_part_number(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObjectAcl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_acl_input::Builder,
    }
    impl<C> GetObjectAcl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectAclOutput,
            smithy_http::result::SdkError<crate::error::GetObjectAclError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name that contains the object for which to get the ACL information. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The key of the object for which to get the ACL information.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObjectLegalHold<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_legal_hold_input::Builder,
    }
    impl<C> GetObjectLegalHold<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectLegalHoldOutput,
            smithy_http::result::SdkError<crate::error::GetObjectLegalHoldError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object whose Legal Hold status you want to retrieve. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The key name for the object whose Legal Hold status you want to retrieve.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The version ID of the object whose Legal Hold status you want to retrieve.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObjectLockConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_lock_configuration_input::Builder,
    }
    impl<C> GetObjectLockConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectLockConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetObjectLockConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket whose Object Lock configuration you want to retrieve.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObjectRetention<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_retention_input::Builder,
    }
    impl<C> GetObjectRetention<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectRetentionOutput,
            smithy_http::result::SdkError<crate::error::GetObjectRetentionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object whose retention settings you want to retrieve. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The key name for the object whose retention settings you want to retrieve.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The version ID for the object whose retention settings you want to retrieve.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObjectTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_tagging_input::Builder,
    }
    impl<C> GetObjectTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectTaggingOutput,
            smithy_http::result::SdkError<crate::error::GetObjectTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object for which to get the tagging information. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Object key for which to get the tagging information.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The versionId of the object for which to get the tagging information.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObjectTorrent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_torrent_input::Builder,
    }
    impl<C> GetObjectTorrent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetObjectTorrentOutput,
            smithy_http::result::SdkError<crate::error::GetObjectTorrentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the object for which to get the torrent files.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The object key for which to get the information.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPublicAccessBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_public_access_block_input::Builder,
    }
    impl<C> GetPublicAccessBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetPublicAccessBlockOutput,
            smithy_http::result::SdkError<crate::error::GetPublicAccessBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
        /// to retrieve. </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct HeadBucket<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::head_bucket_input::Builder,
    }
    impl<C> HeadBucket<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::HeadBucketOutput,
            smithy_http::result::SdkError<crate::error::HeadBucketError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct HeadObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::head_object_input::Builder,
    }
    impl<C> HeadObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::HeadObjectOutput,
            smithy_http::result::SdkError<crate::error::HeadObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the object.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is the same as the one specified,
        /// otherwise return a 412 (precondition failed).</p>
        pub fn if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_match(inp);
            self
        }
        pub fn set_if_match(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_match(inp);
            self
        }
        /// <p>Return the object only if it has been modified since the specified time, otherwise
        /// return a 304 (not modified).</p>
        pub fn if_modified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.if_modified_since(inp);
            self
        }
        pub fn set_if_modified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_if_modified_since(inp);
            self
        }
        /// <p>Return the object only if its entity tag (ETag) is different from the one specified,
        /// otherwise return a 304 (not modified).</p>
        pub fn if_none_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.if_none_match(inp);
            self
        }
        pub fn set_if_none_match(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_if_none_match(inp);
            self
        }
        /// <p>Return the object only if it has not been modified since the specified time, otherwise
        /// return a 412 (precondition failed).</p>
        pub fn if_unmodified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.if_unmodified_since(inp);
            self
        }
        pub fn set_if_unmodified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_if_unmodified_since(inp);
            self
        }
        /// <p>The object key.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Downloads the specified range bytes of an object. For more information about the HTTP
        /// Range header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>.</p>
        /// <note>
        /// <p>Amazon S3 doesn't support retrieving multiple ranges of data per <code>GET</code>
        /// request.</p>
        /// </note>
        pub fn range(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.range(inp);
            self
        }
        pub fn set_range(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_range(inp);
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>Part number of the object being read. This is a positive integer between 1 and 10,000.
        /// Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about
        /// the size of the part and the number of parts in this object.</p>
        pub fn part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.part_number(inp);
            self
        }
        pub fn set_part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_part_number(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBucketAnalyticsConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_bucket_analytics_configurations_input::Builder,
    }
    impl<C> ListBucketAnalyticsConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListBucketAnalyticsConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListBucketAnalyticsConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket from which analytics configurations are retrieved.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ContinuationToken that represents a placeholder from where this request should
        /// begin.</p>
        pub fn continuation_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(inp);
            self
        }
        pub fn set_continuation_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBucketIntelligentTieringConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_bucket_intelligent_tiering_configurations_input::Builder,
    }
    impl<C> ListBucketIntelligentTieringConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListBucketIntelligentTieringConfigurationsOutput,
            smithy_http::result::SdkError<
                crate::error::ListBucketIntelligentTieringConfigurationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ContinuationToken that represents a placeholder from where this request should
        /// begin.</p>
        pub fn continuation_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(inp);
            self
        }
        pub fn set_continuation_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBucketInventoryConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_bucket_inventory_configurations_input::Builder,
    }
    impl<C> ListBucketInventoryConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListBucketInventoryConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListBucketInventoryConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the inventory configurations to retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The marker used to continue an inventory configuration listing that has been truncated.
        /// Use the NextContinuationToken from a previously truncated list response to continue the
        /// listing. The continuation token is an opaque value that Amazon S3 understands.</p>
        pub fn continuation_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(inp);
            self
        }
        pub fn set_continuation_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBucketMetricsConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_bucket_metrics_configurations_input::Builder,
    }
    impl<C> ListBucketMetricsConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListBucketMetricsConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListBucketMetricsConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the metrics configurations to retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The marker that is used to continue a metrics configuration listing that has been
        /// truncated. Use the NextContinuationToken from a previously truncated list response to
        /// continue the listing. The continuation token is an opaque value that Amazon S3
        /// understands.</p>
        pub fn continuation_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(inp);
            self
        }
        pub fn set_continuation_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBuckets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_buckets_input::Builder,
    }
    impl<C> ListBuckets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListBucketsOutput,
            smithy_http::result::SdkError<crate::error::ListBucketsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMultipartUploads<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_multipart_uploads_input::Builder,
    }
    impl<C> ListMultipartUploads<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListMultipartUploadsOutput,
            smithy_http::result::SdkError<crate::error::ListMultipartUploadsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket to which the multipart upload was initiated. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Character you use to group keys.</p>
        /// <p>All keys that contain the same string between the prefix, if specified, and the first
        /// occurrence of the delimiter after the prefix are grouped under a single result element,
        /// <code>CommonPrefixes</code>. If you don't specify the prefix parameter, then the
        /// substring starts at the beginning of the key. The keys that are grouped under
        /// <code>CommonPrefixes</code> result element are not returned elsewhere in the
        /// response.</p>
        pub fn delimiter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delimiter(inp);
            self
        }
        pub fn set_delimiter(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_delimiter(inp);
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, inp: crate::model::EncodingType) -> Self {
            self.inner = self.inner.encoding_type(inp);
            self
        }
        pub fn set_encoding_type(
            mut self,
            inp: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.inner = self.inner.set_encoding_type(inp);
            self
        }
        /// <p>Together with upload-id-marker, this parameter specifies the multipart upload after
        /// which listing should begin.</p>
        /// <p>If <code>upload-id-marker</code> is not specified, only the keys lexicographically
        /// greater than the specified <code>key-marker</code> will be included in the list.</p>
        /// <p>If <code>upload-id-marker</code> is specified, any multipart uploads for a key equal to
        /// the <code>key-marker</code> might also be included, provided those multipart uploads have
        /// upload IDs lexicographically greater than the specified
        /// <code>upload-id-marker</code>.</p>
        pub fn key_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_marker(inp);
            self
        }
        pub fn set_key_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_marker(inp);
            self
        }
        /// <p>Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response
        /// body. 1,000 is the maximum number of uploads that can be returned in a response.</p>
        pub fn max_uploads(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_uploads(inp);
            self
        }
        pub fn set_max_uploads(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_uploads(inp);
            self
        }
        /// <p>Lists in-progress uploads only for those keys that begin with the specified prefix. You
        /// can use prefixes to separate a bucket into different grouping of keys. (You can think of
        /// using prefix to make groups in the same way you'd use a folder in a file system.)</p>
        pub fn prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix(inp);
            self
        }
        pub fn set_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_prefix(inp);
            self
        }
        /// <p>Together with key-marker, specifies the multipart upload after which listing should
        /// begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
        /// Otherwise, any multipart uploads for a key equal to the key-marker might be included in the
        /// list only if they have an upload ID lexicographically greater than the specified
        /// <code>upload-id-marker</code>.</p>
        pub fn upload_id_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.upload_id_marker(inp);
            self
        }
        pub fn set_upload_id_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_upload_id_marker(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListObjects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_objects_input::Builder,
    }
    impl<C> ListObjects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListObjectsOutput,
            smithy_http::result::SdkError<crate::error::ListObjectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket containing the objects.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>A delimiter is a character you use to group keys.</p>
        pub fn delimiter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delimiter(inp);
            self
        }
        pub fn set_delimiter(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_delimiter(inp);
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, inp: crate::model::EncodingType) -> Self {
            self.inner = self.inner.encoding_type(inp);
            self
        }
        pub fn set_encoding_type(
            mut self,
            inp: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.inner = self.inner.set_encoding_type(inp);
            self
        }
        /// <p>Specifies the key to start with when listing objects in a bucket.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain more.
        /// </p>
        pub fn max_keys(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_keys(inp);
            self
        }
        pub fn set_max_keys(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_keys(inp);
            self
        }
        /// <p>Limits the response to keys that begin with the specified prefix.</p>
        pub fn prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix(inp);
            self
        }
        pub fn set_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_prefix(inp);
            self
        }
        /// <p>Confirms that the requester knows that she or he will be charged for the list objects
        /// request. Bucket owners need not specify this parameter in their requests.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListObjectsV2<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_objects_v2_input::Builder,
    }
    impl<C> ListObjectsV2<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListObjectsV2Output,
            smithy_http::result::SdkError<crate::error::ListObjectsV2Error>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Bucket name to list. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>A delimiter is a character you use to group keys.</p>
        pub fn delimiter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delimiter(inp);
            self
        }
        pub fn set_delimiter(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_delimiter(inp);
            self
        }
        /// <p>Encoding type used by Amazon S3 to encode object keys in the response.</p>
        pub fn encoding_type(mut self, inp: crate::model::EncodingType) -> Self {
            self.inner = self.inner.encoding_type(inp);
            self
        }
        pub fn set_encoding_type(
            mut self,
            inp: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.inner = self.inner.set_encoding_type(inp);
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain
        /// more.</p>
        pub fn max_keys(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_keys(inp);
            self
        }
        pub fn set_max_keys(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_keys(inp);
            self
        }
        /// <p>Limits the response to keys that begin with the specified prefix.</p>
        pub fn prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix(inp);
            self
        }
        pub fn set_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_prefix(inp);
            self
        }
        /// <p>ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a
        /// token. ContinuationToken is obfuscated and is not a real key.</p>
        pub fn continuation_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(inp);
            self
        }
        pub fn set_continuation_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(inp);
            self
        }
        /// <p>The owner field is not present in listV2 by default, if you want to return owner field
        /// with each key in the result then set the fetch owner field to true.</p>
        pub fn fetch_owner(mut self, inp: bool) -> Self {
            self.inner = self.inner.fetch_owner(inp);
            self
        }
        pub fn set_fetch_owner(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_fetch_owner(inp);
            self
        }
        /// <p>StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this
        /// specified key. StartAfter can be any key in the bucket.</p>
        pub fn start_after(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_after(inp);
            self
        }
        pub fn set_start_after(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_start_after(inp);
            self
        }
        /// <p>Confirms that the requester knows that she or he will be charged for the list objects
        /// request in V2 style. Bucket owners need not specify this parameter in their
        /// requests.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListObjectVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_object_versions_input::Builder,
    }
    impl<C> ListObjectVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListObjectVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListObjectVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name that contains the objects. </p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>A delimiter is a character that you specify to group keys. All keys that contain the
        /// same string between the <code>prefix</code> and the first occurrence of the delimiter are
        /// grouped under a single result element in CommonPrefixes. These groups are counted as one
        /// result against the max-keys limitation. These keys are not returned elsewhere in the
        /// response.</p>
        pub fn delimiter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delimiter(inp);
            self
        }
        pub fn set_delimiter(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_delimiter(inp);
            self
        }
        /// <p>Requests Amazon S3 to encode the object keys in the response and specifies the encoding
        /// method to use. An object key may contain any Unicode character; however, XML 1.0 parser
        /// cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
        /// characters that are not supported in XML 1.0, you can add this parameter to request that
        /// Amazon S3 encode the keys in the response.</p>
        pub fn encoding_type(mut self, inp: crate::model::EncodingType) -> Self {
            self.inner = self.inner.encoding_type(inp);
            self
        }
        pub fn set_encoding_type(
            mut self,
            inp: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.inner = self.inner.set_encoding_type(inp);
            self
        }
        /// <p>Specifies the key to start with when listing objects in a bucket.</p>
        pub fn key_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_marker(inp);
            self
        }
        pub fn set_key_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_marker(inp);
            self
        }
        /// <p>Sets the maximum number of keys returned in the response. By default the action returns up
        /// to 1,000 key names. The response might contain fewer keys but will never contain more. If
        /// additional keys satisfy the search criteria, but were not returned because max-keys was
        /// exceeded, the response contains <isTruncated>true</isTruncated>. To return the
        /// additional keys, see key-marker and version-id-marker.</p>
        pub fn max_keys(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_keys(inp);
            self
        }
        pub fn set_max_keys(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_keys(inp);
            self
        }
        /// <p>Use this parameter to select only those keys that begin with the specified prefix. You
        /// can use prefixes to separate a bucket into different groupings of keys. (You can think of
        /// using prefix to make groups in the same way you'd use a folder in a file system.) You can
        /// use prefix with delimiter to roll up numerous objects into a single result under
        /// CommonPrefixes. </p>
        pub fn prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix(inp);
            self
        }
        pub fn set_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_prefix(inp);
            self
        }
        /// <p>Specifies the object version you want to start listing from.</p>
        pub fn version_id_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id_marker(inp);
            self
        }
        pub fn set_version_id_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_version_id_marker(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListParts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_parts_input::Builder,
    }
    impl<C> ListParts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListPartsOutput,
            smithy_http::result::SdkError<crate::error::ListPartsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket to which the parts are being uploaded. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Sets the maximum number of parts to return.</p>
        pub fn max_parts(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_parts(inp);
            self
        }
        pub fn set_max_parts(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_parts(inp);
            self
        }
        /// <p>Specifies the part after which listing should begin. Only parts with higher part numbers
        /// will be listed.</p>
        pub fn part_number_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.part_number_marker(inp);
            self
        }
        pub fn set_part_number_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_part_number_marker(inp);
            self
        }
        /// <p>Upload ID identifying the multipart upload whose parts are being listed.</p>
        pub fn upload_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.upload_id(inp);
            self
        }
        pub fn set_upload_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_upload_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketAccelerateConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_accelerate_configuration_input::Builder,
    }
    impl<C> PutBucketAccelerateConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketAccelerateConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketAccelerateConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which the accelerate configuration is set.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for setting the transfer acceleration state.</p>
        pub fn accelerate_configuration(
            mut self,
            inp: crate::model::AccelerateConfiguration,
        ) -> Self {
            self.inner = self.inner.accelerate_configuration(inp);
            self
        }
        pub fn set_accelerate_configuration(
            mut self,
            inp: std::option::Option<crate::model::AccelerateConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_accelerate_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketAcl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_acl_input::Builder,
    }
    impl<C> PutBucketAcl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketAclOutput,
            smithy_http::result::SdkError<crate::error::PutBucketAclError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the bucket.</p>
        pub fn acl(mut self, inp: crate::model::BucketCannedAcl) -> Self {
            self.inner = self.inner.acl(inp);
            self
        }
        pub fn set_acl(mut self, inp: std::option::Option<crate::model::BucketCannedAcl>) -> Self {
            self.inner = self.inner.set_acl(inp);
            self
        }
        /// <p>The bucket to which to apply the ACL.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.</a>
        /// </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        pub fn grant_full_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(inp);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(inp);
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        pub fn grant_read(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(inp);
            self
        }
        pub fn set_grant_read(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(inp);
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        pub fn grant_read_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(inp);
            self
        }
        pub fn set_grant_read_acp(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read_acp(inp);
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write(inp);
            self
        }
        pub fn set_grant_write(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_write(inp);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        pub fn grant_write_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(inp);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
        pub fn access_control_policy(mut self, inp: crate::model::AccessControlPolicy) -> Self {
            self.inner = self.inner.access_control_policy(inp);
            self
        }
        pub fn set_access_control_policy(
            mut self,
            inp: std::option::Option<crate::model::AccessControlPolicy>,
        ) -> Self {
            self.inner = self.inner.set_access_control_policy(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketAnalyticsConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_analytics_configuration_input::Builder,
    }
    impl<C> PutBucketAnalyticsConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketAnalyticsConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketAnalyticsConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket to which an analytics configuration is stored.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID that identifies the analytics configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The configuration and any analyses for the analytics filter.</p>
        pub fn analytics_configuration(
            mut self,
            inp: crate::model::AnalyticsConfiguration,
        ) -> Self {
            self.inner = self.inner.analytics_configuration(inp);
            self
        }
        pub fn set_analytics_configuration(
            mut self,
            inp: std::option::Option<crate::model::AnalyticsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_analytics_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketCors<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_cors_input::Builder,
    }
    impl<C> PutBucketCors<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketCorsOutput,
            smithy_http::result::SdkError<crate::error::PutBucketCorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the bucket impacted by the <code>cors</code>configuration.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.</a>
        /// </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource
        /// Sharing</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn cors_configuration(mut self, inp: crate::model::CORSConfiguration) -> Self {
            self.inner = self.inner.cors_configuration(inp);
            self
        }
        pub fn set_cors_configuration(
            mut self,
            inp: std::option::Option<crate::model::CORSConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_cors_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_encryption_input::Builder,
    }
    impl<C> PutBucketEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketEncryptionOutput,
            smithy_http::result::SdkError<crate::error::PutBucketEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed
        /// keys (SSE-S3) or customer master keys stored in AWS KMS (SSE-KMS). For information about
        /// the Amazon S3 default encryption feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html">Amazon S3 Default Bucket Encryption</a>
        /// in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the server-side encryption configuration.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Specifies the default server-side-encryption configuration.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            inp: crate::model::ServerSideEncryptionConfiguration,
        ) -> Self {
            self.inner = self.inner.server_side_encryption_configuration(inp);
            self
        }
        pub fn set_server_side_encryption_configuration(
            mut self,
            inp: std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_server_side_encryption_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketIntelligentTieringConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_intelligent_tiering_configuration_input::Builder,
    }
    impl<C> PutBucketIntelligentTieringConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketIntelligentTieringConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::PutBucketIntelligentTieringConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose configuration you want to modify or retrieve.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the S3 Intelligent-Tiering configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>Container for S3 Intelligent-Tiering configuration.</p>
        pub fn intelligent_tiering_configuration(
            mut self,
            inp: crate::model::IntelligentTieringConfiguration,
        ) -> Self {
            self.inner = self.inner.intelligent_tiering_configuration(inp);
            self
        }
        pub fn set_intelligent_tiering_configuration(
            mut self,
            inp: std::option::Option<crate::model::IntelligentTieringConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_intelligent_tiering_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketInventoryConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_inventory_configuration_input::Builder,
    }
    impl<C> PutBucketInventoryConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketInventoryConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketInventoryConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket where the inventory configuration will be stored.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the inventory configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Specifies the inventory configuration.</p>
        pub fn inventory_configuration(
            mut self,
            inp: crate::model::InventoryConfiguration,
        ) -> Self {
            self.inner = self.inner.inventory_configuration(inp);
            self
        }
        pub fn set_inventory_configuration(
            mut self,
            inp: std::option::Option<crate::model::InventoryConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_inventory_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_lifecycle_configuration_input::Builder,
    }
    impl<C> PutBucketLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to set the configuration.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
        pub fn lifecycle_configuration(
            mut self,
            inp: crate::model::BucketLifecycleConfiguration,
        ) -> Self {
            self.inner = self.inner.lifecycle_configuration(inp);
            self
        }
        pub fn set_lifecycle_configuration(
            mut self,
            inp: std::option::Option<crate::model::BucketLifecycleConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketLogging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_logging_input::Builder,
    }
    impl<C> PutBucketLogging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketLoggingOutput,
            smithy_http::result::SdkError<crate::error::PutBucketLoggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which to set the logging parameters.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The MD5 hash of the <code>PutBucketLogging</code> request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for logging status information.</p>
        pub fn bucket_logging_status(mut self, inp: crate::model::BucketLoggingStatus) -> Self {
            self.inner = self.inner.bucket_logging_status(inp);
            self
        }
        pub fn set_bucket_logging_status(
            mut self,
            inp: std::option::Option<crate::model::BucketLoggingStatus>,
        ) -> Self {
            self.inner = self.inner.set_bucket_logging_status(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketMetricsConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_metrics_configuration_input::Builder,
    }
    impl<C> PutBucketMetricsConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketMetricsConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketMetricsConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket for which the metrics configuration is set.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The ID used to identify the metrics configuration.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Specifies the metrics configuration.</p>
        pub fn metrics_configuration(mut self, inp: crate::model::MetricsConfiguration) -> Self {
            self.inner = self.inner.metrics_configuration(inp);
            self
        }
        pub fn set_metrics_configuration(
            mut self,
            inp: std::option::Option<crate::model::MetricsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_metrics_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketNotificationConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_notification_configuration_input::Builder,
    }
    impl<C> PutBucketNotificationConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketNotificationConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketNotificationConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>A container for specifying the notification configuration of the bucket. If this element
        /// is empty, notifications are turned off for the bucket.</p>
        pub fn notification_configuration(
            mut self,
            inp: crate::model::NotificationConfiguration,
        ) -> Self {
            self.inner = self.inner.notification_configuration(inp);
            self
        }
        pub fn set_notification_configuration(
            mut self,
            inp: std::option::Option<crate::model::NotificationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_notification_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketOwnershipControls<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_ownership_controls_input::Builder,
    }
    impl<C> PutBucketOwnershipControls<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketOwnershipControlsOutput,
            smithy_http::result::SdkError<crate::error::PutBucketOwnershipControlsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose <code>OwnershipControls</code> you want to set.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The MD5 hash of the <code>OwnershipControls</code> request body. </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The <code>OwnershipControls</code> (BucketOwnerPreferred or ObjectWriter) that you want
        /// to apply to this Amazon S3 bucket.</p>
        pub fn ownership_controls(mut self, inp: crate::model::OwnershipControls) -> Self {
            self.inner = self.inner.ownership_controls(inp);
            self
        }
        pub fn set_ownership_controls(
            mut self,
            inp: std::option::Option<crate::model::OwnershipControls>,
        ) -> Self {
            self.inner = self.inner.set_ownership_controls(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_policy_input::Builder,
    }
    impl<C> PutBucketPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutBucketPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The MD5 hash of the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>Set this parameter to true to confirm that you want to remove your permissions to change
        /// this bucket policy in the future.</p>
        pub fn confirm_remove_self_bucket_access(mut self, inp: bool) -> Self {
            self.inner = self.inner.confirm_remove_self_bucket_access(inp);
            self
        }
        pub fn set_confirm_remove_self_bucket_access(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_confirm_remove_self_bucket_access(inp);
            self
        }
        /// <p>The bucket policy as a JSON document.</p>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        pub fn set_policy(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketReplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_replication_input::Builder,
    }
    impl<C> PutBucketReplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketReplicationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketReplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the bucket</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
        pub fn token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(inp);
            self
        }
        pub fn set_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>A container for replication rules. You can add up to 1,000 rules. The maximum size of a
        /// replication configuration is 2 MB.</p>
        pub fn replication_configuration(
            mut self,
            inp: crate::model::ReplicationConfiguration,
        ) -> Self {
            self.inner = self.inner.replication_configuration(inp);
            self
        }
        pub fn set_replication_configuration(
            mut self,
            inp: std::option::Option<crate::model::ReplicationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_replication_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketRequestPayment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_request_payment_input::Builder,
    }
    impl<C> PutBucketRequestPayment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketRequestPaymentOutput,
            smithy_http::result::SdkError<crate::error::PutBucketRequestPaymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
        /// message integrity check to verify that the request body was not corrupted in transit. For
        /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for Payer.</p>
        pub fn request_payment_configuration(
            mut self,
            inp: crate::model::RequestPaymentConfiguration,
        ) -> Self {
            self.inner = self.inner.request_payment_configuration(inp);
            self
        }
        pub fn set_request_payment_configuration(
            mut self,
            inp: std::option::Option<crate::model::RequestPaymentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_request_payment_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_tagging_input::Builder,
    }
    impl<C> PutBucketTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketTaggingOutput,
            smithy_http::result::SdkError<crate::error::PutBucketTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements.</p>
        pub fn tagging(mut self, inp: crate::model::Tagging) -> Self {
            self.inner = self.inner.tagging(inp);
            self
        }
        pub fn set_tagging(mut self, inp: std::option::Option<crate::model::Tagging>) -> Self {
            self.inner = self.inner.set_tagging(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketVersioning<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_versioning_input::Builder,
    }
    impl<C> PutBucketVersioning<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketVersioningOutput,
            smithy_http::result::SdkError<crate::error::PutBucketVersioningError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a
        /// message integrity check to verify that the request body was not corrupted in transit. For
        /// more information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The concatenation of the authentication device's serial number, a space, and the value
        /// that is displayed on your authentication device.</p>
        pub fn mfa(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mfa(inp);
            self
        }
        pub fn set_mfa(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_mfa(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for setting the versioning state.</p>
        pub fn versioning_configuration(
            mut self,
            inp: crate::model::VersioningConfiguration,
        ) -> Self {
            self.inner = self.inner.versioning_configuration(inp);
            self
        }
        pub fn set_versioning_configuration(
            mut self,
            inp: std::option::Option<crate::model::VersioningConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_versioning_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketWebsite<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_website_input::Builder,
    }
    impl<C> PutBucketWebsite<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutBucketWebsiteOutput,
            smithy_http::result::SdkError<crate::error::PutBucketWebsiteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, see <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC 1864</a>.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for the request.</p>
        pub fn website_configuration(mut self, inp: crate::model::WebsiteConfiguration) -> Self {
            self.inner = self.inner.website_configuration(inp);
            self
        }
        pub fn set_website_configuration(
            mut self,
            inp: std::option::Option<crate::model::WebsiteConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_website_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_input::Builder,
    }
    impl<C> PutObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutObjectOutput,
            smithy_http::result::SdkError<crate::error::PutObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned
        /// ACL</a>.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn acl(mut self, inp: crate::model::ObjectCannedAcl) -> Self {
            self.inner = self.inner.acl(inp);
            self
        }
        pub fn set_acl(mut self, inp: std::option::Option<crate::model::ObjectCannedAcl>) -> Self {
            self.inner = self.inner.set_acl(inp);
            self
        }
        /// <p>Object data.</p>
        pub fn body(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.body(inp);
            self
        }
        pub fn set_body(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.set_body(inp);
            self
        }
        /// <p>The bucket name to which the PUT action was initiated. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p> Can be used to specify caching behavior along the request/reply chain. For more
        /// information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
        pub fn cache_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_control(inp);
            self
        }
        pub fn set_cache_control(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cache_control(inp);
            self
        }
        /// <p>Specifies presentational information for the object. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>.</p>
        pub fn content_disposition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_disposition(inp);
            self
        }
        pub fn set_content_disposition(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_disposition(inp);
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>.</p>
        pub fn content_encoding(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_encoding(inp);
            self
        }
        pub fn set_content_encoding(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_encoding(inp);
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_language(inp);
            self
        }
        pub fn set_content_language(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_language(inp);
            self
        }
        /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
        /// determined automatically. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>.</p>
        pub fn content_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.content_length(inp);
            self
        }
        pub fn set_content_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_content_length(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the message (without the headers) according to
        /// RFC 1864. This header can be used as a message integrity check to verify that the data is
        /// the same data that was originally sent. Although it is optional, we recommend using the
        /// Content-MD5 mechanism as an end-to-end integrity check. For more information about REST
        /// request authentication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">REST
        /// Authentication</a>.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>A standard MIME type describing the format of the contents. For more information, see
        /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>.</p>
        pub fn content_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(inp);
            self
        }
        pub fn set_content_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(inp);
            self
        }
        /// <p>The date and time at which the object is no longer cacheable. For more information, see
        /// <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21</a>.</p>
        pub fn expires(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.expires(inp);
            self
        }
        pub fn set_expires(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_expires(inp);
            self
        }
        /// <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(inp);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(inp);
            self
        }
        /// <p>Allows grantee to read the object data and its
        /// metadata.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(inp);
            self
        }
        pub fn set_grant_read(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(inp);
            self
        }
        /// <p>Allows grantee to read the object ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(inp);
            self
        }
        pub fn set_grant_read_acp(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read_acp(inp);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// object.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(inp);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(inp);
            self
        }
        /// <p>Object key for which the PUT action was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>A map of metadata to store with the object in S3.</p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(inp);
            self
        }
        /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
        /// AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, inp: crate::model::ServerSideEncryption) -> Self {
            self.inner = self.inner.server_side_encryption(inp);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            inp: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.inner = self.inner.set_server_side_encryption(inp);
            self
        }
        /// <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
        /// STANDARD storage class provides high durability and high availability. Depending on
        /// performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
        /// the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn storage_class(mut self, inp: crate::model::StorageClass) -> Self {
            self.inner = self.inner.storage_class(inp);
            self
        }
        pub fn set_storage_class(
            mut self,
            inp: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.inner = self.inner.set_storage_class(inp);
            self
        }
        /// <p>If the bucket is configured as a website, redirects requests for this object to another
        /// object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
        /// the object metadata. For information about object metadata, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a>.</p>
        /// <p>In the following example, the request header sets the redirect to an object
        /// (anotherPage.html) in the same bucket:</p>
        /// <p>
        /// <code>x-amz-website-redirect-location: /anotherPage.html</code>
        /// </p>
        /// <p>In the following example, the request header sets the object redirect to another
        /// website:</p>
        /// <p>
        /// <code>x-amz-website-redirect-location: http://www.example.com/</code>
        /// </p>
        /// <p>For more information about website hosting in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">Hosting Websites on Amazon S3</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html">How to Configure Website Page
        /// Redirects</a>. </p>
        pub fn website_redirect_location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.website_redirect_location(inp);
            self
        }
        pub fn set_website_redirect_location(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_website_redirect_location(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>If <code>x-amz-server-side-encryption</code> is present and has the value of
        /// <code>aws:kms</code>, this header specifies the ID of the AWS Key Management Service
        /// (AWS KMS) symmetrical customer managed customer master key (CMK) that was used for the
        /// object. If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but do not
        /// provide<code> x-amz-server-side-encryption-aws-kms-key-id</code>, Amazon S3 uses the AWS
        /// managed CMK in AWS to protect the data. If the KMS key does not exist in the same account
        /// issuing the command, you must use the full ARN and not just the ID.
        /// </p>
        pub fn ssekms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_key_id(inp);
            self
        }
        pub fn set_ssekms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssekms_key_id(inp);
            self
        }
        /// <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
        /// header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
        /// pairs.</p>
        pub fn ssekms_encryption_context(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_encryption_context(inp);
            self
        }
        pub fn set_ssekms_encryption_context(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssekms_encryption_context(inp);
            self
        }
        /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
        /// <p>Specifying this header with a PUT action doesn’t affect bucket-level settings for S3 Bucket Key.</p>
        pub fn bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.bucket_key_enabled(inp);
            self
        }
        pub fn set_bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bucket_key_enabled(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For
        /// example, "Key1=Value1")</p>
        pub fn tagging(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tagging(inp);
            self
        }
        pub fn set_tagging(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tagging(inp);
            self
        }
        /// <p>The Object Lock mode that you want to apply to this object.</p>
        pub fn object_lock_mode(mut self, inp: crate::model::ObjectLockMode) -> Self {
            self.inner = self.inner.object_lock_mode(inp);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_mode(inp);
            self
        }
        /// <p>The date and time when you want this object's Object Lock to expire. Must be formatted
        /// as a timestamp parameter.</p>
        pub fn object_lock_retain_until_date(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.object_lock_retain_until_date(inp);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_retain_until_date(inp);
            self
        }
        /// <p>Specifies whether a legal hold will be applied to this object. For more information
        /// about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html">Object
        /// Lock</a>.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            inp: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.inner = self.inner.object_lock_legal_hold_status(inp);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_legal_hold_status(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObjectAcl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_acl_input::Builder,
    }
    impl<C> PutObjectAcl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutObjectAclOutput,
            smithy_http::result::SdkError<crate::error::PutObjectAclError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p>
        pub fn acl(mut self, inp: crate::model::ObjectCannedAcl) -> Self {
            self.inner = self.inner.acl(inp);
            self
        }
        pub fn set_acl(mut self, inp: std::option::Option<crate::model::ObjectCannedAcl>) -> Self {
            self.inner = self.inner.set_acl(inp);
            self
        }
        /// <p>The bucket name that contains the object to which you want to attach the ACL. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the data. This header must be used as a message
        /// integrity check to verify that the request body was not corrupted in transit. For more
        /// information, go to <a href="http://www.ietf.org/rfc/rfc1864.txt">RFC
        /// 1864.></a>
        /// </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_full_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(inp);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(inp);
            self
        }
        /// <p>Allows grantee to list the objects in the
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(inp);
            self
        }
        pub fn set_grant_read(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(inp);
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_read_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(inp);
            self
        }
        pub fn set_grant_read_acp(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read_acp(inp);
            self
        }
        /// <p>Allows grantee to create new objects in the bucket.</p>
        /// <p>For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.</p>
        pub fn grant_write(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write(inp);
            self
        }
        pub fn set_grant_write(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_write(inp);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable
        /// bucket.</p>
        /// <p>This action is not supported by Amazon S3 on Outposts.</p>
        pub fn grant_write_acp(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(inp);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(inp);
            self
        }
        /// <p>Key for which the PUT action was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Contains the elements that set the ACL permissions for an object per grantee.</p>
        pub fn access_control_policy(mut self, inp: crate::model::AccessControlPolicy) -> Self {
            self.inner = self.inner.access_control_policy(inp);
            self
        }
        pub fn set_access_control_policy(
            mut self,
            inp: std::option::Option<crate::model::AccessControlPolicy>,
        ) -> Self {
            self.inner = self.inner.set_access_control_policy(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObjectLegalHold<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_legal_hold_input::Builder,
    }
    impl<C> PutObjectLegalHold<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutObjectLegalHoldOutput,
            smithy_http::result::SdkError<crate::error::PutObjectLegalHoldError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object that you want to place a Legal Hold on. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The key name for the object that you want to place a Legal Hold on.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The version ID of the object that you want to place a Legal Hold on.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container element for the Legal Hold configuration you want to apply to the specified
        /// object.</p>
        pub fn legal_hold(mut self, inp: crate::model::ObjectLockLegalHold) -> Self {
            self.inner = self.inner.legal_hold(inp);
            self
        }
        pub fn set_legal_hold(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockLegalHold>,
        ) -> Self {
            self.inner = self.inner.set_legal_hold(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObjectLockConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_lock_configuration_input::Builder,
    }
    impl<C> PutObjectLockConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutObjectLockConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutObjectLockConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket whose Object Lock configuration you want to create or replace.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>A token to allow Object Lock to be enabled for an existing bucket.</p>
        pub fn token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(inp);
            self
        }
        pub fn set_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(inp);
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The Object Lock configuration that you want to apply to the specified bucket.</p>
        pub fn object_lock_configuration(
            mut self,
            inp: crate::model::ObjectLockConfiguration,
        ) -> Self {
            self.inner = self.inner.object_lock_configuration(inp);
            self
        }
        pub fn set_object_lock_configuration(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObjectRetention<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_retention_input::Builder,
    }
    impl<C> PutObjectRetention<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutObjectRetentionOutput,
            smithy_http::result::SdkError<crate::error::PutObjectRetentionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name that contains the object you want to apply this Object Retention
        /// configuration to. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The key name for the object that you want to apply this Object Retention configuration
        /// to.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The version ID for the object that you want to apply this Object Retention configuration
        /// to.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Indicates whether this action should bypass Governance-mode restrictions.</p>
        pub fn bypass_governance_retention(mut self, inp: bool) -> Self {
            self.inner = self.inner.bypass_governance_retention(inp);
            self
        }
        pub fn set_bypass_governance_retention(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bypass_governance_retention(inp);
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The container element for the Object Retention configuration.</p>
        pub fn retention(mut self, inp: crate::model::ObjectLockRetention) -> Self {
            self.inner = self.inner.retention(inp);
            self
        }
        pub fn set_retention(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockRetention>,
        ) -> Self {
            self.inner = self.inner.set_retention(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObjectTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_tagging_input::Builder,
    }
    impl<C> PutObjectTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutObjectTaggingOutput,
            smithy_http::result::SdkError<crate::error::PutObjectTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Name of the object key.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>The versionId of the object that the tag-set will be added to.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>The MD5 hash for the request body.</p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>Container for the <code>TagSet</code> and <code>Tag</code> elements</p>
        pub fn tagging(mut self, inp: crate::model::Tagging) -> Self {
            self.inner = self.inner.tagging(inp);
            self
        }
        pub fn set_tagging(mut self, inp: std::option::Option<crate::model::Tagging>) -> Self {
            self.inner = self.inner.set_tagging(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutPublicAccessBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_public_access_block_input::Builder,
    }
    impl<C> PutPublicAccessBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutPublicAccessBlockOutput,
            smithy_http::result::SdkError<crate::error::PutPublicAccessBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket whose <code>PublicAccessBlock</code> configuration you want
        /// to set.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>The MD5 hash of the <code>PutPublicAccessBlock</code> request body. </p>
        /// <p>For requests made using the AWS Command Line Interface (CLI) or AWS SDKs, this field is calculated automatically.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3
        /// bucket. You can enable the configuration options in any combination. For more information
        /// about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn public_access_block_configuration(
            mut self,
            inp: crate::model::PublicAccessBlockConfiguration,
        ) -> Self {
            self.inner = self.inner.public_access_block_configuration(inp);
            self
        }
        pub fn set_public_access_block_configuration(
            mut self,
            inp: std::option::Option<crate::model::PublicAccessBlockConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_public_access_block_configuration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RestoreObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::restore_object_input::Builder,
    }
    impl<C> RestoreObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RestoreObjectOutput,
            smithy_http::result::SdkError<crate::error::RestoreObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name containing the object to restore. </p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Object key for which the action was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>VersionId used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>Container for restore job parameters.</p>
        pub fn restore_request(mut self, inp: crate::model::RestoreRequest) -> Self {
            self.inner = self.inner.restore_request(inp);
            self
        }
        pub fn set_restore_request(
            mut self,
            inp: std::option::Option<crate::model::RestoreRequest>,
        ) -> Self {
            self.inner = self.inner.set_restore_request(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UploadPart<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::upload_part_input::Builder,
    }
    impl<C> UploadPart<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UploadPartOutput,
            smithy_http::result::SdkError<crate::error::UploadPartError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Object data.</p>
        pub fn body(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.body(inp);
            self
        }
        pub fn set_body(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.set_body(inp);
            self
        }
        /// <p>The name of the bucket to which the multipart upload was initiated.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Size of the body in bytes. This parameter is useful when the size of the body cannot be
        /// determined automatically.</p>
        pub fn content_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.content_length(inp);
            self
        }
        pub fn set_content_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_content_length(inp);
            self
        }
        /// <p>The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated
        /// when using the command from the CLI. This parameter is required if object lock parameters
        /// are specified.</p>
        pub fn content_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_md5(inp);
            self
        }
        pub fn set_content_md5(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_md5(inp);
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Part number of part being uploaded. This is a positive integer between 1 and
        /// 10,000.</p>
        pub fn part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.part_number(inp);
            self
        }
        pub fn set_part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_part_number(inp);
            self
        }
        /// <p>Upload ID identifying the multipart upload whose part is being uploaded.</p>
        pub fn upload_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.upload_id(inp);
            self
        }
        pub fn set_upload_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_upload_id(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm header</code>. This must be the
        /// same encryption key specified in the initiate multipart upload request.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UploadPartCopy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::upload_part_copy_input::Builder,
    }
    impl<C> UploadPartCopy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UploadPartCopyOutput,
            smithy_http::result::SdkError<crate::error::UploadPartCopyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bucket name.</p>
        /// <p>When using this action with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this action with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html">Using access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        /// <p>When using this action with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this action using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(inp);
            self
        }
        pub fn set_bucket(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_bucket(inp);
            self
        }
        /// <p>Specifies the source object for the copy operation. You specify the value in one of two
        /// formats, depending on whether you want to access the source object through an <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">access point</a>:</p>
        /// <ul>
        /// <li>
        /// <p>For objects not accessed through an access point, specify the name of the source
        /// bucket and key of the source object, separated by a slash (/). For example, to copy
        /// the object <code>reports/january.pdf</code> from the bucket
        /// <code>awsexamplebucket</code>, use
        /// <code>awsexamplebucket/reports/january.pdf</code>. The value must be URL
        /// encoded.</p>
        /// </li>
        /// <li>
        /// <p>For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format <code>arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through access point <code>my-access-point</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf</code>. The value must be URL encoded.</p>
        /// <note>
        /// <p>Amazon S3 supports copy operations using access points only when the source and destination buckets are in the same AWS Region.</p>
        /// </note>
        /// <p>Alternatively, for objects accessed through Amazon S3 on Outposts, specify the ARN of the object as accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/object/<key></code>. For example, to copy the object <code>reports/january.pdf</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf</code>. The value must be URL encoded.  </p>
        /// </li>
        /// </ul>
        /// <p>To copy a specific version of an object, append <code>?versionId=<version-id></code>
        /// to the value (for example,
        /// <code>awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893</code>).
        /// If you don't specify a version ID, Amazon S3 copies the latest version of the source
        /// object.</p>
        pub fn copy_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source(inp);
            self
        }
        pub fn set_copy_source(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_copy_source(inp);
            self
        }
        /// <p>Copies the object if its entity tag (ETag) matches the specified tag.</p>
        pub fn copy_source_if_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_if_match(inp);
            self
        }
        pub fn set_copy_source_if_match(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_match(inp);
            self
        }
        /// <p>Copies the object if it has been modified since the specified time.</p>
        pub fn copy_source_if_modified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.copy_source_if_modified_since(inp);
            self
        }
        pub fn set_copy_source_if_modified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_modified_since(inp);
            self
        }
        /// <p>Copies the object if its entity tag (ETag) is different than the specified ETag.</p>
        pub fn copy_source_if_none_match(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_if_none_match(inp);
            self
        }
        pub fn set_copy_source_if_none_match(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_none_match(inp);
            self
        }
        /// <p>Copies the object if it hasn't been modified since the specified time.</p>
        pub fn copy_source_if_unmodified_since(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.copy_source_if_unmodified_since(inp);
            self
        }
        pub fn set_copy_source_if_unmodified_since(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_if_unmodified_since(inp);
            self
        }
        /// <p>The range of bytes to copy from the source object. The range value must use the form
        /// bytes=first-last, where the first and last are the zero-based byte offsets to copy. For
        /// example, bytes=0-9 indicates that you want to copy the first 10 bytes of the source. You
        /// can copy a range only if the source object is greater than 5 MB.</p>
        pub fn copy_source_range(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_range(inp);
            self
        }
        pub fn set_copy_source_range(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_range(inp);
            self
        }
        /// <p>Object key for which the multipart upload was initiated.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key(inp);
            self
        }
        pub fn set_key(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_key(inp);
            self
        }
        /// <p>Part number of part being copied. This is a positive integer between 1 and
        /// 10,000.</p>
        pub fn part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.part_number(inp);
            self
        }
        pub fn set_part_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_part_number(inp);
            self
        }
        /// <p>Upload ID identifying the multipart upload whose part is being copied.</p>
        pub fn upload_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.upload_id(inp);
            self
        }
        pub fn set_upload_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_upload_id(inp);
            self
        }
        /// <p>Specifies the algorithm to use to when encrypting the object (for example,
        /// AES256).</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
        /// value is used to store the object and then it is discarded; Amazon S3 does not store the
        /// encryption key. The key must be appropriate for use with the algorithm specified in the
        /// <code>x-amz-server-side-encryption-customer-algorithm</code> header. This must be the
        /// same encryption key specified in the initiate multipart upload request.</p>
        pub fn sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key(inp);
            self
        }
        pub fn set_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p>Specifies the algorithm to use when decrypting the source object (for example,
        /// AES256).</p>
        pub fn copy_source_sse_customer_algorithm(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.copy_source_sse_customer_algorithm(inp);
            self
        }
        pub fn set_copy_source_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_sse_customer_algorithm(inp);
            self
        }
        /// <p>Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source
        /// object. The encryption key provided in this header must be one that was used when the
        /// source object was created.</p>
        pub fn copy_source_sse_customer_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_source_sse_customer_key(inp);
            self
        }
        pub fn set_copy_source_sse_customer_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_sse_customer_key(inp);
            self
        }
        /// <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
        /// this header for a message integrity check to ensure that the encryption key was transmitted
        /// without error.</p>
        pub fn copy_source_sse_customer_key_md5(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.copy_source_sse_customer_key_md5(inp);
            self
        }
        pub fn set_copy_source_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_copy_source_sse_customer_key_md5(inp);
            self
        }
        /// <p>Confirms that the requester knows that they will be charged for the request. Bucket
        /// owners need not specify this parameter in their requests. For information about downloading
        /// objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
        /// Requestor Pays Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn request_payer(mut self, inp: crate::model::RequestPayer) -> Self {
            self.inner = self.inner.request_payer(inp);
            self
        }
        pub fn set_request_payer(
            mut self,
            inp: std::option::Option<crate::model::RequestPayer>,
        ) -> Self {
            self.inner = self.inner.set_request_payer(inp);
            self
        }
        /// <p>The account ID of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_bucket_owner(inp);
            self
        }
        pub fn set_expected_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_bucket_owner(inp);
            self
        }
        /// <p>The account ID of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
        pub fn expected_source_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expected_source_bucket_owner(inp);
            self
        }
        pub fn set_expected_source_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_expected_source_bucket_owner(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct WriteGetObjectResponse<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::write_get_object_response_input::Builder,
    }
    impl<C> WriteGetObjectResponse<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::WriteGetObjectResponseOutput,
            smithy_http::result::SdkError<crate::error::WriteGetObjectResponseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Route prefix to the HTTP URL generated.</p>
        pub fn request_route(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_route(inp);
            self
        }
        pub fn set_request_route(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_route(inp);
            self
        }
        /// <p>A single use encrypted token that maps <code>WriteGetObjectResponse</code> to the end
        /// user <code>GetObject</code> request.</p>
        pub fn request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_token(inp);
            self
        }
        pub fn set_request_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_request_token(inp);
            self
        }
        /// <p>The object data.</p>
        pub fn body(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.body(inp);
            self
        }
        pub fn set_body(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.set_body(inp);
            self
        }
        /// <p>The integer status code for an HTTP response of a corresponding <code>GetObject</code>
        /// request.</p>
        /// <p class="title">
        /// <b>Status Codes</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>200 - OK</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>206 - Partial Content</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>304 - Not Modified</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>400 - Bad Request</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>401 - Unauthorized</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>403 - Forbidden</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>404 - Not Found</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>405 - Method Not Allowed</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>409 - Conflict</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>411 - Length Required</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>412 - Precondition Failed</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>416 - Range Not Satisfiable</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>500 - Internal Server Error</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>503 - Service Unavailable</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn status_code(mut self, inp: i32) -> Self {
            self.inner = self.inner.status_code(inp);
            self
        }
        pub fn set_status_code(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_status_code(inp);
            self
        }
        /// <p>A string that uniquely identifies an error condition. Returned in the <Code> tag
        /// of the error XML response for a corresponding <code>GetObject</code> call. Cannot be used
        /// with a successful <code>StatusCode</code> header or when the transformed object is provided
        /// in the body. All error codes from S3 are sentence-cased. Regex value is "^[A-Z][a-zA-Z]+$".</p>
        pub fn error_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.error_code(inp);
            self
        }
        pub fn set_error_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_error_code(inp);
            self
        }
        /// <p>Contains a generic description of the error condition. Returned in the <Message>
        /// tag of the error XML response for a corresponding <code>GetObject</code> call. Cannot be
        /// used with a successful <code>StatusCode</code> header or when the transformed object is
        /// provided in body.</p>
        pub fn error_message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.error_message(inp);
            self
        }
        pub fn set_error_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_error_message(inp);
            self
        }
        /// <p>Indicates that a range of bytes was specified.</p>
        pub fn accept_ranges(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.accept_ranges(inp);
            self
        }
        pub fn set_accept_ranges(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_accept_ranges(inp);
            self
        }
        /// <p>Specifies caching behavior along the request/reply chain.</p>
        pub fn cache_control(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_control(inp);
            self
        }
        pub fn set_cache_control(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cache_control(inp);
            self
        }
        /// <p>Specifies presentational information for the object.</p>
        pub fn content_disposition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_disposition(inp);
            self
        }
        pub fn set_content_disposition(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_disposition(inp);
            self
        }
        /// <p>Specifies what content encodings have been applied to the object and thus what decoding
        /// mechanisms must be applied to obtain the media-type referenced by the Content-Type header
        /// field.</p>
        pub fn content_encoding(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_encoding(inp);
            self
        }
        pub fn set_content_encoding(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_encoding(inp);
            self
        }
        /// <p>The language the content is in.</p>
        pub fn content_language(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_language(inp);
            self
        }
        pub fn set_content_language(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_content_language(inp);
            self
        }
        /// <p>The size of the content body in bytes.</p>
        pub fn content_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.content_length(inp);
            self
        }
        pub fn set_content_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_content_length(inp);
            self
        }
        /// <p>The portion of the object returned in the response.</p>
        pub fn content_range(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_range(inp);
            self
        }
        pub fn set_content_range(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_range(inp);
            self
        }
        /// <p>A standard MIME type describing the format of the object data.</p>
        pub fn content_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(inp);
            self
        }
        pub fn set_content_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(inp);
            self
        }
        /// <p>Specifies whether an object stored in Amazon S3 is (<code>true</code>) or is not
        /// (<code>false</code>) a delete marker. </p>
        pub fn delete_marker(mut self, inp: bool) -> Self {
            self.inner = self.inner.delete_marker(inp);
            self
        }
        pub fn set_delete_marker(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_delete_marker(inp);
            self
        }
        /// <p>An opaque identifier assigned by a web server to a specific version of a resource found
        /// at a URL. </p>
        pub fn e_tag(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.e_tag(inp);
            self
        }
        pub fn set_e_tag(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_e_tag(inp);
            self
        }
        /// <p>The date and time at which the object is no longer cacheable.</p>
        pub fn expires(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.expires(inp);
            self
        }
        pub fn set_expires(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_expires(inp);
            self
        }
        /// <p>If object stored in Amazon S3 expiration is configured (see PUT Bucket lifecycle) it includes expiry-date and rule-id key-value pairs providing object expiration information. The value of the rule-id is URL encoded. </p>
        pub fn expiration(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expiration(inp);
            self
        }
        pub fn set_expiration(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_expiration(inp);
            self
        }
        /// <p>The date and time that the object was last modified.</p>
        pub fn last_modified(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.last_modified(inp);
            self
        }
        pub fn set_last_modified(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_last_modified(inp);
            self
        }
        /// <p>Set to the number of metadata entries not returned in <code>x-amz-meta</code> headers.
        /// This can happen if you create metadata using an API like SOAP that supports more flexible
        /// metadata than the REST API. For example, using SOAP, you can create metadata whose values
        /// are not legal HTTP headers.</p>
        pub fn missing_meta(mut self, inp: i32) -> Self {
            self.inner = self.inner.missing_meta(inp);
            self
        }
        pub fn set_missing_meta(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_missing_meta(inp);
            self
        }
        /// <p>A map of metadata to store with the object in S3.</p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(inp);
            self
        }
        /// <p>Indicates whether an object stored in Amazon S3 has Object Lock enabled. For more
        /// information about S3 Object Lock, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">Object Lock</a>.</p>
        pub fn object_lock_mode(mut self, inp: crate::model::ObjectLockMode) -> Self {
            self.inner = self.inner.object_lock_mode(inp);
            self
        }
        pub fn set_object_lock_mode(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockMode>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_mode(inp);
            self
        }
        /// <p>Indicates whether an object stored in Amazon S3 has an active legal hold.</p>
        pub fn object_lock_legal_hold_status(
            mut self,
            inp: crate::model::ObjectLockLegalHoldStatus,
        ) -> Self {
            self.inner = self.inner.object_lock_legal_hold_status(inp);
            self
        }
        pub fn set_object_lock_legal_hold_status(
            mut self,
            inp: std::option::Option<crate::model::ObjectLockLegalHoldStatus>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_legal_hold_status(inp);
            self
        }
        /// <p>The date and time when Object Lock is configured to expire.</p>
        pub fn object_lock_retain_until_date(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.object_lock_retain_until_date(inp);
            self
        }
        pub fn set_object_lock_retain_until_date(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_retain_until_date(inp);
            self
        }
        /// <p>The count of parts this object has.</p>
        pub fn parts_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.parts_count(inp);
            self
        }
        pub fn set_parts_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_parts_count(inp);
            self
        }
        /// <p>Indicates if request involves bucket that is either a source or destination in a Replication rule. For more
        /// information about S3 Replication, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication.html">Replication</a>.</p>
        pub fn replication_status(mut self, inp: crate::model::ReplicationStatus) -> Self {
            self.inner = self.inner.replication_status(inp);
            self
        }
        pub fn set_replication_status(
            mut self,
            inp: std::option::Option<crate::model::ReplicationStatus>,
        ) -> Self {
            self.inner = self.inner.set_replication_status(inp);
            self
        }
        /// <p>If present, indicates that the requester was successfully charged for the
        /// request.</p>
        pub fn request_charged(mut self, inp: crate::model::RequestCharged) -> Self {
            self.inner = self.inner.request_charged(inp);
            self
        }
        pub fn set_request_charged(
            mut self,
            inp: std::option::Option<crate::model::RequestCharged>,
        ) -> Self {
            self.inner = self.inner.set_request_charged(inp);
            self
        }
        /// <p>Provides information about object restoration operation and expiration time of the
        /// restored object copy.</p>
        pub fn restore(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.restore(inp);
            self
        }
        pub fn set_restore(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_restore(inp);
            self
        }
        /// <p> The server-side encryption algorithm used when storing requested object in Amazon S3 (for example, AES256, aws:kms).</p>
        pub fn server_side_encryption(mut self, inp: crate::model::ServerSideEncryption) -> Self {
            self.inner = self.inner.server_side_encryption(inp);
            self
        }
        pub fn set_server_side_encryption(
            mut self,
            inp: std::option::Option<crate::model::ServerSideEncryption>,
        ) -> Self {
            self.inner = self.inner.set_server_side_encryption(inp);
            self
        }
        /// <p>Encryption algorithm used if server-side encryption with a customer-provided encryption key was specified for object stored in Amazon S3.</p>
        pub fn sse_customer_algorithm(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_algorithm(inp);
            self
        }
        pub fn set_sse_customer_algorithm(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_algorithm(inp);
            self
        }
        /// <p> If present, specifies the ID of the AWS Key Management Service (AWS KMS) symmetric customer managed customer master key (CMK) that was used for stored in Amazon S3 object. </p>
        pub fn ssekms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssekms_key_id(inp);
            self
        }
        pub fn set_ssekms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssekms_key_id(inp);
            self
        }
        /// <p> 128-bit MD5 digest of customer-provided encryption key used in Amazon S3 to encrypt data
        /// stored in S3. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html">Protecting data
        /// using server-side encryption with customer-provided encryption keys
        /// (SSE-C)</a>.</p>
        pub fn sse_customer_key_md5(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sse_customer_key_md5(inp);
            self
        }
        pub fn set_sse_customer_key_md5(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sse_customer_key_md5(inp);
            self
        }
        /// <p> The class of storage used to store object in Amazon S3.</p>
        pub fn storage_class(mut self, inp: crate::model::StorageClass) -> Self {
            self.inner = self.inner.storage_class(inp);
            self
        }
        pub fn set_storage_class(
            mut self,
            inp: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.inner = self.inner.set_storage_class(inp);
            self
        }
        /// <p>The number of tags, if any, on the object.</p>
        pub fn tag_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.tag_count(inp);
            self
        }
        pub fn set_tag_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_tag_count(inp);
            self
        }
        /// <p>An ID used to reference a specific version of the object.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
        /// <p> Indicates whether the object stored in Amazon S3 uses an S3 bucket key for server-side
        /// encryption with AWS KMS (SSE-KMS).</p>
        pub fn bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.bucket_key_enabled(inp);
            self
        }
        pub fn set_bucket_key_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_bucket_key_enabled(inp);
            self
        }
    }
}
