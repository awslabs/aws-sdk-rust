// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
pub struct GetObjectOutput  {
    /// <p>Object data.</p>
    pub body: aws_smithy_http::byte_stream::ByteStream,
    /// <p>Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.</p>
    #[doc(hidden)]
    pub delete_marker: bool,
    /// <p>Indicates that a range of bytes was specified.</p>
    #[doc(hidden)]
    pub accept_ranges: std::option::Option<std::string::String>,
    /// <p>If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the <code>expiry-date</code> and <code>rule-id</code> key-value pairs providing object expiration information. The value of the <code>rule-id</code> is URL-encoded.</p>
    #[doc(hidden)]
    pub expiration: std::option::Option<std::string::String>,
    /// <p>Provides information about object restoration action and expiration time of the restored object copy.</p>
    #[doc(hidden)]
    pub restore: std::option::Option<std::string::String>,
    /// <p>Creation date of the object.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Size of the body in bytes.</p>
    #[doc(hidden)]
    pub content_length: i64,
    /// <p>An entity tag (ETag) is an opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
    #[doc(hidden)]
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>The base64-encoded, 32-bit CRC32 checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    #[doc(hidden)]
    pub checksum_crc32: std::option::Option<std::string::String>,
    /// <p>The base64-encoded, 32-bit CRC32C checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    #[doc(hidden)]
    pub checksum_crc32_c: std::option::Option<std::string::String>,
    /// <p>The base64-encoded, 160-bit SHA-1 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    #[doc(hidden)]
    pub checksum_sha1: std::option::Option<std::string::String>,
    /// <p>The base64-encoded, 256-bit SHA-256 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    #[doc(hidden)]
    pub checksum_sha256: std::option::Option<std::string::String>,
    /// <p>This is set to the number of metadata entries not returned in <code>x-amz-meta</code> headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.</p>
    #[doc(hidden)]
    pub missing_meta: i32,
    /// <p>Version of the object.</p>
    #[doc(hidden)]
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    #[doc(hidden)]
    pub cache_control: std::option::Option<std::string::String>,
    /// <p>Specifies presentational information for the object.</p>
    #[doc(hidden)]
    pub content_disposition: std::option::Option<std::string::String>,
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.</p>
    #[doc(hidden)]
    pub content_encoding: std::option::Option<std::string::String>,
    /// <p>The language the content is in.</p>
    #[doc(hidden)]
    pub content_language: std::option::Option<std::string::String>,
    /// <p>The portion of the object returned in the response.</p>
    #[doc(hidden)]
    pub content_range: std::option::Option<std::string::String>,
    /// <p>A standard MIME type describing the format of the object data.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The date and time at which the object is no longer cacheable.</p>
    #[doc(hidden)]
    pub expires: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.</p>
    #[doc(hidden)]
    pub website_redirect_location: std::option::Option<std::string::String>,
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).</p>
    #[doc(hidden)]
    pub server_side_encryption: std::option::Option<crate::types::ServerSideEncryption>,
    /// <p>A map of metadata to store with the object in S3.</p>
    #[doc(hidden)]
    pub metadata: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.</p>
    #[doc(hidden)]
    pub sse_customer_algorithm: std::option::Option<std::string::String>,
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.</p>
    #[doc(hidden)]
    pub sse_customer_key_md5: std::option::Option<std::string::String>,
    /// <p>If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.</p>
    #[doc(hidden)]
    pub ssekms_key_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).</p>
    #[doc(hidden)]
    pub bucket_key_enabled: bool,
    /// <p>Provides storage class information of the object. Amazon S3 returns this header for all objects except for S3 Standard storage class objects.</p>
    #[doc(hidden)]
    pub storage_class: std::option::Option<crate::types::StorageClass>,
    /// <p>If present, indicates that the requester was successfully charged for the request.</p>
    #[doc(hidden)]
    pub request_charged: std::option::Option<crate::types::RequestCharged>,
    /// <p>Amazon S3 can return this if your request involves a bucket that is either a source or destination in a replication rule.</p>
    #[doc(hidden)]
    pub replication_status: std::option::Option<crate::types::ReplicationStatus>,
    /// <p>The count of parts this object has. This value is only returned if you specify <code>partNumber</code> in your request and the object was uploaded as a multipart upload.</p>
    #[doc(hidden)]
    pub parts_count: i32,
    /// <p>The number of tags, if any, on the object.</p>
    #[doc(hidden)]
    pub tag_count: i32,
    /// <p>The Object Lock mode currently in place for this object.</p>
    #[doc(hidden)]
    pub object_lock_mode: std::option::Option<crate::types::ObjectLockMode>,
    /// <p>The date and time when this object's Object Lock will expire.</p>
    #[doc(hidden)]
    pub object_lock_retain_until_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates whether this object has an active legal hold. This field is only returned if you have permission to view an object's legal hold status. </p>
    #[doc(hidden)]
    pub object_lock_legal_hold_status: std::option::Option<crate::types::ObjectLockLegalHoldStatus>,
    _extended_request_id: Option<String>,
    _request_id: Option<String>,
}
impl GetObjectOutput {
    /// <p>Object data.</p>
    pub fn body(&self) -> & aws_smithy_http::byte_stream::ByteStream {
        &self.body
    }
    /// <p>Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.</p>
    pub fn delete_marker(&self) -> bool {
        self.delete_marker
    }
    /// <p>Indicates that a range of bytes was specified.</p>
    pub fn accept_ranges(&self) -> std::option::Option<& str> {
        self.accept_ranges.as_deref()
    }
    /// <p>If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the <code>expiry-date</code> and <code>rule-id</code> key-value pairs providing object expiration information. The value of the <code>rule-id</code> is URL-encoded.</p>
    pub fn expiration(&self) -> std::option::Option<& str> {
        self.expiration.as_deref()
    }
    /// <p>Provides information about object restoration action and expiration time of the restored object copy.</p>
    pub fn restore(&self) -> std::option::Option<& str> {
        self.restore.as_deref()
    }
    /// <p>Creation date of the object.</p>
    pub fn last_modified(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_modified.as_ref()
    }
    /// <p>Size of the body in bytes.</p>
    pub fn content_length(&self) -> i64 {
        self.content_length
    }
    /// <p>An entity tag (ETag) is an opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
    pub fn e_tag(&self) -> std::option::Option<& str> {
        self.e_tag.as_deref()
    }
    /// <p>The base64-encoded, 32-bit CRC32 checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_crc32(&self) -> std::option::Option<& str> {
        self.checksum_crc32.as_deref()
    }
    /// <p>The base64-encoded, 32-bit CRC32C checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_crc32_c(&self) -> std::option::Option<& str> {
        self.checksum_crc32_c.as_deref()
    }
    /// <p>The base64-encoded, 160-bit SHA-1 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_sha1(&self) -> std::option::Option<& str> {
        self.checksum_sha1.as_deref()
    }
    /// <p>The base64-encoded, 256-bit SHA-256 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_sha256(&self) -> std::option::Option<& str> {
        self.checksum_sha256.as_deref()
    }
    /// <p>This is set to the number of metadata entries not returned in <code>x-amz-meta</code> headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.</p>
    pub fn missing_meta(&self) -> i32 {
        self.missing_meta
    }
    /// <p>Version of the object.</p>
    pub fn version_id(&self) -> std::option::Option<& str> {
        self.version_id.as_deref()
    }
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub fn cache_control(&self) -> std::option::Option<& str> {
        self.cache_control.as_deref()
    }
    /// <p>Specifies presentational information for the object.</p>
    pub fn content_disposition(&self) -> std::option::Option<& str> {
        self.content_disposition.as_deref()
    }
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.</p>
    pub fn content_encoding(&self) -> std::option::Option<& str> {
        self.content_encoding.as_deref()
    }
    /// <p>The language the content is in.</p>
    pub fn content_language(&self) -> std::option::Option<& str> {
        self.content_language.as_deref()
    }
    /// <p>The portion of the object returned in the response.</p>
    pub fn content_range(&self) -> std::option::Option<& str> {
        self.content_range.as_deref()
    }
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub fn content_type(&self) -> std::option::Option<& str> {
        self.content_type.as_deref()
    }
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub fn expires(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.expires.as_ref()
    }
    /// <p>If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.</p>
    pub fn website_redirect_location(&self) -> std::option::Option<& str> {
        self.website_redirect_location.as_deref()
    }
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).</p>
    pub fn server_side_encryption(&self) -> std::option::Option<& crate::types::ServerSideEncryption> {
        self.server_side_encryption.as_ref()
    }
    /// <p>A map of metadata to store with the object in S3.</p>
    pub fn metadata(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.metadata.as_ref()
    }
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.</p>
    pub fn sse_customer_algorithm(&self) -> std::option::Option<& str> {
        self.sse_customer_algorithm.as_deref()
    }
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.</p>
    pub fn sse_customer_key_md5(&self) -> std::option::Option<& str> {
        self.sse_customer_key_md5.as_deref()
    }
    /// <p>If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.</p>
    pub fn ssekms_key_id(&self) -> std::option::Option<& str> {
        self.ssekms_key_id.as_deref()
    }
    /// <p>Indicates whether the object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).</p>
    pub fn bucket_key_enabled(&self) -> bool {
        self.bucket_key_enabled
    }
    /// <p>Provides storage class information of the object. Amazon S3 returns this header for all objects except for S3 Standard storage class objects.</p>
    pub fn storage_class(&self) -> std::option::Option<& crate::types::StorageClass> {
        self.storage_class.as_ref()
    }
    /// <p>If present, indicates that the requester was successfully charged for the request.</p>
    pub fn request_charged(&self) -> std::option::Option<& crate::types::RequestCharged> {
        self.request_charged.as_ref()
    }
    /// <p>Amazon S3 can return this if your request involves a bucket that is either a source or destination in a replication rule.</p>
    pub fn replication_status(&self) -> std::option::Option<& crate::types::ReplicationStatus> {
        self.replication_status.as_ref()
    }
    /// <p>The count of parts this object has. This value is only returned if you specify <code>partNumber</code> in your request and the object was uploaded as a multipart upload.</p>
    pub fn parts_count(&self) -> i32 {
        self.parts_count
    }
    /// <p>The number of tags, if any, on the object.</p>
    pub fn tag_count(&self) -> i32 {
        self.tag_count
    }
    /// <p>The Object Lock mode currently in place for this object.</p>
    pub fn object_lock_mode(&self) -> std::option::Option<& crate::types::ObjectLockMode> {
        self.object_lock_mode.as_ref()
    }
    /// <p>The date and time when this object's Object Lock will expire.</p>
    pub fn object_lock_retain_until_date(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.object_lock_retain_until_date.as_ref()
    }
    /// <p>Indicates whether this object has an active legal hold. This field is only returned if you have permission to view an object's legal hold status. </p>
    pub fn object_lock_legal_hold_status(&self) -> std::option::Option<& crate::types::ObjectLockLegalHoldStatus> {
        self.object_lock_legal_hold_status.as_ref()
    }
}
impl  std::fmt::Debug for GetObjectOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectOutput");
        formatter.field("body", &self.body);
        formatter.field("delete_marker", &self.delete_marker);
        formatter.field("accept_ranges", &self.accept_ranges);
        formatter.field("expiration", &self.expiration);
        formatter.field("restore", &self.restore);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("content_length", &self.content_length);
        formatter.field("e_tag", &self.e_tag);
        formatter.field("checksum_crc32", &self.checksum_crc32);
        formatter.field("checksum_crc32_c", &self.checksum_crc32_c);
        formatter.field("checksum_sha1", &self.checksum_sha1);
        formatter.field("checksum_sha256", &self.checksum_sha256);
        formatter.field("missing_meta", &self.missing_meta);
        formatter.field("version_id", &self.version_id);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_range", &self.content_range);
        formatter.field("content_type", &self.content_type);
        formatter.field("expires", &self.expires);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("metadata", &self.metadata);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("request_charged", &self.request_charged);
        formatter.field("replication_status", &self.replication_status);
        formatter.field("parts_count", &self.parts_count);
        formatter.field("tag_count", &self.tag_count);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field("object_lock_retain_until_date", &self.object_lock_retain_until_date);
        formatter.field("object_lock_legal_hold_status", &self.object_lock_legal_hold_status);
        formatter.field("_extended_request_id", &self._extended_request_id);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl crate::s3_request_id::RequestIdExt for GetObjectOutput {
                                fn extended_request_id(&self) -> Option<&str> {
                                    self._extended_request_id.as_deref()
                                }
                            }
impl aws_http::request_id::RequestId for GetObjectOutput {
                                fn request_id(&self) -> Option<&str> {
                                    self._request_id.as_deref()
                                }
                            }
impl GetObjectOutput {
    /// Creates a new builder-style object to manufacture [`GetObjectOutput`](crate::operation::get_object::GetObjectOutput).
    pub fn builder() -> crate::operation::get_object::builders::GetObjectOutputBuilder {
        crate::operation::get_object::builders::GetObjectOutputBuilder::default()
    }
}

/// A builder for [`GetObjectOutput`](crate::operation::get_object::GetObjectOutput).
#[non_exhaustive]
#[derive(std::default::Default)]
pub struct GetObjectOutputBuilder {
    pub(crate) body: std::option::Option<aws_smithy_http::byte_stream::ByteStream>,
    pub(crate) delete_marker: std::option::Option<bool>,
    pub(crate) accept_ranges: std::option::Option<std::string::String>,
    pub(crate) expiration: std::option::Option<std::string::String>,
    pub(crate) restore: std::option::Option<std::string::String>,
    pub(crate) last_modified: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) content_length: std::option::Option<i64>,
    pub(crate) e_tag: std::option::Option<std::string::String>,
    pub(crate) checksum_crc32: std::option::Option<std::string::String>,
    pub(crate) checksum_crc32_c: std::option::Option<std::string::String>,
    pub(crate) checksum_sha1: std::option::Option<std::string::String>,
    pub(crate) checksum_sha256: std::option::Option<std::string::String>,
    pub(crate) missing_meta: std::option::Option<i32>,
    pub(crate) version_id: std::option::Option<std::string::String>,
    pub(crate) cache_control: std::option::Option<std::string::String>,
    pub(crate) content_disposition: std::option::Option<std::string::String>,
    pub(crate) content_encoding: std::option::Option<std::string::String>,
    pub(crate) content_language: std::option::Option<std::string::String>,
    pub(crate) content_range: std::option::Option<std::string::String>,
    pub(crate) content_type: std::option::Option<std::string::String>,
    pub(crate) expires: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) website_redirect_location: std::option::Option<std::string::String>,
    pub(crate) server_side_encryption: std::option::Option<crate::types::ServerSideEncryption>,
    pub(crate) metadata: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) sse_customer_algorithm: std::option::Option<std::string::String>,
    pub(crate) sse_customer_key_md5: std::option::Option<std::string::String>,
    pub(crate) ssekms_key_id: std::option::Option<std::string::String>,
    pub(crate) bucket_key_enabled: std::option::Option<bool>,
    pub(crate) storage_class: std::option::Option<crate::types::StorageClass>,
    pub(crate) request_charged: std::option::Option<crate::types::RequestCharged>,
    pub(crate) replication_status: std::option::Option<crate::types::ReplicationStatus>,
    pub(crate) parts_count: std::option::Option<i32>,
    pub(crate) tag_count: std::option::Option<i32>,
    pub(crate) object_lock_mode: std::option::Option<crate::types::ObjectLockMode>,
    pub(crate) object_lock_retain_until_date: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) object_lock_legal_hold_status: std::option::Option<crate::types::ObjectLockLegalHoldStatus>,
    _extended_request_id: Option<String>,
    _request_id: Option<String>,
}
impl GetObjectOutputBuilder {
    /// <p>Object data.</p>
    pub fn body(mut self, input: aws_smithy_http::byte_stream::ByteStream) -> Self {
        self.body = Some(input);
        self
    }
    /// <p>Object data.</p>
    pub fn set_body(mut self, input: std::option::Option<aws_smithy_http::byte_stream::ByteStream>) -> Self {
        self.body = input; self
    }
    /// <p>Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.</p>
    pub fn delete_marker(mut self, input: bool) -> Self {
        self.delete_marker = Some(input);
        self
    }
    /// <p>Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.</p>
    pub fn set_delete_marker(mut self, input: std::option::Option<bool>) -> Self {
        self.delete_marker = input; self
    }
    /// <p>Indicates that a range of bytes was specified.</p>
    pub fn accept_ranges(mut self, input: impl Into<std::string::String>) -> Self {
        self.accept_ranges = Some(input.into());
        self
    }
    /// <p>Indicates that a range of bytes was specified.</p>
    pub fn set_accept_ranges(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.accept_ranges = input; self
    }
    /// <p>If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the <code>expiry-date</code> and <code>rule-id</code> key-value pairs providing object expiration information. The value of the <code>rule-id</code> is URL-encoded.</p>
    pub fn expiration(mut self, input: impl Into<std::string::String>) -> Self {
        self.expiration = Some(input.into());
        self
    }
    /// <p>If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the <code>expiry-date</code> and <code>rule-id</code> key-value pairs providing object expiration information. The value of the <code>rule-id</code> is URL-encoded.</p>
    pub fn set_expiration(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.expiration = input; self
    }
    /// <p>Provides information about object restoration action and expiration time of the restored object copy.</p>
    pub fn restore(mut self, input: impl Into<std::string::String>) -> Self {
        self.restore = Some(input.into());
        self
    }
    /// <p>Provides information about object restoration action and expiration time of the restored object copy.</p>
    pub fn set_restore(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.restore = input; self
    }
    /// <p>Creation date of the object.</p>
    pub fn last_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.last_modified = Some(input);
        self
    }
    /// <p>Creation date of the object.</p>
    pub fn set_last_modified(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.last_modified = input; self
    }
    /// <p>Size of the body in bytes.</p>
    pub fn content_length(mut self, input: i64) -> Self {
        self.content_length = Some(input);
        self
    }
    /// <p>Size of the body in bytes.</p>
    pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
        self.content_length = input; self
    }
    /// <p>An entity tag (ETag) is an opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
    pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
        self.e_tag = Some(input.into());
        self
    }
    /// <p>An entity tag (ETag) is an opaque identifier assigned by a web server to a specific version of a resource found at a URL.</p>
    pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.e_tag = input; self
    }
    /// <p>The base64-encoded, 32-bit CRC32 checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_crc32(mut self, input: impl Into<std::string::String>) -> Self {
        self.checksum_crc32 = Some(input.into());
        self
    }
    /// <p>The base64-encoded, 32-bit CRC32 checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn set_checksum_crc32(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.checksum_crc32 = input; self
    }
    /// <p>The base64-encoded, 32-bit CRC32C checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_crc32_c(mut self, input: impl Into<std::string::String>) -> Self {
        self.checksum_crc32_c = Some(input.into());
        self
    }
    /// <p>The base64-encoded, 32-bit CRC32C checksum of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn set_checksum_crc32_c(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.checksum_crc32_c = input; self
    }
    /// <p>The base64-encoded, 160-bit SHA-1 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_sha1(mut self, input: impl Into<std::string::String>) -> Self {
        self.checksum_sha1 = Some(input.into());
        self
    }
    /// <p>The base64-encoded, 160-bit SHA-1 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn set_checksum_sha1(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.checksum_sha1 = input; self
    }
    /// <p>The base64-encoded, 256-bit SHA-256 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn checksum_sha256(mut self, input: impl Into<std::string::String>) -> Self {
        self.checksum_sha256 = Some(input.into());
        self
    }
    /// <p>The base64-encoded, 256-bit SHA-256 digest of the object. This will only be present if it was uploaded with the object. With multipart uploads, this may not be a checksum value of the object. For more information about how checksums are calculated with multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums"> Checking object integrity</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn set_checksum_sha256(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.checksum_sha256 = input; self
    }
    /// <p>This is set to the number of metadata entries not returned in <code>x-amz-meta</code> headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.</p>
    pub fn missing_meta(mut self, input: i32) -> Self {
        self.missing_meta = Some(input);
        self
    }
    /// <p>This is set to the number of metadata entries not returned in <code>x-amz-meta</code> headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.</p>
    pub fn set_missing_meta(mut self, input: std::option::Option<i32>) -> Self {
        self.missing_meta = input; self
    }
    /// <p>Version of the object.</p>
    pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.version_id = Some(input.into());
        self
    }
    /// <p>Version of the object.</p>
    pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.version_id = input; self
    }
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_control = Some(input.into());
        self
    }
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    pub fn set_cache_control(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cache_control = input; self
    }
    /// <p>Specifies presentational information for the object.</p>
    pub fn content_disposition(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_disposition = Some(input.into());
        self
    }
    /// <p>Specifies presentational information for the object.</p>
    pub fn set_content_disposition(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_disposition = input; self
    }
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.</p>
    pub fn content_encoding(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_encoding = Some(input.into());
        self
    }
    /// <p>Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.</p>
    pub fn set_content_encoding(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_encoding = input; self
    }
    /// <p>The language the content is in.</p>
    pub fn content_language(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_language = Some(input.into());
        self
    }
    /// <p>The language the content is in.</p>
    pub fn set_content_language(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_language = input; self
    }
    /// <p>The portion of the object returned in the response.</p>
    pub fn content_range(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_range = Some(input.into());
        self
    }
    /// <p>The portion of the object returned in the response.</p>
    pub fn set_content_range(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_range = input; self
    }
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_type = Some(input.into());
        self
    }
    /// <p>A standard MIME type describing the format of the object data.</p>
    pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_type = input; self
    }
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub fn expires(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.expires = Some(input);
        self
    }
    /// <p>The date and time at which the object is no longer cacheable.</p>
    pub fn set_expires(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.expires = input; self
    }
    /// <p>If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.</p>
    pub fn website_redirect_location(mut self, input: impl Into<std::string::String>) -> Self {
        self.website_redirect_location = Some(input.into());
        self
    }
    /// <p>If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.</p>
    pub fn set_website_redirect_location(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.website_redirect_location = input; self
    }
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).</p>
    pub fn server_side_encryption(mut self, input: crate::types::ServerSideEncryption) -> Self {
        self.server_side_encryption = Some(input);
        self
    }
    /// <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example, AES256, aws:kms).</p>
    pub fn set_server_side_encryption(mut self, input: std::option::Option<crate::types::ServerSideEncryption>) -> Self {
        self.server_side_encryption = input; self
    }
    /// Adds a key-value pair to `metadata`.
    ///
    /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
    ///
    /// <p>A map of metadata to store with the object in S3.</p>
    pub fn metadata(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.metadata.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.metadata = Some(hash_map);
                        self
    }
    /// <p>A map of metadata to store with the object in S3.</p>
    pub fn set_metadata(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.metadata = input; self
    }
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.</p>
    pub fn sse_customer_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
        self.sse_customer_algorithm = Some(input.into());
        self
    }
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.</p>
    pub fn set_sse_customer_algorithm(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.sse_customer_algorithm = input; self
    }
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.</p>
    pub fn sse_customer_key_md5(mut self, input: impl Into<std::string::String>) -> Self {
        self.sse_customer_key_md5 = Some(input.into());
        self
    }
    /// <p>If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round-trip message integrity verification of the customer-provided encryption key.</p>
    pub fn set_sse_customer_key_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.sse_customer_key_md5 = input; self
    }
    /// <p>If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.</p>
    pub fn ssekms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.ssekms_key_id = Some(input.into());
        self
    }
    /// <p>If present, specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric customer managed key that was used for the object.</p>
    pub fn set_ssekms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ssekms_key_id = input; self
    }
    /// <p>Indicates whether the object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).</p>
    pub fn bucket_key_enabled(mut self, input: bool) -> Self {
        self.bucket_key_enabled = Some(input);
        self
    }
    /// <p>Indicates whether the object uses an S3 Bucket Key for server-side encryption with Amazon Web Services KMS (SSE-KMS).</p>
    pub fn set_bucket_key_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.bucket_key_enabled = input; self
    }
    /// <p>Provides storage class information of the object. Amazon S3 returns this header for all objects except for S3 Standard storage class objects.</p>
    pub fn storage_class(mut self, input: crate::types::StorageClass) -> Self {
        self.storage_class = Some(input);
        self
    }
    /// <p>Provides storage class information of the object. Amazon S3 returns this header for all objects except for S3 Standard storage class objects.</p>
    pub fn set_storage_class(mut self, input: std::option::Option<crate::types::StorageClass>) -> Self {
        self.storage_class = input; self
    }
    /// <p>If present, indicates that the requester was successfully charged for the request.</p>
    pub fn request_charged(mut self, input: crate::types::RequestCharged) -> Self {
        self.request_charged = Some(input);
        self
    }
    /// <p>If present, indicates that the requester was successfully charged for the request.</p>
    pub fn set_request_charged(mut self, input: std::option::Option<crate::types::RequestCharged>) -> Self {
        self.request_charged = input; self
    }
    /// <p>Amazon S3 can return this if your request involves a bucket that is either a source or destination in a replication rule.</p>
    pub fn replication_status(mut self, input: crate::types::ReplicationStatus) -> Self {
        self.replication_status = Some(input);
        self
    }
    /// <p>Amazon S3 can return this if your request involves a bucket that is either a source or destination in a replication rule.</p>
    pub fn set_replication_status(mut self, input: std::option::Option<crate::types::ReplicationStatus>) -> Self {
        self.replication_status = input; self
    }
    /// <p>The count of parts this object has. This value is only returned if you specify <code>partNumber</code> in your request and the object was uploaded as a multipart upload.</p>
    pub fn parts_count(mut self, input: i32) -> Self {
        self.parts_count = Some(input);
        self
    }
    /// <p>The count of parts this object has. This value is only returned if you specify <code>partNumber</code> in your request and the object was uploaded as a multipart upload.</p>
    pub fn set_parts_count(mut self, input: std::option::Option<i32>) -> Self {
        self.parts_count = input; self
    }
    /// <p>The number of tags, if any, on the object.</p>
    pub fn tag_count(mut self, input: i32) -> Self {
        self.tag_count = Some(input);
        self
    }
    /// <p>The number of tags, if any, on the object.</p>
    pub fn set_tag_count(mut self, input: std::option::Option<i32>) -> Self {
        self.tag_count = input; self
    }
    /// <p>The Object Lock mode currently in place for this object.</p>
    pub fn object_lock_mode(mut self, input: crate::types::ObjectLockMode) -> Self {
        self.object_lock_mode = Some(input);
        self
    }
    /// <p>The Object Lock mode currently in place for this object.</p>
    pub fn set_object_lock_mode(mut self, input: std::option::Option<crate::types::ObjectLockMode>) -> Self {
        self.object_lock_mode = input; self
    }
    /// <p>The date and time when this object's Object Lock will expire.</p>
    pub fn object_lock_retain_until_date(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.object_lock_retain_until_date = Some(input);
        self
    }
    /// <p>The date and time when this object's Object Lock will expire.</p>
    pub fn set_object_lock_retain_until_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.object_lock_retain_until_date = input; self
    }
    /// <p>Indicates whether this object has an active legal hold. This field is only returned if you have permission to view an object's legal hold status. </p>
    pub fn object_lock_legal_hold_status(mut self, input: crate::types::ObjectLockLegalHoldStatus) -> Self {
        self.object_lock_legal_hold_status = Some(input);
        self
    }
    /// <p>Indicates whether this object has an active legal hold. This field is only returned if you have permission to view an object's legal hold status. </p>
    pub fn set_object_lock_legal_hold_status(mut self, input: std::option::Option<crate::types::ObjectLockLegalHoldStatus>) -> Self {
        self.object_lock_legal_hold_status = input; self
    }
    pub(crate) fn _extended_request_id(mut self, extended_request_id: impl Into<String>) -> Self {
                                    self._extended_request_id = Some(extended_request_id.into());
                                    self
                                }
    
                                pub(crate) fn _set_extended_request_id(&mut self, extended_request_id: Option<String>) -> &mut Self {
                                    self._extended_request_id = extended_request_id;
                                    self
                                }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
                                    self._request_id = Some(request_id.into());
                                    self
                                }
    
                                pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
                                    self._request_id = request_id;
                                    self
                                }
    /// Consumes the builder and constructs a [`GetObjectOutput`](crate::operation::get_object::GetObjectOutput).
    pub fn build(self) -> crate::operation::get_object::GetObjectOutput {
        crate::operation::get_object::GetObjectOutput {
            body: self.body
                .unwrap_or_default()
            ,
            delete_marker: self.delete_marker
                .unwrap_or_default()
            ,
            accept_ranges: self.accept_ranges
            ,
            expiration: self.expiration
            ,
            restore: self.restore
            ,
            last_modified: self.last_modified
            ,
            content_length: self.content_length
                .unwrap_or_default()
            ,
            e_tag: self.e_tag
            ,
            checksum_crc32: self.checksum_crc32
            ,
            checksum_crc32_c: self.checksum_crc32_c
            ,
            checksum_sha1: self.checksum_sha1
            ,
            checksum_sha256: self.checksum_sha256
            ,
            missing_meta: self.missing_meta
                .unwrap_or_default()
            ,
            version_id: self.version_id
            ,
            cache_control: self.cache_control
            ,
            content_disposition: self.content_disposition
            ,
            content_encoding: self.content_encoding
            ,
            content_language: self.content_language
            ,
            content_range: self.content_range
            ,
            content_type: self.content_type
            ,
            expires: self.expires
            ,
            website_redirect_location: self.website_redirect_location
            ,
            server_side_encryption: self.server_side_encryption
            ,
            metadata: self.metadata
            ,
            sse_customer_algorithm: self.sse_customer_algorithm
            ,
            sse_customer_key_md5: self.sse_customer_key_md5
            ,
            ssekms_key_id: self.ssekms_key_id
            ,
            bucket_key_enabled: self.bucket_key_enabled
                .unwrap_or_default()
            ,
            storage_class: self.storage_class
            ,
            request_charged: self.request_charged
            ,
            replication_status: self.replication_status
            ,
            parts_count: self.parts_count
                .unwrap_or_default()
            ,
            tag_count: self.tag_count
                .unwrap_or_default()
            ,
            object_lock_mode: self.object_lock_mode
            ,
            object_lock_retain_until_date: self.object_lock_retain_until_date
            ,
            object_lock_legal_hold_status: self.object_lock_legal_hold_status
            ,
            _extended_request_id: self._extended_request_id,
            _request_id: self._request_id,
        }
    }
}
impl std::fmt::Debug for GetObjectOutputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetObjectOutputBuilder");
        formatter.field("body", &self.body);
        formatter.field("delete_marker", &self.delete_marker);
        formatter.field("accept_ranges", &self.accept_ranges);
        formatter.field("expiration", &self.expiration);
        formatter.field("restore", &self.restore);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("content_length", &self.content_length);
        formatter.field("e_tag", &self.e_tag);
        formatter.field("checksum_crc32", &self.checksum_crc32);
        formatter.field("checksum_crc32_c", &self.checksum_crc32_c);
        formatter.field("checksum_sha1", &self.checksum_sha1);
        formatter.field("checksum_sha256", &self.checksum_sha256);
        formatter.field("missing_meta", &self.missing_meta);
        formatter.field("version_id", &self.version_id);
        formatter.field("cache_control", &self.cache_control);
        formatter.field("content_disposition", &self.content_disposition);
        formatter.field("content_encoding", &self.content_encoding);
        formatter.field("content_language", &self.content_language);
        formatter.field("content_range", &self.content_range);
        formatter.field("content_type", &self.content_type);
        formatter.field("expires", &self.expires);
        formatter.field("website_redirect_location", &self.website_redirect_location);
        formatter.field("server_side_encryption", &self.server_side_encryption);
        formatter.field("metadata", &self.metadata);
        formatter.field("sse_customer_algorithm", &self.sse_customer_algorithm);
        formatter.field("sse_customer_key_md5", &self.sse_customer_key_md5);
        formatter.field("ssekms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.field("bucket_key_enabled", &self.bucket_key_enabled);
        formatter.field("storage_class", &self.storage_class);
        formatter.field("request_charged", &self.request_charged);
        formatter.field("replication_status", &self.replication_status);
        formatter.field("parts_count", &self.parts_count);
        formatter.field("tag_count", &self.tag_count);
        formatter.field("object_lock_mode", &self.object_lock_mode);
        formatter.field("object_lock_retain_until_date", &self.object_lock_retain_until_date);
        formatter.field("object_lock_legal_hold_status", &self.object_lock_legal_hold_status);
        formatter.field("_extended_request_id", &self._extended_request_id);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}

