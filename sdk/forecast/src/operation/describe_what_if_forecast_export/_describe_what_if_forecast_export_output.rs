// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DescribeWhatIfForecastExportOutput {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    pub what_if_forecast_export_arn: ::std::option::Option<::std::string::String>,
    /// <p>The name of the what-if forecast export.</p>
    pub what_if_forecast_export_name: ::std::option::Option<::std::string::String>,
    /// <p>An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.</p>
    pub what_if_forecast_arns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional). </p>
    pub destination: ::std::option::Option<crate::types::DataDestination>,
    /// <p>If an error occurred, an informational message about the error.</p>
    pub message: ::std::option::Option<::std::string::String>,
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if forecast export must be <code>ACTIVE</code> before you can access the forecast export.</p>
    /// </note>
    pub status: ::std::option::Option<::std::string::String>,
    /// <p>When the what-if forecast export was created.</p>
    pub creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The approximate time remaining to complete the what-if forecast export, in minutes.</p>
    pub estimated_time_remaining_in_minutes: ::std::option::Option<i64>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub last_modification_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The format of the exported data, CSV or PARQUET.</p>
    pub format: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl DescribeWhatIfForecastExportOutput {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    pub fn what_if_forecast_export_arn(&self) -> ::std::option::Option<&str> {
        self.what_if_forecast_export_arn.as_deref()
    }
    /// <p>The name of the what-if forecast export.</p>
    pub fn what_if_forecast_export_name(&self) -> ::std::option::Option<&str> {
        self.what_if_forecast_export_name.as_deref()
    }
    /// <p>An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.what_if_forecast_arns.is_none()`.
    pub fn what_if_forecast_arns(&self) -> &[::std::string::String] {
        self.what_if_forecast_arns.as_deref().unwrap_or_default()
    }
    /// <p>The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional). </p>
    pub fn destination(&self) -> ::std::option::Option<&crate::types::DataDestination> {
        self.destination.as_ref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> ::std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if forecast export must be <code>ACTIVE</code> before you can access the forecast export.</p>
    /// </note>
    pub fn status(&self) -> ::std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>When the what-if forecast export was created.</p>
    pub fn creation_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The approximate time remaining to complete the what-if forecast export, in minutes.</p>
    pub fn estimated_time_remaining_in_minutes(&self) -> ::std::option::Option<i64> {
        self.estimated_time_remaining_in_minutes
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
    /// <p>The format of the exported data, CSV or PARQUET.</p>
    pub fn format(&self) -> ::std::option::Option<&str> {
        self.format.as_deref()
    }
}
impl ::aws_http::request_id::RequestId for DescribeWhatIfForecastExportOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeWhatIfForecastExportOutput {
    /// Creates a new builder-style object to manufacture [`DescribeWhatIfForecastExportOutput`](crate::operation::describe_what_if_forecast_export::DescribeWhatIfForecastExportOutput).
    pub fn builder() -> crate::operation::describe_what_if_forecast_export::builders::DescribeWhatIfForecastExportOutputBuilder {
        crate::operation::describe_what_if_forecast_export::builders::DescribeWhatIfForecastExportOutputBuilder::default()
    }
}

/// A builder for [`DescribeWhatIfForecastExportOutput`](crate::operation::describe_what_if_forecast_export::DescribeWhatIfForecastExportOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct DescribeWhatIfForecastExportOutputBuilder {
    pub(crate) what_if_forecast_export_arn: ::std::option::Option<::std::string::String>,
    pub(crate) what_if_forecast_export_name: ::std::option::Option<::std::string::String>,
    pub(crate) what_if_forecast_arns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) destination: ::std::option::Option<crate::types::DataDestination>,
    pub(crate) message: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) estimated_time_remaining_in_minutes: ::std::option::Option<i64>,
    pub(crate) last_modification_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) format: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl DescribeWhatIfForecastExportOutputBuilder {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    pub fn what_if_forecast_export_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.what_if_forecast_export_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    pub fn set_what_if_forecast_export_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.what_if_forecast_export_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    pub fn get_what_if_forecast_export_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.what_if_forecast_export_arn
    }
    /// <p>The name of the what-if forecast export.</p>
    pub fn what_if_forecast_export_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.what_if_forecast_export_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the what-if forecast export.</p>
    pub fn set_what_if_forecast_export_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.what_if_forecast_export_name = input;
        self
    }
    /// <p>The name of the what-if forecast export.</p>
    pub fn get_what_if_forecast_export_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.what_if_forecast_export_name
    }
    /// Appends an item to `what_if_forecast_arns`.
    ///
    /// To override the contents of this collection use [`set_what_if_forecast_arns`](Self::set_what_if_forecast_arns).
    ///
    /// <p>An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.</p>
    pub fn what_if_forecast_arns(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.what_if_forecast_arns.unwrap_or_default();
        v.push(input.into());
        self.what_if_forecast_arns = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.</p>
    pub fn set_what_if_forecast_arns(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.what_if_forecast_arns = input;
        self
    }
    /// <p>An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.</p>
    pub fn get_what_if_forecast_arns(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.what_if_forecast_arns
    }
    /// <p>The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional). </p>
    pub fn destination(mut self, input: crate::types::DataDestination) -> Self {
        self.destination = ::std::option::Option::Some(input);
        self
    }
    /// <p>The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional). </p>
    pub fn set_destination(mut self, input: ::std::option::Option<crate::types::DataDestination>) -> Self {
        self.destination = input;
        self
    }
    /// <p>The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional). </p>
    pub fn get_destination(&self) -> &::std::option::Option<crate::types::DataDestination> {
        &self.destination
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn set_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message = input;
        self
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn get_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.message
    }
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if forecast export must be <code>ACTIVE</code> before you can access the forecast export.</p>
    /// </note>
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if forecast export must be <code>ACTIVE</code> before you can access the forecast export.</p>
    /// </note>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if forecast export must be <code>ACTIVE</code> before you can access the forecast export.</p>
    /// </note>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>When the what-if forecast export was created.</p>
    pub fn creation_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.creation_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>When the what-if forecast export was created.</p>
    pub fn set_creation_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.creation_time = input;
        self
    }
    /// <p>When the what-if forecast export was created.</p>
    pub fn get_creation_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.creation_time
    }
    /// <p>The approximate time remaining to complete the what-if forecast export, in minutes.</p>
    pub fn estimated_time_remaining_in_minutes(mut self, input: i64) -> Self {
        self.estimated_time_remaining_in_minutes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The approximate time remaining to complete the what-if forecast export, in minutes.</p>
    pub fn set_estimated_time_remaining_in_minutes(mut self, input: ::std::option::Option<i64>) -> Self {
        self.estimated_time_remaining_in_minutes = input;
        self
    }
    /// <p>The approximate time remaining to complete the what-if forecast export, in minutes.</p>
    pub fn get_estimated_time_remaining_in_minutes(&self) -> &::std::option::Option<i64> {
        &self.estimated_time_remaining_in_minutes
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_modification_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn set_last_modification_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_modification_time = input;
        self
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn get_last_modification_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_modification_time
    }
    /// <p>The format of the exported data, CSV or PARQUET.</p>
    pub fn format(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.format = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The format of the exported data, CSV or PARQUET.</p>
    pub fn set_format(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.format = input;
        self
    }
    /// <p>The format of the exported data, CSV or PARQUET.</p>
    pub fn get_format(&self) -> &::std::option::Option<::std::string::String> {
        &self.format
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DescribeWhatIfForecastExportOutput`](crate::operation::describe_what_if_forecast_export::DescribeWhatIfForecastExportOutput).
    pub fn build(self) -> crate::operation::describe_what_if_forecast_export::DescribeWhatIfForecastExportOutput {
        crate::operation::describe_what_if_forecast_export::DescribeWhatIfForecastExportOutput {
            what_if_forecast_export_arn: self.what_if_forecast_export_arn,
            what_if_forecast_export_name: self.what_if_forecast_export_name,
            what_if_forecast_arns: self.what_if_forecast_arns,
            destination: self.destination,
            message: self.message,
            status: self.status,
            creation_time: self.creation_time,
            estimated_time_remaining_in_minutes: self.estimated_time_remaining_in_minutes,
            last_modification_time: self.last_modification_time,
            format: self.format,
            _request_id: self._request_id,
        }
    }
}
