// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_forecast::_create_forecast_output::CreateForecastOutputBuilder;

pub use crate::operation::create_forecast::_create_forecast_input::CreateForecastInputBuilder;

/// Fluent builder constructing a request to `CreateForecast`.
///
/// <p>Creates a forecast for each item in the <code>TARGET_TIME_SERIES</code> dataset that was used to train the predictor. This is known as inference. To retrieve the forecast for a single item at low latency, use the operation. To export the complete forecast into your Amazon Simple Storage Service (Amazon S3) bucket, use the <code>CreateForecastExportJob</code> operation.</p>
/// <p>The range of the forecast is determined by the <code>ForecastHorizon</code> value, which you specify in the <code>CreatePredictor</code> request. When you query a forecast, you can request a specific date range within the forecast.</p>
/// <p>To get a list of all your forecasts, use the <code>ListForecasts</code> operation.</p> <note>
/// <p>The forecasts generated by Amazon Forecast are in the same time zone as the dataset that was used to create the predictor.</p>
/// </note>
/// <p>For more information, see <code>howitworks-forecast</code>.</p> <note>
/// <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query or export the forecast. Use the <code>DescribeForecast</code> operation to get the status.</p>
/// </note>
/// <p>By default, a forecast includes predictions for every item (<code>item_id</code>) in the dataset group that was used to train the predictor. However, you can use the <code>TimeSeriesSelector</code> object to generate a forecast on a subset of time series. Forecast creation is skipped for any time series that you specify that are not in the input dataset. The forecast export file will not contain these time series or their forecasted values.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct CreateForecastFluentBuilder {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_forecast::builders::CreateForecastInputBuilder,
}
impl CreateForecastFluentBuilder {
    /// Creates a new `CreateForecast`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::client::customize::CustomizableOperation<
            crate::operation::create_forecast::CreateForecast,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::operation::create_forecast::CreateForecastError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::client::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::operation::create_forecast::CreateForecastOutput,
        aws_smithy_http::result::SdkError<crate::operation::create_forecast::CreateForecastError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>A name for the forecast.</p>
    pub fn forecast_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.forecast_name(input.into());
        self
    }
    /// <p>A name for the forecast.</p>
    pub fn set_forecast_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_forecast_name(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.</p>
    pub fn predictor_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.predictor_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.</p>
    pub fn set_predictor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_predictor_arn(input);
        self
    }
    /// Appends an item to `ForecastTypes`.
    ///
    /// To override the contents of this collection use [`set_forecast_types`](Self::set_forecast_types).
    ///
    /// <p>The quantiles at which probabilistic forecasts are generated. <b>You can currently specify up to 5 quantiles per forecast</b>. Accepted values include <code>0.01 to 0.99</code> (increments of .01 only) and <code>mean</code>. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). </p>
    /// <p>The default quantiles are the quantiles you specified during predictor creation. If you didn't specify quantiles, the default values are <code>["0.1", "0.5", "0.9"]</code>. </p>
    pub fn forecast_types(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.forecast_types(input.into());
        self
    }
    /// <p>The quantiles at which probabilistic forecasts are generated. <b>You can currently specify up to 5 quantiles per forecast</b>. Accepted values include <code>0.01 to 0.99</code> (increments of .01 only) and <code>mean</code>. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). </p>
    /// <p>The default quantiles are the quantiles you specified during predictor creation. If you didn't specify quantiles, the default values are <code>["0.1", "0.5", "0.9"]</code>. </p>
    pub fn set_forecast_types(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.inner = self.inner.set_forecast_types(input);
        self
    }
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50.</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8.</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8.</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p> </li>
    /// </ul>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50.</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8.</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8.</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p> </li>
    /// </ul>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>Defines the set of time series that are used to create the forecasts in a <code>TimeSeriesIdentifiers</code> object.</p>
    /// <p>The <code>TimeSeriesIdentifiers</code> object needs the following information:</p>
    /// <ul>
    /// <li> <p> <code>DataSource</code> </p> </li>
    /// <li> <p> <code>Format</code> </p> </li>
    /// <li> <p> <code>Schema</code> </p> </li>
    /// </ul>
    pub fn time_series_selector(mut self, input: crate::types::TimeSeriesSelector) -> Self {
        self.inner = self.inner.time_series_selector(input);
        self
    }
    /// <p>Defines the set of time series that are used to create the forecasts in a <code>TimeSeriesIdentifiers</code> object.</p>
    /// <p>The <code>TimeSeriesIdentifiers</code> object needs the following information:</p>
    /// <ul>
    /// <li> <p> <code>DataSource</code> </p> </li>
    /// <li> <p> <code>Format</code> </p> </li>
    /// <li> <p> <code>Schema</code> </p> </li>
    /// </ul>
    pub fn set_time_series_selector(
        mut self,
        input: std::option::Option<crate::types::TimeSeriesSelector>,
    ) -> Self {
        self.inner = self.inner.set_time_series_selector(input);
        self
    }
}
