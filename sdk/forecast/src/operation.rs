// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates an Amazon Forecast dataset. The information about the dataset that you provide helps
/// Forecast understand how to consume the data for model training. This includes the
/// following:</p>
/// <ul>
/// <li>
/// <p>
/// <i>
/// <code>DataFrequency</code>
/// </i> - How frequently your historical
/// time-series data is collected.</p>
/// </li>
/// <li>
/// <p>
/// <i>
/// <code>Domain</code>
/// </i> and
/// <i>
/// <code>DatasetType</code>
/// </i> - Each dataset has an associated dataset
/// domain and a type within the domain. Amazon Forecast provides a list of predefined domains and
/// types within each domain. For each unique dataset domain and type within the domain,
/// Amazon Forecast requires your data to include a minimum set of predefined fields.</p>
/// </li>
/// <li>
/// <p>
/// <i>
/// <code>Schema</code>
/// </i> - A schema specifies the fields in the dataset,
/// including the field name and data type.</p>
/// </li>
/// </ul>
/// <p>After creating a dataset, you import your training data into it and add the dataset to a
/// dataset group. You use the dataset group to create a predictor. For more information, see
/// <a>howitworks-datasets-groups</a>.</p>
/// <p>To get a list of all your datasets, use the <a>ListDatasets</a>
/// operation.</p>
/// <p>For example Forecast datasets, see the <a href="https://github.com/aws-samples/amazon-forecast-samples">Amazon Forecast Sample GitHub
/// repository</a>.</p>
/// <note>
/// <p>The <code>Status</code> of a dataset must be <code>ACTIVE</code> before you can import
/// training data. Use the <a>DescribeDataset</a> operation to get the status.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataset {
    _private: (),
}
impl CreateDataset {
    /// Creates a new builder-style object to manufacture [`CreateDatasetInput`](crate::input::CreateDatasetInput)
    pub fn builder() -> crate::input::create_dataset_input::Builder {
        crate::input::create_dataset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataset {
    type Output =
        std::result::Result<crate::output::CreateDatasetOutput, crate::error::CreateDatasetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_response(response)
        }
    }
}

/// <p>Creates a dataset group, which holds a collection of related datasets. You can add
/// datasets to the dataset group when you create the dataset group, or later by using the <a>UpdateDatasetGroup</a> operation.</p>
/// <p>After creating a dataset group and adding datasets, you use the dataset group when you
/// create a predictor. For more information, see <a>howitworks-datasets-groups</a>.</p>
/// <p>To get a list of all your datasets groups, use the <a>ListDatasetGroups</a>
/// operation.</p>
/// <note>
/// <p>The <code>Status</code> of a dataset group must be <code>ACTIVE</code> before you can
/// use the dataset group to create a predictor. To get the status, use the <a>DescribeDatasetGroup</a> operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDatasetGroup {
    _private: (),
}
impl CreateDatasetGroup {
    /// Creates a new builder-style object to manufacture [`CreateDatasetGroupInput`](crate::input::CreateDatasetGroupInput)
    pub fn builder() -> crate::input::create_dataset_group_input::Builder {
        crate::input::create_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDatasetGroup {
    type Output = std::result::Result<
        crate::output::CreateDatasetGroupOutput,
        crate::error::CreateDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_group_response(response)
        }
    }
}

/// <p>Imports your training data to an Amazon Forecast dataset. You provide the location of your
/// training data in an Amazon Simple Storage Service (Amazon S3) bucket and the Amazon Resource Name (ARN) of the dataset
/// that you want to import the data to.</p>
/// <p>You must specify a <a>DataSource</a> object that includes an AWS Identity and Access Management (IAM)
/// role that Amazon Forecast can assume to access the data, as Amazon Forecast makes a copy of your data and
/// processes it in an internal AWS system. For more information, see <a>aws-forecast-iam-roles</a>.</p>
/// <p>The training data must be in CSV format. The delimiter must be a comma (,).</p>
/// <p>You can specify the path to a specific CSV file, the S3 bucket, or to a folder in the S3
/// bucket. For the latter two cases, Amazon Forecast imports all files up to the limit of 10,000
/// files.</p>
/// <p>Because dataset imports are not aggregated, your most recent dataset import is the one
/// that is used when training a predictor or generating a forecast. Make sure that your most
/// recent dataset import contains all of the data you want to model off of, and not just the new
/// data collected since the previous import.</p>
/// <p>To get a list of all your dataset import jobs, filtered by specified criteria, use the
/// <a>ListDatasetImportJobs</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDatasetImportJob {
    _private: (),
}
impl CreateDatasetImportJob {
    /// Creates a new builder-style object to manufacture [`CreateDatasetImportJobInput`](crate::input::CreateDatasetImportJobInput)
    pub fn builder() -> crate::input::create_dataset_import_job_input::Builder {
        crate::input::create_dataset_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDatasetImportJob {
    type Output = std::result::Result<
        crate::output::CreateDatasetImportJobOutput,
        crate::error::CreateDatasetImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dataset_import_job_error(response)
        } else {
            crate::operation_deser::parse_create_dataset_import_job_response(response)
        }
    }
}

/// <p>Creates a forecast for each item in the <code>TARGET_TIME_SERIES</code> dataset that was
/// used to train the predictor. This is known as inference. To retrieve the forecast for a single
/// item at low latency, use the  operation. To
/// export the complete forecast into your Amazon Simple Storage Service (Amazon S3) bucket, use the <a>CreateForecastExportJob</a> operation.</p>
/// <p>The range of the forecast is determined by the <code>ForecastHorizon</code> value, which
/// you specify in the <a>CreatePredictor</a> request. When you query a forecast, you
/// can request a specific date range within the forecast.</p>
/// <p>To get a list of all your forecasts, use the <a>ListForecasts</a>
/// operation.</p>
/// <note>
/// <p>The forecasts generated by Amazon Forecast are in the same time zone as the dataset that was
/// used to create the predictor.</p>
/// </note>
/// <p>For more information, see <a>howitworks-forecast</a>.</p>
/// <note>
/// <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query
/// or export the forecast. Use the <a>DescribeForecast</a> operation to get the
/// status.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateForecast {
    _private: (),
}
impl CreateForecast {
    /// Creates a new builder-style object to manufacture [`CreateForecastInput`](crate::input::CreateForecastInput)
    pub fn builder() -> crate::input::create_forecast_input::Builder {
        crate::input::create_forecast_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateForecast {
    type Output =
        std::result::Result<crate::output::CreateForecastOutput, crate::error::CreateForecastError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_forecast_error(response)
        } else {
            crate::operation_deser::parse_create_forecast_response(response)
        }
    }
}

/// <p>Exports a forecast created by the <a>CreateForecast</a> operation to your
/// Amazon Simple Storage Service (Amazon S3) bucket. The forecast file name will match the following conventions:</p>
/// <p><ForecastExportJobName>_<ExportTimestamp>_<PartNumber></p>
/// <p>where the <ExportTimestamp> component is in Java SimpleDateFormat
/// (yyyy-MM-ddTHH-mm-ssZ).</p>
/// <p>You must specify a <a>DataDestination</a> object that includes an AWS Identity and Access Management
/// (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket. For more information, see
/// <a>aws-forecast-iam-roles</a>.</p>
/// <p>For more information, see <a>howitworks-forecast</a>.</p>
/// <p>To get a list of all your forecast export jobs, use the <a>ListForecastExportJobs</a> operation.</p>
/// <note>
/// <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before
/// you can access the forecast in your Amazon S3 bucket. To get the status, use the <a>DescribeForecastExportJob</a> operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateForecastExportJob {
    _private: (),
}
impl CreateForecastExportJob {
    /// Creates a new builder-style object to manufacture [`CreateForecastExportJobInput`](crate::input::CreateForecastExportJobInput)
    pub fn builder() -> crate::input::create_forecast_export_job_input::Builder {
        crate::input::create_forecast_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateForecastExportJob {
    type Output = std::result::Result<
        crate::output::CreateForecastExportJobOutput,
        crate::error::CreateForecastExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_forecast_export_job_error(response)
        } else {
            crate::operation_deser::parse_create_forecast_export_job_response(response)
        }
    }
}

/// <p>Creates an Amazon Forecast predictor.</p>
/// <p>In the request, provide a dataset group and either specify an algorithm or let
/// Amazon Forecast choose an algorithm for you using AutoML. If you specify an algorithm, you also can
/// override algorithm-specific hyperparameters.</p>
/// <p>Amazon Forecast uses the algorithm to train a predictor using the latest version of the
/// datasets in the specified dataset group. You can then generate a
/// forecast using the <a>CreateForecast</a> operation.</p>
/// <p>
/// To see the evaluation metrics, use the <a>GetAccuracyMetrics</a> operation.
/// </p>
/// <p>You can specify a featurization configuration to fill and aggregate the data
/// fields in the <code>TARGET_TIME_SERIES</code> dataset to improve model training. For more
/// information, see <a>FeaturizationConfig</a>.</p>
/// <p>For RELATED_TIME_SERIES datasets, <code>CreatePredictor</code> verifies that the
/// <code>DataFrequency</code> specified when the dataset was created matches the
/// <code>ForecastFrequency</code>. TARGET_TIME_SERIES datasets don't have this restriction.
/// Amazon Forecast also verifies the delimiter and timestamp format. For more information, see <a>howitworks-datasets-groups</a>.</p>
/// <p>By default, predictors are trained and evaluated at the 0.1 (P10), 0.5 (P50), and 0.9
/// (P90) quantiles. You can choose custom forecast types to train and evaluate your predictor
/// by setting the <code>ForecastTypes</code>.
/// </p>
/// <p>
/// <b>AutoML</b>
/// </p>
/// <p>If you want Amazon Forecast to evaluate each algorithm and choose the one that minimizes the
/// <code>objective function</code>, set <code>PerformAutoML</code> to <code>true</code>. The
/// <code>objective function</code> is defined as the mean of the weighted losses over the
/// forecast types. By default, these are the p10, p50, and p90
/// quantile losses. For more information, see <a>EvaluationResult</a>.</p>
/// <p>When AutoML is enabled, the following properties are disallowed:</p>
/// <ul>
/// <li>
/// <p>
/// <code>AlgorithmArn</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>HPOConfig</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>PerformHPO</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>TrainingParameters</code>
/// </p>
/// </li>
/// </ul>
/// <p>To get a list of all of your predictors, use the <a>ListPredictors</a>
/// operation.</p>
/// <note>
/// <p>Before you can use the predictor to create a forecast, the <code>Status</code> of the
/// predictor must be <code>ACTIVE</code>, signifying that training has completed. To get the
/// status, use the <a>DescribePredictor</a> operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePredictor {
    _private: (),
}
impl CreatePredictor {
    /// Creates a new builder-style object to manufacture [`CreatePredictorInput`](crate::input::CreatePredictorInput)
    pub fn builder() -> crate::input::create_predictor_input::Builder {
        crate::input::create_predictor_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePredictor {
    type Output = std::result::Result<
        crate::output::CreatePredictorOutput,
        crate::error::CreatePredictorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_predictor_error(response)
        } else {
            crate::operation_deser::parse_create_predictor_response(response)
        }
    }
}

/// <p>Exports backtest forecasts and accuracy metrics generated by the <a>CreatePredictor</a> operation. Two folders containing CSV files are exported
/// to your specified S3 bucket.</p>
/// <p> The export file names will match the following conventions:</p>
/// <p>
/// <code><ExportJobName>_<ExportTimestamp>_<PartNumber>.csv</code>
/// </p>
/// <p>The <ExportTimestamp> component is in Java SimpleDate format
/// (yyyy-MM-ddTHH-mm-ssZ).</p>
/// <p>You must specify a <a>DataDestination</a> object that includes an Amazon S3
/// bucket and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3
/// bucket. For more information, see <a>aws-forecast-iam-roles</a>.</p>
/// <note>
/// <p>The <code>Status</code> of the export job must be <code>ACTIVE</code> before
/// you can access the export in your Amazon S3 bucket. To get the status, use the <a>DescribePredictorBacktestExportJob</a> operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePredictorBacktestExportJob {
    _private: (),
}
impl CreatePredictorBacktestExportJob {
    /// Creates a new builder-style object to manufacture [`CreatePredictorBacktestExportJobInput`](crate::input::CreatePredictorBacktestExportJobInput)
    pub fn builder() -> crate::input::create_predictor_backtest_export_job_input::Builder {
        crate::input::create_predictor_backtest_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePredictorBacktestExportJob {
    type Output = std::result::Result<
        crate::output::CreatePredictorBacktestExportJobOutput,
        crate::error::CreatePredictorBacktestExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_predictor_backtest_export_job_error(response)
        } else {
            crate::operation_deser::parse_create_predictor_backtest_export_job_response(response)
        }
    }
}

/// <p>Deletes an Amazon Forecast dataset that was created using the <a>CreateDataset</a>
/// operation. You can only delete datasets that have a status of <code>ACTIVE</code> or
/// <code>CREATE_FAILED</code>. To get the status use the <a>DescribeDataset</a>
/// operation.</p>
/// <note>
/// <p>Forecast does not automatically update any dataset groups that contain the deleted dataset.
/// In order to update the dataset group, use the
/// operation, omitting the deleted dataset's ARN.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDataset {
    _private: (),
}
impl DeleteDataset {
    /// Creates a new builder-style object to manufacture [`DeleteDatasetInput`](crate::input::DeleteDatasetInput)
    pub fn builder() -> crate::input::delete_dataset_input::Builder {
        crate::input::delete_dataset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDataset {
    type Output =
        std::result::Result<crate::output::DeleteDatasetOutput, crate::error::DeleteDatasetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dataset_error(response)
        } else {
            crate::operation_deser::parse_delete_dataset_response(response)
        }
    }
}

/// <p>Deletes a dataset group created using the <a>CreateDatasetGroup</a> operation.
/// You can only delete dataset groups that have a status of <code>ACTIVE</code>,
/// <code>CREATE_FAILED</code>, or <code>UPDATE_FAILED</code>. To get the status, use the <a>DescribeDatasetGroup</a> operation.</p>
/// <p>This operation deletes only the dataset group, not the datasets in the group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDatasetGroup {
    _private: (),
}
impl DeleteDatasetGroup {
    /// Creates a new builder-style object to manufacture [`DeleteDatasetGroupInput`](crate::input::DeleteDatasetGroupInput)
    pub fn builder() -> crate::input::delete_dataset_group_input::Builder {
        crate::input::delete_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDatasetGroup {
    type Output = std::result::Result<
        crate::output::DeleteDatasetGroupOutput,
        crate::error::DeleteDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_delete_dataset_group_response(response)
        }
    }
}

/// <p>Deletes a dataset import job created using the <a>CreateDatasetImportJob</a>
/// operation. You can delete only dataset import jobs that have a status of <code>ACTIVE</code>
/// or <code>CREATE_FAILED</code>. To get the status, use the <a>DescribeDatasetImportJob</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDatasetImportJob {
    _private: (),
}
impl DeleteDatasetImportJob {
    /// Creates a new builder-style object to manufacture [`DeleteDatasetImportJobInput`](crate::input::DeleteDatasetImportJobInput)
    pub fn builder() -> crate::input::delete_dataset_import_job_input::Builder {
        crate::input::delete_dataset_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDatasetImportJob {
    type Output = std::result::Result<
        crate::output::DeleteDatasetImportJobOutput,
        crate::error::DeleteDatasetImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dataset_import_job_error(response)
        } else {
            crate::operation_deser::parse_delete_dataset_import_job_response(response)
        }
    }
}

/// <p>Deletes a forecast created using the <a>CreateForecast</a> operation. You can
/// delete only forecasts that have a status of <code>ACTIVE</code> or <code>CREATE_FAILED</code>.
/// To get the status, use the <a>DescribeForecast</a> operation.</p>
/// <p>You can't delete a forecast while it is being exported. After a forecast is deleted, you
/// can no longer query the forecast.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteForecast {
    _private: (),
}
impl DeleteForecast {
    /// Creates a new builder-style object to manufacture [`DeleteForecastInput`](crate::input::DeleteForecastInput)
    pub fn builder() -> crate::input::delete_forecast_input::Builder {
        crate::input::delete_forecast_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteForecast {
    type Output =
        std::result::Result<crate::output::DeleteForecastOutput, crate::error::DeleteForecastError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_forecast_error(response)
        } else {
            crate::operation_deser::parse_delete_forecast_response(response)
        }
    }
}

/// <p>Deletes a forecast export job created using the <a>CreateForecastExportJob</a>
/// operation. You can delete only export jobs that have a status of <code>ACTIVE</code> or
/// <code>CREATE_FAILED</code>. To get the status, use the <a>DescribeForecastExportJob</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteForecastExportJob {
    _private: (),
}
impl DeleteForecastExportJob {
    /// Creates a new builder-style object to manufacture [`DeleteForecastExportJobInput`](crate::input::DeleteForecastExportJobInput)
    pub fn builder() -> crate::input::delete_forecast_export_job_input::Builder {
        crate::input::delete_forecast_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteForecastExportJob {
    type Output = std::result::Result<
        crate::output::DeleteForecastExportJobOutput,
        crate::error::DeleteForecastExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_forecast_export_job_error(response)
        } else {
            crate::operation_deser::parse_delete_forecast_export_job_response(response)
        }
    }
}

/// <p>Deletes a predictor created using the <a>CreatePredictor</a> operation. You can
/// delete only predictor that have a status of <code>ACTIVE</code> or <code>CREATE_FAILED</code>.
/// To get the status, use the <a>DescribePredictor</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePredictor {
    _private: (),
}
impl DeletePredictor {
    /// Creates a new builder-style object to manufacture [`DeletePredictorInput`](crate::input::DeletePredictorInput)
    pub fn builder() -> crate::input::delete_predictor_input::Builder {
        crate::input::delete_predictor_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePredictor {
    type Output = std::result::Result<
        crate::output::DeletePredictorOutput,
        crate::error::DeletePredictorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_predictor_error(response)
        } else {
            crate::operation_deser::parse_delete_predictor_response(response)
        }
    }
}

/// <p>Deletes a predictor backtest export job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePredictorBacktestExportJob {
    _private: (),
}
impl DeletePredictorBacktestExportJob {
    /// Creates a new builder-style object to manufacture [`DeletePredictorBacktestExportJobInput`](crate::input::DeletePredictorBacktestExportJobInput)
    pub fn builder() -> crate::input::delete_predictor_backtest_export_job_input::Builder {
        crate::input::delete_predictor_backtest_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePredictorBacktestExportJob {
    type Output = std::result::Result<
        crate::output::DeletePredictorBacktestExportJobOutput,
        crate::error::DeletePredictorBacktestExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_predictor_backtest_export_job_error(response)
        } else {
            crate::operation_deser::parse_delete_predictor_backtest_export_job_response(response)
        }
    }
}

/// <p>Deletes an entire resource tree. This operation will delete the parent resource and
/// its child resources.</p>
/// <p>Child resources are resources that were created from another resource. For example,
/// when a forecast is generated from a predictor, the forecast is the child resource and
/// the predictor is the parent resource.</p>
/// <p>Amazon Forecast resources possess the following parent-child resource hierarchies:</p>
/// <ul>
/// <li>
/// <p>
/// <b>Dataset</b>: dataset import jobs</p>
/// </li>
/// <li>
/// <p>
/// <b>Dataset Group</b>: predictors, predictor backtest
/// export jobs, forecasts, forecast export jobs</p>
/// </li>
/// <li>
/// <p>
/// <b>Predictor</b>: predictor backtest export jobs,
/// forecasts, forecast export jobs</p>
/// </li>
/// <li>
/// <p>
/// <b>Forecast</b>: forecast export jobs</p>
/// </li>
/// </ul>
/// <note>
/// <p>
/// <code>DeleteResourceTree</code> will only delete Amazon Forecast resources, and will not
/// delete datasets or exported files stored in Amazon S3. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourceTree {
    _private: (),
}
impl DeleteResourceTree {
    /// Creates a new builder-style object to manufacture [`DeleteResourceTreeInput`](crate::input::DeleteResourceTreeInput)
    pub fn builder() -> crate::input::delete_resource_tree_input::Builder {
        crate::input::delete_resource_tree_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourceTree {
    type Output = std::result::Result<
        crate::output::DeleteResourceTreeOutput,
        crate::error::DeleteResourceTreeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resource_tree_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_tree_response(response)
        }
    }
}

/// <p>Describes an Amazon Forecast dataset created using the <a>CreateDataset</a>
/// operation.</p>
/// <p>In addition to listing the parameters specified in the <code>CreateDataset</code> request,
/// this operation includes the following dataset properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataset {
    _private: (),
}
impl DescribeDataset {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetInput`](crate::input::DescribeDatasetInput)
    pub fn builder() -> crate::input::describe_dataset_input::Builder {
        crate::input::describe_dataset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataset {
    type Output = std::result::Result<
        crate::output::DescribeDatasetOutput,
        crate::error::DescribeDatasetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_response(response)
        }
    }
}

/// <p>Describes a dataset group created using the <a>CreateDatasetGroup</a>
/// operation.</p>
/// <p>In addition to listing the parameters provided in the <code>CreateDatasetGroup</code>
/// request, this operation includes the following properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>DatasetArns</code> - The datasets belonging to the group.</p>
/// </li>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDatasetGroup {
    _private: (),
}
impl DescribeDatasetGroup {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetGroupInput`](crate::input::DescribeDatasetGroupInput)
    pub fn builder() -> crate::input::describe_dataset_group_input::Builder {
        crate::input::describe_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDatasetGroup {
    type Output = std::result::Result<
        crate::output::DescribeDatasetGroupOutput,
        crate::error::DescribeDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_group_response(response)
        }
    }
}

/// <p>Describes a dataset import job created using the <a>CreateDatasetImportJob</a>
/// operation.</p>
/// <p>In addition to listing the parameters provided in the <code>CreateDatasetImportJob</code>
/// request, this operation includes the following properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>DataSize</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>FieldStatistics</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Message</code> - If an error occurred, information about the error.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDatasetImportJob {
    _private: (),
}
impl DescribeDatasetImportJob {
    /// Creates a new builder-style object to manufacture [`DescribeDatasetImportJobInput`](crate::input::DescribeDatasetImportJobInput)
    pub fn builder() -> crate::input::describe_dataset_import_job_input::Builder {
        crate::input::describe_dataset_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDatasetImportJob {
    type Output = std::result::Result<
        crate::output::DescribeDatasetImportJobOutput,
        crate::error::DescribeDatasetImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dataset_import_job_error(response)
        } else {
            crate::operation_deser::parse_describe_dataset_import_job_response(response)
        }
    }
}

/// <p>Describes a forecast created using the <a>CreateForecast</a> operation.</p>
/// <p>In addition to listing the properties provided in the <code>CreateForecast</code> request,
/// this operation lists the following properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>DatasetGroupArn</code> - The dataset group that provided the training
/// data.</p>
/// </li>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Message</code> - If an error occurred, information about the error.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeForecast {
    _private: (),
}
impl DescribeForecast {
    /// Creates a new builder-style object to manufacture [`DescribeForecastInput`](crate::input::DescribeForecastInput)
    pub fn builder() -> crate::input::describe_forecast_input::Builder {
        crate::input::describe_forecast_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeForecast {
    type Output = std::result::Result<
        crate::output::DescribeForecastOutput,
        crate::error::DescribeForecastError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_forecast_error(response)
        } else {
            crate::operation_deser::parse_describe_forecast_response(response)
        }
    }
}

/// <p>Describes a forecast export job created using the <a>CreateForecastExportJob</a> operation.</p>
/// <p>In addition to listing the properties provided by the user in the
/// <code>CreateForecastExportJob</code> request, this operation lists the following
/// properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Message</code> - If an error occurred, information about the error.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeForecastExportJob {
    _private: (),
}
impl DescribeForecastExportJob {
    /// Creates a new builder-style object to manufacture [`DescribeForecastExportJobInput`](crate::input::DescribeForecastExportJobInput)
    pub fn builder() -> crate::input::describe_forecast_export_job_input::Builder {
        crate::input::describe_forecast_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeForecastExportJob {
    type Output = std::result::Result<
        crate::output::DescribeForecastExportJobOutput,
        crate::error::DescribeForecastExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_forecast_export_job_error(response)
        } else {
            crate::operation_deser::parse_describe_forecast_export_job_response(response)
        }
    }
}

/// <p>Describes a predictor created using the <a>CreatePredictor</a>
/// operation.</p>
/// <p>In addition to listing the properties provided in the <code>CreatePredictor</code>
/// request, this operation lists the following properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>DatasetImportJobArns</code> - The dataset import jobs used to import training
/// data.</p>
/// </li>
/// <li>
/// <p>
/// <code>AutoMLAlgorithmArns</code> - If AutoML is performed, the algorithms that were
/// evaluated.</p>
/// </li>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Message</code> - If an error occurred, information about the error.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePredictor {
    _private: (),
}
impl DescribePredictor {
    /// Creates a new builder-style object to manufacture [`DescribePredictorInput`](crate::input::DescribePredictorInput)
    pub fn builder() -> crate::input::describe_predictor_input::Builder {
        crate::input::describe_predictor_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePredictor {
    type Output = std::result::Result<
        crate::output::DescribePredictorOutput,
        crate::error::DescribePredictorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_predictor_error(response)
        } else {
            crate::operation_deser::parse_describe_predictor_response(response)
        }
    }
}

/// <p>Describes a predictor backtest export job created using the <a>CreatePredictorBacktestExportJob</a> operation.</p>
/// <p>In addition to listing the properties provided by the user in the
/// <code>CreatePredictorBacktestExportJob</code> request, this operation lists the
/// following properties:</p>
/// <ul>
/// <li>
/// <p>
/// <code>CreationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>LastModificationTime</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Status</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>Message</code> (if an error occurred)</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePredictorBacktestExportJob {
    _private: (),
}
impl DescribePredictorBacktestExportJob {
    /// Creates a new builder-style object to manufacture [`DescribePredictorBacktestExportJobInput`](crate::input::DescribePredictorBacktestExportJobInput)
    pub fn builder() -> crate::input::describe_predictor_backtest_export_job_input::Builder {
        crate::input::describe_predictor_backtest_export_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePredictorBacktestExportJob {
    type Output = std::result::Result<
        crate::output::DescribePredictorBacktestExportJobOutput,
        crate::error::DescribePredictorBacktestExportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_predictor_backtest_export_job_error(response)
        } else {
            crate::operation_deser::parse_describe_predictor_backtest_export_job_response(response)
        }
    }
}

/// <p>Provides metrics on the accuracy of the models that were trained by the <a>CreatePredictor</a> operation. Use metrics to see how well the model performed and
/// to decide whether to use the predictor to generate a forecast. For more information, see
/// <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">Predictor
/// Metrics</a>.</p>
/// <p>This operation generates metrics for each backtest window that was evaluated. The number of backtest windows
/// (<code>NumberOfBacktestWindows</code>) is specified using the
/// <a>EvaluationParameters</a> object, which is optionally
/// included in the <code>CreatePredictor</code> request. If
/// <code>NumberOfBacktestWindows</code> isn't specified, the number defaults to one.</p>
/// <p>The parameters of the <code>filling</code> method determine which items contribute to
/// the metrics. If you want all items to contribute, specify <code>zero</code>.
/// If you want only those items that have complete data in the range being evaluated to
/// contribute, specify <code>nan</code>.
/// For more information, see <a>FeaturizationMethod</a>.</p>
/// <note>
/// <p>Before you can get accuracy metrics, the <code>Status</code> of the predictor must be
/// <code>ACTIVE</code>, signifying that training has completed.
/// To get the status, use the <a>DescribePredictor</a> operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAccuracyMetrics {
    _private: (),
}
impl GetAccuracyMetrics {
    /// Creates a new builder-style object to manufacture [`GetAccuracyMetricsInput`](crate::input::GetAccuracyMetricsInput)
    pub fn builder() -> crate::input::get_accuracy_metrics_input::Builder {
        crate::input::get_accuracy_metrics_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAccuracyMetrics {
    type Output = std::result::Result<
        crate::output::GetAccuracyMetricsOutput,
        crate::error::GetAccuracyMetricsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_accuracy_metrics_error(response)
        } else {
            crate::operation_deser::parse_get_accuracy_metrics_response(response)
        }
    }
}

/// <p>Returns a list of dataset groups created using the <a>CreateDatasetGroup</a>
/// operation. For each dataset group, this operation returns a summary of its properties,
/// including its Amazon Resource Name (ARN). You can retrieve the complete set of properties by
/// using the dataset group ARN with the <a>DescribeDatasetGroup</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasetGroups {
    _private: (),
}
impl ListDatasetGroups {
    /// Creates a new builder-style object to manufacture [`ListDatasetGroupsInput`](crate::input::ListDatasetGroupsInput)
    pub fn builder() -> crate::input::list_dataset_groups_input::Builder {
        crate::input::list_dataset_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasetGroups {
    type Output = std::result::Result<
        crate::output::ListDatasetGroupsOutput,
        crate::error::ListDatasetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dataset_groups_error(response)
        } else {
            crate::operation_deser::parse_list_dataset_groups_response(response)
        }
    }
}

/// <p>Returns a list of dataset import jobs created using the <a>CreateDatasetImportJob</a> operation. For each import job, this operation returns a
/// summary of its properties, including its Amazon Resource Name (ARN). You can retrieve the
/// complete set of properties by using the ARN with the <a>DescribeDatasetImportJob</a> operation. You can filter the list by providing an array of <a>Filter</a>
/// objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasetImportJobs {
    _private: (),
}
impl ListDatasetImportJobs {
    /// Creates a new builder-style object to manufacture [`ListDatasetImportJobsInput`](crate::input::ListDatasetImportJobsInput)
    pub fn builder() -> crate::input::list_dataset_import_jobs_input::Builder {
        crate::input::list_dataset_import_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasetImportJobs {
    type Output = std::result::Result<
        crate::output::ListDatasetImportJobsOutput,
        crate::error::ListDatasetImportJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dataset_import_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_dataset_import_jobs_response(response)
        }
    }
}

/// <p>Returns a list of datasets created using the <a>CreateDataset</a> operation.
/// For each dataset, a summary of its properties, including its Amazon Resource Name (ARN), is
/// returned. To retrieve the complete set of properties, use the ARN with the <a>DescribeDataset</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDatasets {
    _private: (),
}
impl ListDatasets {
    /// Creates a new builder-style object to manufacture [`ListDatasetsInput`](crate::input::ListDatasetsInput)
    pub fn builder() -> crate::input::list_datasets_input::Builder {
        crate::input::list_datasets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDatasets {
    type Output =
        std::result::Result<crate::output::ListDatasetsOutput, crate::error::ListDatasetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_datasets_error(response)
        } else {
            crate::operation_deser::parse_list_datasets_response(response)
        }
    }
}

/// <p>Returns a list of forecast export jobs created using the <a>CreateForecastExportJob</a> operation. For each forecast export job, this operation
/// returns a summary of its properties, including its Amazon Resource Name (ARN). To retrieve the
/// complete set of properties, use the ARN with the <a>DescribeForecastExportJob</a>
/// operation. You can filter the list using an array of <a>Filter</a> objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListForecastExportJobs {
    _private: (),
}
impl ListForecastExportJobs {
    /// Creates a new builder-style object to manufacture [`ListForecastExportJobsInput`](crate::input::ListForecastExportJobsInput)
    pub fn builder() -> crate::input::list_forecast_export_jobs_input::Builder {
        crate::input::list_forecast_export_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListForecastExportJobs {
    type Output = std::result::Result<
        crate::output::ListForecastExportJobsOutput,
        crate::error::ListForecastExportJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_forecast_export_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_forecast_export_jobs_response(response)
        }
    }
}

/// <p>Returns a list of forecasts created using the <a>CreateForecast</a> operation.
/// For each forecast, this operation returns a summary of its properties, including its Amazon
/// Resource Name (ARN). To retrieve the complete set of properties, specify the ARN with the
/// <a>DescribeForecast</a> operation. You can filter the list using an array of
/// <a>Filter</a> objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListForecasts {
    _private: (),
}
impl ListForecasts {
    /// Creates a new builder-style object to manufacture [`ListForecastsInput`](crate::input::ListForecastsInput)
    pub fn builder() -> crate::input::list_forecasts_input::Builder {
        crate::input::list_forecasts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListForecasts {
    type Output =
        std::result::Result<crate::output::ListForecastsOutput, crate::error::ListForecastsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_forecasts_error(response)
        } else {
            crate::operation_deser::parse_list_forecasts_response(response)
        }
    }
}

/// <p>Returns a list of predictor backtest export jobs created using the <a>CreatePredictorBacktestExportJob</a> operation. This operation returns a summary
/// for each backtest export job. You can filter the list using an array of <a>Filter</a> objects.</p>
/// <p>To retrieve the complete set of properties for a particular backtest export job, use the
/// ARN with the <a>DescribePredictorBacktestExportJob</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPredictorBacktestExportJobs {
    _private: (),
}
impl ListPredictorBacktestExportJobs {
    /// Creates a new builder-style object to manufacture [`ListPredictorBacktestExportJobsInput`](crate::input::ListPredictorBacktestExportJobsInput)
    pub fn builder() -> crate::input::list_predictor_backtest_export_jobs_input::Builder {
        crate::input::list_predictor_backtest_export_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPredictorBacktestExportJobs {
    type Output = std::result::Result<
        crate::output::ListPredictorBacktestExportJobsOutput,
        crate::error::ListPredictorBacktestExportJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_predictor_backtest_export_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_predictor_backtest_export_jobs_response(response)
        }
    }
}

/// <p>Returns a list of predictors created using the <a>CreatePredictor</a>
/// operation. For each predictor, this operation returns a summary of its properties, including
/// its Amazon Resource Name (ARN). You can retrieve the complete set of properties by using the
/// ARN with the <a>DescribePredictor</a> operation. You can filter the list using an
/// array of <a>Filter</a> objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPredictors {
    _private: (),
}
impl ListPredictors {
    /// Creates a new builder-style object to manufacture [`ListPredictorsInput`](crate::input::ListPredictorsInput)
    pub fn builder() -> crate::input::list_predictors_input::Builder {
        crate::input::list_predictors_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPredictors {
    type Output =
        std::result::Result<crate::output::ListPredictorsOutput, crate::error::ListPredictorsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_predictors_error(response)
        } else {
            crate::operation_deser::parse_list_predictors_response(response)
        }
    }
}

/// <p>Lists the tags for an Amazon Forecast resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Stops a resource.</p>
/// <p>The resource undergoes the following states:
/// <code>CREATE_STOPPING</code> and <code>CREATE_STOPPED</code>. You cannot resume
/// a resource once it has been stopped.</p>
/// <p>This operation can be applied to the following resources (and their corresponding child
/// resources):</p>
/// <ul>
/// <li>
/// <p>Dataset Import Job</p>
/// </li>
/// <li>
/// <p>Predictor Job</p>
/// </li>
/// <li>
/// <p>Forecast Job</p>
/// </li>
/// <li>
/// <p>Forecast Export Job</p>
/// </li>
/// <li>
/// <p>Predictor Backtest Export Job</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopResource {
    _private: (),
}
impl StopResource {
    /// Creates a new builder-style object to manufacture [`StopResourceInput`](crate::input::StopResourceInput)
    pub fn builder() -> crate::input::stop_resource_input::Builder {
        crate::input::stop_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopResource {
    type Output =
        std::result::Result<crate::output::StopResourceOutput, crate::error::StopResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_resource_error(response)
        } else {
            crate::operation_deser::parse_stop_resource_response(response)
        }
    }
}

/// <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>. If existing tags on a resource are not specified in the request parameters, they are not changed. When a resource is deleted, the tags associated with that resource are also deleted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Deletes the specified tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Replaces the datasets in a dataset group with the specified datasets.</p>
/// <note>
/// <p>The <code>Status</code> of the dataset group must be <code>ACTIVE</code> before you can
/// use the dataset group to create a predictor. Use the <a>DescribeDatasetGroup</a>
/// operation to get the status.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDatasetGroup {
    _private: (),
}
impl UpdateDatasetGroup {
    /// Creates a new builder-style object to manufacture [`UpdateDatasetGroupInput`](crate::input::UpdateDatasetGroupInput)
    pub fn builder() -> crate::input::update_dataset_group_input::Builder {
        crate::input::update_dataset_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDatasetGroup {
    type Output = std::result::Result<
        crate::output::UpdateDatasetGroupOutput,
        crate::error::UpdateDatasetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_dataset_group_error(response)
        } else {
            crate::operation_deser::parse_update_dataset_group_response(response)
        }
    }
}
