// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
/// <p>The following basic restrictions apply to tags:</p>
/// <ul>
/// <li> <p>Maximum number of tags per resource - 50.</p> </li>
/// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
/// <li> <p>Maximum key length - 128 Unicode characters in UTF-8.</p> </li>
/// <li> <p>Maximum value length - 256 Unicode characters in UTF-8.</p> </li>
/// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
/// <li> <p>Tag keys and values are case sensitive.</p> </li>
/// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>One part of a key-value pair that makes up a tag. A <code>key</code> is a general label that acts like a category for more specific tag values.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that makes up a tag. A <code>value</code> acts as a descriptor within a tag category (key).</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>One part of a key-value pair that makes up a tag. A <code>key</code> is a general label that acts like a category for more specific tag values.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The optional part of a key-value pair that makes up a tag. A <code>value</code> acts as a descriptor within a tag category (key).</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &"*** Sensitive Data Redacted ***");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One part of a key-value pair that makes up a tag. A <code>key</code> is a general label that acts like a category for more specific tag values.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair that makes up a tag. A <code>key</code> is a general label that acts like a category for more specific tag values.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The optional part of a key-value pair that makes up a tag. A <code>value</code> acts as a descriptor within a tag category (key).</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The optional part of a key-value pair that makes up a tag. A <code>value</code> acts as a descriptor within a tag category (key).</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("key", &"*** Sensitive Data Redacted ***");
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Provides a summary of the what-if forecast properties used in the <code>ListWhatIfForecasts</code> operation. To get the complete set of properties, call the <code>DescribeWhatIfForecast</code> operation, and provide the <code>WhatIfForecastArn</code> that is listed in the summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WhatIfForecastSummary {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast.</p>
    #[doc(hidden)]
    pub what_if_forecast_arn: std::option::Option<std::string::String>,
    /// <p>The name of the what-if forecast.</p>
    #[doc(hidden)]
    pub what_if_forecast_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.</p>
    #[doc(hidden)]
    pub what_if_analysis_arn: std::option::Option<std::string::String>,
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the what-if forecast was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WhatIfForecastSummary {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast.</p>
    pub fn what_if_forecast_arn(&self) -> std::option::Option<&str> {
        self.what_if_forecast_arn.as_deref()
    }
    /// <p>The name of the what-if forecast.</p>
    pub fn what_if_forecast_name(&self) -> std::option::Option<&str> {
        self.what_if_forecast_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.</p>
    pub fn what_if_analysis_arn(&self) -> std::option::Option<&str> {
        self.what_if_analysis_arn.as_deref()
    }
    /// <p>The status of the what-if forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the what-if forecast was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`WhatIfForecastSummary`](crate::model::WhatIfForecastSummary).
pub mod what_if_forecast_summary {

    /// A builder for [`WhatIfForecastSummary`](crate::model::WhatIfForecastSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) what_if_forecast_arn: std::option::Option<std::string::String>,
        pub(crate) what_if_forecast_name: std::option::Option<std::string::String>,
        pub(crate) what_if_analysis_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the what-if forecast.</p>
        pub fn what_if_forecast_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.what_if_forecast_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the what-if forecast.</p>
        pub fn set_what_if_forecast_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_forecast_arn = input;
            self
        }
        /// <p>The name of the what-if forecast.</p>
        pub fn what_if_forecast_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.what_if_forecast_name = Some(input.into());
            self
        }
        /// <p>The name of the what-if forecast.</p>
        pub fn set_what_if_forecast_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_forecast_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.</p>
        pub fn what_if_analysis_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.what_if_analysis_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.</p>
        pub fn set_what_if_analysis_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_analysis_arn = input;
            self
        }
        /// <p>The status of the what-if forecast. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
        /// </note>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the what-if forecast. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the what-if forecast was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the what-if forecast was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WhatIfForecastSummary`](crate::model::WhatIfForecastSummary).
        pub fn build(self) -> crate::model::WhatIfForecastSummary {
            crate::model::WhatIfForecastSummary {
                what_if_forecast_arn: self.what_if_forecast_arn,
                what_if_forecast_name: self.what_if_forecast_name,
                what_if_analysis_arn: self.what_if_analysis_arn,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl WhatIfForecastSummary {
    /// Creates a new builder-style object to manufacture [`WhatIfForecastSummary`](crate::model::WhatIfForecastSummary).
    pub fn builder() -> crate::model::what_if_forecast_summary::Builder {
        crate::model::what_if_forecast_summary::Builder::default()
    }
}

/// <p>Describes a filter for choosing a subset of objects. Each filter consists of a condition and a match statement. The condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to include or exclude the objects that match the statement, respectively. The match statement consists of a key and a value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p>The name of the parameter to filter on.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value to match.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The condition to apply. To include the objects that match the statement, specify <code>IS</code>. To exclude matching objects, specify <code>IS_NOT</code>.</p>
    #[doc(hidden)]
    pub condition: std::option::Option<crate::model::FilterConditionString>,
}
impl Filter {
    /// <p>The name of the parameter to filter on.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value to match.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The condition to apply. To include the objects that match the statement, specify <code>IS</code>. To exclude matching objects, specify <code>IS_NOT</code>.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::FilterConditionString> {
        self.condition.as_ref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) condition: std::option::Option<crate::model::FilterConditionString>,
    }
    impl Builder {
        /// <p>The name of the parameter to filter on.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The name of the parameter to filter on.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value to match.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value to match.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The condition to apply. To include the objects that match the statement, specify <code>IS</code>. To exclude matching objects, specify <code>IS_NOT</code>.</p>
        pub fn condition(mut self, input: crate::model::FilterConditionString) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The condition to apply. To include the objects that match the statement, specify <code>IS</code>. To exclude matching objects, specify <code>IS_NOT</code>.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::FilterConditionString>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                key: self.key,
                value: self.value,
                condition: self.condition,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// When writing a match expression against `FilterConditionString`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filterconditionstring = unimplemented!();
/// match filterconditionstring {
///     FilterConditionString::Is => { /* ... */ },
///     FilterConditionString::IsNot => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filterconditionstring` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterConditionString::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterConditionString::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterConditionString::NewFeature` is defined.
/// Specifically, when `filterconditionstring` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterConditionString::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterConditionString {
    #[allow(missing_docs)] // documentation missing in model
    Is,
    #[allow(missing_docs)] // documentation missing in model
    IsNot,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterConditionString {
    fn from(s: &str) -> Self {
        match s {
            "IS" => FilterConditionString::Is,
            "IS_NOT" => FilterConditionString::IsNot,
            other => {
                FilterConditionString::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FilterConditionString {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterConditionString::from(s))
    }
}
impl FilterConditionString {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterConditionString::Is => "IS",
            FilterConditionString::IsNot => "IS_NOT",
            FilterConditionString::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IS", "IS_NOT"]
    }
}
impl AsRef<str> for FilterConditionString {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of the what-if forecast export properties used in the <code>ListWhatIfForecastExports</code> operation. To get the complete set of properties, call the <code>DescribeWhatIfForecastExport</code> operation, and provide the <code>WhatIfForecastExportArn</code> that is listed in the summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WhatIfForecastExportSummary {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    #[doc(hidden)]
    pub what_if_forecast_export_arn: std::option::Option<std::string::String>,
    /// <p>An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.</p>
    #[doc(hidden)]
    pub what_if_forecast_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The what-if forecast export name.</p>
    #[doc(hidden)]
    pub what_if_forecast_export_name: std::option::Option<std::string::String>,
    /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::DataDestination>,
    /// <p>The status of the what-if forecast export. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the what-if forecast export was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WhatIfForecastExportSummary {
    /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
    pub fn what_if_forecast_export_arn(&self) -> std::option::Option<&str> {
        self.what_if_forecast_export_arn.as_deref()
    }
    /// <p>An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.</p>
    pub fn what_if_forecast_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.what_if_forecast_arns.as_deref()
    }
    /// <p>The what-if forecast export name.</p>
    pub fn what_if_forecast_export_name(&self) -> std::option::Option<&str> {
        self.what_if_forecast_export_name.as_deref()
    }
    /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
    pub fn destination(&self) -> std::option::Option<&crate::model::DataDestination> {
        self.destination.as_ref()
    }
    /// <p>The status of the what-if forecast export. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the what-if forecast export was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`WhatIfForecastExportSummary`](crate::model::WhatIfForecastExportSummary).
pub mod what_if_forecast_export_summary {

    /// A builder for [`WhatIfForecastExportSummary`](crate::model::WhatIfForecastExportSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) what_if_forecast_export_arn: std::option::Option<std::string::String>,
        pub(crate) what_if_forecast_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) what_if_forecast_export_name: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<crate::model::DataDestination>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
        pub fn what_if_forecast_export_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.what_if_forecast_export_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the what-if forecast export.</p>
        pub fn set_what_if_forecast_export_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_forecast_export_arn = input;
            self
        }
        /// Appends an item to `what_if_forecast_arns`.
        ///
        /// To override the contents of this collection use [`set_what_if_forecast_arns`](Self::set_what_if_forecast_arns).
        ///
        /// <p>An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.</p>
        pub fn what_if_forecast_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.what_if_forecast_arns.unwrap_or_default();
            v.push(input.into());
            self.what_if_forecast_arns = Some(v);
            self
        }
        /// <p>An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.</p>
        pub fn set_what_if_forecast_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.what_if_forecast_arns = input;
            self
        }
        /// <p>The what-if forecast export name.</p>
        pub fn what_if_forecast_export_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.what_if_forecast_export_name = Some(input.into());
            self
        }
        /// <p>The what-if forecast export name.</p>
        pub fn set_what_if_forecast_export_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_forecast_export_name = input;
            self
        }
        /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
        pub fn destination(mut self, input: crate::model::DataDestination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::DataDestination>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>The status of the what-if forecast export. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
        /// </note>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the what-if forecast export. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the what-if forecast export was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the what-if forecast export was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WhatIfForecastExportSummary`](crate::model::WhatIfForecastExportSummary).
        pub fn build(self) -> crate::model::WhatIfForecastExportSummary {
            crate::model::WhatIfForecastExportSummary {
                what_if_forecast_export_arn: self.what_if_forecast_export_arn,
                what_if_forecast_arns: self.what_if_forecast_arns,
                what_if_forecast_export_name: self.what_if_forecast_export_name,
                destination: self.destination,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl WhatIfForecastExportSummary {
    /// Creates a new builder-style object to manufacture [`WhatIfForecastExportSummary`](crate::model::WhatIfForecastExportSummary).
    pub fn builder() -> crate::model::what_if_forecast_export_summary::Builder {
        crate::model::what_if_forecast_export_summary::Builder::default()
    }
}

/// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataDestination {
    /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.</p>
    #[doc(hidden)]
    pub s3_config: std::option::Option<crate::model::S3Config>,
}
impl DataDestination {
    /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.</p>
    pub fn s3_config(&self) -> std::option::Option<&crate::model::S3Config> {
        self.s3_config.as_ref()
    }
}
/// See [`DataDestination`](crate::model::DataDestination).
pub mod data_destination {

    /// A builder for [`DataDestination`](crate::model::DataDestination).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_config: std::option::Option<crate::model::S3Config>,
    }
    impl Builder {
        /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.</p>
        pub fn s3_config(mut self, input: crate::model::S3Config) -> Self {
            self.s3_config = Some(input);
            self
        }
        /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.</p>
        pub fn set_s3_config(mut self, input: std::option::Option<crate::model::S3Config>) -> Self {
            self.s3_config = input;
            self
        }
        /// Consumes the builder and constructs a [`DataDestination`](crate::model::DataDestination).
        pub fn build(self) -> crate::model::DataDestination {
            crate::model::DataDestination {
                s3_config: self.s3_config,
            }
        }
    }
}
impl DataDestination {
    /// Creates a new builder-style object to manufacture [`DataDestination`](crate::model::DataDestination).
    pub fn builder() -> crate::model::data_destination::Builder {
        crate::model::data_destination::Builder::default()
    }
}

/// <p>The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the <code>DataSource</code> object that is submitted in the <code>CreateDatasetImportJob</code> request, and part of the <code>DataDestination</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Config {
    /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the <code>KMSKeyArn</code> key, the role must allow access to the key.</p>
    /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.</p>
    #[doc(hidden)]
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl S3Config {
    /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the <code>KMSKeyArn</code> key, the role must allow access to the key.</p>
    /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
}
/// See [`S3Config`](crate::model::S3Config).
pub mod s3_config {

    /// A builder for [`S3Config`](crate::model::S3Config).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the <code>KMSKeyArn</code> key, the role must allow access to the key.</p>
        /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the <code>KMSKeyArn</code> key, the role must allow access to the key.</p>
        /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Config`](crate::model::S3Config).
        pub fn build(self) -> crate::model::S3Config {
            crate::model::S3Config {
                path: self.path,
                role_arn: self.role_arn,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl S3Config {
    /// Creates a new builder-style object to manufacture [`S3Config`](crate::model::S3Config).
    pub fn builder() -> crate::model::s3_config::Builder {
        crate::model::s3_config::Builder::default()
    }
}

/// <p>Provides a summary of the what-if analysis properties used in the <code>ListWhatIfAnalyses</code> operation. To get the complete set of properties, call the <code>DescribeWhatIfAnalysis</code> operation, and provide the <code>WhatIfAnalysisArn</code> that is listed in the summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WhatIfAnalysisSummary {
    /// <p>The Amazon Resource Name (ARN) of the what-if analysis.</p>
    #[doc(hidden)]
    pub what_if_analysis_arn: std::option::Option<std::string::String>,
    /// <p>The name of the what-if analysis.</p>
    #[doc(hidden)]
    pub what_if_analysis_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.</p>
    #[doc(hidden)]
    pub forecast_arn: std::option::Option<std::string::String>,
    /// <p>The status of the what-if analysis. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the what-if analysis was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WhatIfAnalysisSummary {
    /// <p>The Amazon Resource Name (ARN) of the what-if analysis.</p>
    pub fn what_if_analysis_arn(&self) -> std::option::Option<&str> {
        self.what_if_analysis_arn.as_deref()
    }
    /// <p>The name of the what-if analysis.</p>
    pub fn what_if_analysis_name(&self) -> std::option::Option<&str> {
        self.what_if_analysis_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.</p>
    pub fn forecast_arn(&self) -> std::option::Option<&str> {
        self.forecast_arn.as_deref()
    }
    /// <p>The status of the what-if analysis. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the what-if analysis was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`WhatIfAnalysisSummary`](crate::model::WhatIfAnalysisSummary).
pub mod what_if_analysis_summary {

    /// A builder for [`WhatIfAnalysisSummary`](crate::model::WhatIfAnalysisSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) what_if_analysis_arn: std::option::Option<std::string::String>,
        pub(crate) what_if_analysis_name: std::option::Option<std::string::String>,
        pub(crate) forecast_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the what-if analysis.</p>
        pub fn what_if_analysis_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.what_if_analysis_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the what-if analysis.</p>
        pub fn set_what_if_analysis_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_analysis_arn = input;
            self
        }
        /// <p>The name of the what-if analysis.</p>
        pub fn what_if_analysis_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.what_if_analysis_name = Some(input.into());
            self
        }
        /// <p>The name of the what-if analysis.</p>
        pub fn set_what_if_analysis_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.what_if_analysis_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.</p>
        pub fn forecast_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.</p>
        pub fn set_forecast_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.forecast_arn = input;
            self
        }
        /// <p>The status of the what-if analysis. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
        /// </note>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the what-if analysis. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the what-if analysis must be <code>ACTIVE</code> before you can access the analysis.</p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the what-if analysis was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the what-if analysis was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WhatIfAnalysisSummary`](crate::model::WhatIfAnalysisSummary).
        pub fn build(self) -> crate::model::WhatIfAnalysisSummary {
            crate::model::WhatIfAnalysisSummary {
                what_if_analysis_arn: self.what_if_analysis_arn,
                what_if_analysis_name: self.what_if_analysis_name,
                forecast_arn: self.forecast_arn,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl WhatIfAnalysisSummary {
    /// Creates a new builder-style object to manufacture [`WhatIfAnalysisSummary`](crate::model::WhatIfAnalysisSummary).
    pub fn builder() -> crate::model::what_if_analysis_summary::Builder {
        crate::model::what_if_analysis_summary::Builder::default()
    }
}

/// <p>Provides a summary of the predictor properties that are used in the <code>ListPredictors</code> operation. To get the complete set of properties, call the <code>DescribePredictor</code> operation, and provide the listed <code>PredictorArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorSummary {
    /// <p>The ARN of the predictor.</p>
    #[doc(hidden)]
    pub predictor_arn: std::option::Option<std::string::String>,
    /// <p>The name of the predictor.</p>
    #[doc(hidden)]
    pub predictor_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.</p>
    #[doc(hidden)]
    pub dataset_group_arn: std::option::Option<std::string::String>,
    /// <p>Whether AutoPredictor was used to create the predictor.</p>
    #[doc(hidden)]
    pub is_auto_predictor: std::option::Option<bool>,
    /// <p>A summary of the reference predictor used if the predictor was retrained or upgraded.</p>
    #[doc(hidden)]
    pub reference_predictor_summary: std::option::Option<crate::model::ReferencePredictorSummary>,
    /// <p>The status of the predictor. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the predictor must be <code>ACTIVE</code> before you can use the predictor to create a forecast.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the model training task was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PredictorSummary {
    /// <p>The ARN of the predictor.</p>
    pub fn predictor_arn(&self) -> std::option::Option<&str> {
        self.predictor_arn.as_deref()
    }
    /// <p>The name of the predictor.</p>
    pub fn predictor_name(&self) -> std::option::Option<&str> {
        self.predictor_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.</p>
    pub fn dataset_group_arn(&self) -> std::option::Option<&str> {
        self.dataset_group_arn.as_deref()
    }
    /// <p>Whether AutoPredictor was used to create the predictor.</p>
    pub fn is_auto_predictor(&self) -> std::option::Option<bool> {
        self.is_auto_predictor
    }
    /// <p>A summary of the reference predictor used if the predictor was retrained or upgraded.</p>
    pub fn reference_predictor_summary(
        &self,
    ) -> std::option::Option<&crate::model::ReferencePredictorSummary> {
        self.reference_predictor_summary.as_ref()
    }
    /// <p>The status of the predictor. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the predictor must be <code>ACTIVE</code> before you can use the predictor to create a forecast.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the model training task was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`PredictorSummary`](crate::model::PredictorSummary).
pub mod predictor_summary {

    /// A builder for [`PredictorSummary`](crate::model::PredictorSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predictor_arn: std::option::Option<std::string::String>,
        pub(crate) predictor_name: std::option::Option<std::string::String>,
        pub(crate) dataset_group_arn: std::option::Option<std::string::String>,
        pub(crate) is_auto_predictor: std::option::Option<bool>,
        pub(crate) reference_predictor_summary:
            std::option::Option<crate::model::ReferencePredictorSummary>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN of the predictor.</p>
        pub fn predictor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.predictor_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the predictor.</p>
        pub fn set_predictor_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.predictor_arn = input;
            self
        }
        /// <p>The name of the predictor.</p>
        pub fn predictor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.predictor_name = Some(input.into());
            self
        }
        /// <p>The name of the predictor.</p>
        pub fn set_predictor_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.predictor_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.</p>
        pub fn dataset_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.</p>
        pub fn set_dataset_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_group_arn = input;
            self
        }
        /// <p>Whether AutoPredictor was used to create the predictor.</p>
        pub fn is_auto_predictor(mut self, input: bool) -> Self {
            self.is_auto_predictor = Some(input);
            self
        }
        /// <p>Whether AutoPredictor was used to create the predictor.</p>
        pub fn set_is_auto_predictor(mut self, input: std::option::Option<bool>) -> Self {
            self.is_auto_predictor = input;
            self
        }
        /// <p>A summary of the reference predictor used if the predictor was retrained or upgraded.</p>
        pub fn reference_predictor_summary(
            mut self,
            input: crate::model::ReferencePredictorSummary,
        ) -> Self {
            self.reference_predictor_summary = Some(input);
            self
        }
        /// <p>A summary of the reference predictor used if the predictor was retrained or upgraded.</p>
        pub fn set_reference_predictor_summary(
            mut self,
            input: std::option::Option<crate::model::ReferencePredictorSummary>,
        ) -> Self {
            self.reference_predictor_summary = input;
            self
        }
        /// <p>The status of the predictor. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the predictor must be <code>ACTIVE</code> before you can use the predictor to create a forecast.</p>
        /// </note>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the predictor. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the predictor must be <code>ACTIVE</code> before you can use the predictor to create a forecast.</p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the model training task was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the model training task was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorSummary`](crate::model::PredictorSummary).
        pub fn build(self) -> crate::model::PredictorSummary {
            crate::model::PredictorSummary {
                predictor_arn: self.predictor_arn,
                predictor_name: self.predictor_name,
                dataset_group_arn: self.dataset_group_arn,
                is_auto_predictor: self.is_auto_predictor,
                reference_predictor_summary: self.reference_predictor_summary,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl PredictorSummary {
    /// Creates a new builder-style object to manufacture [`PredictorSummary`](crate::model::PredictorSummary).
    pub fn builder() -> crate::model::predictor_summary::Builder {
        crate::model::predictor_summary::Builder::default()
    }
}

/// <p>Provides a summary of the reference predictor used when retraining or upgrading a predictor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferencePredictorSummary {
    /// <p>The ARN of the reference predictor.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Whether the reference predictor is <code>Active</code> or <code>Deleted</code>.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::State>,
}
impl ReferencePredictorSummary {
    /// <p>The ARN of the reference predictor.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Whether the reference predictor is <code>Active</code> or <code>Deleted</code>.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::State> {
        self.state.as_ref()
    }
}
/// See [`ReferencePredictorSummary`](crate::model::ReferencePredictorSummary).
pub mod reference_predictor_summary {

    /// A builder for [`ReferencePredictorSummary`](crate::model::ReferencePredictorSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::State>,
    }
    impl Builder {
        /// <p>The ARN of the reference predictor.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the reference predictor.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Whether the reference predictor is <code>Active</code> or <code>Deleted</code>.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Whether the reference predictor is <code>Active</code> or <code>Deleted</code>.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferencePredictorSummary`](crate::model::ReferencePredictorSummary).
        pub fn build(self) -> crate::model::ReferencePredictorSummary {
            crate::model::ReferencePredictorSummary {
                arn: self.arn,
                state: self.state,
            }
        }
    }
}
impl ReferencePredictorSummary {
    /// Creates a new builder-style object to manufacture [`ReferencePredictorSummary`](crate::model::ReferencePredictorSummary).
    pub fn builder() -> crate::model::reference_predictor_summary::Builder {
        crate::model::reference_predictor_summary::Builder::default()
    }
}

/// When writing a match expression against `State`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let state = unimplemented!();
/// match state {
///     State::Active => { /* ... */ },
///     State::Deleted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `state` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `State::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `State::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `State::NewFeature` is defined.
/// Specifically, when `state` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `State::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum State {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "Active" => State::Active,
            "Deleted" => State::Deleted,
            other => State::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for State {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(State::from(s))
    }
}
impl State {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            State::Active => "Active",
            State::Deleted => "Deleted",
            State::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "Deleted"]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of the predictor backtest export job properties used in the <code>ListPredictorBacktestExportJobs</code> operation. To get a complete set of properties, call the <code>DescribePredictorBacktestExportJob</code> operation, and provide the listed <code>PredictorBacktestExportJobArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorBacktestExportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
    #[doc(hidden)]
    pub predictor_backtest_export_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the predictor backtest export job.</p>
    #[doc(hidden)]
    pub predictor_backtest_export_job_name: std::option::Option<std::string::String>,
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::DataDestination>,
    /// <p>The status of the predictor backtest export job. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>Information about any errors that may have occurred during the backtest export.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the predictor backtest export job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PredictorBacktestExportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
    pub fn predictor_backtest_export_job_arn(&self) -> std::option::Option<&str> {
        self.predictor_backtest_export_job_arn.as_deref()
    }
    /// <p>The name of the predictor backtest export job.</p>
    pub fn predictor_backtest_export_job_name(&self) -> std::option::Option<&str> {
        self.predictor_backtest_export_job_name.as_deref()
    }
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    pub fn destination(&self) -> std::option::Option<&crate::model::DataDestination> {
        self.destination.as_ref()
    }
    /// <p>The status of the predictor backtest export job. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Information about any errors that may have occurred during the backtest export.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the predictor backtest export job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`PredictorBacktestExportJobSummary`](crate::model::PredictorBacktestExportJobSummary).
pub mod predictor_backtest_export_job_summary {

    /// A builder for [`PredictorBacktestExportJobSummary`](crate::model::PredictorBacktestExportJobSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predictor_backtest_export_job_arn: std::option::Option<std::string::String>,
        pub(crate) predictor_backtest_export_job_name: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<crate::model::DataDestination>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
        pub fn predictor_backtest_export_job_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.predictor_backtest_export_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
        pub fn set_predictor_backtest_export_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.predictor_backtest_export_job_arn = input;
            self
        }
        /// <p>The name of the predictor backtest export job.</p>
        pub fn predictor_backtest_export_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.predictor_backtest_export_job_name = Some(input.into());
            self
        }
        /// <p>The name of the predictor backtest export job.</p>
        pub fn set_predictor_backtest_export_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.predictor_backtest_export_job_name = input;
            self
        }
        /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
        pub fn destination(mut self, input: crate::model::DataDestination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::DataDestination>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>The status of the predictor backtest export job. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the predictor backtest export job. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about any errors that may have occurred during the backtest export.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Information about any errors that may have occurred during the backtest export.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the predictor backtest export job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the predictor backtest export job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorBacktestExportJobSummary`](crate::model::PredictorBacktestExportJobSummary).
        pub fn build(self) -> crate::model::PredictorBacktestExportJobSummary {
            crate::model::PredictorBacktestExportJobSummary {
                predictor_backtest_export_job_arn: self.predictor_backtest_export_job_arn,
                predictor_backtest_export_job_name: self.predictor_backtest_export_job_name,
                destination: self.destination,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl PredictorBacktestExportJobSummary {
    /// Creates a new builder-style object to manufacture [`PredictorBacktestExportJobSummary`](crate::model::PredictorBacktestExportJobSummary).
    pub fn builder() -> crate::model::predictor_backtest_export_job_summary::Builder {
        crate::model::predictor_backtest_export_job_summary::Builder::default()
    }
}

/// <p>Provides a summary of the monitor properties used in the <code>ListMonitors</code> operation. To get a complete set of properties, call the <code>DescribeMonitor</code> operation, and provide the listed <code>MonitorArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitorSummary {
    /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>The name of the monitor resource.</p>
    #[doc(hidden)]
    pub monitor_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the predictor being monitored.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The status of the monitor. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>When the monitor resource was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the monitor resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>STOPPED</code> - When the resource stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the monitor creation finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl MonitorSummary {
    /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
    /// <p>The name of the monitor resource.</p>
    pub fn monitor_name(&self) -> std::option::Option<&str> {
        self.monitor_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the predictor being monitored.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The status of the monitor. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>When the monitor resource was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the monitor resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>STOPPED</code> - When the resource stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the monitor creation finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`MonitorSummary`](crate::model::MonitorSummary).
pub mod monitor_summary {

    /// A builder for [`MonitorSummary`](crate::model::MonitorSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) monitor_name: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>The name of the monitor resource.</p>
        pub fn monitor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_name = Some(input.into());
            self
        }
        /// <p>The name of the monitor resource.</p>
        pub fn set_monitor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the predictor being monitored.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the predictor being monitored.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The status of the monitor. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the monitor. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>When the monitor resource was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the monitor resource was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the monitor resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>STOPPED</code> - When the resource stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the monitor creation finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the monitor resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>STOPPED</code> - When the resource stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the monitor creation finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitorSummary`](crate::model::MonitorSummary).
        pub fn build(self) -> crate::model::MonitorSummary {
            crate::model::MonitorSummary {
                monitor_arn: self.monitor_arn,
                monitor_name: self.monitor_name,
                resource_arn: self.resource_arn,
                status: self.status,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl MonitorSummary {
    /// Creates a new builder-style object to manufacture [`MonitorSummary`](crate::model::MonitorSummary).
    pub fn builder() -> crate::model::monitor_summary::Builder {
        crate::model::monitor_summary::Builder::default()
    }
}

/// <p>Describes the results of a monitor evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorMonitorEvaluation {
    /// <p>The Amazon Resource Name (ARN) of the resource to monitor.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates when the monitor evaluation was started. </p>
    #[doc(hidden)]
    pub evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the monitor evaluation. The state can be <code>SUCCESS</code> or <code>FAILURE</code>.</p>
    #[doc(hidden)]
    pub evaluation_state: std::option::Option<std::string::String>,
    /// <p>The timestamp that indicates the start of the window that is used for monitor evaluation.</p>
    #[doc(hidden)]
    pub window_start_datetime: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp that indicates the end of the window that is used for monitor evaluation.</p>
    #[doc(hidden)]
    pub window_end_datetime: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides details about a predictor event, such as a retraining.</p>
    #[doc(hidden)]
    pub predictor_event: std::option::Option<crate::model::PredictorEvent>,
    /// <p>The source of the data the monitor resource used during the evaluation.</p>
    #[doc(hidden)]
    pub monitor_data_source: std::option::Option<crate::model::MonitorDataSource>,
    /// <p>A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the <code>Baseline</code> to see how your predictor's performance is changing.</p>
    #[doc(hidden)]
    pub metric_results: std::option::Option<std::vec::Vec<crate::model::MetricResult>>,
    /// <p>The number of items considered during the evaluation.</p>
    #[doc(hidden)]
    pub num_items_evaluated: std::option::Option<i64>,
    /// <p>Information about any errors that may have occurred during the monitor evaluation.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl PredictorMonitorEvaluation {
    /// <p>The Amazon Resource Name (ARN) of the resource to monitor.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
    /// <p>The timestamp that indicates when the monitor evaluation was started. </p>
    pub fn evaluation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.evaluation_time.as_ref()
    }
    /// <p>The status of the monitor evaluation. The state can be <code>SUCCESS</code> or <code>FAILURE</code>.</p>
    pub fn evaluation_state(&self) -> std::option::Option<&str> {
        self.evaluation_state.as_deref()
    }
    /// <p>The timestamp that indicates the start of the window that is used for monitor evaluation.</p>
    pub fn window_start_datetime(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.window_start_datetime.as_ref()
    }
    /// <p>The timestamp that indicates the end of the window that is used for monitor evaluation.</p>
    pub fn window_end_datetime(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.window_end_datetime.as_ref()
    }
    /// <p>Provides details about a predictor event, such as a retraining.</p>
    pub fn predictor_event(&self) -> std::option::Option<&crate::model::PredictorEvent> {
        self.predictor_event.as_ref()
    }
    /// <p>The source of the data the monitor resource used during the evaluation.</p>
    pub fn monitor_data_source(&self) -> std::option::Option<&crate::model::MonitorDataSource> {
        self.monitor_data_source.as_ref()
    }
    /// <p>A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the <code>Baseline</code> to see how your predictor's performance is changing.</p>
    pub fn metric_results(&self) -> std::option::Option<&[crate::model::MetricResult]> {
        self.metric_results.as_deref()
    }
    /// <p>The number of items considered during the evaluation.</p>
    pub fn num_items_evaluated(&self) -> std::option::Option<i64> {
        self.num_items_evaluated
    }
    /// <p>Information about any errors that may have occurred during the monitor evaluation.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`PredictorMonitorEvaluation`](crate::model::PredictorMonitorEvaluation).
pub mod predictor_monitor_evaluation {

    /// A builder for [`PredictorMonitorEvaluation`](crate::model::PredictorMonitorEvaluation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) evaluation_state: std::option::Option<std::string::String>,
        pub(crate) window_start_datetime: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) window_end_datetime: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) predictor_event: std::option::Option<crate::model::PredictorEvent>,
        pub(crate) monitor_data_source: std::option::Option<crate::model::MonitorDataSource>,
        pub(crate) metric_results: std::option::Option<std::vec::Vec<crate::model::MetricResult>>,
        pub(crate) num_items_evaluated: std::option::Option<i64>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource to monitor.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to monitor.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>The timestamp that indicates when the monitor evaluation was started. </p>
        pub fn evaluation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.evaluation_time = Some(input);
            self
        }
        /// <p>The timestamp that indicates when the monitor evaluation was started. </p>
        pub fn set_evaluation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.evaluation_time = input;
            self
        }
        /// <p>The status of the monitor evaluation. The state can be <code>SUCCESS</code> or <code>FAILURE</code>.</p>
        pub fn evaluation_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.evaluation_state = Some(input.into());
            self
        }
        /// <p>The status of the monitor evaluation. The state can be <code>SUCCESS</code> or <code>FAILURE</code>.</p>
        pub fn set_evaluation_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_state = input;
            self
        }
        /// <p>The timestamp that indicates the start of the window that is used for monitor evaluation.</p>
        pub fn window_start_datetime(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.window_start_datetime = Some(input);
            self
        }
        /// <p>The timestamp that indicates the start of the window that is used for monitor evaluation.</p>
        pub fn set_window_start_datetime(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.window_start_datetime = input;
            self
        }
        /// <p>The timestamp that indicates the end of the window that is used for monitor evaluation.</p>
        pub fn window_end_datetime(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.window_end_datetime = Some(input);
            self
        }
        /// <p>The timestamp that indicates the end of the window that is used for monitor evaluation.</p>
        pub fn set_window_end_datetime(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.window_end_datetime = input;
            self
        }
        /// <p>Provides details about a predictor event, such as a retraining.</p>
        pub fn predictor_event(mut self, input: crate::model::PredictorEvent) -> Self {
            self.predictor_event = Some(input);
            self
        }
        /// <p>Provides details about a predictor event, such as a retraining.</p>
        pub fn set_predictor_event(
            mut self,
            input: std::option::Option<crate::model::PredictorEvent>,
        ) -> Self {
            self.predictor_event = input;
            self
        }
        /// <p>The source of the data the monitor resource used during the evaluation.</p>
        pub fn monitor_data_source(mut self, input: crate::model::MonitorDataSource) -> Self {
            self.monitor_data_source = Some(input);
            self
        }
        /// <p>The source of the data the monitor resource used during the evaluation.</p>
        pub fn set_monitor_data_source(
            mut self,
            input: std::option::Option<crate::model::MonitorDataSource>,
        ) -> Self {
            self.monitor_data_source = input;
            self
        }
        /// Appends an item to `metric_results`.
        ///
        /// To override the contents of this collection use [`set_metric_results`](Self::set_metric_results).
        ///
        /// <p>A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the <code>Baseline</code> to see how your predictor's performance is changing.</p>
        pub fn metric_results(mut self, input: crate::model::MetricResult) -> Self {
            let mut v = self.metric_results.unwrap_or_default();
            v.push(input);
            self.metric_results = Some(v);
            self
        }
        /// <p>A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the <code>Baseline</code> to see how your predictor's performance is changing.</p>
        pub fn set_metric_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricResult>>,
        ) -> Self {
            self.metric_results = input;
            self
        }
        /// <p>The number of items considered during the evaluation.</p>
        pub fn num_items_evaluated(mut self, input: i64) -> Self {
            self.num_items_evaluated = Some(input);
            self
        }
        /// <p>The number of items considered during the evaluation.</p>
        pub fn set_num_items_evaluated(mut self, input: std::option::Option<i64>) -> Self {
            self.num_items_evaluated = input;
            self
        }
        /// <p>Information about any errors that may have occurred during the monitor evaluation.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Information about any errors that may have occurred during the monitor evaluation.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorMonitorEvaluation`](crate::model::PredictorMonitorEvaluation).
        pub fn build(self) -> crate::model::PredictorMonitorEvaluation {
            crate::model::PredictorMonitorEvaluation {
                resource_arn: self.resource_arn,
                monitor_arn: self.monitor_arn,
                evaluation_time: self.evaluation_time,
                evaluation_state: self.evaluation_state,
                window_start_datetime: self.window_start_datetime,
                window_end_datetime: self.window_end_datetime,
                predictor_event: self.predictor_event,
                monitor_data_source: self.monitor_data_source,
                metric_results: self.metric_results,
                num_items_evaluated: self.num_items_evaluated,
                message: self.message,
            }
        }
    }
}
impl PredictorMonitorEvaluation {
    /// Creates a new builder-style object to manufacture [`PredictorMonitorEvaluation`](crate::model::PredictorMonitorEvaluation).
    pub fn builder() -> crate::model::predictor_monitor_evaluation::Builder {
        crate::model::predictor_monitor_evaluation::Builder::default()
    }
}

/// <p>An individual metric Forecast calculated when monitoring predictor usage. You can compare the value for this metric to the metric's value in the <code>Baseline</code> to see how your predictor's performance is changing.</p>
/// <p>For more information about metrics generated by Forecast see <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">Evaluating Predictor Accuracy</a> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricResult {
    /// <p>The name of the metric.</p>
    #[doc(hidden)]
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The value for the metric.</p>
    #[doc(hidden)]
    pub metric_value: std::option::Option<f64>,
}
impl MetricResult {
    /// <p>The name of the metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The value for the metric.</p>
    pub fn metric_value(&self) -> std::option::Option<f64> {
        self.metric_value
    }
}
/// See [`MetricResult`](crate::model::MetricResult).
pub mod metric_result {

    /// A builder for [`MetricResult`](crate::model::MetricResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) metric_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value for the metric.</p>
        pub fn metric_value(mut self, input: f64) -> Self {
            self.metric_value = Some(input);
            self
        }
        /// <p>The value for the metric.</p>
        pub fn set_metric_value(mut self, input: std::option::Option<f64>) -> Self {
            self.metric_value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricResult`](crate::model::MetricResult).
        pub fn build(self) -> crate::model::MetricResult {
            crate::model::MetricResult {
                metric_name: self.metric_name,
                metric_value: self.metric_value,
            }
        }
    }
}
impl MetricResult {
    /// Creates a new builder-style object to manufacture [`MetricResult`](crate::model::MetricResult).
    pub fn builder() -> crate::model::metric_result::Builder {
        crate::model::metric_result::Builder::default()
    }
}

/// <p>The source of the data the monitor used during the evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitorDataSource {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.</p>
    #[doc(hidden)]
    pub dataset_import_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.</p>
    #[doc(hidden)]
    pub forecast_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the predictor resource you are monitoring.</p>
    #[doc(hidden)]
    pub predictor_arn: std::option::Option<std::string::String>,
}
impl MonitorDataSource {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.</p>
    pub fn dataset_import_job_arn(&self) -> std::option::Option<&str> {
        self.dataset_import_job_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.</p>
    pub fn forecast_arn(&self) -> std::option::Option<&str> {
        self.forecast_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the predictor resource you are monitoring.</p>
    pub fn predictor_arn(&self) -> std::option::Option<&str> {
        self.predictor_arn.as_deref()
    }
}
/// See [`MonitorDataSource`](crate::model::MonitorDataSource).
pub mod monitor_data_source {

    /// A builder for [`MonitorDataSource`](crate::model::MonitorDataSource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_import_job_arn: std::option::Option<std::string::String>,
        pub(crate) forecast_arn: std::option::Option<std::string::String>,
        pub(crate) predictor_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.</p>
        pub fn dataset_import_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_import_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.</p>
        pub fn set_dataset_import_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_import_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.</p>
        pub fn forecast_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.</p>
        pub fn set_forecast_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.forecast_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the predictor resource you are monitoring.</p>
        pub fn predictor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.predictor_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the predictor resource you are monitoring.</p>
        pub fn set_predictor_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.predictor_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitorDataSource`](crate::model::MonitorDataSource).
        pub fn build(self) -> crate::model::MonitorDataSource {
            crate::model::MonitorDataSource {
                dataset_import_job_arn: self.dataset_import_job_arn,
                forecast_arn: self.forecast_arn,
                predictor_arn: self.predictor_arn,
            }
        }
    }
}
impl MonitorDataSource {
    /// Creates a new builder-style object to manufacture [`MonitorDataSource`](crate::model::MonitorDataSource).
    pub fn builder() -> crate::model::monitor_data_source::Builder {
        crate::model::monitor_data_source::Builder::default()
    }
}

/// <p>Provides details about a predictor event, such as a retraining.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorEvent {
    /// <p>The type of event. For example, <code>Retrain</code>. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the <code>Datetime</code> are from the previous predictor. Any new metrics are for the newly retrained predictor.</p>
    #[doc(hidden)]
    pub detail: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the event occurred.</p>
    #[doc(hidden)]
    pub datetime: std::option::Option<aws_smithy_types::DateTime>,
}
impl PredictorEvent {
    /// <p>The type of event. For example, <code>Retrain</code>. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the <code>Datetime</code> are from the previous predictor. Any new metrics are for the newly retrained predictor.</p>
    pub fn detail(&self) -> std::option::Option<&str> {
        self.detail.as_deref()
    }
    /// <p>The timestamp for when the event occurred.</p>
    pub fn datetime(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.datetime.as_ref()
    }
}
/// See [`PredictorEvent`](crate::model::PredictorEvent).
pub mod predictor_event {

    /// A builder for [`PredictorEvent`](crate::model::PredictorEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detail: std::option::Option<std::string::String>,
        pub(crate) datetime: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The type of event. For example, <code>Retrain</code>. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the <code>Datetime</code> are from the previous predictor. Any new metrics are for the newly retrained predictor.</p>
        pub fn detail(mut self, input: impl Into<std::string::String>) -> Self {
            self.detail = Some(input.into());
            self
        }
        /// <p>The type of event. For example, <code>Retrain</code>. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the <code>Datetime</code> are from the previous predictor. Any new metrics are for the newly retrained predictor.</p>
        pub fn set_detail(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detail = input;
            self
        }
        /// <p>The timestamp for when the event occurred.</p>
        pub fn datetime(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.datetime = Some(input);
            self
        }
        /// <p>The timestamp for when the event occurred.</p>
        pub fn set_datetime(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.datetime = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorEvent`](crate::model::PredictorEvent).
        pub fn build(self) -> crate::model::PredictorEvent {
            crate::model::PredictorEvent {
                detail: self.detail,
                datetime: self.datetime,
            }
        }
    }
}
impl PredictorEvent {
    /// Creates a new builder-style object to manufacture [`PredictorEvent`](crate::model::PredictorEvent).
    pub fn builder() -> crate::model::predictor_event::Builder {
        crate::model::predictor_event::Builder::default()
    }
}

/// <p>Provides a summary of the forecast properties used in the <code>ListForecasts</code> operation. To get the complete set of properties, call the <code>DescribeForecast</code> operation, and provide the <code>ForecastArn</code> that is listed in the summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForecastSummary {
    /// <p>The ARN of the forecast.</p>
    #[doc(hidden)]
    pub forecast_arn: std::option::Option<std::string::String>,
    /// <p>The name of the forecast.</p>
    #[doc(hidden)]
    pub forecast_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the predictor used to generate the forecast.</p>
    #[doc(hidden)]
    pub predictor_arn: std::option::Option<std::string::String>,
    /// <p>Whether the Forecast was created from an AutoPredictor.</p>
    #[doc(hidden)]
    pub created_using_auto_predictor: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.</p>
    #[doc(hidden)]
    pub dataset_group_arn: std::option::Option<std::string::String>,
    /// <p>The status of the forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query or export the forecast.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the forecast creation task was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ForecastSummary {
    /// <p>The ARN of the forecast.</p>
    pub fn forecast_arn(&self) -> std::option::Option<&str> {
        self.forecast_arn.as_deref()
    }
    /// <p>The name of the forecast.</p>
    pub fn forecast_name(&self) -> std::option::Option<&str> {
        self.forecast_name.as_deref()
    }
    /// <p>The ARN of the predictor used to generate the forecast.</p>
    pub fn predictor_arn(&self) -> std::option::Option<&str> {
        self.predictor_arn.as_deref()
    }
    /// <p>Whether the Forecast was created from an AutoPredictor.</p>
    pub fn created_using_auto_predictor(&self) -> std::option::Option<bool> {
        self.created_using_auto_predictor
    }
    /// <p>The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.</p>
    pub fn dataset_group_arn(&self) -> std::option::Option<&str> {
        self.dataset_group_arn.as_deref()
    }
    /// <p>The status of the forecast. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query or export the forecast.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the forecast creation task was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`ForecastSummary`](crate::model::ForecastSummary).
pub mod forecast_summary {

    /// A builder for [`ForecastSummary`](crate::model::ForecastSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) forecast_arn: std::option::Option<std::string::String>,
        pub(crate) forecast_name: std::option::Option<std::string::String>,
        pub(crate) predictor_arn: std::option::Option<std::string::String>,
        pub(crate) created_using_auto_predictor: std::option::Option<bool>,
        pub(crate) dataset_group_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN of the forecast.</p>
        pub fn forecast_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the forecast.</p>
        pub fn set_forecast_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.forecast_arn = input;
            self
        }
        /// <p>The name of the forecast.</p>
        pub fn forecast_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_name = Some(input.into());
            self
        }
        /// <p>The name of the forecast.</p>
        pub fn set_forecast_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forecast_name = input;
            self
        }
        /// <p>The ARN of the predictor used to generate the forecast.</p>
        pub fn predictor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.predictor_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the predictor used to generate the forecast.</p>
        pub fn set_predictor_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.predictor_arn = input;
            self
        }
        /// <p>Whether the Forecast was created from an AutoPredictor.</p>
        pub fn created_using_auto_predictor(mut self, input: bool) -> Self {
            self.created_using_auto_predictor = Some(input);
            self
        }
        /// <p>Whether the Forecast was created from an AutoPredictor.</p>
        pub fn set_created_using_auto_predictor(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.created_using_auto_predictor = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.</p>
        pub fn dataset_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.</p>
        pub fn set_dataset_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_group_arn = input;
            self
        }
        /// <p>The status of the forecast. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query or export the forecast.</p>
        /// </note>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the forecast. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query or export the forecast.</p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the forecast creation task was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the forecast creation task was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ForecastSummary`](crate::model::ForecastSummary).
        pub fn build(self) -> crate::model::ForecastSummary {
            crate::model::ForecastSummary {
                forecast_arn: self.forecast_arn,
                forecast_name: self.forecast_name,
                predictor_arn: self.predictor_arn,
                created_using_auto_predictor: self.created_using_auto_predictor,
                dataset_group_arn: self.dataset_group_arn,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl ForecastSummary {
    /// Creates a new builder-style object to manufacture [`ForecastSummary`](crate::model::ForecastSummary).
    pub fn builder() -> crate::model::forecast_summary::Builder {
        crate::model::forecast_summary::Builder::default()
    }
}

/// <p>Provides a summary of the forecast export job properties used in the <code>ListForecastExportJobs</code> operation. To get the complete set of properties, call the <code>DescribeForecastExportJob</code> operation, and provide the listed <code>ForecastExportJobArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForecastExportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the forecast export job.</p>
    #[doc(hidden)]
    pub forecast_export_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the forecast export job.</p>
    #[doc(hidden)]
    pub forecast_export_job_name: std::option::Option<std::string::String>,
    /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::DataDestination>,
    /// <p>The status of the forecast export job. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before you can access the forecast in your S3 bucket.</p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the forecast export job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ForecastExportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the forecast export job.</p>
    pub fn forecast_export_job_arn(&self) -> std::option::Option<&str> {
        self.forecast_export_job_arn.as_deref()
    }
    /// <p>The name of the forecast export job.</p>
    pub fn forecast_export_job_name(&self) -> std::option::Option<&str> {
        self.forecast_export_job_name.as_deref()
    }
    /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
    pub fn destination(&self) -> std::option::Option<&crate::model::DataDestination> {
        self.destination.as_ref()
    }
    /// <p>The status of the forecast export job. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul> <note>
    /// <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before you can access the forecast in your S3 bucket.</p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the forecast export job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`ForecastExportJobSummary`](crate::model::ForecastExportJobSummary).
pub mod forecast_export_job_summary {

    /// A builder for [`ForecastExportJobSummary`](crate::model::ForecastExportJobSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) forecast_export_job_arn: std::option::Option<std::string::String>,
        pub(crate) forecast_export_job_name: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<crate::model::DataDestination>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the forecast export job.</p>
        pub fn forecast_export_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_export_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the forecast export job.</p>
        pub fn set_forecast_export_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forecast_export_job_arn = input;
            self
        }
        /// <p>The name of the forecast export job.</p>
        pub fn forecast_export_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_export_job_name = Some(input.into());
            self
        }
        /// <p>The name of the forecast export job.</p>
        pub fn set_forecast_export_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forecast_export_job_name = input;
            self
        }
        /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
        pub fn destination(mut self, input: crate::model::DataDestination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::DataDestination>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>The status of the forecast export job. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before you can access the forecast in your S3 bucket.</p>
        /// </note>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the forecast export job. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul> <note>
        /// <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before you can access the forecast in your S3 bucket.</p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the forecast export job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the forecast export job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ForecastExportJobSummary`](crate::model::ForecastExportJobSummary).
        pub fn build(self) -> crate::model::ForecastExportJobSummary {
            crate::model::ForecastExportJobSummary {
                forecast_export_job_arn: self.forecast_export_job_arn,
                forecast_export_job_name: self.forecast_export_job_name,
                destination: self.destination,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl ForecastExportJobSummary {
    /// Creates a new builder-style object to manufacture [`ForecastExportJobSummary`](crate::model::ForecastExportJobSummary).
    pub fn builder() -> crate::model::forecast_export_job_summary::Builder {
        crate::model::forecast_export_job_summary::Builder::default()
    }
}

/// <p>Provides a summary of the Explainability export properties used in the <code>ListExplainabilityExports</code> operation. To get a complete set of properties, call the <code>DescribeExplainabilityExport</code> operation, and provide the <code>ExplainabilityExportArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExplainabilityExportSummary {
    /// <p>The Amazon Resource Name (ARN) of the Explainability export.</p>
    #[doc(hidden)]
    pub explainability_export_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Explainability export</p>
    #[doc(hidden)]
    pub explainability_export_name: std::option::Option<std::string::String>,
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::DataDestination>,
    /// <p>The status of the Explainability export. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>Information about any errors that may have occurred during the Explainability export.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the Explainability was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ExplainabilityExportSummary {
    /// <p>The Amazon Resource Name (ARN) of the Explainability export.</p>
    pub fn explainability_export_arn(&self) -> std::option::Option<&str> {
        self.explainability_export_arn.as_deref()
    }
    /// <p>The name of the Explainability export</p>
    pub fn explainability_export_name(&self) -> std::option::Option<&str> {
        self.explainability_export_name.as_deref()
    }
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    pub fn destination(&self) -> std::option::Option<&crate::model::DataDestination> {
        self.destination.as_ref()
    }
    /// <p>The status of the Explainability export. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Information about any errors that may have occurred during the Explainability export.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the Explainability was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`ExplainabilityExportSummary`](crate::model::ExplainabilityExportSummary).
pub mod explainability_export_summary {

    /// A builder for [`ExplainabilityExportSummary`](crate::model::ExplainabilityExportSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) explainability_export_arn: std::option::Option<std::string::String>,
        pub(crate) explainability_export_name: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<crate::model::DataDestination>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Explainability export.</p>
        pub fn explainability_export_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability_export_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Explainability export.</p>
        pub fn set_explainability_export_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability_export_arn = input;
            self
        }
        /// <p>The name of the Explainability export</p>
        pub fn explainability_export_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability_export_name = Some(input.into());
            self
        }
        /// <p>The name of the Explainability export</p>
        pub fn set_explainability_export_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability_export_name = input;
            self
        }
        /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
        pub fn destination(mut self, input: crate::model::DataDestination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::DataDestination>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>The status of the Explainability export. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the Explainability export. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about any errors that may have occurred during the Explainability export.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Information about any errors that may have occurred during the Explainability export.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the Explainability was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the Explainability was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ExplainabilityExportSummary`](crate::model::ExplainabilityExportSummary).
        pub fn build(self) -> crate::model::ExplainabilityExportSummary {
            crate::model::ExplainabilityExportSummary {
                explainability_export_arn: self.explainability_export_arn,
                explainability_export_name: self.explainability_export_name,
                destination: self.destination,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl ExplainabilityExportSummary {
    /// Creates a new builder-style object to manufacture [`ExplainabilityExportSummary`](crate::model::ExplainabilityExportSummary).
    pub fn builder() -> crate::model::explainability_export_summary::Builder {
        crate::model::explainability_export_summary::Builder::default()
    }
}

/// <p>Provides a summary of the Explainability properties used in the <code>ListExplainabilities</code> operation. To get a complete set of properties, call the <code>DescribeExplainability</code> operation, and provide the listed <code>ExplainabilityArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExplainabilitySummary {
    /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
    #[doc(hidden)]
    pub explainability_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Explainability.</p>
    #[doc(hidden)]
    pub explainability_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The configuration settings that define the granularity of time series and time points for the Explainability.</p>
    #[doc(hidden)]
    pub explainability_config: std::option::Option<crate::model::ExplainabilityConfig>,
    /// <p>The status of the Explainability. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>Information about any errors that may have occurred during the Explainability creation process.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the Explainability was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ExplainabilitySummary {
    /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
    pub fn explainability_arn(&self) -> std::option::Option<&str> {
        self.explainability_arn.as_deref()
    }
    /// <p>The name of the Explainability.</p>
    pub fn explainability_name(&self) -> std::option::Option<&str> {
        self.explainability_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The configuration settings that define the granularity of time series and time points for the Explainability.</p>
    pub fn explainability_config(
        &self,
    ) -> std::option::Option<&crate::model::ExplainabilityConfig> {
        self.explainability_config.as_ref()
    }
    /// <p>The status of the Explainability. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Information about any errors that may have occurred during the Explainability creation process.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the Explainability was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`ExplainabilitySummary`](crate::model::ExplainabilitySummary).
pub mod explainability_summary {

    /// A builder for [`ExplainabilitySummary`](crate::model::ExplainabilitySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) explainability_arn: std::option::Option<std::string::String>,
        pub(crate) explainability_name: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) explainability_config: std::option::Option<crate::model::ExplainabilityConfig>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
        pub fn explainability_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
        pub fn set_explainability_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability_arn = input;
            self
        }
        /// <p>The name of the Explainability.</p>
        pub fn explainability_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability_name = Some(input.into());
            self
        }
        /// <p>The name of the Explainability.</p>
        pub fn set_explainability_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The configuration settings that define the granularity of time series and time points for the Explainability.</p>
        pub fn explainability_config(mut self, input: crate::model::ExplainabilityConfig) -> Self {
            self.explainability_config = Some(input);
            self
        }
        /// <p>The configuration settings that define the granularity of time series and time points for the Explainability.</p>
        pub fn set_explainability_config(
            mut self,
            input: std::option::Option<crate::model::ExplainabilityConfig>,
        ) -> Self {
            self.explainability_config = input;
            self
        }
        /// <p>The status of the Explainability. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the Explainability. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about any errors that may have occurred during the Explainability creation process.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Information about any errors that may have occurred during the Explainability creation process.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the Explainability was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the Explainability was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ExplainabilitySummary`](crate::model::ExplainabilitySummary).
        pub fn build(self) -> crate::model::ExplainabilitySummary {
            crate::model::ExplainabilitySummary {
                explainability_arn: self.explainability_arn,
                explainability_name: self.explainability_name,
                resource_arn: self.resource_arn,
                explainability_config: self.explainability_config,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl ExplainabilitySummary {
    /// Creates a new builder-style object to manufacture [`ExplainabilitySummary`](crate::model::ExplainabilitySummary).
    pub fn builder() -> crate::model::explainability_summary::Builder {
        crate::model::explainability_summary::Builder::default()
    }
}

/// <p>The ExplainabilityConfig data type defines the number of time series and time points included in <code>CreateExplainability</code>.</p>
/// <p>If you provide a predictor ARN for <code>ResourceArn</code>, you must set both <code>TimePointGranularity</code> and <code>TimeSeriesGranularity</code> to “ALL”. When creating Predictor Explainability, Amazon Forecast considers all time series and time points.</p>
/// <p>If you provide a forecast ARN for <code>ResourceArn</code>, you can set <code>TimePointGranularity</code> and <code>TimeSeriesGranularity</code> to either “ALL” or “Specific”.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExplainabilityConfig {
    /// <p>To create an Explainability for all time series in your datasets, use <code>ALL</code>. To create an Explainability for specific time series in your datasets, use <code>SPECIFIC</code>.</p>
    /// <p>Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the <code>DataDestination</code> data type.</p>
    #[doc(hidden)]
    pub time_series_granularity: std::option::Option<crate::model::TimeSeriesGranularity>,
    /// <p>To create an Explainability for all time points in your forecast horizon, use <code>ALL</code>. To create an Explainability for specific time points in your forecast horizon, use <code>SPECIFIC</code>.</p>
    /// <p>Specify time points with the <code>StartDateTime</code> and <code>EndDateTime</code> parameters within the <code>CreateExplainability</code> operation.</p>
    #[doc(hidden)]
    pub time_point_granularity: std::option::Option<crate::model::TimePointGranularity>,
}
impl ExplainabilityConfig {
    /// <p>To create an Explainability for all time series in your datasets, use <code>ALL</code>. To create an Explainability for specific time series in your datasets, use <code>SPECIFIC</code>.</p>
    /// <p>Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the <code>DataDestination</code> data type.</p>
    pub fn time_series_granularity(
        &self,
    ) -> std::option::Option<&crate::model::TimeSeriesGranularity> {
        self.time_series_granularity.as_ref()
    }
    /// <p>To create an Explainability for all time points in your forecast horizon, use <code>ALL</code>. To create an Explainability for specific time points in your forecast horizon, use <code>SPECIFIC</code>.</p>
    /// <p>Specify time points with the <code>StartDateTime</code> and <code>EndDateTime</code> parameters within the <code>CreateExplainability</code> operation.</p>
    pub fn time_point_granularity(
        &self,
    ) -> std::option::Option<&crate::model::TimePointGranularity> {
        self.time_point_granularity.as_ref()
    }
}
/// See [`ExplainabilityConfig`](crate::model::ExplainabilityConfig).
pub mod explainability_config {

    /// A builder for [`ExplainabilityConfig`](crate::model::ExplainabilityConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_series_granularity:
            std::option::Option<crate::model::TimeSeriesGranularity>,
        pub(crate) time_point_granularity: std::option::Option<crate::model::TimePointGranularity>,
    }
    impl Builder {
        /// <p>To create an Explainability for all time series in your datasets, use <code>ALL</code>. To create an Explainability for specific time series in your datasets, use <code>SPECIFIC</code>.</p>
        /// <p>Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the <code>DataDestination</code> data type.</p>
        pub fn time_series_granularity(
            mut self,
            input: crate::model::TimeSeriesGranularity,
        ) -> Self {
            self.time_series_granularity = Some(input);
            self
        }
        /// <p>To create an Explainability for all time series in your datasets, use <code>ALL</code>. To create an Explainability for specific time series in your datasets, use <code>SPECIFIC</code>.</p>
        /// <p>Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the <code>DataDestination</code> data type.</p>
        pub fn set_time_series_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeSeriesGranularity>,
        ) -> Self {
            self.time_series_granularity = input;
            self
        }
        /// <p>To create an Explainability for all time points in your forecast horizon, use <code>ALL</code>. To create an Explainability for specific time points in your forecast horizon, use <code>SPECIFIC</code>.</p>
        /// <p>Specify time points with the <code>StartDateTime</code> and <code>EndDateTime</code> parameters within the <code>CreateExplainability</code> operation.</p>
        pub fn time_point_granularity(mut self, input: crate::model::TimePointGranularity) -> Self {
            self.time_point_granularity = Some(input);
            self
        }
        /// <p>To create an Explainability for all time points in your forecast horizon, use <code>ALL</code>. To create an Explainability for specific time points in your forecast horizon, use <code>SPECIFIC</code>.</p>
        /// <p>Specify time points with the <code>StartDateTime</code> and <code>EndDateTime</code> parameters within the <code>CreateExplainability</code> operation.</p>
        pub fn set_time_point_granularity(
            mut self,
            input: std::option::Option<crate::model::TimePointGranularity>,
        ) -> Self {
            self.time_point_granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`ExplainabilityConfig`](crate::model::ExplainabilityConfig).
        pub fn build(self) -> crate::model::ExplainabilityConfig {
            crate::model::ExplainabilityConfig {
                time_series_granularity: self.time_series_granularity,
                time_point_granularity: self.time_point_granularity,
            }
        }
    }
}
impl ExplainabilityConfig {
    /// Creates a new builder-style object to manufacture [`ExplainabilityConfig`](crate::model::ExplainabilityConfig).
    pub fn builder() -> crate::model::explainability_config::Builder {
        crate::model::explainability_config::Builder::default()
    }
}

/// When writing a match expression against `TimePointGranularity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timepointgranularity = unimplemented!();
/// match timepointgranularity {
///     TimePointGranularity::All => { /* ... */ },
///     TimePointGranularity::Specific => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timepointgranularity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimePointGranularity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimePointGranularity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimePointGranularity::NewFeature` is defined.
/// Specifically, when `timepointgranularity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimePointGranularity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimePointGranularity {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Specific,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimePointGranularity {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => TimePointGranularity::All,
            "SPECIFIC" => TimePointGranularity::Specific,
            other => {
                TimePointGranularity::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TimePointGranularity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimePointGranularity::from(s))
    }
}
impl TimePointGranularity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimePointGranularity::All => "ALL",
            TimePointGranularity::Specific => "SPECIFIC",
            TimePointGranularity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "SPECIFIC"]
    }
}
impl AsRef<str> for TimePointGranularity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TimeSeriesGranularity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timeseriesgranularity = unimplemented!();
/// match timeseriesgranularity {
///     TimeSeriesGranularity::All => { /* ... */ },
///     TimeSeriesGranularity::Specific => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timeseriesgranularity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimeSeriesGranularity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimeSeriesGranularity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimeSeriesGranularity::NewFeature` is defined.
/// Specifically, when `timeseriesgranularity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimeSeriesGranularity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimeSeriesGranularity {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Specific,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimeSeriesGranularity {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => TimeSeriesGranularity::All,
            "SPECIFIC" => TimeSeriesGranularity::Specific,
            other => {
                TimeSeriesGranularity::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TimeSeriesGranularity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimeSeriesGranularity::from(s))
    }
}
impl TimeSeriesGranularity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimeSeriesGranularity::All => "ALL",
            TimeSeriesGranularity::Specific => "SPECIFIC",
            TimeSeriesGranularity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "SPECIFIC"]
    }
}
impl AsRef<str> for TimeSeriesGranularity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of the dataset properties used in the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasets.html">ListDatasets</a> operation. To get the complete set of properties, call the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDataset.html">DescribeDataset</a> operation, and provide the <code>DatasetArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    #[doc(hidden)]
    pub dataset_arn: std::option::Option<std::string::String>,
    /// <p>The name of the dataset.</p>
    #[doc(hidden)]
    pub dataset_name: std::option::Option<std::string::String>,
    /// <p>The dataset type.</p>
    #[doc(hidden)]
    pub dataset_type: std::option::Option<crate::model::DatasetType>,
    /// <p>The domain associated with the dataset.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<crate::model::Domain>,
    /// <p>When the dataset was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When you create a dataset, <code>LastModificationTime</code> is the same as <code>CreationTime</code>. While data is being imported to the dataset, <code>LastModificationTime</code> is the current time of the <code>ListDatasets</code> call. After a <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html">CreateDatasetImportJob</a> operation has finished, <code>LastModificationTime</code> is when the import job completed or failed.</p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DatasetSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    pub fn dataset_arn(&self) -> std::option::Option<&str> {
        self.dataset_arn.as_deref()
    }
    /// <p>The name of the dataset.</p>
    pub fn dataset_name(&self) -> std::option::Option<&str> {
        self.dataset_name.as_deref()
    }
    /// <p>The dataset type.</p>
    pub fn dataset_type(&self) -> std::option::Option<&crate::model::DatasetType> {
        self.dataset_type.as_ref()
    }
    /// <p>The domain associated with the dataset.</p>
    pub fn domain(&self) -> std::option::Option<&crate::model::Domain> {
        self.domain.as_ref()
    }
    /// <p>When the dataset was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When you create a dataset, <code>LastModificationTime</code> is the same as <code>CreationTime</code>. While data is being imported to the dataset, <code>LastModificationTime</code> is the current time of the <code>ListDatasets</code> call. After a <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html">CreateDatasetImportJob</a> operation has finished, <code>LastModificationTime</code> is when the import job completed or failed.</p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`DatasetSummary`](crate::model::DatasetSummary).
pub mod dataset_summary {

    /// A builder for [`DatasetSummary`](crate::model::DatasetSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_arn: std::option::Option<std::string::String>,
        pub(crate) dataset_name: std::option::Option<std::string::String>,
        pub(crate) dataset_type: std::option::Option<crate::model::DatasetType>,
        pub(crate) domain: std::option::Option<crate::model::Domain>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
        pub fn dataset_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
        pub fn set_dataset_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_arn = input;
            self
        }
        /// <p>The name of the dataset.</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_name = Some(input.into());
            self
        }
        /// <p>The name of the dataset.</p>
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_name = input;
            self
        }
        /// <p>The dataset type.</p>
        pub fn dataset_type(mut self, input: crate::model::DatasetType) -> Self {
            self.dataset_type = Some(input);
            self
        }
        /// <p>The dataset type.</p>
        pub fn set_dataset_type(
            mut self,
            input: std::option::Option<crate::model::DatasetType>,
        ) -> Self {
            self.dataset_type = input;
            self
        }
        /// <p>The domain associated with the dataset.</p>
        pub fn domain(mut self, input: crate::model::Domain) -> Self {
            self.domain = Some(input);
            self
        }
        /// <p>The domain associated with the dataset.</p>
        pub fn set_domain(mut self, input: std::option::Option<crate::model::Domain>) -> Self {
            self.domain = input;
            self
        }
        /// <p>When the dataset was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the dataset was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When you create a dataset, <code>LastModificationTime</code> is the same as <code>CreationTime</code>. While data is being imported to the dataset, <code>LastModificationTime</code> is the current time of the <code>ListDatasets</code> call. After a <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html">CreateDatasetImportJob</a> operation has finished, <code>LastModificationTime</code> is when the import job completed or failed.</p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>When you create a dataset, <code>LastModificationTime</code> is the same as <code>CreationTime</code>. While data is being imported to the dataset, <code>LastModificationTime</code> is the current time of the <code>ListDatasets</code> call. After a <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html">CreateDatasetImportJob</a> operation has finished, <code>LastModificationTime</code> is when the import job completed or failed.</p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetSummary`](crate::model::DatasetSummary).
        pub fn build(self) -> crate::model::DatasetSummary {
            crate::model::DatasetSummary {
                dataset_arn: self.dataset_arn,
                dataset_name: self.dataset_name,
                dataset_type: self.dataset_type,
                domain: self.domain,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl DatasetSummary {
    /// Creates a new builder-style object to manufacture [`DatasetSummary`](crate::model::DatasetSummary).
    pub fn builder() -> crate::model::dataset_summary::Builder {
        crate::model::dataset_summary::Builder::default()
    }
}

/// When writing a match expression against `Domain`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let domain = unimplemented!();
/// match domain {
///     Domain::Custom => { /* ... */ },
///     Domain::Ec2Capacity => { /* ... */ },
///     Domain::InventoryPlanning => { /* ... */ },
///     Domain::Metrics => { /* ... */ },
///     Domain::Retail => { /* ... */ },
///     Domain::WebTraffic => { /* ... */ },
///     Domain::WorkForce => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `domain` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Domain::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Domain::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Domain::NewFeature` is defined.
/// Specifically, when `domain` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Domain::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Domain {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Ec2Capacity,
    #[allow(missing_docs)] // documentation missing in model
    InventoryPlanning,
    #[allow(missing_docs)] // documentation missing in model
    Metrics,
    #[allow(missing_docs)] // documentation missing in model
    Retail,
    #[allow(missing_docs)] // documentation missing in model
    WebTraffic,
    #[allow(missing_docs)] // documentation missing in model
    WorkForce,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Domain {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => Domain::Custom,
            "EC2_CAPACITY" => Domain::Ec2Capacity,
            "INVENTORY_PLANNING" => Domain::InventoryPlanning,
            "METRICS" => Domain::Metrics,
            "RETAIL" => Domain::Retail,
            "WEB_TRAFFIC" => Domain::WebTraffic,
            "WORK_FORCE" => Domain::WorkForce,
            other => Domain::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Domain {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Domain::from(s))
    }
}
impl Domain {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Domain::Custom => "CUSTOM",
            Domain::Ec2Capacity => "EC2_CAPACITY",
            Domain::InventoryPlanning => "INVENTORY_PLANNING",
            Domain::Metrics => "METRICS",
            Domain::Retail => "RETAIL",
            Domain::WebTraffic => "WEB_TRAFFIC",
            Domain::WorkForce => "WORK_FORCE",
            Domain::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CUSTOM",
            "EC2_CAPACITY",
            "INVENTORY_PLANNING",
            "METRICS",
            "RETAIL",
            "WEB_TRAFFIC",
            "WORK_FORCE",
        ]
    }
}
impl AsRef<str> for Domain {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DatasetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasettype = unimplemented!();
/// match datasettype {
///     DatasetType::ItemMetadata => { /* ... */ },
///     DatasetType::RelatedTimeSeries => { /* ... */ },
///     DatasetType::TargetTimeSeries => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DatasetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DatasetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DatasetType::NewFeature` is defined.
/// Specifically, when `datasettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DatasetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatasetType {
    #[allow(missing_docs)] // documentation missing in model
    ItemMetadata,
    #[allow(missing_docs)] // documentation missing in model
    RelatedTimeSeries,
    #[allow(missing_docs)] // documentation missing in model
    TargetTimeSeries,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DatasetType {
    fn from(s: &str) -> Self {
        match s {
            "ITEM_METADATA" => DatasetType::ItemMetadata,
            "RELATED_TIME_SERIES" => DatasetType::RelatedTimeSeries,
            "TARGET_TIME_SERIES" => DatasetType::TargetTimeSeries,
            other => DatasetType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DatasetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatasetType::from(s))
    }
}
impl DatasetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DatasetType::ItemMetadata => "ITEM_METADATA",
            DatasetType::RelatedTimeSeries => "RELATED_TIME_SERIES",
            DatasetType::TargetTimeSeries => "TARGET_TIME_SERIES",
            DatasetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ITEM_METADATA", "RELATED_TIME_SERIES", "TARGET_TIME_SERIES"]
    }
}
impl AsRef<str> for DatasetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of the dataset import job properties used in the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetImportJobs.html">ListDatasetImportJobs</a> operation. To get the complete set of properties, call the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetImportJob.html">DescribeDatasetImportJob</a> operation, and provide the <code>DatasetImportJobArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetImportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
    #[doc(hidden)]
    pub dataset_import_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the dataset import job.</p>
    #[doc(hidden)]
    pub dataset_import_job_name: std::option::Option<std::string::String>,
    /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
    /// <p>If encryption is used, <code>DataSource</code> includes an AWS Key Management Service (KMS) key.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>The status of the dataset import job. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If an error occurred, an informational message about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>When the dataset import job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DatasetImportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
    pub fn dataset_import_job_arn(&self) -> std::option::Option<&str> {
        self.dataset_import_job_arn.as_deref()
    }
    /// <p>The name of the dataset import job.</p>
    pub fn dataset_import_job_name(&self) -> std::option::Option<&str> {
        self.dataset_import_job_name.as_deref()
    }
    /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
    /// <p>If encryption is used, <code>DataSource</code> includes an AWS Key Management Service (KMS) key.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>The status of the dataset import job. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If an error occurred, an informational message about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>When the dataset import job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
    /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
    /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
    /// </ul>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`DatasetImportJobSummary`](crate::model::DatasetImportJobSummary).
pub mod dataset_import_job_summary {

    /// A builder for [`DatasetImportJobSummary`](crate::model::DatasetImportJobSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_import_job_arn: std::option::Option<std::string::String>,
        pub(crate) dataset_import_job_name: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
        pub fn dataset_import_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_import_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
        pub fn set_dataset_import_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_import_job_arn = input;
            self
        }
        /// <p>The name of the dataset import job.</p>
        pub fn dataset_import_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_import_job_name = Some(input.into());
            self
        }
        /// <p>The name of the dataset import job.</p>
        pub fn set_dataset_import_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_import_job_name = input;
            self
        }
        /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
        /// <p>If encryption is used, <code>DataSource</code> includes an AWS Key Management Service (KMS) key.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
        /// <p>If encryption is used, <code>DataSource</code> includes an AWS Key Management Service (KMS) key.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The status of the dataset import job. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the dataset import job. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If an error occurred, an informational message about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>When the dataset import job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the dataset import job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code> - The current timestamp.</p> </li>
        /// <li> <p> <code>CREATE_STOPPED</code> - When the job stopped.</p> </li>
        /// <li> <p> <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or failed.</p> </li>
        /// </ul>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetImportJobSummary`](crate::model::DatasetImportJobSummary).
        pub fn build(self) -> crate::model::DatasetImportJobSummary {
            crate::model::DatasetImportJobSummary {
                dataset_import_job_arn: self.dataset_import_job_arn,
                dataset_import_job_name: self.dataset_import_job_name,
                data_source: self.data_source,
                status: self.status,
                message: self.message,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl DatasetImportJobSummary {
    /// Creates a new builder-style object to manufacture [`DatasetImportJobSummary`](crate::model::DatasetImportJobSummary).
    pub fn builder() -> crate::model::dataset_import_job_summary::Builder {
        crate::model::dataset_import_job_summary::Builder::default()
    }
}

/// <p>The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSource {
    /// <p>The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.</p>
    #[doc(hidden)]
    pub s3_config: std::option::Option<crate::model::S3Config>,
}
impl DataSource {
    /// <p>The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.</p>
    pub fn s3_config(&self) -> std::option::Option<&crate::model::S3Config> {
        self.s3_config.as_ref()
    }
}
/// See [`DataSource`](crate::model::DataSource).
pub mod data_source {

    /// A builder for [`DataSource`](crate::model::DataSource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_config: std::option::Option<crate::model::S3Config>,
    }
    impl Builder {
        /// <p>The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.</p>
        pub fn s3_config(mut self, input: crate::model::S3Config) -> Self {
            self.s3_config = Some(input);
            self
        }
        /// <p>The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.</p>
        pub fn set_s3_config(mut self, input: std::option::Option<crate::model::S3Config>) -> Self {
            self.s3_config = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSource`](crate::model::DataSource).
        pub fn build(self) -> crate::model::DataSource {
            crate::model::DataSource {
                s3_config: self.s3_config,
            }
        }
    }
}
impl DataSource {
    /// Creates a new builder-style object to manufacture [`DataSource`](crate::model::DataSource).
    pub fn builder() -> crate::model::data_source::Builder {
        crate::model::data_source::Builder::default()
    }
}

/// <p>Provides a summary of the dataset group properties used in the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetGroups.html">ListDatasetGroups</a> operation. To get the complete set of properties, call the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetGroup.html">DescribeDatasetGroup</a> operation, and provide the <code>DatasetGroupArn</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetGroupSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    #[doc(hidden)]
    pub dataset_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the dataset group.</p>
    #[doc(hidden)]
    pub dataset_group_name: std::option::Option<std::string::String>,
    /// <p>When the dataset group was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the dataset group was created or last updated from a call to the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html">UpdateDatasetGroup</a> operation. While the dataset group is being updated, <code>LastModificationTime</code> is the current time of the <code>ListDatasetGroups</code> call.</p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DatasetGroupSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    pub fn dataset_group_arn(&self) -> std::option::Option<&str> {
        self.dataset_group_arn.as_deref()
    }
    /// <p>The name of the dataset group.</p>
    pub fn dataset_group_name(&self) -> std::option::Option<&str> {
        self.dataset_group_name.as_deref()
    }
    /// <p>When the dataset group was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the dataset group was created or last updated from a call to the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html">UpdateDatasetGroup</a> operation. While the dataset group is being updated, <code>LastModificationTime</code> is the current time of the <code>ListDatasetGroups</code> call.</p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`DatasetGroupSummary`](crate::model::DatasetGroupSummary).
pub mod dataset_group_summary {

    /// A builder for [`DatasetGroupSummary`](crate::model::DatasetGroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_group_arn: std::option::Option<std::string::String>,
        pub(crate) dataset_group_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
        pub fn dataset_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
        pub fn set_dataset_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_group_arn = input;
            self
        }
        /// <p>The name of the dataset group.</p>
        pub fn dataset_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_group_name = Some(input.into());
            self
        }
        /// <p>The name of the dataset group.</p>
        pub fn set_dataset_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_group_name = input;
            self
        }
        /// <p>When the dataset group was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the dataset group was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the dataset group was created or last updated from a call to the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html">UpdateDatasetGroup</a> operation. While the dataset group is being updated, <code>LastModificationTime</code> is the current time of the <code>ListDatasetGroups</code> call.</p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>When the dataset group was created or last updated from a call to the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html">UpdateDatasetGroup</a> operation. While the dataset group is being updated, <code>LastModificationTime</code> is the current time of the <code>ListDatasetGroups</code> call.</p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetGroupSummary`](crate::model::DatasetGroupSummary).
        pub fn build(self) -> crate::model::DatasetGroupSummary {
            crate::model::DatasetGroupSummary {
                dataset_group_arn: self.dataset_group_arn,
                dataset_group_name: self.dataset_group_name,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl DatasetGroupSummary {
    /// Creates a new builder-style object to manufacture [`DatasetGroupSummary`](crate::model::DatasetGroupSummary).
    pub fn builder() -> crate::model::dataset_group_summary::Builder {
        crate::model::dataset_group_summary::Builder::default()
    }
}

/// When writing a match expression against `OptimizationMetric`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let optimizationmetric = unimplemented!();
/// match optimizationmetric {
///     OptimizationMetric::AverageWeightedQuantileLoss => { /* ... */ },
///     OptimizationMetric::Mape => { /* ... */ },
///     OptimizationMetric::Mase => { /* ... */ },
///     OptimizationMetric::Rmse => { /* ... */ },
///     OptimizationMetric::Wape => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `optimizationmetric` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OptimizationMetric::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OptimizationMetric::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OptimizationMetric::NewFeature` is defined.
/// Specifically, when `optimizationmetric` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OptimizationMetric::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OptimizationMetric {
    #[allow(missing_docs)] // documentation missing in model
    AverageWeightedQuantileLoss,
    #[allow(missing_docs)] // documentation missing in model
    Mape,
    #[allow(missing_docs)] // documentation missing in model
    Mase,
    #[allow(missing_docs)] // documentation missing in model
    Rmse,
    #[allow(missing_docs)] // documentation missing in model
    Wape,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OptimizationMetric {
    fn from(s: &str) -> Self {
        match s {
            "AverageWeightedQuantileLoss" => OptimizationMetric::AverageWeightedQuantileLoss,
            "MAPE" => OptimizationMetric::Mape,
            "MASE" => OptimizationMetric::Mase,
            "RMSE" => OptimizationMetric::Rmse,
            "WAPE" => OptimizationMetric::Wape,
            other => {
                OptimizationMetric::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OptimizationMetric {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OptimizationMetric::from(s))
    }
}
impl OptimizationMetric {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OptimizationMetric::AverageWeightedQuantileLoss => "AverageWeightedQuantileLoss",
            OptimizationMetric::Mape => "MAPE",
            OptimizationMetric::Mase => "MASE",
            OptimizationMetric::Rmse => "RMSE",
            OptimizationMetric::Wape => "WAPE",
            OptimizationMetric::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AverageWeightedQuantileLoss",
            "MAPE",
            "MASE",
            "RMSE",
            "WAPE",
        ]
    }
}
impl AsRef<str> for OptimizationMetric {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AutoMlOverrideStrategy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let automloverridestrategy = unimplemented!();
/// match automloverridestrategy {
///     AutoMlOverrideStrategy::AccuracyOptimized => { /* ... */ },
///     AutoMlOverrideStrategy::LatencyOptimized => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `automloverridestrategy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AutoMlOverrideStrategy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AutoMlOverrideStrategy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AutoMlOverrideStrategy::NewFeature` is defined.
/// Specifically, when `automloverridestrategy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AutoMlOverrideStrategy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlOverrideStrategy {
    #[allow(missing_docs)] // documentation missing in model
    AccuracyOptimized,
    #[allow(missing_docs)] // documentation missing in model
    LatencyOptimized,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AutoMlOverrideStrategy {
    fn from(s: &str) -> Self {
        match s {
            "AccuracyOptimized" => AutoMlOverrideStrategy::AccuracyOptimized,
            "LatencyOptimized" => AutoMlOverrideStrategy::LatencyOptimized,
            other => {
                AutoMlOverrideStrategy::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AutoMlOverrideStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlOverrideStrategy::from(s))
    }
}
impl AutoMlOverrideStrategy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlOverrideStrategy::AccuracyOptimized => "AccuracyOptimized",
            AutoMlOverrideStrategy::LatencyOptimized => "LatencyOptimized",
            AutoMlOverrideStrategy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AccuracyOptimized", "LatencyOptimized"]
    }
}
impl AsRef<str> for AutoMlOverrideStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The results of evaluating an algorithm. Returned as part of the <code>GetAccuracyMetrics</code> response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationResult {
    /// <p>The Amazon Resource Name (ARN) of the algorithm that was evaluated.</p>
    #[doc(hidden)]
    pub algorithm_arn: std::option::Option<std::string::String>,
    /// <p>The array of test windows used for evaluating the algorithm. The <code>NumberOfBacktestWindows</code> from the <code>EvaluationParameters</code> object determines the number of windows in the array.</p>
    #[doc(hidden)]
    pub test_windows: std::option::Option<std::vec::Vec<crate::model::WindowSummary>>,
}
impl EvaluationResult {
    /// <p>The Amazon Resource Name (ARN) of the algorithm that was evaluated.</p>
    pub fn algorithm_arn(&self) -> std::option::Option<&str> {
        self.algorithm_arn.as_deref()
    }
    /// <p>The array of test windows used for evaluating the algorithm. The <code>NumberOfBacktestWindows</code> from the <code>EvaluationParameters</code> object determines the number of windows in the array.</p>
    pub fn test_windows(&self) -> std::option::Option<&[crate::model::WindowSummary]> {
        self.test_windows.as_deref()
    }
}
/// See [`EvaluationResult`](crate::model::EvaluationResult).
pub mod evaluation_result {

    /// A builder for [`EvaluationResult`](crate::model::EvaluationResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) algorithm_arn: std::option::Option<std::string::String>,
        pub(crate) test_windows: std::option::Option<std::vec::Vec<crate::model::WindowSummary>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the algorithm that was evaluated.</p>
        pub fn algorithm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the algorithm that was evaluated.</p>
        pub fn set_algorithm_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_arn = input;
            self
        }
        /// Appends an item to `test_windows`.
        ///
        /// To override the contents of this collection use [`set_test_windows`](Self::set_test_windows).
        ///
        /// <p>The array of test windows used for evaluating the algorithm. The <code>NumberOfBacktestWindows</code> from the <code>EvaluationParameters</code> object determines the number of windows in the array.</p>
        pub fn test_windows(mut self, input: crate::model::WindowSummary) -> Self {
            let mut v = self.test_windows.unwrap_or_default();
            v.push(input);
            self.test_windows = Some(v);
            self
        }
        /// <p>The array of test windows used for evaluating the algorithm. The <code>NumberOfBacktestWindows</code> from the <code>EvaluationParameters</code> object determines the number of windows in the array.</p>
        pub fn set_test_windows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WindowSummary>>,
        ) -> Self {
            self.test_windows = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationResult`](crate::model::EvaluationResult).
        pub fn build(self) -> crate::model::EvaluationResult {
            crate::model::EvaluationResult {
                algorithm_arn: self.algorithm_arn,
                test_windows: self.test_windows,
            }
        }
    }
}
impl EvaluationResult {
    /// Creates a new builder-style object to manufacture [`EvaluationResult`](crate::model::EvaluationResult).
    pub fn builder() -> crate::model::evaluation_result::Builder {
        crate::model::evaluation_result::Builder::default()
    }
}

/// <p>The metrics for a time range within the evaluation portion of a dataset. This object is part of the <code>EvaluationResult</code> object.</p>
/// <p>The <code>TestWindowStart</code> and <code>TestWindowEnd</code> parameters are determined by the <code>BackTestWindowOffset</code> parameter of the <code>EvaluationParameters</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WindowSummary {
    /// <p>The timestamp that defines the start of the window.</p>
    #[doc(hidden)]
    pub test_window_start: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp that defines the end of the window.</p>
    #[doc(hidden)]
    pub test_window_end: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The number of data points within the window.</p>
    #[doc(hidden)]
    pub item_count: std::option::Option<i32>,
    /// <p>The type of evaluation.</p>
    /// <ul>
    /// <li> <p> <code>SUMMARY</code> - The average metrics across all windows.</p> </li>
    /// <li> <p> <code>COMPUTED</code> - The metrics for the specified window.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub evaluation_type: std::option::Option<crate::model::EvaluationType>,
    /// <p>Provides metrics used to evaluate the performance of a predictor.</p>
    #[doc(hidden)]
    pub metrics: std::option::Option<crate::model::Metrics>,
}
impl WindowSummary {
    /// <p>The timestamp that defines the start of the window.</p>
    pub fn test_window_start(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.test_window_start.as_ref()
    }
    /// <p>The timestamp that defines the end of the window.</p>
    pub fn test_window_end(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.test_window_end.as_ref()
    }
    /// <p>The number of data points within the window.</p>
    pub fn item_count(&self) -> std::option::Option<i32> {
        self.item_count
    }
    /// <p>The type of evaluation.</p>
    /// <ul>
    /// <li> <p> <code>SUMMARY</code> - The average metrics across all windows.</p> </li>
    /// <li> <p> <code>COMPUTED</code> - The metrics for the specified window.</p> </li>
    /// </ul>
    pub fn evaluation_type(&self) -> std::option::Option<&crate::model::EvaluationType> {
        self.evaluation_type.as_ref()
    }
    /// <p>Provides metrics used to evaluate the performance of a predictor.</p>
    pub fn metrics(&self) -> std::option::Option<&crate::model::Metrics> {
        self.metrics.as_ref()
    }
}
/// See [`WindowSummary`](crate::model::WindowSummary).
pub mod window_summary {

    /// A builder for [`WindowSummary`](crate::model::WindowSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) test_window_start: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) test_window_end: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) item_count: std::option::Option<i32>,
        pub(crate) evaluation_type: std::option::Option<crate::model::EvaluationType>,
        pub(crate) metrics: std::option::Option<crate::model::Metrics>,
    }
    impl Builder {
        /// <p>The timestamp that defines the start of the window.</p>
        pub fn test_window_start(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.test_window_start = Some(input);
            self
        }
        /// <p>The timestamp that defines the start of the window.</p>
        pub fn set_test_window_start(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.test_window_start = input;
            self
        }
        /// <p>The timestamp that defines the end of the window.</p>
        pub fn test_window_end(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.test_window_end = Some(input);
            self
        }
        /// <p>The timestamp that defines the end of the window.</p>
        pub fn set_test_window_end(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.test_window_end = input;
            self
        }
        /// <p>The number of data points within the window.</p>
        pub fn item_count(mut self, input: i32) -> Self {
            self.item_count = Some(input);
            self
        }
        /// <p>The number of data points within the window.</p>
        pub fn set_item_count(mut self, input: std::option::Option<i32>) -> Self {
            self.item_count = input;
            self
        }
        /// <p>The type of evaluation.</p>
        /// <ul>
        /// <li> <p> <code>SUMMARY</code> - The average metrics across all windows.</p> </li>
        /// <li> <p> <code>COMPUTED</code> - The metrics for the specified window.</p> </li>
        /// </ul>
        pub fn evaluation_type(mut self, input: crate::model::EvaluationType) -> Self {
            self.evaluation_type = Some(input);
            self
        }
        /// <p>The type of evaluation.</p>
        /// <ul>
        /// <li> <p> <code>SUMMARY</code> - The average metrics across all windows.</p> </li>
        /// <li> <p> <code>COMPUTED</code> - The metrics for the specified window.</p> </li>
        /// </ul>
        pub fn set_evaluation_type(
            mut self,
            input: std::option::Option<crate::model::EvaluationType>,
        ) -> Self {
            self.evaluation_type = input;
            self
        }
        /// <p>Provides metrics used to evaluate the performance of a predictor.</p>
        pub fn metrics(mut self, input: crate::model::Metrics) -> Self {
            self.metrics = Some(input);
            self
        }
        /// <p>Provides metrics used to evaluate the performance of a predictor.</p>
        pub fn set_metrics(mut self, input: std::option::Option<crate::model::Metrics>) -> Self {
            self.metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`WindowSummary`](crate::model::WindowSummary).
        pub fn build(self) -> crate::model::WindowSummary {
            crate::model::WindowSummary {
                test_window_start: self.test_window_start,
                test_window_end: self.test_window_end,
                item_count: self.item_count,
                evaluation_type: self.evaluation_type,
                metrics: self.metrics,
            }
        }
    }
}
impl WindowSummary {
    /// Creates a new builder-style object to manufacture [`WindowSummary`](crate::model::WindowSummary).
    pub fn builder() -> crate::model::window_summary::Builder {
        crate::model::window_summary::Builder::default()
    }
}

/// <p>Provides metrics that are used to evaluate the performance of a predictor. This object is part of the <code>WindowSummary</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Metrics {
    /// <p>The root-mean-square error (RMSE).</p>
    #[deprecated(
        note = "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE"
    )]
    #[doc(hidden)]
    pub rmse: std::option::Option<f64>,
    /// <p>An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.</p>
    #[doc(hidden)]
    pub weighted_quantile_losses:
        std::option::Option<std::vec::Vec<crate::model::WeightedQuantileLoss>>,
    /// <p> Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE). </p>
    #[doc(hidden)]
    pub error_metrics: std::option::Option<std::vec::Vec<crate::model::ErrorMetric>>,
    /// <p>The average value of all weighted quantile losses.</p>
    #[doc(hidden)]
    pub average_weighted_quantile_loss: std::option::Option<f64>,
}
impl Metrics {
    /// <p>The root-mean-square error (RMSE).</p>
    #[deprecated(
        note = "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE"
    )]
    pub fn rmse(&self) -> std::option::Option<f64> {
        self.rmse
    }
    /// <p>An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.</p>
    pub fn weighted_quantile_losses(
        &self,
    ) -> std::option::Option<&[crate::model::WeightedQuantileLoss]> {
        self.weighted_quantile_losses.as_deref()
    }
    /// <p> Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE). </p>
    pub fn error_metrics(&self) -> std::option::Option<&[crate::model::ErrorMetric]> {
        self.error_metrics.as_deref()
    }
    /// <p>The average value of all weighted quantile losses.</p>
    pub fn average_weighted_quantile_loss(&self) -> std::option::Option<f64> {
        self.average_weighted_quantile_loss
    }
}
/// See [`Metrics`](crate::model::Metrics).
pub mod metrics {

    /// A builder for [`Metrics`](crate::model::Metrics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rmse: std::option::Option<f64>,
        pub(crate) weighted_quantile_losses:
            std::option::Option<std::vec::Vec<crate::model::WeightedQuantileLoss>>,
        pub(crate) error_metrics: std::option::Option<std::vec::Vec<crate::model::ErrorMetric>>,
        pub(crate) average_weighted_quantile_loss: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The root-mean-square error (RMSE).</p>
        #[deprecated(
            note = "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE"
        )]
        pub fn rmse(mut self, input: f64) -> Self {
            self.rmse = Some(input);
            self
        }
        /// <p>The root-mean-square error (RMSE).</p>
        #[deprecated(
            note = "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE"
        )]
        pub fn set_rmse(mut self, input: std::option::Option<f64>) -> Self {
            self.rmse = input;
            self
        }
        /// Appends an item to `weighted_quantile_losses`.
        ///
        /// To override the contents of this collection use [`set_weighted_quantile_losses`](Self::set_weighted_quantile_losses).
        ///
        /// <p>An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.</p>
        pub fn weighted_quantile_losses(
            mut self,
            input: crate::model::WeightedQuantileLoss,
        ) -> Self {
            let mut v = self.weighted_quantile_losses.unwrap_or_default();
            v.push(input);
            self.weighted_quantile_losses = Some(v);
            self
        }
        /// <p>An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.</p>
        pub fn set_weighted_quantile_losses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WeightedQuantileLoss>>,
        ) -> Self {
            self.weighted_quantile_losses = input;
            self
        }
        /// Appends an item to `error_metrics`.
        ///
        /// To override the contents of this collection use [`set_error_metrics`](Self::set_error_metrics).
        ///
        /// <p> Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE). </p>
        pub fn error_metrics(mut self, input: crate::model::ErrorMetric) -> Self {
            let mut v = self.error_metrics.unwrap_or_default();
            v.push(input);
            self.error_metrics = Some(v);
            self
        }
        /// <p> Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE). </p>
        pub fn set_error_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ErrorMetric>>,
        ) -> Self {
            self.error_metrics = input;
            self
        }
        /// <p>The average value of all weighted quantile losses.</p>
        pub fn average_weighted_quantile_loss(mut self, input: f64) -> Self {
            self.average_weighted_quantile_loss = Some(input);
            self
        }
        /// <p>The average value of all weighted quantile losses.</p>
        pub fn set_average_weighted_quantile_loss(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.average_weighted_quantile_loss = input;
            self
        }
        /// Consumes the builder and constructs a [`Metrics`](crate::model::Metrics).
        pub fn build(self) -> crate::model::Metrics {
            crate::model::Metrics {
                rmse: self.rmse,
                weighted_quantile_losses: self.weighted_quantile_losses,
                error_metrics: self.error_metrics,
                average_weighted_quantile_loss: self.average_weighted_quantile_loss,
            }
        }
    }
}
impl Metrics {
    /// Creates a new builder-style object to manufacture [`Metrics`](crate::model::Metrics).
    pub fn builder() -> crate::model::metrics::Builder {
        crate::model::metrics::Builder::default()
    }
}

/// <p> Provides detailed error metrics to evaluate the performance of a predictor. This object is part of the <code>Metrics</code> object. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorMetric {
    /// <p> The Forecast type used to compute WAPE, MAPE, MASE, and RMSE. </p>
    #[doc(hidden)]
    pub forecast_type: std::option::Option<std::string::String>,
    /// <p> The weighted absolute percentage error (WAPE). </p>
    #[doc(hidden)]
    pub wape: std::option::Option<f64>,
    /// <p> The root-mean-square error (RMSE). </p>
    #[doc(hidden)]
    pub rmse: std::option::Option<f64>,
    /// <p>The Mean Absolute Scaled Error (MASE)</p>
    #[doc(hidden)]
    pub mase: std::option::Option<f64>,
    /// <p>The Mean Absolute Percentage Error (MAPE)</p>
    #[doc(hidden)]
    pub mape: std::option::Option<f64>,
}
impl ErrorMetric {
    /// <p> The Forecast type used to compute WAPE, MAPE, MASE, and RMSE. </p>
    pub fn forecast_type(&self) -> std::option::Option<&str> {
        self.forecast_type.as_deref()
    }
    /// <p> The weighted absolute percentage error (WAPE). </p>
    pub fn wape(&self) -> std::option::Option<f64> {
        self.wape
    }
    /// <p> The root-mean-square error (RMSE). </p>
    pub fn rmse(&self) -> std::option::Option<f64> {
        self.rmse
    }
    /// <p>The Mean Absolute Scaled Error (MASE)</p>
    pub fn mase(&self) -> std::option::Option<f64> {
        self.mase
    }
    /// <p>The Mean Absolute Percentage Error (MAPE)</p>
    pub fn mape(&self) -> std::option::Option<f64> {
        self.mape
    }
}
/// See [`ErrorMetric`](crate::model::ErrorMetric).
pub mod error_metric {

    /// A builder for [`ErrorMetric`](crate::model::ErrorMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) forecast_type: std::option::Option<std::string::String>,
        pub(crate) wape: std::option::Option<f64>,
        pub(crate) rmse: std::option::Option<f64>,
        pub(crate) mase: std::option::Option<f64>,
        pub(crate) mape: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The Forecast type used to compute WAPE, MAPE, MASE, and RMSE. </p>
        pub fn forecast_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_type = Some(input.into());
            self
        }
        /// <p> The Forecast type used to compute WAPE, MAPE, MASE, and RMSE. </p>
        pub fn set_forecast_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forecast_type = input;
            self
        }
        /// <p> The weighted absolute percentage error (WAPE). </p>
        pub fn wape(mut self, input: f64) -> Self {
            self.wape = Some(input);
            self
        }
        /// <p> The weighted absolute percentage error (WAPE). </p>
        pub fn set_wape(mut self, input: std::option::Option<f64>) -> Self {
            self.wape = input;
            self
        }
        /// <p> The root-mean-square error (RMSE). </p>
        pub fn rmse(mut self, input: f64) -> Self {
            self.rmse = Some(input);
            self
        }
        /// <p> The root-mean-square error (RMSE). </p>
        pub fn set_rmse(mut self, input: std::option::Option<f64>) -> Self {
            self.rmse = input;
            self
        }
        /// <p>The Mean Absolute Scaled Error (MASE)</p>
        pub fn mase(mut self, input: f64) -> Self {
            self.mase = Some(input);
            self
        }
        /// <p>The Mean Absolute Scaled Error (MASE)</p>
        pub fn set_mase(mut self, input: std::option::Option<f64>) -> Self {
            self.mase = input;
            self
        }
        /// <p>The Mean Absolute Percentage Error (MAPE)</p>
        pub fn mape(mut self, input: f64) -> Self {
            self.mape = Some(input);
            self
        }
        /// <p>The Mean Absolute Percentage Error (MAPE)</p>
        pub fn set_mape(mut self, input: std::option::Option<f64>) -> Self {
            self.mape = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorMetric`](crate::model::ErrorMetric).
        pub fn build(self) -> crate::model::ErrorMetric {
            crate::model::ErrorMetric {
                forecast_type: self.forecast_type,
                wape: self.wape,
                rmse: self.rmse,
                mase: self.mase,
                mape: self.mape,
            }
        }
    }
}
impl ErrorMetric {
    /// Creates a new builder-style object to manufacture [`ErrorMetric`](crate::model::ErrorMetric).
    pub fn builder() -> crate::model::error_metric::Builder {
        crate::model::error_metric::Builder::default()
    }
}

/// <p>The weighted loss value for a quantile. This object is part of the <code>Metrics</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WeightedQuantileLoss {
    /// <p>The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.</p>
    #[doc(hidden)]
    pub quantile: std::option::Option<f64>,
    /// <p>The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.</p>
    #[doc(hidden)]
    pub loss_value: std::option::Option<f64>,
}
impl WeightedQuantileLoss {
    /// <p>The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.</p>
    pub fn quantile(&self) -> std::option::Option<f64> {
        self.quantile
    }
    /// <p>The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.</p>
    pub fn loss_value(&self) -> std::option::Option<f64> {
        self.loss_value
    }
}
/// See [`WeightedQuantileLoss`](crate::model::WeightedQuantileLoss).
pub mod weighted_quantile_loss {

    /// A builder for [`WeightedQuantileLoss`](crate::model::WeightedQuantileLoss).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) quantile: std::option::Option<f64>,
        pub(crate) loss_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.</p>
        pub fn quantile(mut self, input: f64) -> Self {
            self.quantile = Some(input);
            self
        }
        /// <p>The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.</p>
        pub fn set_quantile(mut self, input: std::option::Option<f64>) -> Self {
            self.quantile = input;
            self
        }
        /// <p>The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.</p>
        pub fn loss_value(mut self, input: f64) -> Self {
            self.loss_value = Some(input);
            self
        }
        /// <p>The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.</p>
        pub fn set_loss_value(mut self, input: std::option::Option<f64>) -> Self {
            self.loss_value = input;
            self
        }
        /// Consumes the builder and constructs a [`WeightedQuantileLoss`](crate::model::WeightedQuantileLoss).
        pub fn build(self) -> crate::model::WeightedQuantileLoss {
            crate::model::WeightedQuantileLoss {
                quantile: self.quantile,
                loss_value: self.loss_value,
            }
        }
    }
}
impl WeightedQuantileLoss {
    /// Creates a new builder-style object to manufacture [`WeightedQuantileLoss`](crate::model::WeightedQuantileLoss).
    pub fn builder() -> crate::model::weighted_quantile_loss::Builder {
        crate::model::weighted_quantile_loss::Builder::default()
    }
}

/// When writing a match expression against `EvaluationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let evaluationtype = unimplemented!();
/// match evaluationtype {
///     EvaluationType::Computed => { /* ... */ },
///     EvaluationType::Summary => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `evaluationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EvaluationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EvaluationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EvaluationType::NewFeature` is defined.
/// Specifically, when `evaluationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EvaluationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EvaluationType {
    #[allow(missing_docs)] // documentation missing in model
    Computed,
    #[allow(missing_docs)] // documentation missing in model
    Summary,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EvaluationType {
    fn from(s: &str) -> Self {
        match s {
            "COMPUTED" => EvaluationType::Computed,
            "SUMMARY" => EvaluationType::Summary,
            other => EvaluationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EvaluationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EvaluationType::from(s))
    }
}
impl EvaluationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EvaluationType::Computed => "COMPUTED",
            EvaluationType::Summary => "SUMMARY",
            EvaluationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPUTED", "SUMMARY"]
    }
}
impl AsRef<str> for EvaluationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A replacement dataset is a modified version of the baseline related time series that contains only the values that you want to include in a what-if forecast. The replacement dataset must contain the forecast dimensions and item identifiers in the baseline related time series as well as at least 1 changed time series. This dataset is merged with the baseline related time series to create a transformed dataset that is used for the what-if forecast.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSeriesReplacementsDataSource {
    /// <p>The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the <code>DataSource</code> object that is submitted in the <code>CreateDatasetImportJob</code> request, and part of the <code>DataDestination</code> object.</p>
    #[doc(hidden)]
    pub s3_config: std::option::Option<crate::model::S3Config>,
    /// <p>Defines the fields of a dataset.</p>
    #[doc(hidden)]
    pub schema: std::option::Option<crate::model::Schema>,
    /// <p>The format of the replacement data, CSV or PARQUET.</p>
    #[doc(hidden)]
    pub format: std::option::Option<std::string::String>,
    /// <p>The timestamp format of the replacement data.</p>
    #[doc(hidden)]
    pub timestamp_format: std::option::Option<std::string::String>,
}
impl TimeSeriesReplacementsDataSource {
    /// <p>The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the <code>DataSource</code> object that is submitted in the <code>CreateDatasetImportJob</code> request, and part of the <code>DataDestination</code> object.</p>
    pub fn s3_config(&self) -> std::option::Option<&crate::model::S3Config> {
        self.s3_config.as_ref()
    }
    /// <p>Defines the fields of a dataset.</p>
    pub fn schema(&self) -> std::option::Option<&crate::model::Schema> {
        self.schema.as_ref()
    }
    /// <p>The format of the replacement data, CSV or PARQUET.</p>
    pub fn format(&self) -> std::option::Option<&str> {
        self.format.as_deref()
    }
    /// <p>The timestamp format of the replacement data.</p>
    pub fn timestamp_format(&self) -> std::option::Option<&str> {
        self.timestamp_format.as_deref()
    }
}
/// See [`TimeSeriesReplacementsDataSource`](crate::model::TimeSeriesReplacementsDataSource).
pub mod time_series_replacements_data_source {

    /// A builder for [`TimeSeriesReplacementsDataSource`](crate::model::TimeSeriesReplacementsDataSource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_config: std::option::Option<crate::model::S3Config>,
        pub(crate) schema: std::option::Option<crate::model::Schema>,
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) timestamp_format: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the <code>DataSource</code> object that is submitted in the <code>CreateDatasetImportJob</code> request, and part of the <code>DataDestination</code> object.</p>
        pub fn s3_config(mut self, input: crate::model::S3Config) -> Self {
            self.s3_config = Some(input);
            self
        }
        /// <p>The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the <code>DataSource</code> object that is submitted in the <code>CreateDatasetImportJob</code> request, and part of the <code>DataDestination</code> object.</p>
        pub fn set_s3_config(mut self, input: std::option::Option<crate::model::S3Config>) -> Self {
            self.s3_config = input;
            self
        }
        /// <p>Defines the fields of a dataset.</p>
        pub fn schema(mut self, input: crate::model::Schema) -> Self {
            self.schema = Some(input);
            self
        }
        /// <p>Defines the fields of a dataset.</p>
        pub fn set_schema(mut self, input: std::option::Option<crate::model::Schema>) -> Self {
            self.schema = input;
            self
        }
        /// <p>The format of the replacement data, CSV or PARQUET.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        /// <p>The format of the replacement data, CSV or PARQUET.</p>
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The timestamp format of the replacement data.</p>
        pub fn timestamp_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestamp_format = Some(input.into());
            self
        }
        /// <p>The timestamp format of the replacement data.</p>
        pub fn set_timestamp_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestamp_format = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSeriesReplacementsDataSource`](crate::model::TimeSeriesReplacementsDataSource).
        pub fn build(self) -> crate::model::TimeSeriesReplacementsDataSource {
            crate::model::TimeSeriesReplacementsDataSource {
                s3_config: self.s3_config,
                schema: self.schema,
                format: self.format,
                timestamp_format: self.timestamp_format,
            }
        }
    }
}
impl TimeSeriesReplacementsDataSource {
    /// Creates a new builder-style object to manufacture [`TimeSeriesReplacementsDataSource`](crate::model::TimeSeriesReplacementsDataSource).
    pub fn builder() -> crate::model::time_series_replacements_data_source::Builder {
        crate::model::time_series_replacements_data_source::Builder::default()
    }
}

/// <p>Defines the fields of a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Schema {
    /// <p>An array of attributes specifying the name and type of each field in a dataset.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::SchemaAttribute>>,
}
impl Schema {
    /// <p>An array of attributes specifying the name and type of each field in a dataset.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::SchemaAttribute]> {
        self.attributes.as_deref()
    }
}
/// See [`Schema`](crate::model::Schema).
pub mod schema {

    /// A builder for [`Schema`](crate::model::Schema).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::SchemaAttribute>>,
    }
    impl Builder {
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>An array of attributes specifying the name and type of each field in a dataset.</p>
        pub fn attributes(mut self, input: crate::model::SchemaAttribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>An array of attributes specifying the name and type of each field in a dataset.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SchemaAttribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`Schema`](crate::model::Schema).
        pub fn build(self) -> crate::model::Schema {
            crate::model::Schema {
                attributes: self.attributes,
            }
        }
    }
}
impl Schema {
    /// Creates a new builder-style object to manufacture [`Schema`](crate::model::Schema).
    pub fn builder() -> crate::model::schema::Builder {
        crate::model::schema::Builder::default()
    }
}

/// <p>An attribute of a schema, which defines a dataset field. A schema attribute is required for every field in a dataset. The <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_Schema.html">Schema</a> object contains an array of <code>SchemaAttribute</code> objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaAttribute {
    /// <p>The name of the dataset field.</p>
    #[doc(hidden)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The data type of the field.</p>
    /// <p>For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).</p>
    #[doc(hidden)]
    pub attribute_type: std::option::Option<crate::model::AttributeType>,
}
impl SchemaAttribute {
    /// <p>The name of the dataset field.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The data type of the field.</p>
    /// <p>For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).</p>
    pub fn attribute_type(&self) -> std::option::Option<&crate::model::AttributeType> {
        self.attribute_type.as_ref()
    }
}
/// See [`SchemaAttribute`](crate::model::SchemaAttribute).
pub mod schema_attribute {

    /// A builder for [`SchemaAttribute`](crate::model::SchemaAttribute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_type: std::option::Option<crate::model::AttributeType>,
    }
    impl Builder {
        /// <p>The name of the dataset field.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the dataset field.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The data type of the field.</p>
        /// <p>For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).</p>
        pub fn attribute_type(mut self, input: crate::model::AttributeType) -> Self {
            self.attribute_type = Some(input);
            self
        }
        /// <p>The data type of the field.</p>
        /// <p>For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).</p>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<crate::model::AttributeType>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaAttribute`](crate::model::SchemaAttribute).
        pub fn build(self) -> crate::model::SchemaAttribute {
            crate::model::SchemaAttribute {
                attribute_name: self.attribute_name,
                attribute_type: self.attribute_type,
            }
        }
    }
}
impl SchemaAttribute {
    /// Creates a new builder-style object to manufacture [`SchemaAttribute`](crate::model::SchemaAttribute).
    pub fn builder() -> crate::model::schema_attribute::Builder {
        crate::model::schema_attribute::Builder::default()
    }
}

/// When writing a match expression against `AttributeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let attributetype = unimplemented!();
/// match attributetype {
///     AttributeType::Float => { /* ... */ },
///     AttributeType::Geolocation => { /* ... */ },
///     AttributeType::Integer => { /* ... */ },
///     AttributeType::String => { /* ... */ },
///     AttributeType::Timestamp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `attributetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AttributeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AttributeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AttributeType::NewFeature` is defined.
/// Specifically, when `attributetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AttributeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AttributeType {
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Geolocation,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Timestamp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AttributeType {
    fn from(s: &str) -> Self {
        match s {
            "float" => AttributeType::Float,
            "geolocation" => AttributeType::Geolocation,
            "integer" => AttributeType::Integer,
            "string" => AttributeType::String,
            "timestamp" => AttributeType::Timestamp,
            other => AttributeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AttributeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AttributeType::from(s))
    }
}
impl AttributeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AttributeType::Float => "float",
            AttributeType::Geolocation => "geolocation",
            AttributeType::Integer => "integer",
            AttributeType::String => "string",
            AttributeType::Timestamp => "timestamp",
            AttributeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["float", "geolocation", "integer", "string", "timestamp"]
    }
}
impl AsRef<str> for AttributeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A transformation function is a pair of operations that select and modify the rows in a related time series. You select the rows that you want with a condition operation and you modify the rows with a transformation operation. All conditions are joined with an AND operation, meaning that all conditions must be true for the transformation to be applied. Transformations are applied in the order that they are listed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSeriesTransformation {
    /// <p>An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::Action>,
    /// <p>An array of conditions that define which members of the related time series are transformed.</p>
    #[doc(hidden)]
    pub time_series_conditions:
        std::option::Option<std::vec::Vec<crate::model::TimeSeriesCondition>>,
}
impl TimeSeriesTransformation {
    /// <p>An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.</p>
    pub fn action(&self) -> std::option::Option<&crate::model::Action> {
        self.action.as_ref()
    }
    /// <p>An array of conditions that define which members of the related time series are transformed.</p>
    pub fn time_series_conditions(
        &self,
    ) -> std::option::Option<&[crate::model::TimeSeriesCondition]> {
        self.time_series_conditions.as_deref()
    }
}
/// See [`TimeSeriesTransformation`](crate::model::TimeSeriesTransformation).
pub mod time_series_transformation {

    /// A builder for [`TimeSeriesTransformation`](crate::model::TimeSeriesTransformation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) time_series_conditions:
            std::option::Option<std::vec::Vec<crate::model::TimeSeriesCondition>>,
    }
    impl Builder {
        /// <p>An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.</p>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.</p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// Appends an item to `time_series_conditions`.
        ///
        /// To override the contents of this collection use [`set_time_series_conditions`](Self::set_time_series_conditions).
        ///
        /// <p>An array of conditions that define which members of the related time series are transformed.</p>
        pub fn time_series_conditions(mut self, input: crate::model::TimeSeriesCondition) -> Self {
            let mut v = self.time_series_conditions.unwrap_or_default();
            v.push(input);
            self.time_series_conditions = Some(v);
            self
        }
        /// <p>An array of conditions that define which members of the related time series are transformed.</p>
        pub fn set_time_series_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TimeSeriesCondition>>,
        ) -> Self {
            self.time_series_conditions = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSeriesTransformation`](crate::model::TimeSeriesTransformation).
        pub fn build(self) -> crate::model::TimeSeriesTransformation {
            crate::model::TimeSeriesTransformation {
                action: self.action,
                time_series_conditions: self.time_series_conditions,
            }
        }
    }
}
impl TimeSeriesTransformation {
    /// Creates a new builder-style object to manufacture [`TimeSeriesTransformation`](crate::model::TimeSeriesTransformation).
    pub fn builder() -> crate::model::time_series_transformation::Builder {
        crate::model::time_series_transformation::Builder::default()
    }
}

/// <p>Creates a subset of items within an attribute that are modified. For example, you can use this operation to create a subset of items that cost $5 or less. To do this, you specify <code>"AttributeName": "price"</code>, <code>"AttributeValue": "5"</code>, and <code>"Condition": "LESS_THAN"</code>. Pair this operation with the <code>Action</code> operation within the <code>CreateWhatIfForecastRequest$TimeSeriesTransformations</code> operation to define how the attribute is modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSeriesCondition {
    /// <p>The item_id, dimension name, IM name, or timestamp that you are modifying.</p>
    #[doc(hidden)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The value that is applied for the chosen <code>Condition</code>.</p>
    #[doc(hidden)]
    pub attribute_value: std::option::Option<std::string::String>,
    /// <p>The condition to apply. Valid values are <code>EQUALS</code>, <code>NOT_EQUALS</code>, <code>LESS_THAN</code> and <code>GREATER_THAN</code>.</p>
    #[doc(hidden)]
    pub condition: std::option::Option<crate::model::Condition>,
}
impl TimeSeriesCondition {
    /// <p>The item_id, dimension name, IM name, or timestamp that you are modifying.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The value that is applied for the chosen <code>Condition</code>.</p>
    pub fn attribute_value(&self) -> std::option::Option<&str> {
        self.attribute_value.as_deref()
    }
    /// <p>The condition to apply. Valid values are <code>EQUALS</code>, <code>NOT_EQUALS</code>, <code>LESS_THAN</code> and <code>GREATER_THAN</code>.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::Condition> {
        self.condition.as_ref()
    }
}
/// See [`TimeSeriesCondition`](crate::model::TimeSeriesCondition).
pub mod time_series_condition {

    /// A builder for [`TimeSeriesCondition`](crate::model::TimeSeriesCondition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_value: std::option::Option<std::string::String>,
        pub(crate) condition: std::option::Option<crate::model::Condition>,
    }
    impl Builder {
        /// <p>The item_id, dimension name, IM name, or timestamp that you are modifying.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The item_id, dimension name, IM name, or timestamp that you are modifying.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The value that is applied for the chosen <code>Condition</code>.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_value = Some(input.into());
            self
        }
        /// <p>The value that is applied for the chosen <code>Condition</code>.</p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// <p>The condition to apply. Valid values are <code>EQUALS</code>, <code>NOT_EQUALS</code>, <code>LESS_THAN</code> and <code>GREATER_THAN</code>.</p>
        pub fn condition(mut self, input: crate::model::Condition) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The condition to apply. Valid values are <code>EQUALS</code>, <code>NOT_EQUALS</code>, <code>LESS_THAN</code> and <code>GREATER_THAN</code>.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::Condition>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSeriesCondition`](crate::model::TimeSeriesCondition).
        pub fn build(self) -> crate::model::TimeSeriesCondition {
            crate::model::TimeSeriesCondition {
                attribute_name: self.attribute_name,
                attribute_value: self.attribute_value,
                condition: self.condition,
            }
        }
    }
}
impl TimeSeriesCondition {
    /// Creates a new builder-style object to manufacture [`TimeSeriesCondition`](crate::model::TimeSeriesCondition).
    pub fn builder() -> crate::model::time_series_condition::Builder {
        crate::model::time_series_condition::Builder::default()
    }
}

/// When writing a match expression against `Condition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let condition = unimplemented!();
/// match condition {
///     Condition::Equals => { /* ... */ },
///     Condition::GreaterThan => { /* ... */ },
///     Condition::LessThan => { /* ... */ },
///     Condition::NotEquals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `condition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Condition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Condition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Condition::NewFeature` is defined.
/// Specifically, when `condition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Condition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Condition {
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThan,
    #[allow(missing_docs)] // documentation missing in model
    LessThan,
    #[allow(missing_docs)] // documentation missing in model
    NotEquals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Condition {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => Condition::Equals,
            "GREATER_THAN" => Condition::GreaterThan,
            "LESS_THAN" => Condition::LessThan,
            "NOT_EQUALS" => Condition::NotEquals,
            other => Condition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Condition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Condition::from(s))
    }
}
impl Condition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Condition::Equals => "EQUALS",
            Condition::GreaterThan => "GREATER_THAN",
            Condition::LessThan => "LESS_THAN",
            Condition::NotEquals => "NOT_EQUALS",
            Condition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQUALS", "GREATER_THAN", "LESS_THAN", "NOT_EQUALS"]
    }
}
impl AsRef<str> for Condition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the modifications that you are making to an attribute for a what-if forecast. For example, you can use this operation to create a what-if forecast that investigates a 10% off sale on all shoes. To do this, you specify <code>"AttributeName": "shoes"</code>, <code>"Operation": "MULTIPLY"</code>, and <code>"Value": "0.90"</code>. Pair this operation with the <code>TimeSeriesCondition</code> operation within the <code>CreateWhatIfForecastRequest$TimeSeriesTransformations</code> operation to define a subset of attribute items that are modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Action {
    /// <p>The related time series that you are modifying. This value is case insensitive.</p>
    #[doc(hidden)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The operation that is applied to the provided attribute. Operations include:</p>
    /// <ul>
    /// <li> <p> <code>ADD</code> - adds <code>Value</code> to all rows of <code>AttributeName</code>.</p> </li>
    /// <li> <p> <code>SUBTRACT</code> - subtracts <code>Value</code> from all rows of <code>AttributeName</code>.</p> </li>
    /// <li> <p> <code>MULTIPLY</code> - multiplies all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
    /// <li> <p> <code>DIVIDE</code> - divides all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub operation: std::option::Option<crate::model::Operation>,
    /// <p>The value that is applied for the chosen <code>Operation</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
}
impl Action {
    /// <p>The related time series that you are modifying. This value is case insensitive.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The operation that is applied to the provided attribute. Operations include:</p>
    /// <ul>
    /// <li> <p> <code>ADD</code> - adds <code>Value</code> to all rows of <code>AttributeName</code>.</p> </li>
    /// <li> <p> <code>SUBTRACT</code> - subtracts <code>Value</code> from all rows of <code>AttributeName</code>.</p> </li>
    /// <li> <p> <code>MULTIPLY</code> - multiplies all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
    /// <li> <p> <code>DIVIDE</code> - divides all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
    /// </ul>
    pub fn operation(&self) -> std::option::Option<&crate::model::Operation> {
        self.operation.as_ref()
    }
    /// <p>The value that is applied for the chosen <code>Operation</code>.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
/// See [`Action`](crate::model::Action).
pub mod action {

    /// A builder for [`Action`](crate::model::Action).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) operation: std::option::Option<crate::model::Operation>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The related time series that you are modifying. This value is case insensitive.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The related time series that you are modifying. This value is case insensitive.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The operation that is applied to the provided attribute. Operations include:</p>
        /// <ul>
        /// <li> <p> <code>ADD</code> - adds <code>Value</code> to all rows of <code>AttributeName</code>.</p> </li>
        /// <li> <p> <code>SUBTRACT</code> - subtracts <code>Value</code> from all rows of <code>AttributeName</code>.</p> </li>
        /// <li> <p> <code>MULTIPLY</code> - multiplies all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
        /// <li> <p> <code>DIVIDE</code> - divides all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
        /// </ul>
        pub fn operation(mut self, input: crate::model::Operation) -> Self {
            self.operation = Some(input);
            self
        }
        /// <p>The operation that is applied to the provided attribute. Operations include:</p>
        /// <ul>
        /// <li> <p> <code>ADD</code> - adds <code>Value</code> to all rows of <code>AttributeName</code>.</p> </li>
        /// <li> <p> <code>SUBTRACT</code> - subtracts <code>Value</code> from all rows of <code>AttributeName</code>.</p> </li>
        /// <li> <p> <code>MULTIPLY</code> - multiplies all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
        /// <li> <p> <code>DIVIDE</code> - divides all rows of <code>AttributeName</code> by <code>Value</code>.</p> </li>
        /// </ul>
        pub fn set_operation(
            mut self,
            input: std::option::Option<crate::model::Operation>,
        ) -> Self {
            self.operation = input;
            self
        }
        /// <p>The value that is applied for the chosen <code>Operation</code>.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value that is applied for the chosen <code>Operation</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Action`](crate::model::Action).
        pub fn build(self) -> crate::model::Action {
            crate::model::Action {
                attribute_name: self.attribute_name,
                operation: self.operation,
                value: self.value,
            }
        }
    }
}
impl Action {
    /// Creates a new builder-style object to manufacture [`Action`](crate::model::Action).
    pub fn builder() -> crate::model::action::Builder {
        crate::model::action::Builder::default()
    }
}

/// When writing a match expression against `Operation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let operation = unimplemented!();
/// match operation {
///     Operation::Add => { /* ... */ },
///     Operation::Divide => { /* ... */ },
///     Operation::Multiply => { /* ... */ },
///     Operation::Subtract => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `operation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Operation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Operation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Operation::NewFeature` is defined.
/// Specifically, when `operation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Operation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Operation {
    #[allow(missing_docs)] // documentation missing in model
    Add,
    #[allow(missing_docs)] // documentation missing in model
    Divide,
    #[allow(missing_docs)] // documentation missing in model
    Multiply,
    #[allow(missing_docs)] // documentation missing in model
    Subtract,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Operation {
    fn from(s: &str) -> Self {
        match s {
            "ADD" => Operation::Add,
            "DIVIDE" => Operation::Divide,
            "MULTIPLY" => Operation::Multiply,
            "SUBTRACT" => Operation::Subtract,
            other => Operation::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Operation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Operation::from(s))
    }
}
impl Operation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Operation::Add => "ADD",
            Operation::Divide => "DIVIDE",
            Operation::Multiply => "MULTIPLY",
            Operation::Subtract => "SUBTRACT",
            Operation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ADD", "DIVIDE", "MULTIPLY", "SUBTRACT"]
    }
}
impl AsRef<str> for Operation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the set of time series that are used to create the forecasts in a <code>TimeSeriesIdentifiers</code> object.</p>
/// <p>The <code>TimeSeriesIdentifiers</code> object needs the following information:</p>
/// <ul>
/// <li> <p> <code>DataSource</code> </p> </li>
/// <li> <p> <code>Format</code> </p> </li>
/// <li> <p> <code>Schema</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSeriesSelector {
    /// <p>Details about the import file that contains the time series for which you want to create forecasts.</p>
    #[doc(hidden)]
    pub time_series_identifiers: std::option::Option<crate::model::TimeSeriesIdentifiers>,
}
impl TimeSeriesSelector {
    /// <p>Details about the import file that contains the time series for which you want to create forecasts.</p>
    pub fn time_series_identifiers(
        &self,
    ) -> std::option::Option<&crate::model::TimeSeriesIdentifiers> {
        self.time_series_identifiers.as_ref()
    }
}
/// See [`TimeSeriesSelector`](crate::model::TimeSeriesSelector).
pub mod time_series_selector {

    /// A builder for [`TimeSeriesSelector`](crate::model::TimeSeriesSelector).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_series_identifiers:
            std::option::Option<crate::model::TimeSeriesIdentifiers>,
    }
    impl Builder {
        /// <p>Details about the import file that contains the time series for which you want to create forecasts.</p>
        pub fn time_series_identifiers(
            mut self,
            input: crate::model::TimeSeriesIdentifiers,
        ) -> Self {
            self.time_series_identifiers = Some(input);
            self
        }
        /// <p>Details about the import file that contains the time series for which you want to create forecasts.</p>
        pub fn set_time_series_identifiers(
            mut self,
            input: std::option::Option<crate::model::TimeSeriesIdentifiers>,
        ) -> Self {
            self.time_series_identifiers = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSeriesSelector`](crate::model::TimeSeriesSelector).
        pub fn build(self) -> crate::model::TimeSeriesSelector {
            crate::model::TimeSeriesSelector {
                time_series_identifiers: self.time_series_identifiers,
            }
        }
    }
}
impl TimeSeriesSelector {
    /// Creates a new builder-style object to manufacture [`TimeSeriesSelector`](crate::model::TimeSeriesSelector).
    pub fn builder() -> crate::model::time_series_selector::Builder {
        crate::model::time_series_selector::Builder::default()
    }
}

/// <p>Details about the import file that contains the time series for which you want to create forecasts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSeriesIdentifiers {
    /// <p>The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>Defines the fields of a dataset.</p>
    #[doc(hidden)]
    pub schema: std::option::Option<crate::model::Schema>,
    /// <p>The format of the data, either CSV or PARQUET.</p>
    #[doc(hidden)]
    pub format: std::option::Option<std::string::String>,
}
impl TimeSeriesIdentifiers {
    /// <p>The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>Defines the fields of a dataset.</p>
    pub fn schema(&self) -> std::option::Option<&crate::model::Schema> {
        self.schema.as_ref()
    }
    /// <p>The format of the data, either CSV or PARQUET.</p>
    pub fn format(&self) -> std::option::Option<&str> {
        self.format.as_deref()
    }
}
/// See [`TimeSeriesIdentifiers`](crate::model::TimeSeriesIdentifiers).
pub mod time_series_identifiers {

    /// A builder for [`TimeSeriesIdentifiers`](crate::model::TimeSeriesIdentifiers).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) schema: std::option::Option<crate::model::Schema>,
        pub(crate) format: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>Defines the fields of a dataset.</p>
        pub fn schema(mut self, input: crate::model::Schema) -> Self {
            self.schema = Some(input);
            self
        }
        /// <p>Defines the fields of a dataset.</p>
        pub fn set_schema(mut self, input: std::option::Option<crate::model::Schema>) -> Self {
            self.schema = input;
            self
        }
        /// <p>The format of the data, either CSV or PARQUET.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        /// <p>The format of the data, either CSV or PARQUET.</p>
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSeriesIdentifiers`](crate::model::TimeSeriesIdentifiers).
        pub fn build(self) -> crate::model::TimeSeriesIdentifiers {
            crate::model::TimeSeriesIdentifiers {
                data_source: self.data_source,
                schema: self.schema,
                format: self.format,
            }
        }
    }
}
impl TimeSeriesIdentifiers {
    /// Creates a new builder-style object to manufacture [`TimeSeriesIdentifiers`](crate::model::TimeSeriesIdentifiers).
    pub fn builder() -> crate::model::time_series_identifiers::Builder {
        crate::model::time_series_identifiers::Builder::default()
    }
}

/// <p>Contains details on the backtests performed to evaluate the accuracy of the predictor. The tests are returned in descending order of accuracy, with the most accurate backtest appearing first. You specify the number of backtests to perform when you call the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorExecutionDetails {
    /// <p>An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
    #[doc(hidden)]
    pub predictor_executions: std::option::Option<std::vec::Vec<crate::model::PredictorExecution>>,
}
impl PredictorExecutionDetails {
    /// <p>An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
    pub fn predictor_executions(&self) -> std::option::Option<&[crate::model::PredictorExecution]> {
        self.predictor_executions.as_deref()
    }
}
/// See [`PredictorExecutionDetails`](crate::model::PredictorExecutionDetails).
pub mod predictor_execution_details {

    /// A builder for [`PredictorExecutionDetails`](crate::model::PredictorExecutionDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predictor_executions:
            std::option::Option<std::vec::Vec<crate::model::PredictorExecution>>,
    }
    impl Builder {
        /// Appends an item to `predictor_executions`.
        ///
        /// To override the contents of this collection use [`set_predictor_executions`](Self::set_predictor_executions).
        ///
        /// <p>An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
        pub fn predictor_executions(mut self, input: crate::model::PredictorExecution) -> Self {
            let mut v = self.predictor_executions.unwrap_or_default();
            v.push(input);
            self.predictor_executions = Some(v);
            self
        }
        /// <p>An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
        pub fn set_predictor_executions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PredictorExecution>>,
        ) -> Self {
            self.predictor_executions = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorExecutionDetails`](crate::model::PredictorExecutionDetails).
        pub fn build(self) -> crate::model::PredictorExecutionDetails {
            crate::model::PredictorExecutionDetails {
                predictor_executions: self.predictor_executions,
            }
        }
    }
}
impl PredictorExecutionDetails {
    /// Creates a new builder-style object to manufacture [`PredictorExecutionDetails`](crate::model::PredictorExecutionDetails).
    pub fn builder() -> crate::model::predictor_execution_details::Builder {
        crate::model::predictor_execution_details::Builder::default()
    }
}

/// <p>The algorithm used to perform a backtest and the status of those tests.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorExecution {
    /// <p>The ARN of the algorithm used to test the predictor.</p>
    #[doc(hidden)]
    pub algorithm_arn: std::option::Option<std::string::String>,
    /// <p>An array of test windows used to evaluate the algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
    #[doc(hidden)]
    pub test_windows: std::option::Option<std::vec::Vec<crate::model::TestWindowSummary>>,
}
impl PredictorExecution {
    /// <p>The ARN of the algorithm used to test the predictor.</p>
    pub fn algorithm_arn(&self) -> std::option::Option<&str> {
        self.algorithm_arn.as_deref()
    }
    /// <p>An array of test windows used to evaluate the algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
    pub fn test_windows(&self) -> std::option::Option<&[crate::model::TestWindowSummary]> {
        self.test_windows.as_deref()
    }
}
/// See [`PredictorExecution`](crate::model::PredictorExecution).
pub mod predictor_execution {

    /// A builder for [`PredictorExecution`](crate::model::PredictorExecution).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) algorithm_arn: std::option::Option<std::string::String>,
        pub(crate) test_windows:
            std::option::Option<std::vec::Vec<crate::model::TestWindowSummary>>,
    }
    impl Builder {
        /// <p>The ARN of the algorithm used to test the predictor.</p>
        pub fn algorithm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the algorithm used to test the predictor.</p>
        pub fn set_algorithm_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_arn = input;
            self
        }
        /// Appends an item to `test_windows`.
        ///
        /// To override the contents of this collection use [`set_test_windows`](Self::set_test_windows).
        ///
        /// <p>An array of test windows used to evaluate the algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
        pub fn test_windows(mut self, input: crate::model::TestWindowSummary) -> Self {
            let mut v = self.test_windows.unwrap_or_default();
            v.push(input);
            self.test_windows = Some(v);
            self
        }
        /// <p>An array of test windows used to evaluate the algorithm. The <code>NumberOfBacktestWindows</code> from the object determines the number of windows in the array.</p>
        pub fn set_test_windows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TestWindowSummary>>,
        ) -> Self {
            self.test_windows = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorExecution`](crate::model::PredictorExecution).
        pub fn build(self) -> crate::model::PredictorExecution {
            crate::model::PredictorExecution {
                algorithm_arn: self.algorithm_arn,
                test_windows: self.test_windows,
            }
        }
    }
}
impl PredictorExecution {
    /// Creates a new builder-style object to manufacture [`PredictorExecution`](crate::model::PredictorExecution).
    pub fn builder() -> crate::model::predictor_execution::Builder {
        crate::model::predictor_execution::Builder::default()
    }
}

/// <p>The status, start time, and end time of a backtest, as well as a failure reason if applicable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestWindowSummary {
    /// <p>The time at which the test began.</p>
    #[doc(hidden)]
    pub test_window_start: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the test ended.</p>
    #[doc(hidden)]
    pub test_window_end: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the test. Possible status values are:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>If the test failed, the reason why it failed.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl TestWindowSummary {
    /// <p>The time at which the test began.</p>
    pub fn test_window_start(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.test_window_start.as_ref()
    }
    /// <p>The time at which the test ended.</p>
    pub fn test_window_end(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.test_window_end.as_ref()
    }
    /// <p>The status of the test. Possible status values are:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>If the test failed, the reason why it failed.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`TestWindowSummary`](crate::model::TestWindowSummary).
pub mod test_window_summary {

    /// A builder for [`TestWindowSummary`](crate::model::TestWindowSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) test_window_start: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) test_window_end: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time at which the test began.</p>
        pub fn test_window_start(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.test_window_start = Some(input);
            self
        }
        /// <p>The time at which the test began.</p>
        pub fn set_test_window_start(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.test_window_start = input;
            self
        }
        /// <p>The time at which the test ended.</p>
        pub fn test_window_end(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.test_window_end = Some(input);
            self
        }
        /// <p>The time at which the test ended.</p>
        pub fn set_test_window_end(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.test_window_end = input;
            self
        }
        /// <p>The status of the test. Possible status values are:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the test. Possible status values are:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>If the test failed, the reason why it failed.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>If the test failed, the reason why it failed.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TestWindowSummary`](crate::model::TestWindowSummary).
        pub fn build(self) -> crate::model::TestWindowSummary {
            crate::model::TestWindowSummary {
                test_window_start: self.test_window_start,
                test_window_end: self.test_window_end,
                status: self.status,
                message: self.message,
            }
        }
    }
}
impl TestWindowSummary {
    /// Creates a new builder-style object to manufacture [`TestWindowSummary`](crate::model::TestWindowSummary).
    pub fn builder() -> crate::model::test_window_summary::Builder {
        crate::model::test_window_summary::Builder::default()
    }
}

/// <p>An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the <code>CreateDataset</code> and <code>CreatePredictor</code> requests.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionConfig {
    /// <p>The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key.</p>
    /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the KMS key.</p>
    #[doc(hidden)]
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl EncryptionConfig {
    /// <p>The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key.</p>
    /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
}
/// See [`EncryptionConfig`](crate::model::EncryptionConfig).
pub mod encryption_config {

    /// A builder for [`EncryptionConfig`](crate::model::EncryptionConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key.</p>
        /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key.</p>
        /// <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an <code>InvalidInputException</code> error.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the KMS key.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfig`](crate::model::EncryptionConfig).
        pub fn build(self) -> crate::model::EncryptionConfig {
            crate::model::EncryptionConfig {
                role_arn: self.role_arn,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl EncryptionConfig {
    /// Creates a new builder-style object to manufacture [`EncryptionConfig`](crate::model::EncryptionConfig).
    pub fn builder() -> crate::model::encryption_config::Builder {
        crate::model::encryption_config::Builder::default()
    }
}

/// <note>
/// <p>This object belongs to the <code>CreatePredictor</code> operation. If you created your predictor with <code>CreateAutoPredictor</code>, see <code>AttributeConfig</code>.</p>
/// </note>
/// <p>In a <code>CreatePredictor</code> operation, the specified algorithm trains a model using the specified dataset group. You can optionally tell the operation to modify data fields prior to training a model. These modifications are referred to as <i>featurization</i>.</p>
/// <p>You define featurization using the <code>FeaturizationConfig</code> object. You specify an array of transformations, one for each field that you want to featurize. You then include the <code>FeaturizationConfig</code> object in your <code>CreatePredictor</code> request. Amazon Forecast applies the featurization to the <code>TARGET_TIME_SERIES</code> and <code>RELATED_TIME_SERIES</code> datasets before model training.</p>
/// <p>You can create multiple featurization configurations. For example, you might call the <code>CreatePredictor</code> operation twice by specifying different featurization configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FeaturizationConfig {
    /// <p>The frequency of predictions in a forecast.</p>
    /// <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.</p>
    /// <p>The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency.</p>
    /// <p>When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.</p>
    #[doc(hidden)]
    pub forecast_frequency: std::option::Option<std::string::String>,
    /// <p>An array of dimension (field) names that specify how to group the generated forecast.</p>
    /// <p>For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a <code>store_id</code> field. If you want the sales forecast for each item by store, you would specify <code>store_id</code> as the dimension.</p>
    /// <p>All forecast dimensions specified in the <code>TARGET_TIME_SERIES</code> dataset don't need to be specified in the <code>CreatePredictor</code> request. All forecast dimensions specified in the <code>RELATED_TIME_SERIES</code> dataset must be specified in the <code>CreatePredictor</code> request.</p>
    #[doc(hidden)]
    pub forecast_dimensions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of featurization (transformation) information for the fields of a dataset.</p>
    #[doc(hidden)]
    pub featurizations: std::option::Option<std::vec::Vec<crate::model::Featurization>>,
}
impl FeaturizationConfig {
    /// <p>The frequency of predictions in a forecast.</p>
    /// <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.</p>
    /// <p>The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency.</p>
    /// <p>When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.</p>
    pub fn forecast_frequency(&self) -> std::option::Option<&str> {
        self.forecast_frequency.as_deref()
    }
    /// <p>An array of dimension (field) names that specify how to group the generated forecast.</p>
    /// <p>For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a <code>store_id</code> field. If you want the sales forecast for each item by store, you would specify <code>store_id</code> as the dimension.</p>
    /// <p>All forecast dimensions specified in the <code>TARGET_TIME_SERIES</code> dataset don't need to be specified in the <code>CreatePredictor</code> request. All forecast dimensions specified in the <code>RELATED_TIME_SERIES</code> dataset must be specified in the <code>CreatePredictor</code> request.</p>
    pub fn forecast_dimensions(&self) -> std::option::Option<&[std::string::String]> {
        self.forecast_dimensions.as_deref()
    }
    /// <p>An array of featurization (transformation) information for the fields of a dataset.</p>
    pub fn featurizations(&self) -> std::option::Option<&[crate::model::Featurization]> {
        self.featurizations.as_deref()
    }
}
/// See [`FeaturizationConfig`](crate::model::FeaturizationConfig).
pub mod featurization_config {

    /// A builder for [`FeaturizationConfig`](crate::model::FeaturizationConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) forecast_frequency: std::option::Option<std::string::String>,
        pub(crate) forecast_dimensions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) featurizations: std::option::Option<std::vec::Vec<crate::model::Featurization>>,
    }
    impl Builder {
        /// <p>The frequency of predictions in a forecast.</p>
        /// <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.</p>
        /// <p>The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency.</p>
        /// <p>When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.</p>
        pub fn forecast_frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.forecast_frequency = Some(input.into());
            self
        }
        /// <p>The frequency of predictions in a forecast.</p>
        /// <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.</p>
        /// <p>The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency.</p>
        /// <p>When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.</p>
        pub fn set_forecast_frequency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forecast_frequency = input;
            self
        }
        /// Appends an item to `forecast_dimensions`.
        ///
        /// To override the contents of this collection use [`set_forecast_dimensions`](Self::set_forecast_dimensions).
        ///
        /// <p>An array of dimension (field) names that specify how to group the generated forecast.</p>
        /// <p>For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a <code>store_id</code> field. If you want the sales forecast for each item by store, you would specify <code>store_id</code> as the dimension.</p>
        /// <p>All forecast dimensions specified in the <code>TARGET_TIME_SERIES</code> dataset don't need to be specified in the <code>CreatePredictor</code> request. All forecast dimensions specified in the <code>RELATED_TIME_SERIES</code> dataset must be specified in the <code>CreatePredictor</code> request.</p>
        pub fn forecast_dimensions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.forecast_dimensions.unwrap_or_default();
            v.push(input.into());
            self.forecast_dimensions = Some(v);
            self
        }
        /// <p>An array of dimension (field) names that specify how to group the generated forecast.</p>
        /// <p>For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a <code>store_id</code> field. If you want the sales forecast for each item by store, you would specify <code>store_id</code> as the dimension.</p>
        /// <p>All forecast dimensions specified in the <code>TARGET_TIME_SERIES</code> dataset don't need to be specified in the <code>CreatePredictor</code> request. All forecast dimensions specified in the <code>RELATED_TIME_SERIES</code> dataset must be specified in the <code>CreatePredictor</code> request.</p>
        pub fn set_forecast_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.forecast_dimensions = input;
            self
        }
        /// Appends an item to `featurizations`.
        ///
        /// To override the contents of this collection use [`set_featurizations`](Self::set_featurizations).
        ///
        /// <p>An array of featurization (transformation) information for the fields of a dataset.</p>
        pub fn featurizations(mut self, input: crate::model::Featurization) -> Self {
            let mut v = self.featurizations.unwrap_or_default();
            v.push(input);
            self.featurizations = Some(v);
            self
        }
        /// <p>An array of featurization (transformation) information for the fields of a dataset.</p>
        pub fn set_featurizations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Featurization>>,
        ) -> Self {
            self.featurizations = input;
            self
        }
        /// Consumes the builder and constructs a [`FeaturizationConfig`](crate::model::FeaturizationConfig).
        pub fn build(self) -> crate::model::FeaturizationConfig {
            crate::model::FeaturizationConfig {
                forecast_frequency: self.forecast_frequency,
                forecast_dimensions: self.forecast_dimensions,
                featurizations: self.featurizations,
            }
        }
    }
}
impl FeaturizationConfig {
    /// Creates a new builder-style object to manufacture [`FeaturizationConfig`](crate::model::FeaturizationConfig).
    pub fn builder() -> crate::model::featurization_config::Builder {
        crate::model::featurization_config::Builder::default()
    }
}

/// <note>
/// <p>This object belongs to the <code>CreatePredictor</code> operation. If you created your predictor with <code>CreateAutoPredictor</code>, see <code>AttributeConfig</code>.</p>
/// </note>
/// <p>Provides featurization (transformation) information for a dataset field. This object is part of the <code>FeaturizationConfig</code> object.</p>
/// <p>For example:</p>
/// <p> <code>{</code> </p>
/// <p> <code>"AttributeName": "demand",</code> </p>
/// <p> <code>FeaturizationPipeline [ {</code> </p>
/// <p> <code>"FeaturizationMethodName": "filling",</code> </p>
/// <p> <code>"FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}</code> </p>
/// <p> <code>} ]</code> </p>
/// <p> <code>}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Featurization {
    /// <p>The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the <code>TARGET_TIME_SERIES</code> and the <code>RELATED_TIME_SERIES</code> datasets. For example, for the <code>RETAIL</code> domain, the target is <code>demand</code>, and for the <code>CUSTOM</code> domain, the target is <code>target_value</code>. For more information, see <code>howitworks-missing-values</code>.</p>
    #[doc(hidden)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>An array of one <code>FeaturizationMethod</code> object that specifies the feature transformation method.</p>
    #[doc(hidden)]
    pub featurization_pipeline:
        std::option::Option<std::vec::Vec<crate::model::FeaturizationMethod>>,
}
impl Featurization {
    /// <p>The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the <code>TARGET_TIME_SERIES</code> and the <code>RELATED_TIME_SERIES</code> datasets. For example, for the <code>RETAIL</code> domain, the target is <code>demand</code>, and for the <code>CUSTOM</code> domain, the target is <code>target_value</code>. For more information, see <code>howitworks-missing-values</code>.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>An array of one <code>FeaturizationMethod</code> object that specifies the feature transformation method.</p>
    pub fn featurization_pipeline(
        &self,
    ) -> std::option::Option<&[crate::model::FeaturizationMethod]> {
        self.featurization_pipeline.as_deref()
    }
}
/// See [`Featurization`](crate::model::Featurization).
pub mod featurization {

    /// A builder for [`Featurization`](crate::model::Featurization).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) featurization_pipeline:
            std::option::Option<std::vec::Vec<crate::model::FeaturizationMethod>>,
    }
    impl Builder {
        /// <p>The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the <code>TARGET_TIME_SERIES</code> and the <code>RELATED_TIME_SERIES</code> datasets. For example, for the <code>RETAIL</code> domain, the target is <code>demand</code>, and for the <code>CUSTOM</code> domain, the target is <code>target_value</code>. For more information, see <code>howitworks-missing-values</code>.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the <code>TARGET_TIME_SERIES</code> and the <code>RELATED_TIME_SERIES</code> datasets. For example, for the <code>RETAIL</code> domain, the target is <code>demand</code>, and for the <code>CUSTOM</code> domain, the target is <code>target_value</code>. For more information, see <code>howitworks-missing-values</code>.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// Appends an item to `featurization_pipeline`.
        ///
        /// To override the contents of this collection use [`set_featurization_pipeline`](Self::set_featurization_pipeline).
        ///
        /// <p>An array of one <code>FeaturizationMethod</code> object that specifies the feature transformation method.</p>
        pub fn featurization_pipeline(mut self, input: crate::model::FeaturizationMethod) -> Self {
            let mut v = self.featurization_pipeline.unwrap_or_default();
            v.push(input);
            self.featurization_pipeline = Some(v);
            self
        }
        /// <p>An array of one <code>FeaturizationMethod</code> object that specifies the feature transformation method.</p>
        pub fn set_featurization_pipeline(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FeaturizationMethod>>,
        ) -> Self {
            self.featurization_pipeline = input;
            self
        }
        /// Consumes the builder and constructs a [`Featurization`](crate::model::Featurization).
        pub fn build(self) -> crate::model::Featurization {
            crate::model::Featurization {
                attribute_name: self.attribute_name,
                featurization_pipeline: self.featurization_pipeline,
            }
        }
    }
}
impl Featurization {
    /// Creates a new builder-style object to manufacture [`Featurization`](crate::model::Featurization).
    pub fn builder() -> crate::model::featurization::Builder {
        crate::model::featurization::Builder::default()
    }
}

/// <p>Provides information about the method that featurizes (transforms) a dataset field. The method is part of the <code>FeaturizationPipeline</code> of the <code>Featurization</code> object. </p>
/// <p>The following is an example of how you specify a <code>FeaturizationMethod</code> object.</p>
/// <p> <code>{</code> </p>
/// <p> <code>"FeaturizationMethodName": "filling",</code> </p>
/// <p> <code>"FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}</code> </p>
/// <p> <code>}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FeaturizationMethod {
    /// <p>The name of the method. The "filling" method is the only supported method.</p>
    #[doc(hidden)]
    pub featurization_method_name: std::option::Option<crate::model::FeaturizationMethodName>,
    /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
    /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Bold signifies the default value.</p>
    /// <ul>
    /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
    /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
    /// <ul>
    /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
    #[doc(hidden)]
    pub featurization_method_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl FeaturizationMethod {
    /// <p>The name of the method. The "filling" method is the only supported method.</p>
    pub fn featurization_method_name(
        &self,
    ) -> std::option::Option<&crate::model::FeaturizationMethodName> {
        self.featurization_method_name.as_ref()
    }
    /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
    /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Bold signifies the default value.</p>
    /// <ul>
    /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
    /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
    /// <ul>
    /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
    pub fn featurization_method_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.featurization_method_parameters.as_ref()
    }
}
/// See [`FeaturizationMethod`](crate::model::FeaturizationMethod).
pub mod featurization_method {

    /// A builder for [`FeaturizationMethod`](crate::model::FeaturizationMethod).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) featurization_method_name:
            std::option::Option<crate::model::FeaturizationMethodName>,
        pub(crate) featurization_method_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the method. The "filling" method is the only supported method.</p>
        pub fn featurization_method_name(
            mut self,
            input: crate::model::FeaturizationMethodName,
        ) -> Self {
            self.featurization_method_name = Some(input);
            self
        }
        /// <p>The name of the method. The "filling" method is the only supported method.</p>
        pub fn set_featurization_method_name(
            mut self,
            input: std::option::Option<crate::model::FeaturizationMethodName>,
        ) -> Self {
            self.featurization_method_name = input;
            self
        }
        /// Adds a key-value pair to `featurization_method_parameters`.
        ///
        /// To override the contents of this collection use [`set_featurization_method_parameters`](Self::set_featurization_method_parameters).
        ///
        /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
        /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Bold signifies the default value.</p>
        /// <ul>
        /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
        /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
        /// <ul>
        /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
        pub fn featurization_method_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.featurization_method_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.featurization_method_parameters = Some(hash_map);
            self
        }
        /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
        /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Bold signifies the default value.</p>
        /// <ul>
        /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
        /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
        /// <ul>
        /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
        pub fn set_featurization_method_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.featurization_method_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`FeaturizationMethod`](crate::model::FeaturizationMethod).
        pub fn build(self) -> crate::model::FeaturizationMethod {
            crate::model::FeaturizationMethod {
                featurization_method_name: self.featurization_method_name,
                featurization_method_parameters: self.featurization_method_parameters,
            }
        }
    }
}
impl FeaturizationMethod {
    /// Creates a new builder-style object to manufacture [`FeaturizationMethod`](crate::model::FeaturizationMethod).
    pub fn builder() -> crate::model::featurization_method::Builder {
        crate::model::featurization_method::Builder::default()
    }
}

/// When writing a match expression against `FeaturizationMethodName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let featurizationmethodname = unimplemented!();
/// match featurizationmethodname {
///     FeaturizationMethodName::Filling => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `featurizationmethodname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FeaturizationMethodName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FeaturizationMethodName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FeaturizationMethodName::NewFeature` is defined.
/// Specifically, when `featurizationmethodname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FeaturizationMethodName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeaturizationMethodName {
    #[allow(missing_docs)] // documentation missing in model
    Filling,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FeaturizationMethodName {
    fn from(s: &str) -> Self {
        match s {
            "filling" => FeaturizationMethodName::Filling,
            other => FeaturizationMethodName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for FeaturizationMethodName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeaturizationMethodName::from(s))
    }
}
impl FeaturizationMethodName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FeaturizationMethodName::Filling => "filling",
            FeaturizationMethodName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["filling"]
    }
}
impl AsRef<str> for FeaturizationMethodName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <note>
/// <p>This object belongs to the <code>CreatePredictor</code> operation. If you created your predictor with <code>CreateAutoPredictor</code>, see <code>DataConfig</code>.</p>
/// </note>
/// <p>The data used to train a predictor. The data includes a dataset group and any supplementary features. You specify this object in the <code>CreatePredictor</code> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputDataConfig {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    #[doc(hidden)]
    pub dataset_group_arn: std::option::Option<std::string::String>,
    /// <p>An array of supplementary features. The only supported feature is a holiday calendar.</p>
    #[doc(hidden)]
    pub supplementary_features:
        std::option::Option<std::vec::Vec<crate::model::SupplementaryFeature>>,
}
impl InputDataConfig {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    pub fn dataset_group_arn(&self) -> std::option::Option<&str> {
        self.dataset_group_arn.as_deref()
    }
    /// <p>An array of supplementary features. The only supported feature is a holiday calendar.</p>
    pub fn supplementary_features(
        &self,
    ) -> std::option::Option<&[crate::model::SupplementaryFeature]> {
        self.supplementary_features.as_deref()
    }
}
/// See [`InputDataConfig`](crate::model::InputDataConfig).
pub mod input_data_config {

    /// A builder for [`InputDataConfig`](crate::model::InputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_group_arn: std::option::Option<std::string::String>,
        pub(crate) supplementary_features:
            std::option::Option<std::vec::Vec<crate::model::SupplementaryFeature>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
        pub fn dataset_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
        pub fn set_dataset_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_group_arn = input;
            self
        }
        /// Appends an item to `supplementary_features`.
        ///
        /// To override the contents of this collection use [`set_supplementary_features`](Self::set_supplementary_features).
        ///
        /// <p>An array of supplementary features. The only supported feature is a holiday calendar.</p>
        pub fn supplementary_features(mut self, input: crate::model::SupplementaryFeature) -> Self {
            let mut v = self.supplementary_features.unwrap_or_default();
            v.push(input);
            self.supplementary_features = Some(v);
            self
        }
        /// <p>An array of supplementary features. The only supported feature is a holiday calendar.</p>
        pub fn set_supplementary_features(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SupplementaryFeature>>,
        ) -> Self {
            self.supplementary_features = input;
            self
        }
        /// Consumes the builder and constructs a [`InputDataConfig`](crate::model::InputDataConfig).
        pub fn build(self) -> crate::model::InputDataConfig {
            crate::model::InputDataConfig {
                dataset_group_arn: self.dataset_group_arn,
                supplementary_features: self.supplementary_features,
            }
        }
    }
}
impl InputDataConfig {
    /// Creates a new builder-style object to manufacture [`InputDataConfig`](crate::model::InputDataConfig).
    pub fn builder() -> crate::model::input_data_config::Builder {
        crate::model::input_data_config::Builder::default()
    }
}

/// <note>
/// <p>This object belongs to the <code>CreatePredictor</code> operation. If you created your predictor with <code>CreateAutoPredictor</code>, see <code>AdditionalDataset</code>.</p>
/// </note>
/// <p>Describes a supplementary feature of a dataset group. This object is part of the <code>InputDataConfig</code> object. Forecast supports the Weather Index and Holidays built-in featurizations.</p>
/// <p> <b>Weather Index</b> </p>
/// <p>The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/weather.html">Amazon Forecast Weather Index</a>.</p>
/// <p> <b>Holidays</b> </p>
/// <p>Holidays is a built-in featurization that incorporates a feature-engineered dataset of national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the <a href="http://jollyday.sourceforge.net/data.html">Jollyday</a> library. For more information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/holidays.html">Holidays Featurization</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SupplementaryFeature {
    /// <p>The name of the feature. Valid values: <code>"holiday"</code> and <code>"weather"</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> <b>Weather Index</b> </p>
    /// <p>To enable the Weather Index, set the value to <code>"true"</code> </p>
    /// <p> <b>Holidays</b> </p>
    /// <p>To enable Holidays, specify a country with one of the following two-letter country codes:</p>
    /// <ul>
    /// <li> <p>"AL" - ALBANIA</p> </li>
    /// <li> <p>"AR" - ARGENTINA</p> </li>
    /// <li> <p>"AT" - AUSTRIA</p> </li>
    /// <li> <p>"AU" - AUSTRALIA</p> </li>
    /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
    /// <li> <p>"BE" - BELGIUM</p> </li>
    /// <li> <p>"BG" - BULGARIA</p> </li>
    /// <li> <p>"BO" - BOLIVIA</p> </li>
    /// <li> <p>"BR" - BRAZIL</p> </li>
    /// <li> <p>"BY" - BELARUS</p> </li>
    /// <li> <p>"CA" - CANADA</p> </li>
    /// <li> <p>"CL" - CHILE</p> </li>
    /// <li> <p>"CO" - COLOMBIA</p> </li>
    /// <li> <p>"CR" - COSTA RICA</p> </li>
    /// <li> <p>"HR" - CROATIA</p> </li>
    /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
    /// <li> <p>"DK" - DENMARK</p> </li>
    /// <li> <p>"EC" - ECUADOR</p> </li>
    /// <li> <p>"EE" - ESTONIA</p> </li>
    /// <li> <p>"ET" - ETHIOPIA</p> </li>
    /// <li> <p>"FI" - FINLAND</p> </li>
    /// <li> <p>"FR" - FRANCE</p> </li>
    /// <li> <p>"DE" - GERMANY</p> </li>
    /// <li> <p>"GR" - GREECE</p> </li>
    /// <li> <p>"HU" - HUNGARY</p> </li>
    /// <li> <p>"IS" - ICELAND</p> </li>
    /// <li> <p>"IN" - INDIA</p> </li>
    /// <li> <p>"IE" - IRELAND</p> </li>
    /// <li> <p>"IT" - ITALY</p> </li>
    /// <li> <p>"JP" - JAPAN</p> </li>
    /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
    /// <li> <p>"KR" - KOREA</p> </li>
    /// <li> <p>"LV" - LATVIA</p> </li>
    /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
    /// <li> <p>"LT" - LITHUANIA</p> </li>
    /// <li> <p>"LU" - LUXEMBOURG</p> </li>
    /// <li> <p>"MK" - MACEDONIA</p> </li>
    /// <li> <p>"MT" - MALTA</p> </li>
    /// <li> <p>"MX" - MEXICO</p> </li>
    /// <li> <p>"MD" - MOLDOVA</p> </li>
    /// <li> <p>"ME" - MONTENEGRO</p> </li>
    /// <li> <p>"NL" - NETHERLANDS</p> </li>
    /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
    /// <li> <p>"NI" - NICARAGUA</p> </li>
    /// <li> <p>"NG" - NIGERIA</p> </li>
    /// <li> <p>"NO" - NORWAY</p> </li>
    /// <li> <p>"PA" - PANAMA</p> </li>
    /// <li> <p>"PY" - PARAGUAY</p> </li>
    /// <li> <p>"PE" - PERU</p> </li>
    /// <li> <p>"PL" - POLAND</p> </li>
    /// <li> <p>"PT" - PORTUGAL</p> </li>
    /// <li> <p>"RO" - ROMANIA</p> </li>
    /// <li> <p>"RU" - RUSSIA</p> </li>
    /// <li> <p>"RS" - SERBIA</p> </li>
    /// <li> <p>"SK" - SLOVAKIA</p> </li>
    /// <li> <p>"SI" - SLOVENIA</p> </li>
    /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
    /// <li> <p>"ES" - SPAIN</p> </li>
    /// <li> <p>"SE" - SWEDEN</p> </li>
    /// <li> <p>"CH" - SWITZERLAND</p> </li>
    /// <li> <p>"UA" - UKRAINE</p> </li>
    /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
    /// <li> <p>"US" - UNITED STATES</p> </li>
    /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
    /// <li> <p>"UY" - URUGUAY</p> </li>
    /// <li> <p>"VE" - VENEZUELA</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl SupplementaryFeature {
    /// <p>The name of the feature. Valid values: <code>"holiday"</code> and <code>"weather"</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> <b>Weather Index</b> </p>
    /// <p>To enable the Weather Index, set the value to <code>"true"</code> </p>
    /// <p> <b>Holidays</b> </p>
    /// <p>To enable Holidays, specify a country with one of the following two-letter country codes:</p>
    /// <ul>
    /// <li> <p>"AL" - ALBANIA</p> </li>
    /// <li> <p>"AR" - ARGENTINA</p> </li>
    /// <li> <p>"AT" - AUSTRIA</p> </li>
    /// <li> <p>"AU" - AUSTRALIA</p> </li>
    /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
    /// <li> <p>"BE" - BELGIUM</p> </li>
    /// <li> <p>"BG" - BULGARIA</p> </li>
    /// <li> <p>"BO" - BOLIVIA</p> </li>
    /// <li> <p>"BR" - BRAZIL</p> </li>
    /// <li> <p>"BY" - BELARUS</p> </li>
    /// <li> <p>"CA" - CANADA</p> </li>
    /// <li> <p>"CL" - CHILE</p> </li>
    /// <li> <p>"CO" - COLOMBIA</p> </li>
    /// <li> <p>"CR" - COSTA RICA</p> </li>
    /// <li> <p>"HR" - CROATIA</p> </li>
    /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
    /// <li> <p>"DK" - DENMARK</p> </li>
    /// <li> <p>"EC" - ECUADOR</p> </li>
    /// <li> <p>"EE" - ESTONIA</p> </li>
    /// <li> <p>"ET" - ETHIOPIA</p> </li>
    /// <li> <p>"FI" - FINLAND</p> </li>
    /// <li> <p>"FR" - FRANCE</p> </li>
    /// <li> <p>"DE" - GERMANY</p> </li>
    /// <li> <p>"GR" - GREECE</p> </li>
    /// <li> <p>"HU" - HUNGARY</p> </li>
    /// <li> <p>"IS" - ICELAND</p> </li>
    /// <li> <p>"IN" - INDIA</p> </li>
    /// <li> <p>"IE" - IRELAND</p> </li>
    /// <li> <p>"IT" - ITALY</p> </li>
    /// <li> <p>"JP" - JAPAN</p> </li>
    /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
    /// <li> <p>"KR" - KOREA</p> </li>
    /// <li> <p>"LV" - LATVIA</p> </li>
    /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
    /// <li> <p>"LT" - LITHUANIA</p> </li>
    /// <li> <p>"LU" - LUXEMBOURG</p> </li>
    /// <li> <p>"MK" - MACEDONIA</p> </li>
    /// <li> <p>"MT" - MALTA</p> </li>
    /// <li> <p>"MX" - MEXICO</p> </li>
    /// <li> <p>"MD" - MOLDOVA</p> </li>
    /// <li> <p>"ME" - MONTENEGRO</p> </li>
    /// <li> <p>"NL" - NETHERLANDS</p> </li>
    /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
    /// <li> <p>"NI" - NICARAGUA</p> </li>
    /// <li> <p>"NG" - NIGERIA</p> </li>
    /// <li> <p>"NO" - NORWAY</p> </li>
    /// <li> <p>"PA" - PANAMA</p> </li>
    /// <li> <p>"PY" - PARAGUAY</p> </li>
    /// <li> <p>"PE" - PERU</p> </li>
    /// <li> <p>"PL" - POLAND</p> </li>
    /// <li> <p>"PT" - PORTUGAL</p> </li>
    /// <li> <p>"RO" - ROMANIA</p> </li>
    /// <li> <p>"RU" - RUSSIA</p> </li>
    /// <li> <p>"RS" - SERBIA</p> </li>
    /// <li> <p>"SK" - SLOVAKIA</p> </li>
    /// <li> <p>"SI" - SLOVENIA</p> </li>
    /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
    /// <li> <p>"ES" - SPAIN</p> </li>
    /// <li> <p>"SE" - SWEDEN</p> </li>
    /// <li> <p>"CH" - SWITZERLAND</p> </li>
    /// <li> <p>"UA" - UKRAINE</p> </li>
    /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
    /// <li> <p>"US" - UNITED STATES</p> </li>
    /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
    /// <li> <p>"UY" - URUGUAY</p> </li>
    /// <li> <p>"VE" - VENEZUELA</p> </li>
    /// </ul>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`SupplementaryFeature`](crate::model::SupplementaryFeature).
pub mod supplementary_feature {

    /// A builder for [`SupplementaryFeature`](crate::model::SupplementaryFeature).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the feature. Valid values: <code>"holiday"</code> and <code>"weather"</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the feature. Valid values: <code>"holiday"</code> and <code>"weather"</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> <b>Weather Index</b> </p>
        /// <p>To enable the Weather Index, set the value to <code>"true"</code> </p>
        /// <p> <b>Holidays</b> </p>
        /// <p>To enable Holidays, specify a country with one of the following two-letter country codes:</p>
        /// <ul>
        /// <li> <p>"AL" - ALBANIA</p> </li>
        /// <li> <p>"AR" - ARGENTINA</p> </li>
        /// <li> <p>"AT" - AUSTRIA</p> </li>
        /// <li> <p>"AU" - AUSTRALIA</p> </li>
        /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
        /// <li> <p>"BE" - BELGIUM</p> </li>
        /// <li> <p>"BG" - BULGARIA</p> </li>
        /// <li> <p>"BO" - BOLIVIA</p> </li>
        /// <li> <p>"BR" - BRAZIL</p> </li>
        /// <li> <p>"BY" - BELARUS</p> </li>
        /// <li> <p>"CA" - CANADA</p> </li>
        /// <li> <p>"CL" - CHILE</p> </li>
        /// <li> <p>"CO" - COLOMBIA</p> </li>
        /// <li> <p>"CR" - COSTA RICA</p> </li>
        /// <li> <p>"HR" - CROATIA</p> </li>
        /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
        /// <li> <p>"DK" - DENMARK</p> </li>
        /// <li> <p>"EC" - ECUADOR</p> </li>
        /// <li> <p>"EE" - ESTONIA</p> </li>
        /// <li> <p>"ET" - ETHIOPIA</p> </li>
        /// <li> <p>"FI" - FINLAND</p> </li>
        /// <li> <p>"FR" - FRANCE</p> </li>
        /// <li> <p>"DE" - GERMANY</p> </li>
        /// <li> <p>"GR" - GREECE</p> </li>
        /// <li> <p>"HU" - HUNGARY</p> </li>
        /// <li> <p>"IS" - ICELAND</p> </li>
        /// <li> <p>"IN" - INDIA</p> </li>
        /// <li> <p>"IE" - IRELAND</p> </li>
        /// <li> <p>"IT" - ITALY</p> </li>
        /// <li> <p>"JP" - JAPAN</p> </li>
        /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
        /// <li> <p>"KR" - KOREA</p> </li>
        /// <li> <p>"LV" - LATVIA</p> </li>
        /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
        /// <li> <p>"LT" - LITHUANIA</p> </li>
        /// <li> <p>"LU" - LUXEMBOURG</p> </li>
        /// <li> <p>"MK" - MACEDONIA</p> </li>
        /// <li> <p>"MT" - MALTA</p> </li>
        /// <li> <p>"MX" - MEXICO</p> </li>
        /// <li> <p>"MD" - MOLDOVA</p> </li>
        /// <li> <p>"ME" - MONTENEGRO</p> </li>
        /// <li> <p>"NL" - NETHERLANDS</p> </li>
        /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
        /// <li> <p>"NI" - NICARAGUA</p> </li>
        /// <li> <p>"NG" - NIGERIA</p> </li>
        /// <li> <p>"NO" - NORWAY</p> </li>
        /// <li> <p>"PA" - PANAMA</p> </li>
        /// <li> <p>"PY" - PARAGUAY</p> </li>
        /// <li> <p>"PE" - PERU</p> </li>
        /// <li> <p>"PL" - POLAND</p> </li>
        /// <li> <p>"PT" - PORTUGAL</p> </li>
        /// <li> <p>"RO" - ROMANIA</p> </li>
        /// <li> <p>"RU" - RUSSIA</p> </li>
        /// <li> <p>"RS" - SERBIA</p> </li>
        /// <li> <p>"SK" - SLOVAKIA</p> </li>
        /// <li> <p>"SI" - SLOVENIA</p> </li>
        /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
        /// <li> <p>"ES" - SPAIN</p> </li>
        /// <li> <p>"SE" - SWEDEN</p> </li>
        /// <li> <p>"CH" - SWITZERLAND</p> </li>
        /// <li> <p>"UA" - UKRAINE</p> </li>
        /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
        /// <li> <p>"US" - UNITED STATES</p> </li>
        /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
        /// <li> <p>"UY" - URUGUAY</p> </li>
        /// <li> <p>"VE" - VENEZUELA</p> </li>
        /// </ul>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> <b>Weather Index</b> </p>
        /// <p>To enable the Weather Index, set the value to <code>"true"</code> </p>
        /// <p> <b>Holidays</b> </p>
        /// <p>To enable Holidays, specify a country with one of the following two-letter country codes:</p>
        /// <ul>
        /// <li> <p>"AL" - ALBANIA</p> </li>
        /// <li> <p>"AR" - ARGENTINA</p> </li>
        /// <li> <p>"AT" - AUSTRIA</p> </li>
        /// <li> <p>"AU" - AUSTRALIA</p> </li>
        /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
        /// <li> <p>"BE" - BELGIUM</p> </li>
        /// <li> <p>"BG" - BULGARIA</p> </li>
        /// <li> <p>"BO" - BOLIVIA</p> </li>
        /// <li> <p>"BR" - BRAZIL</p> </li>
        /// <li> <p>"BY" - BELARUS</p> </li>
        /// <li> <p>"CA" - CANADA</p> </li>
        /// <li> <p>"CL" - CHILE</p> </li>
        /// <li> <p>"CO" - COLOMBIA</p> </li>
        /// <li> <p>"CR" - COSTA RICA</p> </li>
        /// <li> <p>"HR" - CROATIA</p> </li>
        /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
        /// <li> <p>"DK" - DENMARK</p> </li>
        /// <li> <p>"EC" - ECUADOR</p> </li>
        /// <li> <p>"EE" - ESTONIA</p> </li>
        /// <li> <p>"ET" - ETHIOPIA</p> </li>
        /// <li> <p>"FI" - FINLAND</p> </li>
        /// <li> <p>"FR" - FRANCE</p> </li>
        /// <li> <p>"DE" - GERMANY</p> </li>
        /// <li> <p>"GR" - GREECE</p> </li>
        /// <li> <p>"HU" - HUNGARY</p> </li>
        /// <li> <p>"IS" - ICELAND</p> </li>
        /// <li> <p>"IN" - INDIA</p> </li>
        /// <li> <p>"IE" - IRELAND</p> </li>
        /// <li> <p>"IT" - ITALY</p> </li>
        /// <li> <p>"JP" - JAPAN</p> </li>
        /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
        /// <li> <p>"KR" - KOREA</p> </li>
        /// <li> <p>"LV" - LATVIA</p> </li>
        /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
        /// <li> <p>"LT" - LITHUANIA</p> </li>
        /// <li> <p>"LU" - LUXEMBOURG</p> </li>
        /// <li> <p>"MK" - MACEDONIA</p> </li>
        /// <li> <p>"MT" - MALTA</p> </li>
        /// <li> <p>"MX" - MEXICO</p> </li>
        /// <li> <p>"MD" - MOLDOVA</p> </li>
        /// <li> <p>"ME" - MONTENEGRO</p> </li>
        /// <li> <p>"NL" - NETHERLANDS</p> </li>
        /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
        /// <li> <p>"NI" - NICARAGUA</p> </li>
        /// <li> <p>"NG" - NIGERIA</p> </li>
        /// <li> <p>"NO" - NORWAY</p> </li>
        /// <li> <p>"PA" - PANAMA</p> </li>
        /// <li> <p>"PY" - PARAGUAY</p> </li>
        /// <li> <p>"PE" - PERU</p> </li>
        /// <li> <p>"PL" - POLAND</p> </li>
        /// <li> <p>"PT" - PORTUGAL</p> </li>
        /// <li> <p>"RO" - ROMANIA</p> </li>
        /// <li> <p>"RU" - RUSSIA</p> </li>
        /// <li> <p>"RS" - SERBIA</p> </li>
        /// <li> <p>"SK" - SLOVAKIA</p> </li>
        /// <li> <p>"SI" - SLOVENIA</p> </li>
        /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
        /// <li> <p>"ES" - SPAIN</p> </li>
        /// <li> <p>"SE" - SWEDEN</p> </li>
        /// <li> <p>"CH" - SWITZERLAND</p> </li>
        /// <li> <p>"UA" - UKRAINE</p> </li>
        /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
        /// <li> <p>"US" - UNITED STATES</p> </li>
        /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
        /// <li> <p>"UY" - URUGUAY</p> </li>
        /// <li> <p>"VE" - VENEZUELA</p> </li>
        /// </ul>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`SupplementaryFeature`](crate::model::SupplementaryFeature).
        pub fn build(self) -> crate::model::SupplementaryFeature {
            crate::model::SupplementaryFeature {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl SupplementaryFeature {
    /// Creates a new builder-style object to manufacture [`SupplementaryFeature`](crate::model::SupplementaryFeature).
    pub fn builder() -> crate::model::supplementary_feature::Builder {
        crate::model::supplementary_feature::Builder::default()
    }
}

/// <p>Configuration information for a hyperparameter tuning job. You specify this object in the <code>CreatePredictor</code> request.</p>
/// <p>A <i>hyperparameter</i> is a parameter that governs the model training process. You set hyperparameters before training starts, unlike model parameters, which are determined during training. The values of the hyperparameters effect which values are chosen for the model parameters.</p>
/// <p>In a <i>hyperparameter tuning job</i>, Amazon Forecast chooses the set of hyperparameter values that optimize a specified metric. Forecast accomplishes this by running many training jobs over a range of hyperparameter values. The optimum set of values depends on the algorithm, the training data, and the specified metric objective.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HyperParameterTuningJobConfig {
    /// <p>Specifies the ranges of valid values for the hyperparameters.</p>
    #[doc(hidden)]
    pub parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
}
impl HyperParameterTuningJobConfig {
    /// <p>Specifies the ranges of valid values for the hyperparameters.</p>
    pub fn parameter_ranges(&self) -> std::option::Option<&crate::model::ParameterRanges> {
        self.parameter_ranges.as_ref()
    }
}
/// See [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig).
pub mod hyper_parameter_tuning_job_config {

    /// A builder for [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
    }
    impl Builder {
        /// <p>Specifies the ranges of valid values for the hyperparameters.</p>
        pub fn parameter_ranges(mut self, input: crate::model::ParameterRanges) -> Self {
            self.parameter_ranges = Some(input);
            self
        }
        /// <p>Specifies the ranges of valid values for the hyperparameters.</p>
        pub fn set_parameter_ranges(
            mut self,
            input: std::option::Option<crate::model::ParameterRanges>,
        ) -> Self {
            self.parameter_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig).
        pub fn build(self) -> crate::model::HyperParameterTuningJobConfig {
            crate::model::HyperParameterTuningJobConfig {
                parameter_ranges: self.parameter_ranges,
            }
        }
    }
}
impl HyperParameterTuningJobConfig {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig).
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_config::Builder {
        crate::model::hyper_parameter_tuning_job_config::Builder::default()
    }
}

/// <p>Specifies the categorical, continuous, and integer hyperparameters, and their ranges of tunable values. The range of tunable values determines which values that a hyperparameter tuning job can choose for the specified hyperparameter. This object is part of the <code>HyperParameterTuningJobConfig</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterRanges {
    /// <p>Specifies the tunable range for each categorical hyperparameter.</p>
    #[doc(hidden)]
    pub categorical_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
    /// <p>Specifies the tunable range for each continuous hyperparameter.</p>
    #[doc(hidden)]
    pub continuous_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
    /// <p>Specifies the tunable range for each integer hyperparameter.</p>
    #[doc(hidden)]
    pub integer_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
}
impl ParameterRanges {
    /// <p>Specifies the tunable range for each categorical hyperparameter.</p>
    pub fn categorical_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::CategoricalParameterRange]> {
        self.categorical_parameter_ranges.as_deref()
    }
    /// <p>Specifies the tunable range for each continuous hyperparameter.</p>
    pub fn continuous_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::ContinuousParameterRange]> {
        self.continuous_parameter_ranges.as_deref()
    }
    /// <p>Specifies the tunable range for each integer hyperparameter.</p>
    pub fn integer_parameter_ranges(
        &self,
    ) -> std::option::Option<&[crate::model::IntegerParameterRange]> {
        self.integer_parameter_ranges.as_deref()
    }
}
/// See [`ParameterRanges`](crate::model::ParameterRanges).
pub mod parameter_ranges {

    /// A builder for [`ParameterRanges`](crate::model::ParameterRanges).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) categorical_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
        pub(crate) continuous_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
        pub(crate) integer_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
    }
    impl Builder {
        /// Appends an item to `categorical_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_categorical_parameter_ranges`](Self::set_categorical_parameter_ranges).
        ///
        /// <p>Specifies the tunable range for each categorical hyperparameter.</p>
        pub fn categorical_parameter_ranges(
            mut self,
            input: crate::model::CategoricalParameterRange,
        ) -> Self {
            let mut v = self.categorical_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.categorical_parameter_ranges = Some(v);
            self
        }
        /// <p>Specifies the tunable range for each categorical hyperparameter.</p>
        pub fn set_categorical_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
        ) -> Self {
            self.categorical_parameter_ranges = input;
            self
        }
        /// Appends an item to `continuous_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_continuous_parameter_ranges`](Self::set_continuous_parameter_ranges).
        ///
        /// <p>Specifies the tunable range for each continuous hyperparameter.</p>
        pub fn continuous_parameter_ranges(
            mut self,
            input: crate::model::ContinuousParameterRange,
        ) -> Self {
            let mut v = self.continuous_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.continuous_parameter_ranges = Some(v);
            self
        }
        /// <p>Specifies the tunable range for each continuous hyperparameter.</p>
        pub fn set_continuous_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
        ) -> Self {
            self.continuous_parameter_ranges = input;
            self
        }
        /// Appends an item to `integer_parameter_ranges`.
        ///
        /// To override the contents of this collection use [`set_integer_parameter_ranges`](Self::set_integer_parameter_ranges).
        ///
        /// <p>Specifies the tunable range for each integer hyperparameter.</p>
        pub fn integer_parameter_ranges(
            mut self,
            input: crate::model::IntegerParameterRange,
        ) -> Self {
            let mut v = self.integer_parameter_ranges.unwrap_or_default();
            v.push(input);
            self.integer_parameter_ranges = Some(v);
            self
        }
        /// <p>Specifies the tunable range for each integer hyperparameter.</p>
        pub fn set_integer_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
        ) -> Self {
            self.integer_parameter_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterRanges`](crate::model::ParameterRanges).
        pub fn build(self) -> crate::model::ParameterRanges {
            crate::model::ParameterRanges {
                categorical_parameter_ranges: self.categorical_parameter_ranges,
                continuous_parameter_ranges: self.continuous_parameter_ranges,
                integer_parameter_ranges: self.integer_parameter_ranges,
            }
        }
    }
}
impl ParameterRanges {
    /// Creates a new builder-style object to manufacture [`ParameterRanges`](crate::model::ParameterRanges).
    pub fn builder() -> crate::model::parameter_ranges::Builder {
        crate::model::parameter_ranges::Builder::default()
    }
}

/// <p>Specifies an integer hyperparameter and it's range of tunable values. This object is part of the <code>ParameterRanges</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IntegerParameterRange {
    /// <p>The name of the hyperparameter to tune.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The maximum tunable value of the hyperparameter.</p>
    #[doc(hidden)]
    pub max_value: std::option::Option<i32>,
    /// <p>The minimum tunable value of the hyperparameter.</p>
    #[doc(hidden)]
    pub min_value: std::option::Option<i32>,
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
    /// </dd>
    /// <dt>
    /// ReverseLogarithmic
    /// </dt>
    /// <dd>
    /// <p>Not supported for <code>IntegerParameterRange</code>.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
    /// </dd>
    /// </dl>
    /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    #[doc(hidden)]
    pub scaling_type: std::option::Option<crate::model::ScalingType>,
}
impl IntegerParameterRange {
    /// <p>The name of the hyperparameter to tune.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The maximum tunable value of the hyperparameter.</p>
    pub fn max_value(&self) -> std::option::Option<i32> {
        self.max_value
    }
    /// <p>The minimum tunable value of the hyperparameter.</p>
    pub fn min_value(&self) -> std::option::Option<i32> {
        self.min_value
    }
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
    /// </dd>
    /// <dt>
    /// ReverseLogarithmic
    /// </dt>
    /// <dd>
    /// <p>Not supported for <code>IntegerParameterRange</code>.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
    /// </dd>
    /// </dl>
    /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    pub fn scaling_type(&self) -> std::option::Option<&crate::model::ScalingType> {
        self.scaling_type.as_ref()
    }
}
/// See [`IntegerParameterRange`](crate::model::IntegerParameterRange).
pub mod integer_parameter_range {

    /// A builder for [`IntegerParameterRange`](crate::model::IntegerParameterRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<i32>,
        pub(crate) min_value: std::option::Option<i32>,
        pub(crate) scaling_type: std::option::Option<crate::model::ScalingType>,
    }
    impl Builder {
        /// <p>The name of the hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hyperparameter to tune.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The maximum tunable value of the hyperparameter.</p>
        pub fn max_value(mut self, input: i32) -> Self {
            self.max_value = Some(input);
            self
        }
        /// <p>The maximum tunable value of the hyperparameter.</p>
        pub fn set_max_value(mut self, input: std::option::Option<i32>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The minimum tunable value of the hyperparameter.</p>
        pub fn min_value(mut self, input: i32) -> Self {
            self.min_value = Some(input);
            self
        }
        /// <p>The minimum tunable value of the hyperparameter.</p>
        pub fn set_min_value(mut self, input: std::option::Option<i32>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
        /// </dd>
        /// <dt>
        /// ReverseLogarithmic
        /// </dt>
        /// <dd>
        /// <p>Not supported for <code>IntegerParameterRange</code>.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
        /// </dd>
        /// </dl>
        /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        pub fn scaling_type(mut self, input: crate::model::ScalingType) -> Self {
            self.scaling_type = Some(input);
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
        /// </dd>
        /// <dt>
        /// ReverseLogarithmic
        /// </dt>
        /// <dd>
        /// <p>Not supported for <code>IntegerParameterRange</code>.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
        /// </dd>
        /// </dl>
        /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::ScalingType>,
        ) -> Self {
            self.scaling_type = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameterRange`](crate::model::IntegerParameterRange).
        pub fn build(self) -> crate::model::IntegerParameterRange {
            crate::model::IntegerParameterRange {
                name: self.name,
                max_value: self.max_value,
                min_value: self.min_value,
                scaling_type: self.scaling_type,
            }
        }
    }
}
impl IntegerParameterRange {
    /// Creates a new builder-style object to manufacture [`IntegerParameterRange`](crate::model::IntegerParameterRange).
    pub fn builder() -> crate::model::integer_parameter_range::Builder {
        crate::model::integer_parameter_range::Builder::default()
    }
}

/// When writing a match expression against `ScalingType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scalingtype = unimplemented!();
/// match scalingtype {
///     ScalingType::Auto => { /* ... */ },
///     ScalingType::Linear => { /* ... */ },
///     ScalingType::Logarithmic => { /* ... */ },
///     ScalingType::ReverseLogarithmic => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scalingtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScalingType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScalingType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScalingType::NewFeature` is defined.
/// Specifically, when `scalingtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScalingType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingType {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    #[allow(missing_docs)] // documentation missing in model
    Logarithmic,
    #[allow(missing_docs)] // documentation missing in model
    ReverseLogarithmic,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScalingType {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => ScalingType::Auto,
            "Linear" => ScalingType::Linear,
            "Logarithmic" => ScalingType::Logarithmic,
            "ReverseLogarithmic" => ScalingType::ReverseLogarithmic,
            other => ScalingType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScalingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalingType::from(s))
    }
}
impl ScalingType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalingType::Auto => "Auto",
            ScalingType::Linear => "Linear",
            ScalingType::Logarithmic => "Logarithmic",
            ScalingType::ReverseLogarithmic => "ReverseLogarithmic",
            ScalingType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Auto", "Linear", "Logarithmic", "ReverseLogarithmic"]
    }
}
impl AsRef<str> for ScalingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a continuous hyperparameter and it's range of tunable values. This object is part of the <code>ParameterRanges</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContinuousParameterRange {
    /// <p>The name of the hyperparameter to tune.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The maximum tunable value of the hyperparameter.</p>
    #[doc(hidden)]
    pub max_value: std::option::Option<f64>,
    /// <p>The minimum tunable value of the hyperparameter.</p>
    #[doc(hidden)]
    pub min_value: std::option::Option<f64>,
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
    /// </dd>
    /// <dt>
    /// ReverseLogarithmic
    /// </dt>
    /// <dd>
    /// <p>hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
    /// </dd>
    /// </dl>
    /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    #[doc(hidden)]
    pub scaling_type: std::option::Option<crate::model::ScalingType>,
}
impl ContinuousParameterRange {
    /// <p>The name of the hyperparameter to tune.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The maximum tunable value of the hyperparameter.</p>
    pub fn max_value(&self) -> std::option::Option<f64> {
        self.max_value
    }
    /// <p>The minimum tunable value of the hyperparameter.</p>
    pub fn min_value(&self) -> std::option::Option<f64> {
        self.min_value
    }
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
    /// <dl>
    /// <dt>
    /// Auto
    /// </dt>
    /// <dd>
    /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    /// </dd>
    /// <dt>
    /// Linear
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
    /// </dd>
    /// <dt>
    /// Logarithmic
    /// </dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
    /// </dd>
    /// <dt>
    /// ReverseLogarithmic
    /// </dt>
    /// <dd>
    /// <p>hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
    /// </dd>
    /// </dl>
    /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    pub fn scaling_type(&self) -> std::option::Option<&crate::model::ScalingType> {
        self.scaling_type.as_ref()
    }
}
/// See [`ContinuousParameterRange`](crate::model::ContinuousParameterRange).
pub mod continuous_parameter_range {

    /// A builder for [`ContinuousParameterRange`](crate::model::ContinuousParameterRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<f64>,
        pub(crate) min_value: std::option::Option<f64>,
        pub(crate) scaling_type: std::option::Option<crate::model::ScalingType>,
    }
    impl Builder {
        /// <p>The name of the hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the hyperparameter to tune.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The maximum tunable value of the hyperparameter.</p>
        pub fn max_value(mut self, input: f64) -> Self {
            self.max_value = Some(input);
            self
        }
        /// <p>The maximum tunable value of the hyperparameter.</p>
        pub fn set_max_value(mut self, input: std::option::Option<f64>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The minimum tunable value of the hyperparameter.</p>
        pub fn min_value(mut self, input: f64) -> Self {
            self.min_value = Some(input);
            self
        }
        /// <p>The minimum tunable value of the hyperparameter.</p>
        pub fn set_min_value(mut self, input: std::option::Option<f64>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
        /// </dd>
        /// <dt>
        /// ReverseLogarithmic
        /// </dt>
        /// <dd>
        /// <p>hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
        /// </dd>
        /// </dl>
        /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        pub fn scaling_type(mut self, input: crate::model::ScalingType) -> Self {
            self.scaling_type = Some(input);
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:</p>
        /// <dl>
        /// <dt>
        /// Auto
        /// </dt>
        /// <dd>
        /// <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
        /// </dd>
        /// <dt>
        /// Linear
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.</p>
        /// </dd>
        /// <dt>
        /// Logarithmic
        /// </dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
        /// </dd>
        /// <dt>
        /// ReverseLogarithmic
        /// </dt>
        /// <dd>
        /// <p>hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.</p>
        /// </dd>
        /// </dl>
        /// <p>For information about choosing a hyperparameter scale, see <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::ScalingType>,
        ) -> Self {
            self.scaling_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousParameterRange`](crate::model::ContinuousParameterRange).
        pub fn build(self) -> crate::model::ContinuousParameterRange {
            crate::model::ContinuousParameterRange {
                name: self.name,
                max_value: self.max_value,
                min_value: self.min_value,
                scaling_type: self.scaling_type,
            }
        }
    }
}
impl ContinuousParameterRange {
    /// Creates a new builder-style object to manufacture [`ContinuousParameterRange`](crate::model::ContinuousParameterRange).
    pub fn builder() -> crate::model::continuous_parameter_range::Builder {
        crate::model::continuous_parameter_range::Builder::default()
    }
}

/// <p>Specifies a categorical hyperparameter and it's range of tunable values. This object is part of the <code>ParameterRanges</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoricalParameterRange {
    /// <p>The name of the categorical hyperparameter to tune.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the tunable categories for the hyperparameter.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CategoricalParameterRange {
    /// <p>The name of the categorical hyperparameter to tune.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the tunable categories for the hyperparameter.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`CategoricalParameterRange`](crate::model::CategoricalParameterRange).
pub mod categorical_parameter_range {

    /// A builder for [`CategoricalParameterRange`](crate::model::CategoricalParameterRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the categorical hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the categorical hyperparameter to tune.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of the tunable categories for the hyperparameter.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>A list of the tunable categories for the hyperparameter.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalParameterRange`](crate::model::CategoricalParameterRange).
        pub fn build(self) -> crate::model::CategoricalParameterRange {
            crate::model::CategoricalParameterRange {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl CategoricalParameterRange {
    /// Creates a new builder-style object to manufacture [`CategoricalParameterRange`](crate::model::CategoricalParameterRange).
    pub fn builder() -> crate::model::categorical_parameter_range::Builder {
        crate::model::categorical_parameter_range::Builder::default()
    }
}

/// <p>Parameters that define how to split a dataset into training data and testing data, and the number of iterations to perform. These parameters are specified in the predefined algorithms but you can override them in the <code>CreatePredictor</code> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationParameters {
    /// <p>The number of times to split the input data. The default is 1. Valid values are 1 through 5.</p>
    #[doc(hidden)]
    pub number_of_backtest_windows: std::option::Option<i32>,
    /// <p>The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. <code>BackTestWindowOffset</code> can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length.</p>
    /// <p> <code>ForecastHorizon</code> &lt;= <code>BackTestWindowOffset</code> &lt; 1/2 * TARGET_TIME_SERIES dataset length</p>
    #[doc(hidden)]
    pub back_test_window_offset: std::option::Option<i32>,
}
impl EvaluationParameters {
    /// <p>The number of times to split the input data. The default is 1. Valid values are 1 through 5.</p>
    pub fn number_of_backtest_windows(&self) -> std::option::Option<i32> {
        self.number_of_backtest_windows
    }
    /// <p>The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. <code>BackTestWindowOffset</code> can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length.</p>
    /// <p> <code>ForecastHorizon</code> &lt;= <code>BackTestWindowOffset</code> &lt; 1/2 * TARGET_TIME_SERIES dataset length</p>
    pub fn back_test_window_offset(&self) -> std::option::Option<i32> {
        self.back_test_window_offset
    }
}
/// See [`EvaluationParameters`](crate::model::EvaluationParameters).
pub mod evaluation_parameters {

    /// A builder for [`EvaluationParameters`](crate::model::EvaluationParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) number_of_backtest_windows: std::option::Option<i32>,
        pub(crate) back_test_window_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of times to split the input data. The default is 1. Valid values are 1 through 5.</p>
        pub fn number_of_backtest_windows(mut self, input: i32) -> Self {
            self.number_of_backtest_windows = Some(input);
            self
        }
        /// <p>The number of times to split the input data. The default is 1. Valid values are 1 through 5.</p>
        pub fn set_number_of_backtest_windows(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_backtest_windows = input;
            self
        }
        /// <p>The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. <code>BackTestWindowOffset</code> can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length.</p>
        /// <p> <code>ForecastHorizon</code> &lt;= <code>BackTestWindowOffset</code> &lt; 1/2 * TARGET_TIME_SERIES dataset length</p>
        pub fn back_test_window_offset(mut self, input: i32) -> Self {
            self.back_test_window_offset = Some(input);
            self
        }
        /// <p>The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. <code>BackTestWindowOffset</code> can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length.</p>
        /// <p> <code>ForecastHorizon</code> &lt;= <code>BackTestWindowOffset</code> &lt; 1/2 * TARGET_TIME_SERIES dataset length</p>
        pub fn set_back_test_window_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.back_test_window_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationParameters`](crate::model::EvaluationParameters).
        pub fn build(self) -> crate::model::EvaluationParameters {
            crate::model::EvaluationParameters {
                number_of_backtest_windows: self.number_of_backtest_windows,
                back_test_window_offset: self.back_test_window_offset,
            }
        }
    }
}
impl EvaluationParameters {
    /// Creates a new builder-style object to manufacture [`EvaluationParameters`](crate::model::EvaluationParameters).
    pub fn builder() -> crate::model::evaluation_parameters::Builder {
        crate::model::evaluation_parameters::Builder::default()
    }
}

/// <p>Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Baseline {
    /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
    #[doc(hidden)]
    pub predictor_baseline: std::option::Option<crate::model::PredictorBaseline>,
}
impl Baseline {
    /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
    pub fn predictor_baseline(&self) -> std::option::Option<&crate::model::PredictorBaseline> {
        self.predictor_baseline.as_ref()
    }
}
/// See [`Baseline`](crate::model::Baseline).
pub mod baseline {

    /// A builder for [`Baseline`](crate::model::Baseline).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predictor_baseline: std::option::Option<crate::model::PredictorBaseline>,
    }
    impl Builder {
        /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
        pub fn predictor_baseline(mut self, input: crate::model::PredictorBaseline) -> Self {
            self.predictor_baseline = Some(input);
            self
        }
        /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
        pub fn set_predictor_baseline(
            mut self,
            input: std::option::Option<crate::model::PredictorBaseline>,
        ) -> Self {
            self.predictor_baseline = input;
            self
        }
        /// Consumes the builder and constructs a [`Baseline`](crate::model::Baseline).
        pub fn build(self) -> crate::model::Baseline {
            crate::model::Baseline {
                predictor_baseline: self.predictor_baseline,
            }
        }
    }
}
impl Baseline {
    /// Creates a new builder-style object to manufacture [`Baseline`](crate::model::Baseline).
    pub fn builder() -> crate::model::baseline::Builder {
        crate::model::baseline::Builder::default()
    }
}

/// <p>Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictorBaseline {
    /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
    #[doc(hidden)]
    pub baseline_metrics: std::option::Option<std::vec::Vec<crate::model::BaselineMetric>>,
}
impl PredictorBaseline {
    /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
    pub fn baseline_metrics(&self) -> std::option::Option<&[crate::model::BaselineMetric]> {
        self.baseline_metrics.as_deref()
    }
}
/// See [`PredictorBaseline`](crate::model::PredictorBaseline).
pub mod predictor_baseline {

    /// A builder for [`PredictorBaseline`](crate::model::PredictorBaseline).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baseline_metrics:
            std::option::Option<std::vec::Vec<crate::model::BaselineMetric>>,
    }
    impl Builder {
        /// Appends an item to `baseline_metrics`.
        ///
        /// To override the contents of this collection use [`set_baseline_metrics`](Self::set_baseline_metrics).
        ///
        /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
        pub fn baseline_metrics(mut self, input: crate::model::BaselineMetric) -> Self {
            let mut v = self.baseline_metrics.unwrap_or_default();
            v.push(input);
            self.baseline_metrics = Some(v);
            self
        }
        /// <p>The initial <a href="https://docs.aws.amazon.com/forecast/latest/dg/metrics.html">accuracy metrics</a> for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.</p>
        pub fn set_baseline_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BaselineMetric>>,
        ) -> Self {
            self.baseline_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictorBaseline`](crate::model::PredictorBaseline).
        pub fn build(self) -> crate::model::PredictorBaseline {
            crate::model::PredictorBaseline {
                baseline_metrics: self.baseline_metrics,
            }
        }
    }
}
impl PredictorBaseline {
    /// Creates a new builder-style object to manufacture [`PredictorBaseline`](crate::model::PredictorBaseline).
    pub fn builder() -> crate::model::predictor_baseline::Builder {
        crate::model::predictor_baseline::Builder::default()
    }
}

/// <p>An individual metric that you can use for comparison as you evaluate your monitoring results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BaselineMetric {
    /// <p>The name of the metric.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value for the metric.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
}
impl BaselineMetric {
    /// <p>The name of the metric.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value for the metric.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
/// See [`BaselineMetric`](crate::model::BaselineMetric).
pub mod baseline_metric {

    /// A builder for [`BaselineMetric`](crate::model::BaselineMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value for the metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value for the metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`BaselineMetric`](crate::model::BaselineMetric).
        pub fn build(self) -> crate::model::BaselineMetric {
            crate::model::BaselineMetric {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl BaselineMetric {
    /// Creates a new builder-style object to manufacture [`BaselineMetric`](crate::model::BaselineMetric).
    pub fn builder() -> crate::model::baseline_metric::Builder {
        crate::model::baseline_metric::Builder::default()
    }
}

/// <p>Provides statistics for each data field imported into to an Amazon Forecast dataset with the <a href="https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html">CreateDatasetImportJob</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Statistics {
    /// <p>The number of values in the field. If the response value is -1, refer to <code>CountLong</code>.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
    /// <p>The number of distinct values in the field. If the response value is -1, refer to <code>CountDistinctLong</code>.</p>
    #[doc(hidden)]
    pub count_distinct: std::option::Option<i32>,
    /// <p>The number of null values in the field. If the response value is -1, refer to <code>CountNullLong</code>.</p>
    #[doc(hidden)]
    pub count_null: std::option::Option<i32>,
    /// <p>The number of NAN (not a number) values in the field. If the response value is -1, refer to <code>CountNanLong</code>.</p>
    #[doc(hidden)]
    pub count_nan: std::option::Option<i32>,
    /// <p>For a numeric field, the minimum value in the field.</p>
    #[doc(hidden)]
    pub min: std::option::Option<std::string::String>,
    /// <p>For a numeric field, the maximum value in the field.</p>
    #[doc(hidden)]
    pub max: std::option::Option<std::string::String>,
    /// <p>For a numeric field, the average value in the field.</p>
    #[doc(hidden)]
    pub avg: std::option::Option<f64>,
    /// <p>For a numeric field, the standard deviation.</p>
    #[doc(hidden)]
    pub stddev: std::option::Option<f64>,
    /// <p>The number of values in the field. <code>CountLong</code> is used instead of <code>Count</code> if the value is greater than 2,147,483,647.</p>
    #[doc(hidden)]
    pub count_long: std::option::Option<i64>,
    /// <p>The number of distinct values in the field. <code>CountDistinctLong</code> is used instead of <code>CountDistinct</code> if the value is greater than 2,147,483,647.</p>
    #[doc(hidden)]
    pub count_distinct_long: std::option::Option<i64>,
    /// <p>The number of null values in the field. <code>CountNullLong</code> is used instead of <code>CountNull</code> if the value is greater than 2,147,483,647.</p>
    #[doc(hidden)]
    pub count_null_long: std::option::Option<i64>,
    /// <p>The number of NAN (not a number) values in the field. <code>CountNanLong</code> is used instead of <code>CountNan</code> if the value is greater than 2,147,483,647.</p>
    #[doc(hidden)]
    pub count_nan_long: std::option::Option<i64>,
}
impl Statistics {
    /// <p>The number of values in the field. If the response value is -1, refer to <code>CountLong</code>.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
    /// <p>The number of distinct values in the field. If the response value is -1, refer to <code>CountDistinctLong</code>.</p>
    pub fn count_distinct(&self) -> std::option::Option<i32> {
        self.count_distinct
    }
    /// <p>The number of null values in the field. If the response value is -1, refer to <code>CountNullLong</code>.</p>
    pub fn count_null(&self) -> std::option::Option<i32> {
        self.count_null
    }
    /// <p>The number of NAN (not a number) values in the field. If the response value is -1, refer to <code>CountNanLong</code>.</p>
    pub fn count_nan(&self) -> std::option::Option<i32> {
        self.count_nan
    }
    /// <p>For a numeric field, the minimum value in the field.</p>
    pub fn min(&self) -> std::option::Option<&str> {
        self.min.as_deref()
    }
    /// <p>For a numeric field, the maximum value in the field.</p>
    pub fn max(&self) -> std::option::Option<&str> {
        self.max.as_deref()
    }
    /// <p>For a numeric field, the average value in the field.</p>
    pub fn avg(&self) -> std::option::Option<f64> {
        self.avg
    }
    /// <p>For a numeric field, the standard deviation.</p>
    pub fn stddev(&self) -> std::option::Option<f64> {
        self.stddev
    }
    /// <p>The number of values in the field. <code>CountLong</code> is used instead of <code>Count</code> if the value is greater than 2,147,483,647.</p>
    pub fn count_long(&self) -> std::option::Option<i64> {
        self.count_long
    }
    /// <p>The number of distinct values in the field. <code>CountDistinctLong</code> is used instead of <code>CountDistinct</code> if the value is greater than 2,147,483,647.</p>
    pub fn count_distinct_long(&self) -> std::option::Option<i64> {
        self.count_distinct_long
    }
    /// <p>The number of null values in the field. <code>CountNullLong</code> is used instead of <code>CountNull</code> if the value is greater than 2,147,483,647.</p>
    pub fn count_null_long(&self) -> std::option::Option<i64> {
        self.count_null_long
    }
    /// <p>The number of NAN (not a number) values in the field. <code>CountNanLong</code> is used instead of <code>CountNan</code> if the value is greater than 2,147,483,647.</p>
    pub fn count_nan_long(&self) -> std::option::Option<i64> {
        self.count_nan_long
    }
}
/// See [`Statistics`](crate::model::Statistics).
pub mod statistics {

    /// A builder for [`Statistics`](crate::model::Statistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) count_distinct: std::option::Option<i32>,
        pub(crate) count_null: std::option::Option<i32>,
        pub(crate) count_nan: std::option::Option<i32>,
        pub(crate) min: std::option::Option<std::string::String>,
        pub(crate) max: std::option::Option<std::string::String>,
        pub(crate) avg: std::option::Option<f64>,
        pub(crate) stddev: std::option::Option<f64>,
        pub(crate) count_long: std::option::Option<i64>,
        pub(crate) count_distinct_long: std::option::Option<i64>,
        pub(crate) count_null_long: std::option::Option<i64>,
        pub(crate) count_nan_long: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of values in the field. If the response value is -1, refer to <code>CountLong</code>.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of values in the field. If the response value is -1, refer to <code>CountLong</code>.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The number of distinct values in the field. If the response value is -1, refer to <code>CountDistinctLong</code>.</p>
        pub fn count_distinct(mut self, input: i32) -> Self {
            self.count_distinct = Some(input);
            self
        }
        /// <p>The number of distinct values in the field. If the response value is -1, refer to <code>CountDistinctLong</code>.</p>
        pub fn set_count_distinct(mut self, input: std::option::Option<i32>) -> Self {
            self.count_distinct = input;
            self
        }
        /// <p>The number of null values in the field. If the response value is -1, refer to <code>CountNullLong</code>.</p>
        pub fn count_null(mut self, input: i32) -> Self {
            self.count_null = Some(input);
            self
        }
        /// <p>The number of null values in the field. If the response value is -1, refer to <code>CountNullLong</code>.</p>
        pub fn set_count_null(mut self, input: std::option::Option<i32>) -> Self {
            self.count_null = input;
            self
        }
        /// <p>The number of NAN (not a number) values in the field. If the response value is -1, refer to <code>CountNanLong</code>.</p>
        pub fn count_nan(mut self, input: i32) -> Self {
            self.count_nan = Some(input);
            self
        }
        /// <p>The number of NAN (not a number) values in the field. If the response value is -1, refer to <code>CountNanLong</code>.</p>
        pub fn set_count_nan(mut self, input: std::option::Option<i32>) -> Self {
            self.count_nan = input;
            self
        }
        /// <p>For a numeric field, the minimum value in the field.</p>
        pub fn min(mut self, input: impl Into<std::string::String>) -> Self {
            self.min = Some(input.into());
            self
        }
        /// <p>For a numeric field, the minimum value in the field.</p>
        pub fn set_min(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min = input;
            self
        }
        /// <p>For a numeric field, the maximum value in the field.</p>
        pub fn max(mut self, input: impl Into<std::string::String>) -> Self {
            self.max = Some(input.into());
            self
        }
        /// <p>For a numeric field, the maximum value in the field.</p>
        pub fn set_max(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max = input;
            self
        }
        /// <p>For a numeric field, the average value in the field.</p>
        pub fn avg(mut self, input: f64) -> Self {
            self.avg = Some(input);
            self
        }
        /// <p>For a numeric field, the average value in the field.</p>
        pub fn set_avg(mut self, input: std::option::Option<f64>) -> Self {
            self.avg = input;
            self
        }
        /// <p>For a numeric field, the standard deviation.</p>
        pub fn stddev(mut self, input: f64) -> Self {
            self.stddev = Some(input);
            self
        }
        /// <p>For a numeric field, the standard deviation.</p>
        pub fn set_stddev(mut self, input: std::option::Option<f64>) -> Self {
            self.stddev = input;
            self
        }
        /// <p>The number of values in the field. <code>CountLong</code> is used instead of <code>Count</code> if the value is greater than 2,147,483,647.</p>
        pub fn count_long(mut self, input: i64) -> Self {
            self.count_long = Some(input);
            self
        }
        /// <p>The number of values in the field. <code>CountLong</code> is used instead of <code>Count</code> if the value is greater than 2,147,483,647.</p>
        pub fn set_count_long(mut self, input: std::option::Option<i64>) -> Self {
            self.count_long = input;
            self
        }
        /// <p>The number of distinct values in the field. <code>CountDistinctLong</code> is used instead of <code>CountDistinct</code> if the value is greater than 2,147,483,647.</p>
        pub fn count_distinct_long(mut self, input: i64) -> Self {
            self.count_distinct_long = Some(input);
            self
        }
        /// <p>The number of distinct values in the field. <code>CountDistinctLong</code> is used instead of <code>CountDistinct</code> if the value is greater than 2,147,483,647.</p>
        pub fn set_count_distinct_long(mut self, input: std::option::Option<i64>) -> Self {
            self.count_distinct_long = input;
            self
        }
        /// <p>The number of null values in the field. <code>CountNullLong</code> is used instead of <code>CountNull</code> if the value is greater than 2,147,483,647.</p>
        pub fn count_null_long(mut self, input: i64) -> Self {
            self.count_null_long = Some(input);
            self
        }
        /// <p>The number of null values in the field. <code>CountNullLong</code> is used instead of <code>CountNull</code> if the value is greater than 2,147,483,647.</p>
        pub fn set_count_null_long(mut self, input: std::option::Option<i64>) -> Self {
            self.count_null_long = input;
            self
        }
        /// <p>The number of NAN (not a number) values in the field. <code>CountNanLong</code> is used instead of <code>CountNan</code> if the value is greater than 2,147,483,647.</p>
        pub fn count_nan_long(mut self, input: i64) -> Self {
            self.count_nan_long = Some(input);
            self
        }
        /// <p>The number of NAN (not a number) values in the field. <code>CountNanLong</code> is used instead of <code>CountNan</code> if the value is greater than 2,147,483,647.</p>
        pub fn set_count_nan_long(mut self, input: std::option::Option<i64>) -> Self {
            self.count_nan_long = input;
            self
        }
        /// Consumes the builder and constructs a [`Statistics`](crate::model::Statistics).
        pub fn build(self) -> crate::model::Statistics {
            crate::model::Statistics {
                count: self.count,
                count_distinct: self.count_distinct,
                count_null: self.count_null,
                count_nan: self.count_nan,
                min: self.min,
                max: self.max,
                avg: self.avg,
                stddev: self.stddev,
                count_long: self.count_long,
                count_distinct_long: self.count_distinct_long,
                count_null_long: self.count_null_long,
                count_nan_long: self.count_nan_long,
            }
        }
    }
}
impl Statistics {
    /// Creates a new builder-style object to manufacture [`Statistics`](crate::model::Statistics).
    pub fn builder() -> crate::model::statistics::Builder {
        crate::model::statistics::Builder::default()
    }
}

/// <p>The time boundary Forecast uses to align and aggregate your data to match your forecast frequency. Provide the unit of time and the time boundary as a key value pair. If you don't provide a time boundary, Forecast uses a set of <a href="https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries">Default Time Boundaries</a>. </p>
/// <p>For more information about aggregation, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html">Data Aggregation for Different Forecast Frequencies</a>. For more information setting a custom time boundary, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary">Specifying a Time Boundary</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeAlignmentBoundary {
    /// <p>The month to use for time alignment during aggregation. The month must be in uppercase.</p>
    #[doc(hidden)]
    pub month: std::option::Option<crate::model::Month>,
    /// <p>The day of the month to use for time alignment during aggregation.</p>
    #[doc(hidden)]
    pub day_of_month: std::option::Option<i32>,
    /// <p>The day of week to use for time alignment during aggregation. The day must be in uppercase.</p>
    #[doc(hidden)]
    pub day_of_week: std::option::Option<crate::model::DayOfWeek>,
    /// <p>The hour of day to use for time alignment during aggregation.</p>
    #[doc(hidden)]
    pub hour: std::option::Option<i32>,
}
impl TimeAlignmentBoundary {
    /// <p>The month to use for time alignment during aggregation. The month must be in uppercase.</p>
    pub fn month(&self) -> std::option::Option<&crate::model::Month> {
        self.month.as_ref()
    }
    /// <p>The day of the month to use for time alignment during aggregation.</p>
    pub fn day_of_month(&self) -> std::option::Option<i32> {
        self.day_of_month
    }
    /// <p>The day of week to use for time alignment during aggregation. The day must be in uppercase.</p>
    pub fn day_of_week(&self) -> std::option::Option<&crate::model::DayOfWeek> {
        self.day_of_week.as_ref()
    }
    /// <p>The hour of day to use for time alignment during aggregation.</p>
    pub fn hour(&self) -> std::option::Option<i32> {
        self.hour
    }
}
/// See [`TimeAlignmentBoundary`](crate::model::TimeAlignmentBoundary).
pub mod time_alignment_boundary {

    /// A builder for [`TimeAlignmentBoundary`](crate::model::TimeAlignmentBoundary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) month: std::option::Option<crate::model::Month>,
        pub(crate) day_of_month: std::option::Option<i32>,
        pub(crate) day_of_week: std::option::Option<crate::model::DayOfWeek>,
        pub(crate) hour: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The month to use for time alignment during aggregation. The month must be in uppercase.</p>
        pub fn month(mut self, input: crate::model::Month) -> Self {
            self.month = Some(input);
            self
        }
        /// <p>The month to use for time alignment during aggregation. The month must be in uppercase.</p>
        pub fn set_month(mut self, input: std::option::Option<crate::model::Month>) -> Self {
            self.month = input;
            self
        }
        /// <p>The day of the month to use for time alignment during aggregation.</p>
        pub fn day_of_month(mut self, input: i32) -> Self {
            self.day_of_month = Some(input);
            self
        }
        /// <p>The day of the month to use for time alignment during aggregation.</p>
        pub fn set_day_of_month(mut self, input: std::option::Option<i32>) -> Self {
            self.day_of_month = input;
            self
        }
        /// <p>The day of week to use for time alignment during aggregation. The day must be in uppercase.</p>
        pub fn day_of_week(mut self, input: crate::model::DayOfWeek) -> Self {
            self.day_of_week = Some(input);
            self
        }
        /// <p>The day of week to use for time alignment during aggregation. The day must be in uppercase.</p>
        pub fn set_day_of_week(
            mut self,
            input: std::option::Option<crate::model::DayOfWeek>,
        ) -> Self {
            self.day_of_week = input;
            self
        }
        /// <p>The hour of day to use for time alignment during aggregation.</p>
        pub fn hour(mut self, input: i32) -> Self {
            self.hour = Some(input);
            self
        }
        /// <p>The hour of day to use for time alignment during aggregation.</p>
        pub fn set_hour(mut self, input: std::option::Option<i32>) -> Self {
            self.hour = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeAlignmentBoundary`](crate::model::TimeAlignmentBoundary).
        pub fn build(self) -> crate::model::TimeAlignmentBoundary {
            crate::model::TimeAlignmentBoundary {
                month: self.month,
                day_of_month: self.day_of_month,
                day_of_week: self.day_of_week,
                hour: self.hour,
            }
        }
    }
}
impl TimeAlignmentBoundary {
    /// Creates a new builder-style object to manufacture [`TimeAlignmentBoundary`](crate::model::TimeAlignmentBoundary).
    pub fn builder() -> crate::model::time_alignment_boundary::Builder {
        crate::model::time_alignment_boundary::Builder::default()
    }
}

/// When writing a match expression against `DayOfWeek`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dayofweek = unimplemented!();
/// match dayofweek {
///     DayOfWeek::Friday => { /* ... */ },
///     DayOfWeek::Monday => { /* ... */ },
///     DayOfWeek::Saturday => { /* ... */ },
///     DayOfWeek::Sunday => { /* ... */ },
///     DayOfWeek::Thursday => { /* ... */ },
///     DayOfWeek::Tuesday => { /* ... */ },
///     DayOfWeek::Wednesday => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dayofweek` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DayOfWeek::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DayOfWeek::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DayOfWeek::NewFeature` is defined.
/// Specifically, when `dayofweek` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DayOfWeek::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DayOfWeek {
    #[allow(missing_docs)] // documentation missing in model
    Friday,
    #[allow(missing_docs)] // documentation missing in model
    Monday,
    #[allow(missing_docs)] // documentation missing in model
    Saturday,
    #[allow(missing_docs)] // documentation missing in model
    Sunday,
    #[allow(missing_docs)] // documentation missing in model
    Thursday,
    #[allow(missing_docs)] // documentation missing in model
    Tuesday,
    #[allow(missing_docs)] // documentation missing in model
    Wednesday,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DayOfWeek {
    fn from(s: &str) -> Self {
        match s {
            "FRIDAY" => DayOfWeek::Friday,
            "MONDAY" => DayOfWeek::Monday,
            "SATURDAY" => DayOfWeek::Saturday,
            "SUNDAY" => DayOfWeek::Sunday,
            "THURSDAY" => DayOfWeek::Thursday,
            "TUESDAY" => DayOfWeek::Tuesday,
            "WEDNESDAY" => DayOfWeek::Wednesday,
            other => DayOfWeek::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DayOfWeek {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DayOfWeek::from(s))
    }
}
impl DayOfWeek {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DayOfWeek::Friday => "FRIDAY",
            DayOfWeek::Monday => "MONDAY",
            DayOfWeek::Saturday => "SATURDAY",
            DayOfWeek::Sunday => "SUNDAY",
            DayOfWeek::Thursday => "THURSDAY",
            DayOfWeek::Tuesday => "TUESDAY",
            DayOfWeek::Wednesday => "WEDNESDAY",
            DayOfWeek::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FRIDAY",
            "MONDAY",
            "SATURDAY",
            "SUNDAY",
            "THURSDAY",
            "TUESDAY",
            "WEDNESDAY",
        ]
    }
}
impl AsRef<str> for DayOfWeek {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Month`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let month = unimplemented!();
/// match month {
///     Month::April => { /* ... */ },
///     Month::August => { /* ... */ },
///     Month::December => { /* ... */ },
///     Month::February => { /* ... */ },
///     Month::January => { /* ... */ },
///     Month::July => { /* ... */ },
///     Month::June => { /* ... */ },
///     Month::March => { /* ... */ },
///     Month::May => { /* ... */ },
///     Month::November => { /* ... */ },
///     Month::October => { /* ... */ },
///     Month::September => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `month` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Month::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Month::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Month::NewFeature` is defined.
/// Specifically, when `month` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Month::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Month {
    #[allow(missing_docs)] // documentation missing in model
    April,
    #[allow(missing_docs)] // documentation missing in model
    August,
    #[allow(missing_docs)] // documentation missing in model
    December,
    #[allow(missing_docs)] // documentation missing in model
    February,
    #[allow(missing_docs)] // documentation missing in model
    January,
    #[allow(missing_docs)] // documentation missing in model
    July,
    #[allow(missing_docs)] // documentation missing in model
    June,
    #[allow(missing_docs)] // documentation missing in model
    March,
    #[allow(missing_docs)] // documentation missing in model
    May,
    #[allow(missing_docs)] // documentation missing in model
    November,
    #[allow(missing_docs)] // documentation missing in model
    October,
    #[allow(missing_docs)] // documentation missing in model
    September,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Month {
    fn from(s: &str) -> Self {
        match s {
            "APRIL" => Month::April,
            "AUGUST" => Month::August,
            "DECEMBER" => Month::December,
            "FEBRUARY" => Month::February,
            "JANUARY" => Month::January,
            "JULY" => Month::July,
            "JUNE" => Month::June,
            "MARCH" => Month::March,
            "MAY" => Month::May,
            "NOVEMBER" => Month::November,
            "OCTOBER" => Month::October,
            "SEPTEMBER" => Month::September,
            other => Month::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Month {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Month::from(s))
    }
}
impl Month {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Month::April => "APRIL",
            Month::August => "AUGUST",
            Month::December => "DECEMBER",
            Month::February => "FEBRUARY",
            Month::January => "JANUARY",
            Month::July => "JULY",
            Month::June => "JUNE",
            Month::March => "MARCH",
            Month::May => "MAY",
            Month::November => "NOVEMBER",
            Month::October => "OCTOBER",
            Month::September => "SEPTEMBER",
            Month::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "APRIL",
            "AUGUST",
            "DECEMBER",
            "FEBRUARY",
            "JANUARY",
            "JULY",
            "JUNE",
            "MARCH",
            "MAY",
            "NOVEMBER",
            "OCTOBER",
            "SEPTEMBER",
        ]
    }
}
impl AsRef<str> for Month {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the monitor resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitorInfo {
    /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>The status of the monitor. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
}
impl MonitorInfo {
    /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
    /// <p>The status of the monitor. States include:</p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
/// See [`MonitorInfo`](crate::model::MonitorInfo).
pub mod monitor_info {

    /// A builder for [`MonitorInfo`](crate::model::MonitorInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitor resource.</p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>The status of the monitor. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the monitor. States include:</p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>ACTIVE_STOPPING</code>, <code>ACTIVE_STOPPED</code> </p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitorInfo`](crate::model::MonitorInfo).
        pub fn build(self) -> crate::model::MonitorInfo {
            crate::model::MonitorInfo {
                monitor_arn: self.monitor_arn,
                status: self.status,
            }
        }
    }
}
impl MonitorInfo {
    /// Creates a new builder-style object to manufacture [`MonitorInfo`](crate::model::MonitorInfo).
    pub fn builder() -> crate::model::monitor_info::Builder {
        crate::model::monitor_info::Builder::default()
    }
}

/// <p>Provides information about the Explainability resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExplainabilityInfo {
    /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
    #[doc(hidden)]
    pub explainability_arn: std::option::Option<std::string::String>,
    /// <p>The status of the Explainability. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
}
impl ExplainabilityInfo {
    /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
    pub fn explainability_arn(&self) -> std::option::Option<&str> {
        self.explainability_arn.as_deref()
    }
    /// <p>The status of the Explainability. States include: </p>
    /// <ul>
    /// <li> <p> <code>ACTIVE</code> </p> </li>
    /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
    /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
    /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
/// See [`ExplainabilityInfo`](crate::model::ExplainabilityInfo).
pub mod explainability_info {

    /// A builder for [`ExplainabilityInfo`](crate::model::ExplainabilityInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) explainability_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
        pub fn explainability_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Explainability.</p>
        pub fn set_explainability_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability_arn = input;
            self
        }
        /// <p>The status of the Explainability. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the Explainability. States include: </p>
        /// <ul>
        /// <li> <p> <code>ACTIVE</code> </p> </li>
        /// <li> <p> <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>, <code>CREATE_FAILED</code> </p> </li>
        /// <li> <p> <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code> </p> </li>
        /// <li> <p> <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>, <code>DELETE_FAILED</code> </p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ExplainabilityInfo`](crate::model::ExplainabilityInfo).
        pub fn build(self) -> crate::model::ExplainabilityInfo {
            crate::model::ExplainabilityInfo {
                explainability_arn: self.explainability_arn,
                status: self.status,
            }
        }
    }
}
impl ExplainabilityInfo {
    /// Creates a new builder-style object to manufacture [`ExplainabilityInfo`](crate::model::ExplainabilityInfo).
    pub fn builder() -> crate::model::explainability_info::Builder {
        crate::model::explainability_info::Builder::default()
    }
}

/// <p>The data configuration for your dataset group and any additional datasets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataConfig {
    /// <p>The ARN of the dataset group used to train the predictor.</p>
    #[doc(hidden)]
    pub dataset_group_arn: std::option::Option<std::string::String>,
    /// <p>Aggregation and filling options for attributes in your dataset group.</p>
    #[doc(hidden)]
    pub attribute_configs: std::option::Option<std::vec::Vec<crate::model::AttributeConfig>>,
    /// <p>Additional built-in datasets like Holidays and the Weather Index.</p>
    #[doc(hidden)]
    pub additional_datasets: std::option::Option<std::vec::Vec<crate::model::AdditionalDataset>>,
}
impl DataConfig {
    /// <p>The ARN of the dataset group used to train the predictor.</p>
    pub fn dataset_group_arn(&self) -> std::option::Option<&str> {
        self.dataset_group_arn.as_deref()
    }
    /// <p>Aggregation and filling options for attributes in your dataset group.</p>
    pub fn attribute_configs(&self) -> std::option::Option<&[crate::model::AttributeConfig]> {
        self.attribute_configs.as_deref()
    }
    /// <p>Additional built-in datasets like Holidays and the Weather Index.</p>
    pub fn additional_datasets(&self) -> std::option::Option<&[crate::model::AdditionalDataset]> {
        self.additional_datasets.as_deref()
    }
}
/// See [`DataConfig`](crate::model::DataConfig).
pub mod data_config {

    /// A builder for [`DataConfig`](crate::model::DataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_group_arn: std::option::Option<std::string::String>,
        pub(crate) attribute_configs:
            std::option::Option<std::vec::Vec<crate::model::AttributeConfig>>,
        pub(crate) additional_datasets:
            std::option::Option<std::vec::Vec<crate::model::AdditionalDataset>>,
    }
    impl Builder {
        /// <p>The ARN of the dataset group used to train the predictor.</p>
        pub fn dataset_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the dataset group used to train the predictor.</p>
        pub fn set_dataset_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_group_arn = input;
            self
        }
        /// Appends an item to `attribute_configs`.
        ///
        /// To override the contents of this collection use [`set_attribute_configs`](Self::set_attribute_configs).
        ///
        /// <p>Aggregation and filling options for attributes in your dataset group.</p>
        pub fn attribute_configs(mut self, input: crate::model::AttributeConfig) -> Self {
            let mut v = self.attribute_configs.unwrap_or_default();
            v.push(input);
            self.attribute_configs = Some(v);
            self
        }
        /// <p>Aggregation and filling options for attributes in your dataset group.</p>
        pub fn set_attribute_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttributeConfig>>,
        ) -> Self {
            self.attribute_configs = input;
            self
        }
        /// Appends an item to `additional_datasets`.
        ///
        /// To override the contents of this collection use [`set_additional_datasets`](Self::set_additional_datasets).
        ///
        /// <p>Additional built-in datasets like Holidays and the Weather Index.</p>
        pub fn additional_datasets(mut self, input: crate::model::AdditionalDataset) -> Self {
            let mut v = self.additional_datasets.unwrap_or_default();
            v.push(input);
            self.additional_datasets = Some(v);
            self
        }
        /// <p>Additional built-in datasets like Holidays and the Weather Index.</p>
        pub fn set_additional_datasets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdditionalDataset>>,
        ) -> Self {
            self.additional_datasets = input;
            self
        }
        /// Consumes the builder and constructs a [`DataConfig`](crate::model::DataConfig).
        pub fn build(self) -> crate::model::DataConfig {
            crate::model::DataConfig {
                dataset_group_arn: self.dataset_group_arn,
                attribute_configs: self.attribute_configs,
                additional_datasets: self.additional_datasets,
            }
        }
    }
}
impl DataConfig {
    /// Creates a new builder-style object to manufacture [`DataConfig`](crate::model::DataConfig).
    pub fn builder() -> crate::model::data_config::Builder {
        crate::model::data_config::Builder::default()
    }
}

/// <p>Describes an additional dataset. This object is part of the <code>DataConfig</code> object. Forecast supports the Weather Index and Holidays additional datasets.</p>
/// <p> <b>Weather Index</b> </p>
/// <p>The Amazon Forecast Weather Index is a built-in dataset that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/weather.html">Amazon Forecast Weather Index</a>.</p>
/// <p> <b>Holidays</b> </p>
/// <p>Holidays is a built-in dataset that incorporates national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the <a href="http://jollyday.sourceforge.net/data.html">Jollyday</a> library. For more information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/holidays.html">Holidays Featurization</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdditionalDataset {
    /// <p>The name of the additional dataset. Valid names: <code>"holiday"</code> and <code>"weather"</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> <b>Weather Index</b> </p>
    /// <p>To enable the Weather Index, do not specify a value for <code>Configuration</code>.</p>
    /// <p> <b>Holidays</b> </p>
    /// <p> <b>Holidays</b> </p>
    /// <p>To enable Holidays, set <code>CountryCode</code> to one of the following two-letter country codes:</p>
    /// <ul>
    /// <li> <p>"AL" - ALBANIA</p> </li>
    /// <li> <p>"AR" - ARGENTINA</p> </li>
    /// <li> <p>"AT" - AUSTRIA</p> </li>
    /// <li> <p>"AU" - AUSTRALIA</p> </li>
    /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
    /// <li> <p>"BE" - BELGIUM</p> </li>
    /// <li> <p>"BG" - BULGARIA</p> </li>
    /// <li> <p>"BO" - BOLIVIA</p> </li>
    /// <li> <p>"BR" - BRAZIL</p> </li>
    /// <li> <p>"BY" - BELARUS</p> </li>
    /// <li> <p>"CA" - CANADA</p> </li>
    /// <li> <p>"CL" - CHILE</p> </li>
    /// <li> <p>"CO" - COLOMBIA</p> </li>
    /// <li> <p>"CR" - COSTA RICA</p> </li>
    /// <li> <p>"HR" - CROATIA</p> </li>
    /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
    /// <li> <p>"DK" - DENMARK</p> </li>
    /// <li> <p>"EC" - ECUADOR</p> </li>
    /// <li> <p>"EE" - ESTONIA</p> </li>
    /// <li> <p>"ET" - ETHIOPIA</p> </li>
    /// <li> <p>"FI" - FINLAND</p> </li>
    /// <li> <p>"FR" - FRANCE</p> </li>
    /// <li> <p>"DE" - GERMANY</p> </li>
    /// <li> <p>"GR" - GREECE</p> </li>
    /// <li> <p>"HU" - HUNGARY</p> </li>
    /// <li> <p>"IS" - ICELAND</p> </li>
    /// <li> <p>"IN" - INDIA</p> </li>
    /// <li> <p>"IE" - IRELAND</p> </li>
    /// <li> <p>"IT" - ITALY</p> </li>
    /// <li> <p>"JP" - JAPAN</p> </li>
    /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
    /// <li> <p>"KR" - KOREA</p> </li>
    /// <li> <p>"LV" - LATVIA</p> </li>
    /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
    /// <li> <p>"LT" - LITHUANIA</p> </li>
    /// <li> <p>"LU" - LUXEMBOURG</p> </li>
    /// <li> <p>"MK" - MACEDONIA</p> </li>
    /// <li> <p>"MT" - MALTA</p> </li>
    /// <li> <p>"MX" - MEXICO</p> </li>
    /// <li> <p>"MD" - MOLDOVA</p> </li>
    /// <li> <p>"ME" - MONTENEGRO</p> </li>
    /// <li> <p>"NL" - NETHERLANDS</p> </li>
    /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
    /// <li> <p>"NI" - NICARAGUA</p> </li>
    /// <li> <p>"NG" - NIGERIA</p> </li>
    /// <li> <p>"NO" - NORWAY</p> </li>
    /// <li> <p>"PA" - PANAMA</p> </li>
    /// <li> <p>"PY" - PARAGUAY</p> </li>
    /// <li> <p>"PE" - PERU</p> </li>
    /// <li> <p>"PL" - POLAND</p> </li>
    /// <li> <p>"PT" - PORTUGAL</p> </li>
    /// <li> <p>"RO" - ROMANIA</p> </li>
    /// <li> <p>"RU" - RUSSIA</p> </li>
    /// <li> <p>"RS" - SERBIA</p> </li>
    /// <li> <p>"SK" - SLOVAKIA</p> </li>
    /// <li> <p>"SI" - SLOVENIA</p> </li>
    /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
    /// <li> <p>"ES" - SPAIN</p> </li>
    /// <li> <p>"SE" - SWEDEN</p> </li>
    /// <li> <p>"CH" - SWITZERLAND</p> </li>
    /// <li> <p>"UA" - UKRAINE</p> </li>
    /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
    /// <li> <p>"US" - UNITED STATES</p> </li>
    /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
    /// <li> <p>"UY" - URUGUAY</p> </li>
    /// <li> <p>"VE" - VENEZUELA</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub configuration: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl AdditionalDataset {
    /// <p>The name of the additional dataset. Valid names: <code>"holiday"</code> and <code>"weather"</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> <b>Weather Index</b> </p>
    /// <p>To enable the Weather Index, do not specify a value for <code>Configuration</code>.</p>
    /// <p> <b>Holidays</b> </p>
    /// <p> <b>Holidays</b> </p>
    /// <p>To enable Holidays, set <code>CountryCode</code> to one of the following two-letter country codes:</p>
    /// <ul>
    /// <li> <p>"AL" - ALBANIA</p> </li>
    /// <li> <p>"AR" - ARGENTINA</p> </li>
    /// <li> <p>"AT" - AUSTRIA</p> </li>
    /// <li> <p>"AU" - AUSTRALIA</p> </li>
    /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
    /// <li> <p>"BE" - BELGIUM</p> </li>
    /// <li> <p>"BG" - BULGARIA</p> </li>
    /// <li> <p>"BO" - BOLIVIA</p> </li>
    /// <li> <p>"BR" - BRAZIL</p> </li>
    /// <li> <p>"BY" - BELARUS</p> </li>
    /// <li> <p>"CA" - CANADA</p> </li>
    /// <li> <p>"CL" - CHILE</p> </li>
    /// <li> <p>"CO" - COLOMBIA</p> </li>
    /// <li> <p>"CR" - COSTA RICA</p> </li>
    /// <li> <p>"HR" - CROATIA</p> </li>
    /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
    /// <li> <p>"DK" - DENMARK</p> </li>
    /// <li> <p>"EC" - ECUADOR</p> </li>
    /// <li> <p>"EE" - ESTONIA</p> </li>
    /// <li> <p>"ET" - ETHIOPIA</p> </li>
    /// <li> <p>"FI" - FINLAND</p> </li>
    /// <li> <p>"FR" - FRANCE</p> </li>
    /// <li> <p>"DE" - GERMANY</p> </li>
    /// <li> <p>"GR" - GREECE</p> </li>
    /// <li> <p>"HU" - HUNGARY</p> </li>
    /// <li> <p>"IS" - ICELAND</p> </li>
    /// <li> <p>"IN" - INDIA</p> </li>
    /// <li> <p>"IE" - IRELAND</p> </li>
    /// <li> <p>"IT" - ITALY</p> </li>
    /// <li> <p>"JP" - JAPAN</p> </li>
    /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
    /// <li> <p>"KR" - KOREA</p> </li>
    /// <li> <p>"LV" - LATVIA</p> </li>
    /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
    /// <li> <p>"LT" - LITHUANIA</p> </li>
    /// <li> <p>"LU" - LUXEMBOURG</p> </li>
    /// <li> <p>"MK" - MACEDONIA</p> </li>
    /// <li> <p>"MT" - MALTA</p> </li>
    /// <li> <p>"MX" - MEXICO</p> </li>
    /// <li> <p>"MD" - MOLDOVA</p> </li>
    /// <li> <p>"ME" - MONTENEGRO</p> </li>
    /// <li> <p>"NL" - NETHERLANDS</p> </li>
    /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
    /// <li> <p>"NI" - NICARAGUA</p> </li>
    /// <li> <p>"NG" - NIGERIA</p> </li>
    /// <li> <p>"NO" - NORWAY</p> </li>
    /// <li> <p>"PA" - PANAMA</p> </li>
    /// <li> <p>"PY" - PARAGUAY</p> </li>
    /// <li> <p>"PE" - PERU</p> </li>
    /// <li> <p>"PL" - POLAND</p> </li>
    /// <li> <p>"PT" - PORTUGAL</p> </li>
    /// <li> <p>"RO" - ROMANIA</p> </li>
    /// <li> <p>"RU" - RUSSIA</p> </li>
    /// <li> <p>"RS" - SERBIA</p> </li>
    /// <li> <p>"SK" - SLOVAKIA</p> </li>
    /// <li> <p>"SI" - SLOVENIA</p> </li>
    /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
    /// <li> <p>"ES" - SPAIN</p> </li>
    /// <li> <p>"SE" - SWEDEN</p> </li>
    /// <li> <p>"CH" - SWITZERLAND</p> </li>
    /// <li> <p>"UA" - UKRAINE</p> </li>
    /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
    /// <li> <p>"US" - UNITED STATES</p> </li>
    /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
    /// <li> <p>"UY" - URUGUAY</p> </li>
    /// <li> <p>"VE" - VENEZUELA</p> </li>
    /// </ul>
    pub fn configuration(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.configuration.as_ref()
    }
}
/// See [`AdditionalDataset`](crate::model::AdditionalDataset).
pub mod additional_dataset {

    /// A builder for [`AdditionalDataset`](crate::model::AdditionalDataset).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) configuration: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The name of the additional dataset. Valid names: <code>"holiday"</code> and <code>"weather"</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the additional dataset. Valid names: <code>"holiday"</code> and <code>"weather"</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Adds a key-value pair to `configuration`.
        ///
        /// To override the contents of this collection use [`set_configuration`](Self::set_configuration).
        ///
        /// <p> <b>Weather Index</b> </p>
        /// <p>To enable the Weather Index, do not specify a value for <code>Configuration</code>.</p>
        /// <p> <b>Holidays</b> </p>
        /// <p> <b>Holidays</b> </p>
        /// <p>To enable Holidays, set <code>CountryCode</code> to one of the following two-letter country codes:</p>
        /// <ul>
        /// <li> <p>"AL" - ALBANIA</p> </li>
        /// <li> <p>"AR" - ARGENTINA</p> </li>
        /// <li> <p>"AT" - AUSTRIA</p> </li>
        /// <li> <p>"AU" - AUSTRALIA</p> </li>
        /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
        /// <li> <p>"BE" - BELGIUM</p> </li>
        /// <li> <p>"BG" - BULGARIA</p> </li>
        /// <li> <p>"BO" - BOLIVIA</p> </li>
        /// <li> <p>"BR" - BRAZIL</p> </li>
        /// <li> <p>"BY" - BELARUS</p> </li>
        /// <li> <p>"CA" - CANADA</p> </li>
        /// <li> <p>"CL" - CHILE</p> </li>
        /// <li> <p>"CO" - COLOMBIA</p> </li>
        /// <li> <p>"CR" - COSTA RICA</p> </li>
        /// <li> <p>"HR" - CROATIA</p> </li>
        /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
        /// <li> <p>"DK" - DENMARK</p> </li>
        /// <li> <p>"EC" - ECUADOR</p> </li>
        /// <li> <p>"EE" - ESTONIA</p> </li>
        /// <li> <p>"ET" - ETHIOPIA</p> </li>
        /// <li> <p>"FI" - FINLAND</p> </li>
        /// <li> <p>"FR" - FRANCE</p> </li>
        /// <li> <p>"DE" - GERMANY</p> </li>
        /// <li> <p>"GR" - GREECE</p> </li>
        /// <li> <p>"HU" - HUNGARY</p> </li>
        /// <li> <p>"IS" - ICELAND</p> </li>
        /// <li> <p>"IN" - INDIA</p> </li>
        /// <li> <p>"IE" - IRELAND</p> </li>
        /// <li> <p>"IT" - ITALY</p> </li>
        /// <li> <p>"JP" - JAPAN</p> </li>
        /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
        /// <li> <p>"KR" - KOREA</p> </li>
        /// <li> <p>"LV" - LATVIA</p> </li>
        /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
        /// <li> <p>"LT" - LITHUANIA</p> </li>
        /// <li> <p>"LU" - LUXEMBOURG</p> </li>
        /// <li> <p>"MK" - MACEDONIA</p> </li>
        /// <li> <p>"MT" - MALTA</p> </li>
        /// <li> <p>"MX" - MEXICO</p> </li>
        /// <li> <p>"MD" - MOLDOVA</p> </li>
        /// <li> <p>"ME" - MONTENEGRO</p> </li>
        /// <li> <p>"NL" - NETHERLANDS</p> </li>
        /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
        /// <li> <p>"NI" - NICARAGUA</p> </li>
        /// <li> <p>"NG" - NIGERIA</p> </li>
        /// <li> <p>"NO" - NORWAY</p> </li>
        /// <li> <p>"PA" - PANAMA</p> </li>
        /// <li> <p>"PY" - PARAGUAY</p> </li>
        /// <li> <p>"PE" - PERU</p> </li>
        /// <li> <p>"PL" - POLAND</p> </li>
        /// <li> <p>"PT" - PORTUGAL</p> </li>
        /// <li> <p>"RO" - ROMANIA</p> </li>
        /// <li> <p>"RU" - RUSSIA</p> </li>
        /// <li> <p>"RS" - SERBIA</p> </li>
        /// <li> <p>"SK" - SLOVAKIA</p> </li>
        /// <li> <p>"SI" - SLOVENIA</p> </li>
        /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
        /// <li> <p>"ES" - SPAIN</p> </li>
        /// <li> <p>"SE" - SWEDEN</p> </li>
        /// <li> <p>"CH" - SWITZERLAND</p> </li>
        /// <li> <p>"UA" - UKRAINE</p> </li>
        /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
        /// <li> <p>"US" - UNITED STATES</p> </li>
        /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
        /// <li> <p>"UY" - URUGUAY</p> </li>
        /// <li> <p>"VE" - VENEZUELA</p> </li>
        /// </ul>
        pub fn configuration(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.configuration.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.configuration = Some(hash_map);
            self
        }
        /// <p> <b>Weather Index</b> </p>
        /// <p>To enable the Weather Index, do not specify a value for <code>Configuration</code>.</p>
        /// <p> <b>Holidays</b> </p>
        /// <p> <b>Holidays</b> </p>
        /// <p>To enable Holidays, set <code>CountryCode</code> to one of the following two-letter country codes:</p>
        /// <ul>
        /// <li> <p>"AL" - ALBANIA</p> </li>
        /// <li> <p>"AR" - ARGENTINA</p> </li>
        /// <li> <p>"AT" - AUSTRIA</p> </li>
        /// <li> <p>"AU" - AUSTRALIA</p> </li>
        /// <li> <p>"BA" - BOSNIA HERZEGOVINA</p> </li>
        /// <li> <p>"BE" - BELGIUM</p> </li>
        /// <li> <p>"BG" - BULGARIA</p> </li>
        /// <li> <p>"BO" - BOLIVIA</p> </li>
        /// <li> <p>"BR" - BRAZIL</p> </li>
        /// <li> <p>"BY" - BELARUS</p> </li>
        /// <li> <p>"CA" - CANADA</p> </li>
        /// <li> <p>"CL" - CHILE</p> </li>
        /// <li> <p>"CO" - COLOMBIA</p> </li>
        /// <li> <p>"CR" - COSTA RICA</p> </li>
        /// <li> <p>"HR" - CROATIA</p> </li>
        /// <li> <p>"CZ" - CZECH REPUBLIC</p> </li>
        /// <li> <p>"DK" - DENMARK</p> </li>
        /// <li> <p>"EC" - ECUADOR</p> </li>
        /// <li> <p>"EE" - ESTONIA</p> </li>
        /// <li> <p>"ET" - ETHIOPIA</p> </li>
        /// <li> <p>"FI" - FINLAND</p> </li>
        /// <li> <p>"FR" - FRANCE</p> </li>
        /// <li> <p>"DE" - GERMANY</p> </li>
        /// <li> <p>"GR" - GREECE</p> </li>
        /// <li> <p>"HU" - HUNGARY</p> </li>
        /// <li> <p>"IS" - ICELAND</p> </li>
        /// <li> <p>"IN" - INDIA</p> </li>
        /// <li> <p>"IE" - IRELAND</p> </li>
        /// <li> <p>"IT" - ITALY</p> </li>
        /// <li> <p>"JP" - JAPAN</p> </li>
        /// <li> <p>"KZ" - KAZAKHSTAN</p> </li>
        /// <li> <p>"KR" - KOREA</p> </li>
        /// <li> <p>"LV" - LATVIA</p> </li>
        /// <li> <p>"LI" - LIECHTENSTEIN</p> </li>
        /// <li> <p>"LT" - LITHUANIA</p> </li>
        /// <li> <p>"LU" - LUXEMBOURG</p> </li>
        /// <li> <p>"MK" - MACEDONIA</p> </li>
        /// <li> <p>"MT" - MALTA</p> </li>
        /// <li> <p>"MX" - MEXICO</p> </li>
        /// <li> <p>"MD" - MOLDOVA</p> </li>
        /// <li> <p>"ME" - MONTENEGRO</p> </li>
        /// <li> <p>"NL" - NETHERLANDS</p> </li>
        /// <li> <p>"NZ" - NEW ZEALAND</p> </li>
        /// <li> <p>"NI" - NICARAGUA</p> </li>
        /// <li> <p>"NG" - NIGERIA</p> </li>
        /// <li> <p>"NO" - NORWAY</p> </li>
        /// <li> <p>"PA" - PANAMA</p> </li>
        /// <li> <p>"PY" - PARAGUAY</p> </li>
        /// <li> <p>"PE" - PERU</p> </li>
        /// <li> <p>"PL" - POLAND</p> </li>
        /// <li> <p>"PT" - PORTUGAL</p> </li>
        /// <li> <p>"RO" - ROMANIA</p> </li>
        /// <li> <p>"RU" - RUSSIA</p> </li>
        /// <li> <p>"RS" - SERBIA</p> </li>
        /// <li> <p>"SK" - SLOVAKIA</p> </li>
        /// <li> <p>"SI" - SLOVENIA</p> </li>
        /// <li> <p>"ZA" - SOUTH AFRICA</p> </li>
        /// <li> <p>"ES" - SPAIN</p> </li>
        /// <li> <p>"SE" - SWEDEN</p> </li>
        /// <li> <p>"CH" - SWITZERLAND</p> </li>
        /// <li> <p>"UA" - UKRAINE</p> </li>
        /// <li> <p>"AE" - UNITED ARAB EMIRATES</p> </li>
        /// <li> <p>"US" - UNITED STATES</p> </li>
        /// <li> <p>"UK" - UNITED KINGDOM</p> </li>
        /// <li> <p>"UY" - URUGUAY</p> </li>
        /// <li> <p>"VE" - VENEZUELA</p> </li>
        /// </ul>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalDataset`](crate::model::AdditionalDataset).
        pub fn build(self) -> crate::model::AdditionalDataset {
            crate::model::AdditionalDataset {
                name: self.name,
                configuration: self.configuration,
            }
        }
    }
}
impl AdditionalDataset {
    /// Creates a new builder-style object to manufacture [`AdditionalDataset`](crate::model::AdditionalDataset).
    pub fn builder() -> crate::model::additional_dataset::Builder {
        crate::model::additional_dataset::Builder::default()
    }
}

/// <p>Provides information about the method used to transform attributes.</p>
/// <p>The following is an example using the RETAIL domain:</p>
/// <p> <code>{</code> </p>
/// <p> <code>"AttributeName": "demand",</code> </p>
/// <p> <code>"Transformations": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}</code> </p>
/// <p> <code>}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AttributeConfig {
    /// <p>The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is <code>demand</code>.</p>
    #[doc(hidden)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
    /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Default values are bolded.</p>
    /// <ul>
    /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
    /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
    /// <ul>
    /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
    #[doc(hidden)]
    pub transformations:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl AttributeConfig {
    /// <p>The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is <code>demand</code>.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
    /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Default values are bolded.</p>
    /// <ul>
    /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
    /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
    /// <ul>
    /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
    /// </ul>
    /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
    pub fn transformations(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.transformations.as_ref()
    }
}
/// See [`AttributeConfig`](crate::model::AttributeConfig).
pub mod attribute_config {

    /// A builder for [`AttributeConfig`](crate::model::AttributeConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) transformations: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is <code>demand</code>.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is <code>demand</code>.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// Adds a key-value pair to `transformations`.
        ///
        /// To override the contents of this collection use [`set_transformations`](Self::set_transformations).
        ///
        /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
        /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Default values are bolded.</p>
        /// <ul>
        /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
        /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
        /// <ul>
        /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
        pub fn transformations(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.transformations.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.transformations = Some(hash_map);
            self
        }
        /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters.</p>
        /// <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Default values are bolded.</p>
        /// <ul>
        /// <li> <p> <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>frontfill</code>: <b>none</b> </p> </li>
        /// <li> <p> <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
        /// <ul>
        /// <li> <p> <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// <li> <p> <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code> </p> </li>
        /// </ul>
        /// <p>To set a filling method to a specific value, set the fill parameter to <code>value</code> and define the value in a corresponding <code>_value</code> parameter. For example, to set backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and <code>"backfill_value":"2"</code>. </p>
        pub fn set_transformations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeConfig`](crate::model::AttributeConfig).
        pub fn build(self) -> crate::model::AttributeConfig {
            crate::model::AttributeConfig {
                attribute_name: self.attribute_name,
                transformations: self.transformations,
            }
        }
    }
}
impl AttributeConfig {
    /// Creates a new builder-style object to manufacture [`AttributeConfig`](crate::model::AttributeConfig).
    pub fn builder() -> crate::model::attribute_config::Builder {
        crate::model::attribute_config::Builder::default()
    }
}

/// <p>The configuration details for the predictor monitor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitorConfig {
    /// <p>The name of the monitor resource.</p>
    #[doc(hidden)]
    pub monitor_name: std::option::Option<std::string::String>,
}
impl MonitorConfig {
    /// <p>The name of the monitor resource.</p>
    pub fn monitor_name(&self) -> std::option::Option<&str> {
        self.monitor_name.as_deref()
    }
}
/// See [`MonitorConfig`](crate::model::MonitorConfig).
pub mod monitor_config {

    /// A builder for [`MonitorConfig`](crate::model::MonitorConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the monitor resource.</p>
        pub fn monitor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_name = Some(input.into());
            self
        }
        /// <p>The name of the monitor resource.</p>
        pub fn set_monitor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitorConfig`](crate::model::MonitorConfig).
        pub fn build(self) -> crate::model::MonitorConfig {
            crate::model::MonitorConfig {
                monitor_name: self.monitor_name,
            }
        }
    }
}
impl MonitorConfig {
    /// Creates a new builder-style object to manufacture [`MonitorConfig`](crate::model::MonitorConfig).
    pub fn builder() -> crate::model::monitor_config::Builder {
        crate::model::monitor_config::Builder::default()
    }
}
