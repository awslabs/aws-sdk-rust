// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_replication_set(&self) -> fluent_builders::CreateReplicationSet<C> {
        fluent_builders::CreateReplicationSet::new(self.handle.clone())
    }
    pub fn create_response_plan(&self) -> fluent_builders::CreateResponsePlan<C> {
        fluent_builders::CreateResponsePlan::new(self.handle.clone())
    }
    pub fn create_timeline_event(&self) -> fluent_builders::CreateTimelineEvent<C> {
        fluent_builders::CreateTimelineEvent::new(self.handle.clone())
    }
    pub fn delete_incident_record(&self) -> fluent_builders::DeleteIncidentRecord<C> {
        fluent_builders::DeleteIncidentRecord::new(self.handle.clone())
    }
    pub fn delete_replication_set(&self) -> fluent_builders::DeleteReplicationSet<C> {
        fluent_builders::DeleteReplicationSet::new(self.handle.clone())
    }
    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy<C> {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }
    pub fn delete_response_plan(&self) -> fluent_builders::DeleteResponsePlan<C> {
        fluent_builders::DeleteResponsePlan::new(self.handle.clone())
    }
    pub fn delete_timeline_event(&self) -> fluent_builders::DeleteTimelineEvent<C> {
        fluent_builders::DeleteTimelineEvent::new(self.handle.clone())
    }
    pub fn get_incident_record(&self) -> fluent_builders::GetIncidentRecord<C> {
        fluent_builders::GetIncidentRecord::new(self.handle.clone())
    }
    pub fn get_replication_set(&self) -> fluent_builders::GetReplicationSet<C> {
        fluent_builders::GetReplicationSet::new(self.handle.clone())
    }
    pub fn get_resource_policies(&self) -> fluent_builders::GetResourcePolicies<C> {
        fluent_builders::GetResourcePolicies::new(self.handle.clone())
    }
    pub fn get_response_plan(&self) -> fluent_builders::GetResponsePlan<C> {
        fluent_builders::GetResponsePlan::new(self.handle.clone())
    }
    pub fn get_timeline_event(&self) -> fluent_builders::GetTimelineEvent<C> {
        fluent_builders::GetTimelineEvent::new(self.handle.clone())
    }
    pub fn list_incident_records(&self) -> fluent_builders::ListIncidentRecords<C> {
        fluent_builders::ListIncidentRecords::new(self.handle.clone())
    }
    pub fn list_related_items(&self) -> fluent_builders::ListRelatedItems<C> {
        fluent_builders::ListRelatedItems::new(self.handle.clone())
    }
    pub fn list_replication_sets(&self) -> fluent_builders::ListReplicationSets<C> {
        fluent_builders::ListReplicationSets::new(self.handle.clone())
    }
    pub fn list_response_plans(&self) -> fluent_builders::ListResponsePlans<C> {
        fluent_builders::ListResponsePlans::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_timeline_events(&self) -> fluent_builders::ListTimelineEvents<C> {
        fluent_builders::ListTimelineEvents::new(self.handle.clone())
    }
    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy<C> {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }
    pub fn start_incident(&self) -> fluent_builders::StartIncident<C> {
        fluent_builders::StartIncident::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_deletion_protection(&self) -> fluent_builders::UpdateDeletionProtection<C> {
        fluent_builders::UpdateDeletionProtection::new(self.handle.clone())
    }
    pub fn update_incident_record(&self) -> fluent_builders::UpdateIncidentRecord<C> {
        fluent_builders::UpdateIncidentRecord::new(self.handle.clone())
    }
    pub fn update_related_items(&self) -> fluent_builders::UpdateRelatedItems<C> {
        fluent_builders::UpdateRelatedItems::new(self.handle.clone())
    }
    pub fn update_replication_set(&self) -> fluent_builders::UpdateReplicationSet<C> {
        fluent_builders::UpdateReplicationSet::new(self.handle.clone())
    }
    pub fn update_response_plan(&self) -> fluent_builders::UpdateResponsePlan<C> {
        fluent_builders::UpdateResponsePlan::new(self.handle.clone())
    }
    pub fn update_timeline_event(&self) -> fluent_builders::UpdateTimelineEvent<C> {
        fluent_builders::UpdateTimelineEvent::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateReplicationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_replication_set_input::Builder,
    }
    impl<C> CreateReplicationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReplicationSetOutput,
            smithy_http::result::SdkError<crate::error::CreateReplicationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Regions that Incident Manager replicates your data to. You can have up to three Regions
        /// in your replication set.</p>
        pub fn regions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::RegionMapInputValue>,
        ) -> Self {
            self.inner = self.inner.regions(k, v);
            self
        }
        pub fn set_regions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::RegionMapInputValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_regions(input);
            self
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateResponsePlan<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_response_plan_input::Builder,
    }
    impl<C> CreateResponsePlan<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateResponsePlanOutput,
            smithy_http::result::SdkError<crate::error::CreateResponsePlanError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The short format name of the response plan. Can't include spaces.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The long format of the response plan name. This field can contain spaces.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(input);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>Details used to create an incident when using this response plan.</p>
        pub fn incident_template(mut self, input: crate::model::IncidentTemplate) -> Self {
            self.inner = self.inner.incident_template(input);
            self
        }
        pub fn set_incident_template(
            mut self,
            input: std::option::Option<crate::model::IncidentTemplate>,
        ) -> Self {
            self.inner = self.inner.set_incident_template(input);
            self
        }
        /// <p>The
        /// AWS Chatbot
        /// chat channel used for collaboration during an incident.</p>
        pub fn chat_channel(mut self, input: crate::model::ChatChannel) -> Self {
            self.inner = self.inner.chat_channel(input);
            self
        }
        pub fn set_chat_channel(
            mut self,
            input: std::option::Option<crate::model::ChatChannel>,
        ) -> Self {
            self.inner = self.inner.set_chat_channel(input);
            self
        }
        /// <p>The contacts and escalation plans that the response plan engages during an
        /// incident.</p>
        pub fn engagements(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            self.inner = self.inner.engagements(input);
            self
        }
        pub fn set_engagements(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_engagements(input);
            self
        }
        /// <p>The actions that the response plan starts at the beginning of an incident.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>A list of tags that you are adding to the response plan.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTimelineEvent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_timeline_event_input::Builder,
    }
    impl<C> CreateTimelineEvent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTimelineEventOutput,
            smithy_http::result::SdkError<crate::error::CreateTimelineEventError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record you are adding the event
        /// to.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>The time that the event occurred.</p>
        pub fn event_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.event_time(input);
            self
        }
        pub fn set_event_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_event_time(input);
            self
        }
        /// <p>The type of the event. You can create timeline events of type <code>Custom
        /// Event</code>.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_type(input);
            self
        }
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_type(input);
            self
        }
        /// <p>A valid JSON string. There is no other schema imposed. A short description of the event.</p>
        pub fn event_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_data(input);
            self
        }
        pub fn set_event_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteIncidentRecord<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_incident_record_input::Builder,
    }
    impl<C> DeleteIncidentRecord<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteIncidentRecordOutput,
            smithy_http::result::SdkError<crate::error::DeleteIncidentRecordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record you are deleting.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReplicationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_replication_set_input::Builder,
    }
    impl<C> DeleteReplicationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReplicationSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteReplicationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication set you're deleting.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl<C> DeleteResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource you're deleting the policy from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The ID of the resource policy you're deleting.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_id(input);
            self
        }
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResponsePlan<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_response_plan_input::Builder,
    }
    impl<C> DeleteResponsePlan<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResponsePlanOutput,
            smithy_http::result::SdkError<crate::error::DeleteResponsePlanError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTimelineEvent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_timeline_event_input::Builder,
    }
    impl<C> DeleteTimelineEvent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTimelineEventOutput,
            smithy_http::result::SdkError<crate::error::DeleteTimelineEventError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the incident that the event is part of.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>The ID of the event you are updating. You can find this by using <code>ListTimelineEvents</code>.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_id(input);
            self
        }
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIncidentRecord<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_incident_record_input::Builder,
    }
    impl<C> GetIncidentRecord<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIncidentRecordOutput,
            smithy_http::result::SdkError<crate::error::GetIncidentRecordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReplicationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_replication_set_input::Builder,
    }
    impl<C> GetReplicationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetReplicationSetOutput,
            smithy_http::result::SdkError<crate::error::GetReplicationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication set you want to retrieve.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResourcePolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resource_policies_input::Builder,
    }
    impl<C> GetResourcePolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResourcePoliciesOutput,
            smithy_http::result::SdkError<crate::error::GetResourcePoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan with the attached resource policy. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The maximum number of resource policies to display per page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token to continue to the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResponsePlan<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_response_plan_input::Builder,
    }
    impl<C> GetResponsePlan<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResponsePlanOutput,
            smithy_http::result::SdkError<crate::error::GetResponsePlanError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTimelineEvent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_timeline_event_input::Builder,
    }
    impl<C> GetTimelineEvent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTimelineEventOutput,
            smithy_http::result::SdkError<crate::error::GetTimelineEventError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the incident that the timeline event is part of.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>The ID of the event. You can get an event's ID when you create it or by using <code>ListTimelineEvents</code>.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_id(input);
            self
        }
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIncidentRecords<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_incident_records_input::Builder,
    }
    impl<C> ListIncidentRecords<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIncidentRecordsOutput,
            smithy_http::result::SdkError<crate::error::ListIncidentRecordsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filter the list of incident records you are searching through. You can filter on the
        /// following keys:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>creationTime</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>impact</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>createdBy</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token to continue to the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRelatedItems<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_related_items_input::Builder,
    }
    impl<C> ListRelatedItems<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRelatedItemsOutput,
            smithy_http::result::SdkError<crate::error::ListRelatedItemsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record that you are listing related items for.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>The maximum number of related items per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token to continue to the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReplicationSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_replication_sets_input::Builder,
    }
    impl<C> ListReplicationSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReplicationSetsOutput,
            smithy_http::result::SdkError<crate::error::ListReplicationSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results per page. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token to continue to the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResponsePlans<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_response_plans_input::Builder,
    }
    impl<C> ListResponsePlans<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResponsePlansOutput,
            smithy_http::result::SdkError<crate::error::ListResponsePlansError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of response plans per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token to continue to the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTimelineEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_timeline_events_input::Builder,
    }
    impl<C> ListTimelineEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTimelineEventsOutput,
            smithy_http::result::SdkError<crate::error::ListTimelineEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the incident that the event is part of.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>Filters the timeline events based on the provided conditional values. You can filter
        /// timeline events using the following keys:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>eventTime</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>eventType</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Sort by the specified key value pair.</p>
        pub fn sort_by(mut self, input: crate::model::TimelineEventSort) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::TimelineEventSort>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>Sorts the order of timeline events by the value specified in the <code>sortBy</code>
        /// field.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.inner = self.inner.sort_order(input);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(input);
            self
        }
        /// <p>The maximum number of results per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token to continue to the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl<C> PutResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan you're adding the resource policy
        /// to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Details of the resource policy.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartIncident<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_incident_input::Builder,
    }
    impl<C> StartIncident<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartIncidentOutput,
            smithy_http::result::SdkError<crate::error::StartIncidentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat
        /// channels, SNS topics, runbooks, title, and impact of the incident. </p>
        pub fn response_plan_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_plan_arn(input);
            self
        }
        pub fn set_response_plan_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_plan_arn(input);
            self
        }
        /// <p>Provide a title for the incident. Providing a title overwrites the title provided by
        /// the response plan. </p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(input);
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(input);
            self
        }
        /// <p>Defines the impact to the customers. Providing an impact overwrites the impact
        /// provided by a response plan.</p>
        /// <p class="title">
        /// <b>Possible impacts:</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>1</code> - Critical impact, this typically relates to full application
        /// failure that impacts many to all customers. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>2</code> - High impact, partial application failure with impact to many
        /// customers.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>3</code> -  Medium impact, the application is providing reduced service
        /// to customers.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>4</code> -  Low impact, customer might aren't impacted by the problem
        /// yet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>5</code> - No impact, customers aren't currently impacted but urgent
        /// action is needed to avoid impact.</p>
        /// </li>
        /// </ul>
        pub fn impact(mut self, input: i32) -> Self {
            self.inner = self.inner.impact(input);
            self
        }
        pub fn set_impact(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_impact(input);
            self
        }
        /// <p>Details of what created the incident record in Incident Manager.</p>
        pub fn trigger_details(mut self, input: crate::model::TriggerDetails) -> Self {
            self.inner = self.inner.trigger_details(input);
            self
        }
        pub fn set_trigger_details(
            mut self,
            input: std::option::Option<crate::model::TriggerDetails>,
        ) -> Self {
            self.inner = self.inner.set_trigger_details(input);
            self
        }
        /// <p>Add related items to the incident for other responders to use. Related items are AWS
        /// resources, external links, or files uploaded to an S3 bucket. </p>
        pub fn related_items(mut self, inp: impl Into<crate::model::RelatedItem>) -> Self {
            self.inner = self.inner.related_items(inp);
            self
        }
        pub fn set_related_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelatedItem>>,
        ) -> Self {
            self.inner = self.inner.set_related_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan you're adding the tags to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of tags that you are adding to the response plan.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan you're removing a tag from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The name of the tag you're removing from the response plan.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDeletionProtection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_deletion_protection_input::Builder,
    }
    impl<C> UpdateDeletionProtection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDeletionProtectionOutput,
            smithy_http::result::SdkError<crate::error::UpdateDeletionProtectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication set you're updating.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>Details if deletion protection is enabled or disabled in your account.</p>
        pub fn deletion_protected(mut self, input: bool) -> Self {
            self.inner = self.inner.deletion_protected(input);
            self
        }
        pub fn set_deletion_protected(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_deletion_protected(input);
            self
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateIncidentRecord<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_incident_record_input::Builder,
    }
    impl<C> UpdateIncidentRecord<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateIncidentRecordOutput,
            smithy_http::result::SdkError<crate::error::UpdateIncidentRecordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record you are updating.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The title of the incident is a brief and easily recognizable.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(input);
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(input);
            self
        }
        /// <p>The summary describes what has happened during the incident.</p>
        pub fn summary(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.summary(input);
            self
        }
        pub fn set_summary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_summary(input);
            self
        }
        /// <p>Defines the impact to customers and applications. Providing an impact overwrites the
        /// impact provided by the response plan.</p>
        /// <p class="title">
        /// <b>Possible impacts:</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>1</code> - Critical impact, this typically relates to full application
        /// failure that impacts many to all customers. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>2</code> - High impact, partial application failure with impact to many
        /// customers.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>3</code> -  Medium impact, the application is providing reduced service
        /// to customers.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>4</code> -  Low impact, customer might aren't impacted by the problem
        /// yet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>5</code> - No impact, customers aren't currently impacted but urgent
        /// action is needed to avoid impact.</p>
        /// </li>
        /// </ul>
        pub fn impact(mut self, input: i32) -> Self {
            self.inner = self.inner.impact(input);
            self
        }
        pub fn set_impact(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_impact(input);
            self
        }
        /// <p>The status of the incident. An incident can be <code>Open</code> or <code>Resolved</code>.</p>
        pub fn status(mut self, input: crate::model::IncidentRecordStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::IncidentRecordStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The AWS Chatbot chat channel for responders to collaborate in.</p>
        pub fn chat_channel(mut self, input: crate::model::ChatChannel) -> Self {
            self.inner = self.inner.chat_channel(input);
            self
        }
        pub fn set_chat_channel(
            mut self,
            input: std::option::Option<crate::model::ChatChannel>,
        ) -> Self {
            self.inner = self.inner.set_chat_channel(input);
            self
        }
        /// <p>The SNS targets that are notified when updates are made to an incident.</p>
        /// <p>Using multiple SNS topics creates redundancy in the case that a Region is down during
        /// the incident.</p>
        pub fn notification_targets(
            mut self,
            inp: impl Into<crate::model::NotificationTargetItem>,
        ) -> Self {
            self.inner = self.inner.notification_targets(inp);
            self
        }
        pub fn set_notification_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
        ) -> Self {
            self.inner = self.inner.set_notification_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRelatedItems<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_related_items_input::Builder,
    }
    impl<C> UpdateRelatedItems<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRelatedItemsOutput,
            smithy_http::result::SdkError<crate::error::UpdateRelatedItemsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record you are updating related items
        /// in.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>Details about the item you are adding or deleting.</p>
        pub fn related_items_update(mut self, input: crate::model::RelatedItemsUpdate) -> Self {
            self.inner = self.inner.related_items_update(input);
            self
        }
        pub fn set_related_items_update(
            mut self,
            input: std::option::Option<crate::model::RelatedItemsUpdate>,
        ) -> Self {
            self.inner = self.inner.set_related_items_update(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateReplicationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_replication_set_input::Builder,
    }
    impl<C> UpdateReplicationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateReplicationSetOutput,
            smithy_http::result::SdkError<crate::error::UpdateReplicationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication set you're updating.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An action to add or delete a Region.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::UpdateReplicationSetAction>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdateReplicationSetAction>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateResponsePlan<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_response_plan_input::Builder,
    }
    impl<C> UpdateResponsePlan<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateResponsePlanOutput,
            smithy_http::result::SdkError<crate::error::UpdateResponsePlanError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The long format name of the response plan. Can't contain spaces.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(input);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>The short format name of the incident. Can't contain spaces.</p>
        pub fn incident_template_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_template_title(input);
            self
        }
        pub fn set_incident_template_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_template_title(input);
            self
        }
        /// <p>Defines the impact to the customers. Providing an impact overwrites the impact
        /// provided by a response plan.</p>
        /// <p class="title">
        /// <b>Possible impacts:</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>5</code> - Severe impact</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>4</code> - High impact</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>3</code> - Medium impact</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>2</code> - Low impact</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>1</code> - No impact</p>
        /// </li>
        /// </ul>
        pub fn incident_template_impact(mut self, input: i32) -> Self {
            self.inner = self.inner.incident_template_impact(input);
            self
        }
        pub fn set_incident_template_impact(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_incident_template_impact(input);
            self
        }
        /// <p>A brief summary of the incident. This typically contains what has happened, what's
        /// currently happening, and next steps.</p>
        pub fn incident_template_summary(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_template_summary(input);
            self
        }
        pub fn set_incident_template_summary(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_template_summary(input);
            self
        }
        /// <p>Used to create only one incident record for an incident.</p>
        pub fn incident_template_dedupe_string(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.incident_template_dedupe_string(input);
            self
        }
        pub fn set_incident_template_dedupe_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_template_dedupe_string(input);
            self
        }
        /// <p>The SNS targets that are notified when updates are made to an incident.</p>
        pub fn incident_template_notification_targets(
            mut self,
            inp: impl Into<crate::model::NotificationTargetItem>,
        ) -> Self {
            self.inner = self.inner.incident_template_notification_targets(inp);
            self
        }
        pub fn set_incident_template_notification_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
        ) -> Self {
            self.inner = self.inner.set_incident_template_notification_targets(input);
            self
        }
        /// <p>The
        /// AWS
        /// Chatbot chat channel used for collaboration during an
        /// incident.</p>
        /// <p>Use the empty structure to remove the chat channel from the response plan.</p>
        pub fn chat_channel(mut self, input: crate::model::ChatChannel) -> Self {
            self.inner = self.inner.chat_channel(input);
            self
        }
        pub fn set_chat_channel(
            mut self,
            input: std::option::Option<crate::model::ChatChannel>,
        ) -> Self {
            self.inner = self.inner.set_chat_channel(input);
            self
        }
        /// <p>The contacts and escalation plans that Incident Manager engages at the start of the incident.</p>
        pub fn engagements(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            self.inner = self.inner.engagements(input);
            self
        }
        pub fn set_engagements(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_engagements(input);
            self
        }
        /// <p>The actions that this response plan takes at the beginning of an incident.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTimelineEvent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_timeline_event_input::Builder,
    }
    impl<C> UpdateTimelineEvent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTimelineEventOutput,
            smithy_http::result::SdkError<crate::error::UpdateTimelineEventError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token ensuring that the action is called only once with the specified details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident that the timeline event is part
        /// of.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.incident_record_arn(input);
            self
        }
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_incident_record_arn(input);
            self
        }
        /// <p>The ID of the event you are updating. You can find this by using <code>ListTimelineEvents</code>.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_id(input);
            self
        }
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_id(input);
            self
        }
        /// <p>The time that the event occurred.</p>
        pub fn event_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.event_time(input);
            self
        }
        pub fn set_event_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_event_time(input);
            self
        }
        /// <p>The type of the event. You can update events of type <code>Custom Event</code>.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_type(input);
            self
        }
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_type(input);
            self
        }
        /// <p>A short description of the event.</p>
        pub fn event_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_data(input);
            self
        }
        pub fn set_event_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_event_data(input);
            self
        }
    }
}
