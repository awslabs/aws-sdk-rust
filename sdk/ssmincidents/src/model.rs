// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ServiceCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let servicecode = unimplemented!();
/// match servicecode {
///     ServiceCode::SsmIncidents => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `servicecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceCode::NewFeature` is defined.
/// Specifically, when `servicecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceCode {
    #[allow(missing_docs)] // documentation missing in model
    SsmIncidents,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceCode {
    fn from(s: &str) -> Self {
        match s {
            "ssm-incidents" => ServiceCode::SsmIncidents,
            other => ServiceCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ServiceCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceCode::from(s))
    }
}
impl ServiceCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceCode::SsmIncidents => "ssm-incidents",
            ServiceCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ssm-incidents"]
    }
}
impl AsRef<str> for ServiceCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::IncidentRecord => { /* ... */ },
///     ResourceType::ReplicationSet => { /* ... */ },
///     ResourceType::ResourcePolicy => { /* ... */ },
///     ResourceType::ResponsePlan => { /* ... */ },
///     ResourceType::TimelineEvent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    IncidentRecord,
    #[allow(missing_docs)] // documentation missing in model
    ReplicationSet,
    #[allow(missing_docs)] // documentation missing in model
    ResourcePolicy,
    #[allow(missing_docs)] // documentation missing in model
    ResponsePlan,
    #[allow(missing_docs)] // documentation missing in model
    TimelineEvent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "INCIDENT_RECORD" => ResourceType::IncidentRecord,
            "REPLICATION_SET" => ResourceType::ReplicationSet,
            "RESOURCE_POLICY" => ResourceType::ResourcePolicy,
            "RESPONSE_PLAN" => ResourceType::ResponsePlan,
            "TIMELINE_EVENT" => ResourceType::TimelineEvent,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::IncidentRecord => "INCIDENT_RECORD",
            ResourceType::ReplicationSet => "REPLICATION_SET",
            ResourceType::ResourcePolicy => "RESOURCE_POLICY",
            ResourceType::ResponsePlan => "RESPONSE_PLAN",
            ResourceType::TimelineEvent => "TIMELINE_EVENT",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INCIDENT_RECORD",
            "REPLICATION_SET",
            "RESOURCE_POLICY",
            "RESPONSE_PLAN",
            "TIMELINE_EVENT",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An item referenced in a <code>TimelineEvent</code> that is involved in or somehow associated with an incident. You can specify an Amazon Resource Name (ARN) for an Amazon Web Services resource or a <code>RelatedItem</code> ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum EventReference {
    /// <p>The ID of a <code>RelatedItem</code> referenced in a <code>TimelineEvent</code>.</p>
    RelatedItemId(std::string::String),
    /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services resource referenced in a <code>TimelineEvent</code>.</p>
    Resource(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl EventReference {
    /// Tries to convert the enum instance into [`RelatedItemId`](crate::model::EventReference::RelatedItemId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_related_item_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let EventReference::RelatedItemId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`RelatedItemId`](crate::model::EventReference::RelatedItemId).
    pub fn is_related_item_id(&self) -> bool {
        self.as_related_item_id().is_ok()
    }
    /// Tries to convert the enum instance into [`Resource`](crate::model::EventReference::Resource), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_resource(&self) -> std::result::Result<&std::string::String, &Self> {
        if let EventReference::Resource(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Resource`](crate::model::EventReference::Resource).
    pub fn is_resource(&self) -> bool {
        self.as_resource().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Information about third-party services integrated into a response plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Integration {
    /// <p>Information about the PagerDuty service where the response plan creates an incident.</p>
    PagerDutyConfiguration(crate::model::PagerDutyConfiguration),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Integration {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`PagerDutyConfiguration`](crate::model::Integration::PagerDutyConfiguration), extracting the inner [`PagerDutyConfiguration`](crate::model::PagerDutyConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_pager_duty_configuration(
        &self,
    ) -> std::result::Result<&crate::model::PagerDutyConfiguration, &Self> {
        if let Integration::PagerDutyConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`PagerDutyConfiguration`](crate::model::Integration::PagerDutyConfiguration).
    pub fn is_pager_duty_configuration(&self) -> bool {
        self.as_pager_duty_configuration().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details about the PagerDuty configuration for a response plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PagerDutyConfiguration {
    /// <p>The name of the PagerDuty configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
    #[doc(hidden)]
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>Details about the PagerDuty service associated with the configuration.</p>
    #[doc(hidden)]
    pub pager_duty_incident_configuration:
        std::option::Option<crate::model::PagerDutyIncidentConfiguration>,
}
impl PagerDutyConfiguration {
    /// <p>The name of the PagerDuty configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
    pub fn secret_id(&self) -> std::option::Option<&str> {
        self.secret_id.as_deref()
    }
    /// <p>Details about the PagerDuty service associated with the configuration.</p>
    pub fn pager_duty_incident_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PagerDutyIncidentConfiguration> {
        self.pager_duty_incident_configuration.as_ref()
    }
}
/// See [`PagerDutyConfiguration`](crate::model::PagerDutyConfiguration).
pub mod pager_duty_configuration {

    /// A builder for [`PagerDutyConfiguration`](crate::model::PagerDutyConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) secret_id: std::option::Option<std::string::String>,
        pub(crate) pager_duty_incident_configuration:
            std::option::Option<crate::model::PagerDutyIncidentConfiguration>,
    }
    impl Builder {
        /// <p>The name of the PagerDuty configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the PagerDuty configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
        pub fn secret_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_id = input;
            self
        }
        /// <p>Details about the PagerDuty service associated with the configuration.</p>
        pub fn pager_duty_incident_configuration(
            mut self,
            input: crate::model::PagerDutyIncidentConfiguration,
        ) -> Self {
            self.pager_duty_incident_configuration = Some(input);
            self
        }
        /// <p>Details about the PagerDuty service associated with the configuration.</p>
        pub fn set_pager_duty_incident_configuration(
            mut self,
            input: std::option::Option<crate::model::PagerDutyIncidentConfiguration>,
        ) -> Self {
            self.pager_duty_incident_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PagerDutyConfiguration`](crate::model::PagerDutyConfiguration).
        pub fn build(self) -> crate::model::PagerDutyConfiguration {
            crate::model::PagerDutyConfiguration {
                name: self.name,
                secret_id: self.secret_id,
                pager_duty_incident_configuration: self.pager_duty_incident_configuration,
            }
        }
    }
}
impl PagerDutyConfiguration {
    /// Creates a new builder-style object to manufacture [`PagerDutyConfiguration`](crate::model::PagerDutyConfiguration).
    pub fn builder() -> crate::model::pager_duty_configuration::Builder {
        crate::model::pager_duty_configuration::Builder::default()
    }
}

/// <p>Details about the PagerDuty service where the response plan creates an incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PagerDutyIncidentConfiguration {
    /// <p>The ID of the PagerDuty service that the response plan associates with an incident when it launches.</p>
    #[doc(hidden)]
    pub service_id: std::option::Option<std::string::String>,
}
impl PagerDutyIncidentConfiguration {
    /// <p>The ID of the PagerDuty service that the response plan associates with an incident when it launches.</p>
    pub fn service_id(&self) -> std::option::Option<&str> {
        self.service_id.as_deref()
    }
}
/// See [`PagerDutyIncidentConfiguration`](crate::model::PagerDutyIncidentConfiguration).
pub mod pager_duty_incident_configuration {

    /// A builder for [`PagerDutyIncidentConfiguration`](crate::model::PagerDutyIncidentConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the PagerDuty service that the response plan associates with an incident when it launches.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        /// <p>The ID of the PagerDuty service that the response plan associates with an incident when it launches.</p>
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PagerDutyIncidentConfiguration`](crate::model::PagerDutyIncidentConfiguration).
        pub fn build(self) -> crate::model::PagerDutyIncidentConfiguration {
            crate::model::PagerDutyIncidentConfiguration {
                service_id: self.service_id,
            }
        }
    }
}
impl PagerDutyIncidentConfiguration {
    /// Creates a new builder-style object to manufacture [`PagerDutyIncidentConfiguration`](crate::model::PagerDutyIncidentConfiguration).
    pub fn builder() -> crate::model::pager_duty_incident_configuration::Builder {
        crate::model::pager_duty_incident_configuration::Builder::default()
    }
}

/// <p>The action that starts at the beginning of an incident. The response plan defines the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Action {
    /// <p>The Systems Manager automation document to start as the runbook at the beginning of the incident.</p>
    SsmAutomation(crate::model::SsmAutomation),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Action {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`SsmAutomation`](crate::model::Action::SsmAutomation), extracting the inner [`SsmAutomation`](crate::model::SsmAutomation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_ssm_automation(&self) -> std::result::Result<&crate::model::SsmAutomation, &Self> {
        if let Action::SsmAutomation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SsmAutomation`](crate::model::Action::SsmAutomation).
    pub fn is_ssm_automation(&self) -> bool {
        self.as_ssm_automation().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details about the Systems Manager automation document that will be used as a runbook during an incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SsmAutomation {
    /// <p>The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The automation document's name.</p>
    #[doc(hidden)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The automation document's version to use when running.</p>
    #[doc(hidden)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>The account that the automation document will be run in. This can be in either the management account or an application account.</p>
    #[doc(hidden)]
    pub target_account: std::option::Option<crate::model::SsmTargetAccount>,
    /// <p>The key-value pair parameters to use when running the automation document.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.</p>
    #[doc(hidden)]
    pub dynamic_parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::DynamicSsmParameterValue>,
    >,
}
impl SsmAutomation {
    /// <p>The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The automation document's name.</p>
    pub fn document_name(&self) -> std::option::Option<&str> {
        self.document_name.as_deref()
    }
    /// <p>The automation document's version to use when running.</p>
    pub fn document_version(&self) -> std::option::Option<&str> {
        self.document_version.as_deref()
    }
    /// <p>The account that the automation document will be run in. This can be in either the management account or an application account.</p>
    pub fn target_account(&self) -> std::option::Option<&crate::model::SsmTargetAccount> {
        self.target_account.as_ref()
    }
    /// <p>The key-value pair parameters to use when running the automation document.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.parameters.as_ref()
    }
    /// <p>The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.</p>
    pub fn dynamic_parameters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::DynamicSsmParameterValue>,
    > {
        self.dynamic_parameters.as_ref()
    }
}
/// See [`SsmAutomation`](crate::model::SsmAutomation).
pub mod ssm_automation {

    /// A builder for [`SsmAutomation`](crate::model::SsmAutomation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) target_account: std::option::Option<crate::model::SsmTargetAccount>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) dynamic_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::DynamicSsmParameterValue>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The automation document's name.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        /// <p>The automation document's name.</p>
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The automation document's version to use when running.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        /// <p>The automation document's version to use when running.</p>
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// <p>The account that the automation document will be run in. This can be in either the management account or an application account.</p>
        pub fn target_account(mut self, input: crate::model::SsmTargetAccount) -> Self {
            self.target_account = Some(input);
            self
        }
        /// <p>The account that the automation document will be run in. This can be in either the management account or an application account.</p>
        pub fn set_target_account(
            mut self,
            input: std::option::Option<crate::model::SsmTargetAccount>,
        ) -> Self {
            self.target_account = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>The key-value pair parameters to use when running the automation document.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.parameters = Some(hash_map);
            self
        }
        /// <p>The key-value pair parameters to use when running the automation document.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Adds a key-value pair to `dynamic_parameters`.
        ///
        /// To override the contents of this collection use [`set_dynamic_parameters`](Self::set_dynamic_parameters).
        ///
        /// <p>The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.</p>
        pub fn dynamic_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::DynamicSsmParameterValue,
        ) -> Self {
            let mut hash_map = self.dynamic_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.dynamic_parameters = Some(hash_map);
            self
        }
        /// <p>The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.</p>
        pub fn set_dynamic_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::DynamicSsmParameterValue,
                >,
            >,
        ) -> Self {
            self.dynamic_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`SsmAutomation`](crate::model::SsmAutomation).
        pub fn build(self) -> crate::model::SsmAutomation {
            crate::model::SsmAutomation {
                role_arn: self.role_arn,
                document_name: self.document_name,
                document_version: self.document_version,
                target_account: self.target_account,
                parameters: self.parameters,
                dynamic_parameters: self.dynamic_parameters,
            }
        }
    }
}
impl SsmAutomation {
    /// Creates a new builder-style object to manufacture [`SsmAutomation`](crate::model::SsmAutomation).
    pub fn builder() -> crate::model::ssm_automation::Builder {
        crate::model::ssm_automation::Builder::default()
    }
}

/// <p>The dynamic SSM parameter value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DynamicSsmParameterValue {
    /// <p>Variable dynamic parameters. A parameter value is determined when an incident is created.</p>
    Variable(crate::model::VariableType),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DynamicSsmParameterValue {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Variable`](crate::model::DynamicSsmParameterValue::Variable), extracting the inner [`VariableType`](crate::model::VariableType).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_variable(&self) -> std::result::Result<&crate::model::VariableType, &Self> {
        if let DynamicSsmParameterValue::Variable(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Variable`](crate::model::DynamicSsmParameterValue::Variable).
    pub fn is_variable(&self) -> bool {
        self.as_variable().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `VariableType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let variabletype = unimplemented!();
/// match variabletype {
///     VariableType::IncidentRecordArn => { /* ... */ },
///     VariableType::InvolvedResources => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `variabletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VariableType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VariableType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VariableType::NewFeature` is defined.
/// Specifically, when `variabletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VariableType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VariableType {
    #[allow(missing_docs)] // documentation missing in model
    IncidentRecordArn,
    #[allow(missing_docs)] // documentation missing in model
    InvolvedResources,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VariableType {
    fn from(s: &str) -> Self {
        match s {
            "INCIDENT_RECORD_ARN" => VariableType::IncidentRecordArn,
            "INVOLVED_RESOURCES" => VariableType::InvolvedResources,
            other => VariableType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for VariableType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VariableType::from(s))
    }
}
impl VariableType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VariableType::IncidentRecordArn => "INCIDENT_RECORD_ARN",
            VariableType::InvolvedResources => "INVOLVED_RESOURCES",
            VariableType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INCIDENT_RECORD_ARN", "INVOLVED_RESOURCES"]
    }
}
impl AsRef<str> for VariableType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SsmTargetAccount`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ssmtargetaccount = unimplemented!();
/// match ssmtargetaccount {
///     SsmTargetAccount::ImpactedAccount => { /* ... */ },
///     SsmTargetAccount::ResponsePlanOwnerAccount => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ssmtargetaccount` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SsmTargetAccount::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SsmTargetAccount::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SsmTargetAccount::NewFeature` is defined.
/// Specifically, when `ssmtargetaccount` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SsmTargetAccount::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SsmTargetAccount {
    #[allow(missing_docs)] // documentation missing in model
    ImpactedAccount,
    #[allow(missing_docs)] // documentation missing in model
    ResponsePlanOwnerAccount,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SsmTargetAccount {
    fn from(s: &str) -> Self {
        match s {
            "IMPACTED_ACCOUNT" => SsmTargetAccount::ImpactedAccount,
            "RESPONSE_PLAN_OWNER_ACCOUNT" => SsmTargetAccount::ResponsePlanOwnerAccount,
            other => SsmTargetAccount::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SsmTargetAccount {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SsmTargetAccount::from(s))
    }
}
impl SsmTargetAccount {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SsmTargetAccount::ImpactedAccount => "IMPACTED_ACCOUNT",
            SsmTargetAccount::ResponsePlanOwnerAccount => "RESPONSE_PLAN_OWNER_ACCOUNT",
            SsmTargetAccount::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IMPACTED_ACCOUNT", "RESPONSE_PLAN_OWNER_ACCOUNT"]
    }
}
impl AsRef<str> for SsmTargetAccount {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Chatbot chat channel used for collaboration during an incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ChatChannel {
    /// <p>The Amazon SNS targets that Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel by using the Amazon SNS topics. </p>
    ChatbotSns(std::vec::Vec<std::string::String>),
    /// <p>Used to remove the chat channel from an incident record or response plan.</p>
    Empty(crate::model::EmptyChatChannel),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ChatChannel {
    /// Tries to convert the enum instance into [`ChatbotSns`](crate::model::ChatChannel::ChatbotSns), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_chatbot_sns(
        &self,
    ) -> std::result::Result<&std::vec::Vec<std::string::String>, &Self> {
        if let ChatChannel::ChatbotSns(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ChatbotSns`](crate::model::ChatChannel::ChatbotSns).
    pub fn is_chatbot_sns(&self) -> bool {
        self.as_chatbot_sns().is_ok()
    }
    /// Tries to convert the enum instance into [`Empty`](crate::model::ChatChannel::Empty), extracting the inner [`EmptyChatChannel`](crate::model::EmptyChatChannel).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_empty(&self) -> std::result::Result<&crate::model::EmptyChatChannel, &Self> {
        if let ChatChannel::Empty(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Empty`](crate::model::ChatChannel::Empty).
    pub fn is_empty(&self) -> bool {
        self.as_empty().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Used to remove the chat channel from an incident record or response plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EmptyChatChannel {}
/// See [`EmptyChatChannel`](crate::model::EmptyChatChannel).
pub mod empty_chat_channel {

    /// A builder for [`EmptyChatChannel`](crate::model::EmptyChatChannel).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyChatChannel`](crate::model::EmptyChatChannel).
        pub fn build(self) -> crate::model::EmptyChatChannel {
            crate::model::EmptyChatChannel {}
        }
    }
}
impl EmptyChatChannel {
    /// Creates a new builder-style object to manufacture [`EmptyChatChannel`](crate::model::EmptyChatChannel).
    pub fn builder() -> crate::model::empty_chat_channel::Builder {
        crate::model::empty_chat_channel::Builder::default()
    }
}

/// <p>The SNS targets that are notified when updates are made to an incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum NotificationTargetItem {
    /// <p>The Amazon Resource Name (ARN) of the SNS topic.</p>
    SnsTopicArn(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl NotificationTargetItem {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`SnsTopicArn`](crate::model::NotificationTargetItem::SnsTopicArn), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_sns_topic_arn(&self) -> std::result::Result<&std::string::String, &Self> {
        if let NotificationTargetItem::SnsTopicArn(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SnsTopicArn`](crate::model::NotificationTargetItem::SnsTopicArn).
    pub fn is_sns_topic_arn(&self) -> bool {
        self.as_sns_topic_arn().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details used when updating the replication set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum UpdateReplicationSetAction {
    /// <p>Details about the Amazon Web Services Region that you're adding to the replication set.</p>
    AddRegionAction(crate::model::AddRegionAction),
    /// <p>Details about the Amazon Web Services Region that you're deleting to the replication set.</p>
    DeleteRegionAction(crate::model::DeleteRegionAction),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl UpdateReplicationSetAction {
    /// Tries to convert the enum instance into [`AddRegionAction`](crate::model::UpdateReplicationSetAction::AddRegionAction), extracting the inner [`AddRegionAction`](crate::model::AddRegionAction).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_region_action(
        &self,
    ) -> std::result::Result<&crate::model::AddRegionAction, &Self> {
        if let UpdateReplicationSetAction::AddRegionAction(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AddRegionAction`](crate::model::UpdateReplicationSetAction::AddRegionAction).
    pub fn is_add_region_action(&self) -> bool {
        self.as_add_region_action().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteRegionAction`](crate::model::UpdateReplicationSetAction::DeleteRegionAction), extracting the inner [`DeleteRegionAction`](crate::model::DeleteRegionAction).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_region_action(
        &self,
    ) -> std::result::Result<&crate::model::DeleteRegionAction, &Self> {
        if let UpdateReplicationSetAction::DeleteRegionAction(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`DeleteRegionAction`](crate::model::UpdateReplicationSetAction::DeleteRegionAction).
    pub fn is_delete_region_action(&self) -> bool {
        self.as_delete_region_action().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Defines the information about the Amazon Web Services Region you're deleting from your replication set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRegionAction {
    /// <p>The name of the Amazon Web Services Region you're deleting from the replication set.</p>
    #[doc(hidden)]
    pub region_name: std::option::Option<std::string::String>,
}
impl DeleteRegionAction {
    /// <p>The name of the Amazon Web Services Region you're deleting from the replication set.</p>
    pub fn region_name(&self) -> std::option::Option<&str> {
        self.region_name.as_deref()
    }
}
/// See [`DeleteRegionAction`](crate::model::DeleteRegionAction).
pub mod delete_region_action {

    /// A builder for [`DeleteRegionAction`](crate::model::DeleteRegionAction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon Web Services Region you're deleting from the replication set.</p>
        pub fn region_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.region_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Web Services Region you're deleting from the replication set.</p>
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRegionAction`](crate::model::DeleteRegionAction).
        pub fn build(self) -> crate::model::DeleteRegionAction {
            crate::model::DeleteRegionAction {
                region_name: self.region_name,
            }
        }
    }
}
impl DeleteRegionAction {
    /// Creates a new builder-style object to manufacture [`DeleteRegionAction`](crate::model::DeleteRegionAction).
    pub fn builder() -> crate::model::delete_region_action::Builder {
        crate::model::delete_region_action::Builder::default()
    }
}

/// <p>Defines the Amazon Web Services Region and KMS key to add to the replication set. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AddRegionAction {
    /// <p>The Amazon Web Services Region name to add to the replication set.</p>
    #[doc(hidden)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The KMS key ID to use to encrypt your replication set.</p>
    #[doc(hidden)]
    pub sse_kms_key_id: std::option::Option<std::string::String>,
}
impl AddRegionAction {
    /// <p>The Amazon Web Services Region name to add to the replication set.</p>
    pub fn region_name(&self) -> std::option::Option<&str> {
        self.region_name.as_deref()
    }
    /// <p>The KMS key ID to use to encrypt your replication set.</p>
    pub fn sse_kms_key_id(&self) -> std::option::Option<&str> {
        self.sse_kms_key_id.as_deref()
    }
}
/// See [`AddRegionAction`](crate::model::AddRegionAction).
pub mod add_region_action {

    /// A builder for [`AddRegionAction`](crate::model::AddRegionAction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) sse_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Region name to add to the replication set.</p>
        pub fn region_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.region_name = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region name to add to the replication set.</p>
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region_name = input;
            self
        }
        /// <p>The KMS key ID to use to encrypt your replication set.</p>
        pub fn sse_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key ID to use to encrypt your replication set.</p>
        pub fn set_sse_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AddRegionAction`](crate::model::AddRegionAction).
        pub fn build(self) -> crate::model::AddRegionAction {
            crate::model::AddRegionAction {
                region_name: self.region_name,
                sse_kms_key_id: self.sse_kms_key_id,
            }
        }
    }
}
impl AddRegionAction {
    /// Creates a new builder-style object to manufacture [`AddRegionAction`](crate::model::AddRegionAction).
    pub fn builder() -> crate::model::add_region_action::Builder {
        crate::model::add_region_action::Builder::default()
    }
}

/// <p>Details about the related item you're adding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum RelatedItemsUpdate {
    /// <p>Details about the related item you're adding.</p>
    ItemToAdd(crate::model::RelatedItem),
    /// <p>Details about the related item you're deleting.</p>
    ItemToRemove(crate::model::ItemIdentifier),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl RelatedItemsUpdate {
    /// Tries to convert the enum instance into [`ItemToAdd`](crate::model::RelatedItemsUpdate::ItemToAdd), extracting the inner [`RelatedItem`](crate::model::RelatedItem).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_item_to_add(&self) -> std::result::Result<&crate::model::RelatedItem, &Self> {
        if let RelatedItemsUpdate::ItemToAdd(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ItemToAdd`](crate::model::RelatedItemsUpdate::ItemToAdd).
    pub fn is_item_to_add(&self) -> bool {
        self.as_item_to_add().is_ok()
    }
    /// Tries to convert the enum instance into [`ItemToRemove`](crate::model::RelatedItemsUpdate::ItemToRemove), extracting the inner [`ItemIdentifier`](crate::model::ItemIdentifier).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_item_to_remove(&self) -> std::result::Result<&crate::model::ItemIdentifier, &Self> {
        if let RelatedItemsUpdate::ItemToRemove(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ItemToRemove`](crate::model::RelatedItemsUpdate::ItemToRemove).
    pub fn is_item_to_remove(&self) -> bool {
        self.as_item_to_remove().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details and type of a related item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ItemIdentifier {
    /// <p>Details about the related item.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::ItemValue>,
    /// <p>The type of related item. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ItemType>,
}
impl ItemIdentifier {
    /// <p>Details about the related item.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::ItemValue> {
        self.value.as_ref()
    }
    /// <p>The type of related item. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ItemType> {
        self.r#type.as_ref()
    }
}
/// See [`ItemIdentifier`](crate::model::ItemIdentifier).
pub mod item_identifier {

    /// A builder for [`ItemIdentifier`](crate::model::ItemIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<crate::model::ItemValue>,
        pub(crate) r#type: std::option::Option<crate::model::ItemType>,
    }
    impl Builder {
        /// <p>Details about the related item.</p>
        pub fn value(mut self, input: crate::model::ItemValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Details about the related item.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::ItemValue>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of related item. </p>
        pub fn r#type(mut self, input: crate::model::ItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of related item. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ItemType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ItemIdentifier`](crate::model::ItemIdentifier).
        pub fn build(self) -> crate::model::ItemIdentifier {
            crate::model::ItemIdentifier {
                value: self.value,
                r#type: self.r#type,
            }
        }
    }
}
impl ItemIdentifier {
    /// Creates a new builder-style object to manufacture [`ItemIdentifier`](crate::model::ItemIdentifier).
    pub fn builder() -> crate::model::item_identifier::Builder {
        crate::model::item_identifier::Builder::default()
    }
}

/// When writing a match expression against `ItemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let itemtype = unimplemented!();
/// match itemtype {
///     ItemType::Analysis => { /* ... */ },
///     ItemType::Attachment => { /* ... */ },
///     ItemType::Automation => { /* ... */ },
///     ItemType::Incident => { /* ... */ },
///     ItemType::InvolvedResource => { /* ... */ },
///     ItemType::Metric => { /* ... */ },
///     ItemType::Other => { /* ... */ },
///     ItemType::Parent => { /* ... */ },
///     ItemType::Task => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `itemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ItemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ItemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ItemType::NewFeature` is defined.
/// Specifically, when `itemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ItemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ItemType {
    #[allow(missing_docs)] // documentation missing in model
    Analysis,
    #[allow(missing_docs)] // documentation missing in model
    Attachment,
    #[allow(missing_docs)] // documentation missing in model
    Automation,
    #[allow(missing_docs)] // documentation missing in model
    Incident,
    #[allow(missing_docs)] // documentation missing in model
    InvolvedResource,
    #[allow(missing_docs)] // documentation missing in model
    Metric,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Parent,
    #[allow(missing_docs)] // documentation missing in model
    Task,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ItemType {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS" => ItemType::Analysis,
            "ATTACHMENT" => ItemType::Attachment,
            "AUTOMATION" => ItemType::Automation,
            "INCIDENT" => ItemType::Incident,
            "INVOLVED_RESOURCE" => ItemType::InvolvedResource,
            "METRIC" => ItemType::Metric,
            "OTHER" => ItemType::Other,
            "PARENT" => ItemType::Parent,
            "TASK" => ItemType::Task,
            other => ItemType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ItemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ItemType::from(s))
    }
}
impl ItemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ItemType::Analysis => "ANALYSIS",
            ItemType::Attachment => "ATTACHMENT",
            ItemType::Automation => "AUTOMATION",
            ItemType::Incident => "INCIDENT",
            ItemType::InvolvedResource => "INVOLVED_RESOURCE",
            ItemType::Metric => "METRIC",
            ItemType::Other => "OTHER",
            ItemType::Parent => "PARENT",
            ItemType::Task => "TASK",
            ItemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANALYSIS",
            "ATTACHMENT",
            "AUTOMATION",
            "INCIDENT",
            "INVOLVED_RESOURCE",
            "METRIC",
            "OTHER",
            "PARENT",
            "TASK",
        ]
    }
}
impl AsRef<str> for ItemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a related item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ItemValue {
    /// <p>The Amazon Resource Name (ARN) of the related item, if the related item is an Amazon resource.</p>
    Arn(std::string::String),
    /// <p>The metric definition, if the related item is a metric in Amazon CloudWatch.</p>
    MetricDefinition(std::string::String),
    /// <p>Details about an incident that is associated with a PagerDuty incident.</p>
    PagerDutyIncidentDetail(crate::model::PagerDutyIncidentDetail),
    /// <p>The URL, if the related item is a non-Amazon Web Services resource.</p>
    Url(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ItemValue {
    /// Tries to convert the enum instance into [`Arn`](crate::model::ItemValue::Arn), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_arn(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ItemValue::Arn(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Arn`](crate::model::ItemValue::Arn).
    pub fn is_arn(&self) -> bool {
        self.as_arn().is_ok()
    }
    /// Tries to convert the enum instance into [`MetricDefinition`](crate::model::ItemValue::MetricDefinition), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_metric_definition(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ItemValue::MetricDefinition(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`MetricDefinition`](crate::model::ItemValue::MetricDefinition).
    pub fn is_metric_definition(&self) -> bool {
        self.as_metric_definition().is_ok()
    }
    /// Tries to convert the enum instance into [`PagerDutyIncidentDetail`](crate::model::ItemValue::PagerDutyIncidentDetail), extracting the inner [`PagerDutyIncidentDetail`](crate::model::PagerDutyIncidentDetail).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_pager_duty_incident_detail(
        &self,
    ) -> std::result::Result<&crate::model::PagerDutyIncidentDetail, &Self> {
        if let ItemValue::PagerDutyIncidentDetail(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`PagerDutyIncidentDetail`](crate::model::ItemValue::PagerDutyIncidentDetail).
    pub fn is_pager_duty_incident_detail(&self) -> bool {
        self.as_pager_duty_incident_detail().is_ok()
    }
    /// Tries to convert the enum instance into [`Url`](crate::model::ItemValue::Url), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_url(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ItemValue::Url(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Url`](crate::model::ItemValue::Url).
    pub fn is_url(&self) -> bool {
        self.as_url().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details about the PagerDuty incident associated with an incident created by an Incident Manager response plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PagerDutyIncidentDetail {
    /// <p>The ID of the incident associated with the PagerDuty service for the response plan.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.</p>
    #[doc(hidden)]
    pub auto_resolve: std::option::Option<bool>,
    /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
    #[doc(hidden)]
    pub secret_id: std::option::Option<std::string::String>,
}
impl PagerDutyIncidentDetail {
    /// <p>The ID of the incident associated with the PagerDuty service for the response plan.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.</p>
    pub fn auto_resolve(&self) -> std::option::Option<bool> {
        self.auto_resolve
    }
    /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
    pub fn secret_id(&self) -> std::option::Option<&str> {
        self.secret_id.as_deref()
    }
}
/// See [`PagerDutyIncidentDetail`](crate::model::PagerDutyIncidentDetail).
pub mod pager_duty_incident_detail {

    /// A builder for [`PagerDutyIncidentDetail`](crate::model::PagerDutyIncidentDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) auto_resolve: std::option::Option<bool>,
        pub(crate) secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the incident associated with the PagerDuty service for the response plan.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the incident associated with the PagerDuty service for the response plan.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.</p>
        pub fn auto_resolve(mut self, input: bool) -> Self {
            self.auto_resolve = Some(input);
            self
        }
        /// <p>Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.</p>
        pub fn set_auto_resolve(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_resolve = input;
            self
        }
        /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
        pub fn secret_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.</p>
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PagerDutyIncidentDetail`](crate::model::PagerDutyIncidentDetail).
        pub fn build(self) -> crate::model::PagerDutyIncidentDetail {
            crate::model::PagerDutyIncidentDetail {
                id: self.id,
                auto_resolve: self.auto_resolve,
                secret_id: self.secret_id,
            }
        }
    }
}
impl PagerDutyIncidentDetail {
    /// Creates a new builder-style object to manufacture [`PagerDutyIncidentDetail`](crate::model::PagerDutyIncidentDetail).
    pub fn builder() -> crate::model::pager_duty_incident_detail::Builder {
        crate::model::pager_duty_incident_detail::Builder::default()
    }
}

/// <p>Resources that responders use to triage and mitigate the incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelatedItem {
    /// <p>Details about the related item.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<crate::model::ItemIdentifier>,
    /// <p>The title of the related item.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>A unique ID for a <code>RelatedItem</code>.</p> <important>
    /// <p>Don't specify this parameter when you add a <code>RelatedItem</code> by using the <code>UpdateRelatedItems</code> API action.</p>
    /// </important>
    #[doc(hidden)]
    pub generated_id: std::option::Option<std::string::String>,
}
impl RelatedItem {
    /// <p>Details about the related item.</p>
    pub fn identifier(&self) -> std::option::Option<&crate::model::ItemIdentifier> {
        self.identifier.as_ref()
    }
    /// <p>The title of the related item.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>A unique ID for a <code>RelatedItem</code>.</p> <important>
    /// <p>Don't specify this parameter when you add a <code>RelatedItem</code> by using the <code>UpdateRelatedItems</code> API action.</p>
    /// </important>
    pub fn generated_id(&self) -> std::option::Option<&str> {
        self.generated_id.as_deref()
    }
}
/// See [`RelatedItem`](crate::model::RelatedItem).
pub mod related_item {

    /// A builder for [`RelatedItem`](crate::model::RelatedItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<crate::model::ItemIdentifier>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) generated_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Details about the related item.</p>
        pub fn identifier(mut self, input: crate::model::ItemIdentifier) -> Self {
            self.identifier = Some(input);
            self
        }
        /// <p>Details about the related item.</p>
        pub fn set_identifier(
            mut self,
            input: std::option::Option<crate::model::ItemIdentifier>,
        ) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The title of the related item.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the related item.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>A unique ID for a <code>RelatedItem</code>.</p> <important>
        /// <p>Don't specify this parameter when you add a <code>RelatedItem</code> by using the <code>UpdateRelatedItems</code> API action.</p>
        /// </important>
        pub fn generated_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_id = Some(input.into());
            self
        }
        /// <p>A unique ID for a <code>RelatedItem</code>.</p> <important>
        /// <p>Don't specify this parameter when you add a <code>RelatedItem</code> by using the <code>UpdateRelatedItems</code> API action.</p>
        /// </important>
        pub fn set_generated_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.generated_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RelatedItem`](crate::model::RelatedItem).
        pub fn build(self) -> crate::model::RelatedItem {
            crate::model::RelatedItem {
                identifier: self.identifier,
                title: self.title,
                generated_id: self.generated_id,
            }
        }
    }
}
impl RelatedItem {
    /// Creates a new builder-style object to manufacture [`RelatedItem`](crate::model::RelatedItem).
    pub fn builder() -> crate::model::related_item::Builder {
        crate::model::related_item::Builder::default()
    }
}

/// When writing a match expression against `IncidentRecordStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let incidentrecordstatus = unimplemented!();
/// match incidentrecordstatus {
///     IncidentRecordStatus::Open => { /* ... */ },
///     IncidentRecordStatus::Resolved => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `incidentrecordstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IncidentRecordStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IncidentRecordStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IncidentRecordStatus::NewFeature` is defined.
/// Specifically, when `incidentrecordstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IncidentRecordStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IncidentRecordStatus {
    #[allow(missing_docs)] // documentation missing in model
    Open,
    #[allow(missing_docs)] // documentation missing in model
    Resolved,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IncidentRecordStatus {
    fn from(s: &str) -> Self {
        match s {
            "OPEN" => IncidentRecordStatus::Open,
            "RESOLVED" => IncidentRecordStatus::Resolved,
            other => {
                IncidentRecordStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for IncidentRecordStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IncidentRecordStatus::from(s))
    }
}
impl IncidentRecordStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IncidentRecordStatus::Open => "OPEN",
            IncidentRecordStatus::Resolved => "RESOLVED",
            IncidentRecordStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OPEN", "RESOLVED"]
    }
}
impl AsRef<str> for IncidentRecordStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about what caused the incident to be created in Incident Manager.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TriggerDetails {
    /// <p>Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "<code>aws.</code>" Customer-generated events can have any value here, as long as it doesn't begin with "<code>aws.</code>" We recommend the use of Java package-name style reverse domain-name strings. </p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source that detected the incident.</p>
    #[doc(hidden)]
    pub trigger_arn: std::option::Option<std::string::String>,
    /// <p>The time that the incident was detected.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.</p>
    #[doc(hidden)]
    pub raw_data: std::option::Option<std::string::String>,
}
impl TriggerDetails {
    /// <p>Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "<code>aws.</code>" Customer-generated events can have any value here, as long as it doesn't begin with "<code>aws.</code>" We recommend the use of Java package-name style reverse domain-name strings. </p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the source that detected the incident.</p>
    pub fn trigger_arn(&self) -> std::option::Option<&str> {
        self.trigger_arn.as_deref()
    }
    /// <p>The time that the incident was detected.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.</p>
    pub fn raw_data(&self) -> std::option::Option<&str> {
        self.raw_data.as_deref()
    }
}
/// See [`TriggerDetails`](crate::model::TriggerDetails).
pub mod trigger_details {

    /// A builder for [`TriggerDetails`](crate::model::TriggerDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) trigger_arn: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) raw_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "<code>aws.</code>" Customer-generated events can have any value here, as long as it doesn't begin with "<code>aws.</code>" We recommend the use of Java package-name style reverse domain-name strings. </p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "<code>aws.</code>" Customer-generated events can have any value here, as long as it doesn't begin with "<code>aws.</code>" We recommend the use of Java package-name style reverse domain-name strings. </p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source that detected the incident.</p>
        pub fn trigger_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trigger_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source that detected the incident.</p>
        pub fn set_trigger_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trigger_arn = input;
            self
        }
        /// <p>The time that the incident was detected.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time that the incident was detected.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.</p>
        pub fn raw_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_data = Some(input.into());
            self
        }
        /// <p>Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.</p>
        pub fn set_raw_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_data = input;
            self
        }
        /// Consumes the builder and constructs a [`TriggerDetails`](crate::model::TriggerDetails).
        pub fn build(self) -> crate::model::TriggerDetails {
            crate::model::TriggerDetails {
                source: self.source,
                trigger_arn: self.trigger_arn,
                timestamp: self.timestamp,
                raw_data: self.raw_data,
            }
        }
    }
}
impl TriggerDetails {
    /// Creates a new builder-style object to manufacture [`TriggerDetails`](crate::model::TriggerDetails).
    pub fn builder() -> crate::model::trigger_details::Builder {
        crate::model::trigger_details::Builder::default()
    }
}

/// <p>Details about a timeline event during an incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventSummary {
    /// <p>The Amazon Resource Name (ARN) of the incident that the event happened during.</p>
    #[doc(hidden)]
    pub incident_record_arn: std::option::Option<std::string::String>,
    /// <p>The timeline event ID.</p>
    #[doc(hidden)]
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The time that the event occurred.</p>
    #[doc(hidden)]
    pub event_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the timeline event was last updated.</p>
    #[doc(hidden)]
    pub event_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of event. The timeline event must be <code>Custom Event</code>.</p>
    #[doc(hidden)]
    pub event_type: std::option::Option<std::string::String>,
    /// <p>A list of references in a <code>TimelineEvent</code>.</p>
    #[doc(hidden)]
    pub event_references: std::option::Option<std::vec::Vec<crate::model::EventReference>>,
}
impl EventSummary {
    /// <p>The Amazon Resource Name (ARN) of the incident that the event happened during.</p>
    pub fn incident_record_arn(&self) -> std::option::Option<&str> {
        self.incident_record_arn.as_deref()
    }
    /// <p>The timeline event ID.</p>
    pub fn event_id(&self) -> std::option::Option<&str> {
        self.event_id.as_deref()
    }
    /// <p>The time that the event occurred.</p>
    pub fn event_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.event_time.as_ref()
    }
    /// <p>The time that the timeline event was last updated.</p>
    pub fn event_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.event_updated_time.as_ref()
    }
    /// <p>The type of event. The timeline event must be <code>Custom Event</code>.</p>
    pub fn event_type(&self) -> std::option::Option<&str> {
        self.event_type.as_deref()
    }
    /// <p>A list of references in a <code>TimelineEvent</code>.</p>
    pub fn event_references(&self) -> std::option::Option<&[crate::model::EventReference]> {
        self.event_references.as_deref()
    }
}
/// See [`EventSummary`](crate::model::EventSummary).
pub mod event_summary {

    /// A builder for [`EventSummary`](crate::model::EventSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) incident_record_arn: std::option::Option<std::string::String>,
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) event_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) event_type: std::option::Option<std::string::String>,
        pub(crate) event_references:
            std::option::Option<std::vec::Vec<crate::model::EventReference>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the incident that the event happened during.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.incident_record_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident that the event happened during.</p>
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.incident_record_arn = input;
            self
        }
        /// <p>The timeline event ID.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p>The timeline event ID.</p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p>The time that the event occurred.</p>
        pub fn event_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.event_time = Some(input);
            self
        }
        /// <p>The time that the event occurred.</p>
        pub fn set_event_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.event_time = input;
            self
        }
        /// <p>The time that the timeline event was last updated.</p>
        pub fn event_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.event_updated_time = Some(input);
            self
        }
        /// <p>The time that the timeline event was last updated.</p>
        pub fn set_event_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.event_updated_time = input;
            self
        }
        /// <p>The type of event. The timeline event must be <code>Custom Event</code>.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type = Some(input.into());
            self
        }
        /// <p>The type of event. The timeline event must be <code>Custom Event</code>.</p>
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_type = input;
            self
        }
        /// Appends an item to `event_references`.
        ///
        /// To override the contents of this collection use [`set_event_references`](Self::set_event_references).
        ///
        /// <p>A list of references in a <code>TimelineEvent</code>.</p>
        pub fn event_references(mut self, input: crate::model::EventReference) -> Self {
            let mut v = self.event_references.unwrap_or_default();
            v.push(input);
            self.event_references = Some(v);
            self
        }
        /// <p>A list of references in a <code>TimelineEvent</code>.</p>
        pub fn set_event_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventReference>>,
        ) -> Self {
            self.event_references = input;
            self
        }
        /// Consumes the builder and constructs a [`EventSummary`](crate::model::EventSummary).
        pub fn build(self) -> crate::model::EventSummary {
            crate::model::EventSummary {
                incident_record_arn: self.incident_record_arn,
                event_id: self.event_id,
                event_time: self.event_time,
                event_updated_time: self.event_updated_time,
                event_type: self.event_type,
                event_references: self.event_references,
            }
        }
    }
}
impl EventSummary {
    /// Creates a new builder-style object to manufacture [`EventSummary`](crate::model::EventSummary).
    pub fn builder() -> crate::model::event_summary::Builder {
        crate::model::event_summary::Builder::default()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Ascending => { /* ... */ },
///     SortOrder::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortOrder::Ascending,
            "DESCENDING" => SortOrder::Descending,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "ASCENDING",
            SortOrder::Descending => "DESCENDING",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TimelineEventSort`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timelineeventsort = unimplemented!();
/// match timelineeventsort {
///     TimelineEventSort::EventTime => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timelineeventsort` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimelineEventSort::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimelineEventSort::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimelineEventSort::NewFeature` is defined.
/// Specifically, when `timelineeventsort` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimelineEventSort::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimelineEventSort {
    #[allow(missing_docs)] // documentation missing in model
    EventTime,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimelineEventSort {
    fn from(s: &str) -> Self {
        match s {
            "EVENT_TIME" => TimelineEventSort::EventTime,
            other => {
                TimelineEventSort::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TimelineEventSort {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimelineEventSort::from(s))
    }
}
impl TimelineEventSort {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimelineEventSort::EventTime => "EVENT_TIME",
            TimelineEventSort::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EVENT_TIME"]
    }
}
impl AsRef<str> for TimelineEventSort {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filter the selection by using a condition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p>The key that you're filtering on.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The condition accepts before or after a specified time, equal to a string, or equal to an integer.</p>
    #[doc(hidden)]
    pub condition: std::option::Option<crate::model::Condition>,
}
impl Filter {
    /// <p>The key that you're filtering on.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The condition accepts before or after a specified time, equal to a string, or equal to an integer.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::Condition> {
        self.condition.as_ref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) condition: std::option::Option<crate::model::Condition>,
    }
    impl Builder {
        /// <p>The key that you're filtering on.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key that you're filtering on.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The condition accepts before or after a specified time, equal to a string, or equal to an integer.</p>
        pub fn condition(mut self, input: crate::model::Condition) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The condition accepts before or after a specified time, equal to a string, or equal to an integer.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::Condition>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                key: self.key,
                condition: self.condition,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>A conditional statement with which to compare a value, after a timestamp, before a timestamp, or equal to a string or integer. If multiple conditions are specified, the conditionals become an <code>AND</code>ed statement. If multiple values are specified for a conditional, the values are <code>OR</code>d.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Condition {
    /// <p>After the specified timestamp.</p>
    After(aws_smithy_types::DateTime),
    /// <p>Before the specified timestamp</p>
    Before(aws_smithy_types::DateTime),
    /// <p>The value is equal to the provided string or integer. </p>
    Equals(crate::model::AttributeValueList),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Condition {
    /// Tries to convert the enum instance into [`After`](crate::model::Condition::After), extracting the inner [`DateTime`](aws_smithy_types::DateTime).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_after(&self) -> std::result::Result<&aws_smithy_types::DateTime, &Self> {
        if let Condition::After(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`After`](crate::model::Condition::After).
    pub fn is_after(&self) -> bool {
        self.as_after().is_ok()
    }
    /// Tries to convert the enum instance into [`Before`](crate::model::Condition::Before), extracting the inner [`DateTime`](aws_smithy_types::DateTime).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_before(&self) -> std::result::Result<&aws_smithy_types::DateTime, &Self> {
        if let Condition::Before(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Before`](crate::model::Condition::Before).
    pub fn is_before(&self) -> bool {
        self.as_before().is_ok()
    }
    /// Tries to convert the enum instance into [`Equals`](crate::model::Condition::Equals), extracting the inner [`AttributeValueList`](crate::model::AttributeValueList).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_equals(&self) -> std::result::Result<&crate::model::AttributeValueList, &Self> {
        if let Condition::Equals(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Equals`](crate::model::Condition::Equals).
    pub fn is_equals(&self) -> bool {
        self.as_equals().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Use the AttributeValueList to filter by string or integer values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AttributeValueList {
    /// <p>The list of integer values that the filter matches.</p>
    IntegerValues(std::vec::Vec<i32>),
    /// <p>The list of string values that the filter matches.</p>
    StringValues(std::vec::Vec<std::string::String>),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AttributeValueList {
    /// Tries to convert the enum instance into [`IntegerValues`](crate::model::AttributeValueList::IntegerValues), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_integer_values(&self) -> std::result::Result<&std::vec::Vec<i32>, &Self> {
        if let AttributeValueList::IntegerValues(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`IntegerValues`](crate::model::AttributeValueList::IntegerValues).
    pub fn is_integer_values(&self) -> bool {
        self.as_integer_values().is_ok()
    }
    /// Tries to convert the enum instance into [`StringValues`](crate::model::AttributeValueList::StringValues), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string_values(
        &self,
    ) -> std::result::Result<&std::vec::Vec<std::string::String>, &Self> {
        if let AttributeValueList::StringValues(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`StringValues`](crate::model::AttributeValueList::StringValues).
    pub fn is_string_values(&self) -> bool {
        self.as_string_values().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details of the response plan that are used when creating an incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResponsePlanSummary {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the response plan. This can't include spaces.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The human readable name of the response plan. This can include spaces.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl ResponsePlanSummary {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the response plan. This can't include spaces.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The human readable name of the response plan. This can include spaces.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
/// See [`ResponsePlanSummary`](crate::model::ResponsePlanSummary).
pub mod response_plan_summary {

    /// A builder for [`ResponsePlanSummary`](crate::model::ResponsePlanSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the response plan. This can't include spaces.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the response plan. This can't include spaces.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The human readable name of the response plan. This can include spaces.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The human readable name of the response plan. This can include spaces.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ResponsePlanSummary`](crate::model::ResponsePlanSummary).
        pub fn build(self) -> crate::model::ResponsePlanSummary {
            crate::model::ResponsePlanSummary {
                arn: self.arn,
                name: self.name,
                display_name: self.display_name,
            }
        }
    }
}
impl ResponsePlanSummary {
    /// Creates a new builder-style object to manufacture [`ResponsePlanSummary`](crate::model::ResponsePlanSummary).
    pub fn builder() -> crate::model::response_plan_summary::Builder {
        crate::model::response_plan_summary::Builder::default()
    }
}

/// <p>Details describing an incident record.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncidentRecordSummary {
    /// <p>The Amazon Resource Name (ARN) of the incident.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The title of the incident. This value is either provided by the response plan or overwritten on creation.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The current status of the incident.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::IncidentRecordStatus>,
    /// <p>Defines the impact to customers and applications.</p>
    #[doc(hidden)]
    pub impact: std::option::Option<i32>,
    /// <p>The time the incident was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the incident was resolved.</p>
    #[doc(hidden)]
    pub resolved_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>What caused Incident Manager to create the incident.</p>
    #[doc(hidden)]
    pub incident_record_source: std::option::Option<crate::model::IncidentRecordSource>,
}
impl IncidentRecordSummary {
    /// <p>The Amazon Resource Name (ARN) of the incident.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The title of the incident. This value is either provided by the response plan or overwritten on creation.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The current status of the incident.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::IncidentRecordStatus> {
        self.status.as_ref()
    }
    /// <p>Defines the impact to customers and applications.</p>
    pub fn impact(&self) -> std::option::Option<i32> {
        self.impact
    }
    /// <p>The time the incident was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time the incident was resolved.</p>
    pub fn resolved_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.resolved_time.as_ref()
    }
    /// <p>What caused Incident Manager to create the incident.</p>
    pub fn incident_record_source(
        &self,
    ) -> std::option::Option<&crate::model::IncidentRecordSource> {
        self.incident_record_source.as_ref()
    }
}
/// See [`IncidentRecordSummary`](crate::model::IncidentRecordSummary).
pub mod incident_record_summary {

    /// A builder for [`IncidentRecordSummary`](crate::model::IncidentRecordSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::IncidentRecordStatus>,
        pub(crate) impact: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) resolved_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) incident_record_source: std::option::Option<crate::model::IncidentRecordSource>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the incident.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The title of the incident. This value is either provided by the response plan or overwritten on creation.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the incident. This value is either provided by the response plan or overwritten on creation.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The current status of the incident.</p>
        pub fn status(mut self, input: crate::model::IncidentRecordStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the incident.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::IncidentRecordStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Defines the impact to customers and applications.</p>
        pub fn impact(mut self, input: i32) -> Self {
            self.impact = Some(input);
            self
        }
        /// <p>Defines the impact to customers and applications.</p>
        pub fn set_impact(mut self, input: std::option::Option<i32>) -> Self {
            self.impact = input;
            self
        }
        /// <p>The time the incident was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the incident was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time the incident was resolved.</p>
        pub fn resolved_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.resolved_time = Some(input);
            self
        }
        /// <p>The time the incident was resolved.</p>
        pub fn set_resolved_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.resolved_time = input;
            self
        }
        /// <p>What caused Incident Manager to create the incident.</p>
        pub fn incident_record_source(mut self, input: crate::model::IncidentRecordSource) -> Self {
            self.incident_record_source = Some(input);
            self
        }
        /// <p>What caused Incident Manager to create the incident.</p>
        pub fn set_incident_record_source(
            mut self,
            input: std::option::Option<crate::model::IncidentRecordSource>,
        ) -> Self {
            self.incident_record_source = input;
            self
        }
        /// Consumes the builder and constructs a [`IncidentRecordSummary`](crate::model::IncidentRecordSummary).
        pub fn build(self) -> crate::model::IncidentRecordSummary {
            crate::model::IncidentRecordSummary {
                arn: self.arn,
                title: self.title,
                status: self.status,
                impact: self.impact,
                creation_time: self.creation_time,
                resolved_time: self.resolved_time,
                incident_record_source: self.incident_record_source,
            }
        }
    }
}
impl IncidentRecordSummary {
    /// Creates a new builder-style object to manufacture [`IncidentRecordSummary`](crate::model::IncidentRecordSummary).
    pub fn builder() -> crate::model::incident_record_summary::Builder {
        crate::model::incident_record_summary::Builder::default()
    }
}

/// <p>Details about what created the incident record and when it was created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncidentRecordSource {
    /// <p>The principal that started the incident.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The service principal that assumed the role specified in <code>createdBy</code>. If no service principal assumed the role this will be left blank.</p>
    #[doc(hidden)]
    pub invoked_by: std::option::Option<std::string::String>,
    /// <p>The resource that caused the incident to be created.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
}
impl IncidentRecordSource {
    /// <p>The principal that started the incident.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The service principal that assumed the role specified in <code>createdBy</code>. If no service principal assumed the role this will be left blank.</p>
    pub fn invoked_by(&self) -> std::option::Option<&str> {
        self.invoked_by.as_deref()
    }
    /// <p>The resource that caused the incident to be created.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
}
/// See [`IncidentRecordSource`](crate::model::IncidentRecordSource).
pub mod incident_record_source {

    /// A builder for [`IncidentRecordSource`](crate::model::IncidentRecordSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) invoked_by: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The principal that started the incident.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The principal that started the incident.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The service principal that assumed the role specified in <code>createdBy</code>. If no service principal assumed the role this will be left blank.</p>
        pub fn invoked_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.invoked_by = Some(input.into());
            self
        }
        /// <p>The service principal that assumed the role specified in <code>createdBy</code>. If no service principal assumed the role this will be left blank.</p>
        pub fn set_invoked_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.invoked_by = input;
            self
        }
        /// <p>The resource that caused the incident to be created.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource that caused the incident to be created.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`IncidentRecordSource`](crate::model::IncidentRecordSource).
        pub fn build(self) -> crate::model::IncidentRecordSource {
            crate::model::IncidentRecordSource {
                created_by: self.created_by,
                invoked_by: self.invoked_by,
                resource_arn: self.resource_arn,
                source: self.source,
            }
        }
    }
}
impl IncidentRecordSource {
    /// Creates a new builder-style object to manufacture [`IncidentRecordSource`](crate::model::IncidentRecordSource).
    pub fn builder() -> crate::model::incident_record_source::Builder {
        crate::model::incident_record_source::Builder::default()
    }
}

/// <p>A significant event that happened during the incident. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimelineEvent {
    /// <p>The Amazon Resource Name (ARN) of the incident that the event occurred during.</p>
    #[doc(hidden)]
    pub incident_record_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the timeline event.</p>
    #[doc(hidden)]
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The time that the event occurred.</p>
    #[doc(hidden)]
    pub event_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the timeline event was last updated.</p>
    #[doc(hidden)]
    pub event_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of event that occurred. Currently Incident Manager supports only the <code>Custom Event</code> type.</p>
    #[doc(hidden)]
    pub event_type: std::option::Option<std::string::String>,
    /// <p>A short description of the event.</p>
    #[doc(hidden)]
    pub event_data: std::option::Option<std::string::String>,
    /// <p>A list of references in a <code>TimelineEvent</code>.</p>
    #[doc(hidden)]
    pub event_references: std::option::Option<std::vec::Vec<crate::model::EventReference>>,
}
impl TimelineEvent {
    /// <p>The Amazon Resource Name (ARN) of the incident that the event occurred during.</p>
    pub fn incident_record_arn(&self) -> std::option::Option<&str> {
        self.incident_record_arn.as_deref()
    }
    /// <p>The ID of the timeline event.</p>
    pub fn event_id(&self) -> std::option::Option<&str> {
        self.event_id.as_deref()
    }
    /// <p>The time that the event occurred.</p>
    pub fn event_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.event_time.as_ref()
    }
    /// <p>The time that the timeline event was last updated.</p>
    pub fn event_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.event_updated_time.as_ref()
    }
    /// <p>The type of event that occurred. Currently Incident Manager supports only the <code>Custom Event</code> type.</p>
    pub fn event_type(&self) -> std::option::Option<&str> {
        self.event_type.as_deref()
    }
    /// <p>A short description of the event.</p>
    pub fn event_data(&self) -> std::option::Option<&str> {
        self.event_data.as_deref()
    }
    /// <p>A list of references in a <code>TimelineEvent</code>.</p>
    pub fn event_references(&self) -> std::option::Option<&[crate::model::EventReference]> {
        self.event_references.as_deref()
    }
}
/// See [`TimelineEvent`](crate::model::TimelineEvent).
pub mod timeline_event {

    /// A builder for [`TimelineEvent`](crate::model::TimelineEvent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) incident_record_arn: std::option::Option<std::string::String>,
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) event_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) event_type: std::option::Option<std::string::String>,
        pub(crate) event_data: std::option::Option<std::string::String>,
        pub(crate) event_references:
            std::option::Option<std::vec::Vec<crate::model::EventReference>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the incident that the event occurred during.</p>
        pub fn incident_record_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.incident_record_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident that the event occurred during.</p>
        pub fn set_incident_record_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.incident_record_arn = input;
            self
        }
        /// <p>The ID of the timeline event.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p>The ID of the timeline event.</p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p>The time that the event occurred.</p>
        pub fn event_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.event_time = Some(input);
            self
        }
        /// <p>The time that the event occurred.</p>
        pub fn set_event_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.event_time = input;
            self
        }
        /// <p>The time that the timeline event was last updated.</p>
        pub fn event_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.event_updated_time = Some(input);
            self
        }
        /// <p>The time that the timeline event was last updated.</p>
        pub fn set_event_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.event_updated_time = input;
            self
        }
        /// <p>The type of event that occurred. Currently Incident Manager supports only the <code>Custom Event</code> type.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type = Some(input.into());
            self
        }
        /// <p>The type of event that occurred. Currently Incident Manager supports only the <code>Custom Event</code> type.</p>
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_type = input;
            self
        }
        /// <p>A short description of the event.</p>
        pub fn event_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_data = Some(input.into());
            self
        }
        /// <p>A short description of the event.</p>
        pub fn set_event_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_data = input;
            self
        }
        /// Appends an item to `event_references`.
        ///
        /// To override the contents of this collection use [`set_event_references`](Self::set_event_references).
        ///
        /// <p>A list of references in a <code>TimelineEvent</code>.</p>
        pub fn event_references(mut self, input: crate::model::EventReference) -> Self {
            let mut v = self.event_references.unwrap_or_default();
            v.push(input);
            self.event_references = Some(v);
            self
        }
        /// <p>A list of references in a <code>TimelineEvent</code>.</p>
        pub fn set_event_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventReference>>,
        ) -> Self {
            self.event_references = input;
            self
        }
        /// Consumes the builder and constructs a [`TimelineEvent`](crate::model::TimelineEvent).
        pub fn build(self) -> crate::model::TimelineEvent {
            crate::model::TimelineEvent {
                incident_record_arn: self.incident_record_arn,
                event_id: self.event_id,
                event_time: self.event_time,
                event_updated_time: self.event_updated_time,
                event_type: self.event_type,
                event_data: self.event_data,
                event_references: self.event_references,
            }
        }
    }
}
impl TimelineEvent {
    /// Creates a new builder-style object to manufacture [`TimelineEvent`](crate::model::TimelineEvent).
    pub fn builder() -> crate::model::timeline_event::Builder {
        crate::model::timeline_event::Builder::default()
    }
}

/// <p>Basic details used in creating a response plan. The response plan is then used to create an incident record.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncidentTemplate {
    /// <p>The title of the incident. </p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The impact of the incident on your customers and applications. </p>
    #[doc(hidden)]
    pub impact: std::option::Option<i32>,
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    #[doc(hidden)]
    pub summary: std::option::Option<std::string::String>,
    /// <p>Used to stop Incident Manager from creating multiple incident records for the same incident. </p>
    #[doc(hidden)]
    pub dedupe_string: std::option::Option<std::string::String>,
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    #[doc(hidden)]
    pub notification_targets:
        std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    #[doc(hidden)]
    pub incident_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl IncidentTemplate {
    /// <p>The title of the incident. </p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The impact of the incident on your customers and applications. </p>
    pub fn impact(&self) -> std::option::Option<i32> {
        self.impact
    }
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    pub fn summary(&self) -> std::option::Option<&str> {
        self.summary.as_deref()
    }
    /// <p>Used to stop Incident Manager from creating multiple incident records for the same incident. </p>
    pub fn dedupe_string(&self) -> std::option::Option<&str> {
        self.dedupe_string.as_deref()
    }
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    pub fn notification_targets(
        &self,
    ) -> std::option::Option<&[crate::model::NotificationTargetItem]> {
        self.notification_targets.as_deref()
    }
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    pub fn incident_tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.incident_tags.as_ref()
    }
}
/// See [`IncidentTemplate`](crate::model::IncidentTemplate).
pub mod incident_template {

    /// A builder for [`IncidentTemplate`](crate::model::IncidentTemplate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) impact: std::option::Option<i32>,
        pub(crate) summary: std::option::Option<std::string::String>,
        pub(crate) dedupe_string: std::option::Option<std::string::String>,
        pub(crate) notification_targets:
            std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
        pub(crate) incident_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The title of the incident. </p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the incident. </p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The impact of the incident on your customers and applications. </p>
        pub fn impact(mut self, input: i32) -> Self {
            self.impact = Some(input);
            self
        }
        /// <p>The impact of the incident on your customers and applications. </p>
        pub fn set_impact(mut self, input: std::option::Option<i32>) -> Self {
            self.impact = input;
            self
        }
        /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
        pub fn summary(mut self, input: impl Into<std::string::String>) -> Self {
            self.summary = Some(input.into());
            self
        }
        /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
        pub fn set_summary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.summary = input;
            self
        }
        /// <p>Used to stop Incident Manager from creating multiple incident records for the same incident. </p>
        pub fn dedupe_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.dedupe_string = Some(input.into());
            self
        }
        /// <p>Used to stop Incident Manager from creating multiple incident records for the same incident. </p>
        pub fn set_dedupe_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dedupe_string = input;
            self
        }
        /// Appends an item to `notification_targets`.
        ///
        /// To override the contents of this collection use [`set_notification_targets`](Self::set_notification_targets).
        ///
        /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
        pub fn notification_targets(mut self, input: crate::model::NotificationTargetItem) -> Self {
            let mut v = self.notification_targets.unwrap_or_default();
            v.push(input);
            self.notification_targets = Some(v);
            self
        }
        /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
        pub fn set_notification_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
        ) -> Self {
            self.notification_targets = input;
            self
        }
        /// Adds a key-value pair to `incident_tags`.
        ///
        /// To override the contents of this collection use [`set_incident_tags`](Self::set_incident_tags).
        ///
        /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
        pub fn incident_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.incident_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.incident_tags = Some(hash_map);
            self
        }
        /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
        pub fn set_incident_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.incident_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`IncidentTemplate`](crate::model::IncidentTemplate).
        pub fn build(self) -> crate::model::IncidentTemplate {
            crate::model::IncidentTemplate {
                title: self.title,
                impact: self.impact,
                summary: self.summary,
                dedupe_string: self.dedupe_string,
                notification_targets: self.notification_targets,
                incident_tags: self.incident_tags,
            }
        }
    }
}
impl IncidentTemplate {
    /// Creates a new builder-style object to manufacture [`IncidentTemplate`](crate::model::IncidentTemplate).
    pub fn builder() -> crate::model::incident_template::Builder {
        crate::model::incident_template::Builder::default()
    }
}

/// <p>The resource policy that allows Incident Manager to perform actions on resources on your behalf.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourcePolicy {
    /// <p>The JSON blob that describes the policy.</p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>The ID of the resource policy.</p>
    #[doc(hidden)]
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region that policy allows resources to be used in.</p>
    #[doc(hidden)]
    pub ram_resource_share_region: std::option::Option<std::string::String>,
}
impl ResourcePolicy {
    /// <p>The JSON blob that describes the policy.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>The ID of the resource policy.</p>
    pub fn policy_id(&self) -> std::option::Option<&str> {
        self.policy_id.as_deref()
    }
    /// <p>The Amazon Web Services Region that policy allows resources to be used in.</p>
    pub fn ram_resource_share_region(&self) -> std::option::Option<&str> {
        self.ram_resource_share_region.as_deref()
    }
}
/// See [`ResourcePolicy`](crate::model::ResourcePolicy).
pub mod resource_policy {

    /// A builder for [`ResourcePolicy`](crate::model::ResourcePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) ram_resource_share_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The JSON blob that describes the policy.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The JSON blob that describes the policy.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>The ID of the resource policy.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource policy.</p>
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The Amazon Web Services Region that policy allows resources to be used in.</p>
        pub fn ram_resource_share_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.ram_resource_share_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region that policy allows resources to be used in.</p>
        pub fn set_ram_resource_share_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ram_resource_share_region = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourcePolicy`](crate::model::ResourcePolicy).
        pub fn build(self) -> crate::model::ResourcePolicy {
            crate::model::ResourcePolicy {
                policy_document: self.policy_document,
                policy_id: self.policy_id,
                ram_resource_share_region: self.ram_resource_share_region,
            }
        }
    }
}
impl ResourcePolicy {
    /// Creates a new builder-style object to manufacture [`ResourcePolicy`](crate::model::ResourcePolicy).
    pub fn builder() -> crate::model::resource_policy::Builder {
        crate::model::resource_policy::Builder::default()
    }
}

/// <p>The set of Amazon Web Services Region that your Incident Manager data will be replicated to and the KMS key used to encrypt the data. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReplicationSet {
    /// <p>The Amazon Resource Name (ARN) of the replication set.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.</p>
    #[doc(hidden)]
    pub region_map: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::RegionInfo>,
    >,
    /// <p>The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReplicationSetStatus>,
    /// <p>Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set. </p>
    #[doc(hidden)]
    pub deletion_protected: std::option::Option<bool>,
    /// <p>When the replication set was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Details about who created the replication set.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>When the replication set was last updated.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who last modified the replication set.</p>
    #[doc(hidden)]
    pub last_modified_by: std::option::Option<std::string::String>,
}
impl ReplicationSet {
    /// <p>The Amazon Resource Name (ARN) of the replication set.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.</p>
    pub fn region_map(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::RegionInfo>,
    > {
        self.region_map.as_ref()
    }
    /// <p>The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReplicationSetStatus> {
        self.status.as_ref()
    }
    /// <p>Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set. </p>
    pub fn deletion_protected(&self) -> std::option::Option<bool> {
        self.deletion_protected
    }
    /// <p>When the replication set was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>Details about who created the replication set.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>When the replication set was last updated.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Who last modified the replication set.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&str> {
        self.last_modified_by.as_deref()
    }
}
/// See [`ReplicationSet`](crate::model::ReplicationSet).
pub mod replication_set {

    /// A builder for [`ReplicationSet`](crate::model::ReplicationSet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) region_map: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::RegionInfo>,
        >,
        pub(crate) status: std::option::Option<crate::model::ReplicationSetStatus>,
        pub(crate) deletion_protected: std::option::Option<bool>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the replication set.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the replication set.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Adds a key-value pair to `region_map`.
        ///
        /// To override the contents of this collection use [`set_region_map`](Self::set_region_map).
        ///
        /// <p>The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.</p>
        pub fn region_map(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::RegionInfo,
        ) -> Self {
            let mut hash_map = self.region_map.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.region_map = Some(hash_map);
            self
        }
        /// <p>The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.</p>
        pub fn set_region_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::RegionInfo>,
            >,
        ) -> Self {
            self.region_map = input;
            self
        }
        /// <p>The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.</p>
        pub fn status(mut self, input: crate::model::ReplicationSetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReplicationSetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set. </p>
        pub fn deletion_protected(mut self, input: bool) -> Self {
            self.deletion_protected = Some(input);
            self
        }
        /// <p>Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set. </p>
        pub fn set_deletion_protected(mut self, input: std::option::Option<bool>) -> Self {
            self.deletion_protected = input;
            self
        }
        /// <p>When the replication set was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>When the replication set was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Details about who created the replication set.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>Details about who created the replication set.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the replication set was last updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>When the replication set was last updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Who last modified the replication set.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>Who last modified the replication set.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationSet`](crate::model::ReplicationSet).
        pub fn build(self) -> crate::model::ReplicationSet {
            crate::model::ReplicationSet {
                arn: self.arn,
                region_map: self.region_map,
                status: self.status,
                deletion_protected: self.deletion_protected,
                created_time: self.created_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
            }
        }
    }
}
impl ReplicationSet {
    /// Creates a new builder-style object to manufacture [`ReplicationSet`](crate::model::ReplicationSet).
    pub fn builder() -> crate::model::replication_set::Builder {
        crate::model::replication_set::Builder::default()
    }
}

/// When writing a match expression against `ReplicationSetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicationsetstatus = unimplemented!();
/// match replicationsetstatus {
///     ReplicationSetStatus::Active => { /* ... */ },
///     ReplicationSetStatus::Creating => { /* ... */ },
///     ReplicationSetStatus::Deleting => { /* ... */ },
///     ReplicationSetStatus::Failed => { /* ... */ },
///     ReplicationSetStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicationsetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicationSetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicationSetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicationSetStatus::NewFeature` is defined.
/// Specifically, when `replicationsetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicationSetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicationSetStatus {
    /// All operations have completed successfully and the replication set is ready to use
    Active,
    /// Replication set is in the process of being created.
    Creating,
    /// Replication set is in the process of being deleted.
    Deleting,
    /// Replication set is not healthy and we cannot fix it.
    Failed,
    /// Replication set is in the process of being updated.
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicationSetStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ReplicationSetStatus::Active,
            "CREATING" => ReplicationSetStatus::Creating,
            "DELETING" => ReplicationSetStatus::Deleting,
            "FAILED" => ReplicationSetStatus::Failed,
            "UPDATING" => ReplicationSetStatus::Updating,
            other => {
                ReplicationSetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ReplicationSetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicationSetStatus::from(s))
    }
}
impl ReplicationSetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicationSetStatus::Active => "ACTIVE",
            ReplicationSetStatus::Creating => "CREATING",
            ReplicationSetStatus::Deleting => "DELETING",
            ReplicationSetStatus::Failed => "FAILED",
            ReplicationSetStatus::Updating => "UPDATING",
            ReplicationSetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for ReplicationSetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a Amazon Web Services Region in your replication set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegionInfo {
    /// <p>The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub sse_kms_key_id: std::option::Option<std::string::String>,
    /// <p>The status of the Amazon Web Services Region in the replication set.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RegionStatus>,
    /// <p>Information displayed about the status of the Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The most recent date and time that Incident Manager updated the Amazon Web Services Region's status.</p>
    #[doc(hidden)]
    pub status_update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RegionInfo {
    /// <p>The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.</p>
    pub fn sse_kms_key_id(&self) -> std::option::Option<&str> {
        self.sse_kms_key_id.as_deref()
    }
    /// <p>The status of the Amazon Web Services Region in the replication set.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RegionStatus> {
        self.status.as_ref()
    }
    /// <p>Information displayed about the status of the Amazon Web Services Region.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The most recent date and time that Incident Manager updated the Amazon Web Services Region's status.</p>
    pub fn status_update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.status_update_date_time.as_ref()
    }
}
/// See [`RegionInfo`](crate::model::RegionInfo).
pub mod region_info {

    /// A builder for [`RegionInfo`](crate::model::RegionInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sse_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RegionStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) status_update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.</p>
        pub fn sse_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.</p>
        pub fn set_sse_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_kms_key_id = input;
            self
        }
        /// <p>The status of the Amazon Web Services Region in the replication set.</p>
        pub fn status(mut self, input: crate::model::RegionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Amazon Web Services Region in the replication set.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::RegionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Information displayed about the status of the Amazon Web Services Region.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>Information displayed about the status of the Amazon Web Services Region.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The most recent date and time that Incident Manager updated the Amazon Web Services Region's status.</p>
        pub fn status_update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.status_update_date_time = Some(input);
            self
        }
        /// <p>The most recent date and time that Incident Manager updated the Amazon Web Services Region's status.</p>
        pub fn set_status_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.status_update_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RegionInfo`](crate::model::RegionInfo).
        pub fn build(self) -> crate::model::RegionInfo {
            crate::model::RegionInfo {
                sse_kms_key_id: self.sse_kms_key_id,
                status: self.status,
                status_message: self.status_message,
                status_update_date_time: self.status_update_date_time,
            }
        }
    }
}
impl RegionInfo {
    /// Creates a new builder-style object to manufacture [`RegionInfo`](crate::model::RegionInfo).
    pub fn builder() -> crate::model::region_info::Builder {
        crate::model::region_info::Builder::default()
    }
}

/// When writing a match expression against `RegionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let regionstatus = unimplemented!();
/// match regionstatus {
///     RegionStatus::Active => { /* ... */ },
///     RegionStatus::Creating => { /* ... */ },
///     RegionStatus::Deleting => { /* ... */ },
///     RegionStatus::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `regionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RegionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RegionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RegionStatus::NewFeature` is defined.
/// Specifically, when `regionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RegionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RegionStatus {
    /// All operations have completed successfully and the region is ready to use
    Active,
    /// The region is in the process of being created.
    Creating,
    /// The region is in the process of being deleted.
    Deleting,
    /// The region is not healthy and we cannot automatically fix it.
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RegionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => RegionStatus::Active,
            "CREATING" => RegionStatus::Creating,
            "DELETING" => RegionStatus::Deleting,
            "FAILED" => RegionStatus::Failed,
            other => RegionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RegionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RegionStatus::from(s))
    }
}
impl RegionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RegionStatus::Active => "ACTIVE",
            RegionStatus::Creating => "CREATING",
            RegionStatus::Deleting => "DELETING",
            RegionStatus::Failed => "FAILED",
            RegionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED"]
    }
}
impl AsRef<str> for RegionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The record of the incident that's created when an incident occurs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncidentRecord {
    /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The title of the incident.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.</p>
    #[doc(hidden)]
    pub summary: std::option::Option<std::string::String>,
    /// <p>The current status of the incident.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::IncidentRecordStatus>,
    /// <p>The impact of the incident on customers and applications.</p>
    #[doc(hidden)]
    pub impact: std::option::Option<i32>,
    /// <p>The time that Incident Manager created the incident record.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the incident was resolved. This appears as a timeline event.</p>
    #[doc(hidden)]
    pub resolved_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the incident was most recently modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Who modified the incident most recently.</p>
    #[doc(hidden)]
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The runbook, or automation document, that's run at the beginning of the incident.</p>
    #[doc(hidden)]
    pub automation_executions:
        std::option::Option<std::vec::Vec<crate::model::AutomationExecution>>,
    /// <p>Details about the action that started the incident.</p>
    #[doc(hidden)]
    pub incident_record_source: std::option::Option<crate::model::IncidentRecordSource>,
    /// <p>The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.</p>
    #[doc(hidden)]
    pub dedupe_string: std::option::Option<std::string::String>,
    /// <p>The chat channel used for collaboration during an incident.</p>
    #[doc(hidden)]
    pub chat_channel: std::option::Option<crate::model::ChatChannel>,
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    #[doc(hidden)]
    pub notification_targets:
        std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
}
impl IncidentRecord {
    /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The title of the incident.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.</p>
    pub fn summary(&self) -> std::option::Option<&str> {
        self.summary.as_deref()
    }
    /// <p>The current status of the incident.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::IncidentRecordStatus> {
        self.status.as_ref()
    }
    /// <p>The impact of the incident on customers and applications.</p>
    pub fn impact(&self) -> std::option::Option<i32> {
        self.impact
    }
    /// <p>The time that Incident Manager created the incident record.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time at which the incident was resolved. This appears as a timeline event.</p>
    pub fn resolved_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.resolved_time.as_ref()
    }
    /// <p>The time at which the incident was most recently modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>Who modified the incident most recently.</p>
    pub fn last_modified_by(&self) -> std::option::Option<&str> {
        self.last_modified_by.as_deref()
    }
    /// <p>The runbook, or automation document, that's run at the beginning of the incident.</p>
    pub fn automation_executions(
        &self,
    ) -> std::option::Option<&[crate::model::AutomationExecution]> {
        self.automation_executions.as_deref()
    }
    /// <p>Details about the action that started the incident.</p>
    pub fn incident_record_source(
        &self,
    ) -> std::option::Option<&crate::model::IncidentRecordSource> {
        self.incident_record_source.as_ref()
    }
    /// <p>The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.</p>
    pub fn dedupe_string(&self) -> std::option::Option<&str> {
        self.dedupe_string.as_deref()
    }
    /// <p>The chat channel used for collaboration during an incident.</p>
    pub fn chat_channel(&self) -> std::option::Option<&crate::model::ChatChannel> {
        self.chat_channel.as_ref()
    }
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    pub fn notification_targets(
        &self,
    ) -> std::option::Option<&[crate::model::NotificationTargetItem]> {
        self.notification_targets.as_deref()
    }
}
/// See [`IncidentRecord`](crate::model::IncidentRecord).
pub mod incident_record {

    /// A builder for [`IncidentRecord`](crate::model::IncidentRecord).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) summary: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::IncidentRecordStatus>,
        pub(crate) impact: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) resolved_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) automation_executions:
            std::option::Option<std::vec::Vec<crate::model::AutomationExecution>>,
        pub(crate) incident_record_source: std::option::Option<crate::model::IncidentRecordSource>,
        pub(crate) dedupe_string: std::option::Option<std::string::String>,
        pub(crate) chat_channel: std::option::Option<crate::model::ChatChannel>,
        pub(crate) notification_targets:
            std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The title of the incident.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the incident.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.</p>
        pub fn summary(mut self, input: impl Into<std::string::String>) -> Self {
            self.summary = Some(input.into());
            self
        }
        /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.</p>
        pub fn set_summary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.summary = input;
            self
        }
        /// <p>The current status of the incident.</p>
        pub fn status(mut self, input: crate::model::IncidentRecordStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the incident.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::IncidentRecordStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The impact of the incident on customers and applications.</p>
        pub fn impact(mut self, input: i32) -> Self {
            self.impact = Some(input);
            self
        }
        /// <p>The impact of the incident on customers and applications.</p>
        pub fn set_impact(mut self, input: std::option::Option<i32>) -> Self {
            self.impact = input;
            self
        }
        /// <p>The time that Incident Manager created the incident record.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that Incident Manager created the incident record.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the incident was resolved. This appears as a timeline event.</p>
        pub fn resolved_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.resolved_time = Some(input);
            self
        }
        /// <p>The time at which the incident was resolved. This appears as a timeline event.</p>
        pub fn set_resolved_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.resolved_time = input;
            self
        }
        /// <p>The time at which the incident was most recently modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time at which the incident was most recently modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Who modified the incident most recently.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>Who modified the incident most recently.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Appends an item to `automation_executions`.
        ///
        /// To override the contents of this collection use [`set_automation_executions`](Self::set_automation_executions).
        ///
        /// <p>The runbook, or automation document, that's run at the beginning of the incident.</p>
        pub fn automation_executions(mut self, input: crate::model::AutomationExecution) -> Self {
            let mut v = self.automation_executions.unwrap_or_default();
            v.push(input);
            self.automation_executions = Some(v);
            self
        }
        /// <p>The runbook, or automation document, that's run at the beginning of the incident.</p>
        pub fn set_automation_executions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutomationExecution>>,
        ) -> Self {
            self.automation_executions = input;
            self
        }
        /// <p>Details about the action that started the incident.</p>
        pub fn incident_record_source(mut self, input: crate::model::IncidentRecordSource) -> Self {
            self.incident_record_source = Some(input);
            self
        }
        /// <p>Details about the action that started the incident.</p>
        pub fn set_incident_record_source(
            mut self,
            input: std::option::Option<crate::model::IncidentRecordSource>,
        ) -> Self {
            self.incident_record_source = input;
            self
        }
        /// <p>The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.</p>
        pub fn dedupe_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.dedupe_string = Some(input.into());
            self
        }
        /// <p>The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.</p>
        pub fn set_dedupe_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dedupe_string = input;
            self
        }
        /// <p>The chat channel used for collaboration during an incident.</p>
        pub fn chat_channel(mut self, input: crate::model::ChatChannel) -> Self {
            self.chat_channel = Some(input);
            self
        }
        /// <p>The chat channel used for collaboration during an incident.</p>
        pub fn set_chat_channel(
            mut self,
            input: std::option::Option<crate::model::ChatChannel>,
        ) -> Self {
            self.chat_channel = input;
            self
        }
        /// Appends an item to `notification_targets`.
        ///
        /// To override the contents of this collection use [`set_notification_targets`](Self::set_notification_targets).
        ///
        /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
        pub fn notification_targets(mut self, input: crate::model::NotificationTargetItem) -> Self {
            let mut v = self.notification_targets.unwrap_or_default();
            v.push(input);
            self.notification_targets = Some(v);
            self
        }
        /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
        pub fn set_notification_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotificationTargetItem>>,
        ) -> Self {
            self.notification_targets = input;
            self
        }
        /// Consumes the builder and constructs a [`IncidentRecord`](crate::model::IncidentRecord).
        pub fn build(self) -> crate::model::IncidentRecord {
            crate::model::IncidentRecord {
                arn: self.arn,
                title: self.title,
                summary: self.summary,
                status: self.status,
                impact: self.impact,
                creation_time: self.creation_time,
                resolved_time: self.resolved_time,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                automation_executions: self.automation_executions,
                incident_record_source: self.incident_record_source,
                dedupe_string: self.dedupe_string,
                chat_channel: self.chat_channel,
                notification_targets: self.notification_targets,
            }
        }
    }
}
impl IncidentRecord {
    /// Creates a new builder-style object to manufacture [`IncidentRecord`](crate::model::IncidentRecord).
    pub fn builder() -> crate::model::incident_record::Builder {
        crate::model::incident_record::Builder::default()
    }
}

/// <p>The Systems Manager automation document process to start as the runbook at the beginning of the incident.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AutomationExecution {
    /// <p>The Amazon Resource Name (ARN) of the automation process.</p>
    SsmExecutionArn(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AutomationExecution {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`SsmExecutionArn`](crate::model::AutomationExecution::SsmExecutionArn), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_ssm_execution_arn(&self) -> std::result::Result<&std::string::String, &Self> {
        if let AutomationExecution::SsmExecutionArn(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SsmExecutionArn`](crate::model::AutomationExecution::SsmExecutionArn).
    pub fn is_ssm_execution_arn(&self) -> bool {
        self.as_ssm_execution_arn().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The mapping between a Amazon Web Services Region and the key that's used to encrypt the data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegionMapInputValue {
    /// <p>The KMS key used to encrypt the data in your replication set.</p>
    #[doc(hidden)]
    pub sse_kms_key_id: std::option::Option<std::string::String>,
}
impl RegionMapInputValue {
    /// <p>The KMS key used to encrypt the data in your replication set.</p>
    pub fn sse_kms_key_id(&self) -> std::option::Option<&str> {
        self.sse_kms_key_id.as_deref()
    }
}
/// See [`RegionMapInputValue`](crate::model::RegionMapInputValue).
pub mod region_map_input_value {

    /// A builder for [`RegionMapInputValue`](crate::model::RegionMapInputValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sse_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The KMS key used to encrypt the data in your replication set.</p>
        pub fn sse_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sse_kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key used to encrypt the data in your replication set.</p>
        pub fn set_sse_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sse_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RegionMapInputValue`](crate::model::RegionMapInputValue).
        pub fn build(self) -> crate::model::RegionMapInputValue {
            crate::model::RegionMapInputValue {
                sse_kms_key_id: self.sse_kms_key_id,
            }
        }
    }
}
impl RegionMapInputValue {
    /// Creates a new builder-style object to manufacture [`RegionMapInputValue`](crate::model::RegionMapInputValue).
    pub fn builder() -> crate::model::region_map_input_value::Builder {
        crate::model::region_map_input_value::Builder::default()
    }
}
