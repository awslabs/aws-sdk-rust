// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Basic details used in creating a response plan. The response plan is then used to create an incident record.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IncidentTemplate {
    /// <p>The title of the incident.</p>
    pub title: ::std::string::String,
    /// <p>The impact of the incident on your customers and applications.</p>
    /// <p class="title"><b>Supported impact codes</b></p>
    /// <ul>
    /// <li>
    /// <p><code>1</code> - Critical</p></li>
    /// <li>
    /// <p><code>2</code> - High</p></li>
    /// <li>
    /// <p><code>3</code> - Medium</p></li>
    /// <li>
    /// <p><code>4</code> - Low</p></li>
    /// <li>
    /// <p><code>5</code> - No Impact</p></li>
    /// </ul>
    pub impact: i32,
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    pub summary: ::std::option::Option<::std::string::String>,
    /// <p>The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account.</p>
    /// <p>A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the <code>dedupeString</code> field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident.</p><note>
    /// <p>By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.</p>
    /// </note>
    pub dedupe_string: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    pub notification_targets: ::std::option::Option<::std::vec::Vec<crate::types::NotificationTargetItem>>,
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    pub incident_tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl IncidentTemplate {
    /// <p>The title of the incident.</p>
    pub fn title(&self) -> &str {
        use std::ops::Deref;
        self.title.deref()
    }
    /// <p>The impact of the incident on your customers and applications.</p>
    /// <p class="title"><b>Supported impact codes</b></p>
    /// <ul>
    /// <li>
    /// <p><code>1</code> - Critical</p></li>
    /// <li>
    /// <p><code>2</code> - High</p></li>
    /// <li>
    /// <p><code>3</code> - Medium</p></li>
    /// <li>
    /// <p><code>4</code> - Low</p></li>
    /// <li>
    /// <p><code>5</code> - No Impact</p></li>
    /// </ul>
    pub fn impact(&self) -> i32 {
        self.impact
    }
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    pub fn summary(&self) -> ::std::option::Option<&str> {
        self.summary.as_deref()
    }
    /// <p>The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account.</p>
    /// <p>A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the <code>dedupeString</code> field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident.</p><note>
    /// <p>By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.</p>
    /// </note>
    pub fn dedupe_string(&self) -> ::std::option::Option<&str> {
        self.dedupe_string.as_deref()
    }
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.notification_targets.is_none()`.
    pub fn notification_targets(&self) -> &[crate::types::NotificationTargetItem] {
        self.notification_targets.as_deref().unwrap_or_default()
    }
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    pub fn incident_tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.incident_tags.as_ref()
    }
}
impl IncidentTemplate {
    /// Creates a new builder-style object to manufacture [`IncidentTemplate`](crate::types::IncidentTemplate).
    pub fn builder() -> crate::types::builders::IncidentTemplateBuilder {
        crate::types::builders::IncidentTemplateBuilder::default()
    }
}

/// A builder for [`IncidentTemplate`](crate::types::IncidentTemplate).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct IncidentTemplateBuilder {
    pub(crate) title: ::std::option::Option<::std::string::String>,
    pub(crate) impact: ::std::option::Option<i32>,
    pub(crate) summary: ::std::option::Option<::std::string::String>,
    pub(crate) dedupe_string: ::std::option::Option<::std::string::String>,
    pub(crate) notification_targets: ::std::option::Option<::std::vec::Vec<crate::types::NotificationTargetItem>>,
    pub(crate) incident_tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl IncidentTemplateBuilder {
    /// <p>The title of the incident.</p>
    /// This field is required.
    pub fn title(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.title = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The title of the incident.</p>
    pub fn set_title(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.title = input;
        self
    }
    /// <p>The title of the incident.</p>
    pub fn get_title(&self) -> &::std::option::Option<::std::string::String> {
        &self.title
    }
    /// <p>The impact of the incident on your customers and applications.</p>
    /// <p class="title"><b>Supported impact codes</b></p>
    /// <ul>
    /// <li>
    /// <p><code>1</code> - Critical</p></li>
    /// <li>
    /// <p><code>2</code> - High</p></li>
    /// <li>
    /// <p><code>3</code> - Medium</p></li>
    /// <li>
    /// <p><code>4</code> - Low</p></li>
    /// <li>
    /// <p><code>5</code> - No Impact</p></li>
    /// </ul>
    /// This field is required.
    pub fn impact(mut self, input: i32) -> Self {
        self.impact = ::std::option::Option::Some(input);
        self
    }
    /// <p>The impact of the incident on your customers and applications.</p>
    /// <p class="title"><b>Supported impact codes</b></p>
    /// <ul>
    /// <li>
    /// <p><code>1</code> - Critical</p></li>
    /// <li>
    /// <p><code>2</code> - High</p></li>
    /// <li>
    /// <p><code>3</code> - Medium</p></li>
    /// <li>
    /// <p><code>4</code> - Low</p></li>
    /// <li>
    /// <p><code>5</code> - No Impact</p></li>
    /// </ul>
    pub fn set_impact(mut self, input: ::std::option::Option<i32>) -> Self {
        self.impact = input;
        self
    }
    /// <p>The impact of the incident on your customers and applications.</p>
    /// <p class="title"><b>Supported impact codes</b></p>
    /// <ul>
    /// <li>
    /// <p><code>1</code> - Critical</p></li>
    /// <li>
    /// <p><code>2</code> - High</p></li>
    /// <li>
    /// <p><code>3</code> - Medium</p></li>
    /// <li>
    /// <p><code>4</code> - Low</p></li>
    /// <li>
    /// <p><code>5</code> - No Impact</p></li>
    /// </ul>
    pub fn get_impact(&self) -> &::std::option::Option<i32> {
        &self.impact
    }
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    pub fn summary(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.summary = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    pub fn set_summary(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.summary = input;
        self
    }
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.</p>
    pub fn get_summary(&self) -> &::std::option::Option<::std::string::String> {
        &self.summary
    }
    /// <p>The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account.</p>
    /// <p>A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the <code>dedupeString</code> field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident.</p><note>
    /// <p>By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.</p>
    /// </note>
    pub fn dedupe_string(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.dedupe_string = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account.</p>
    /// <p>A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the <code>dedupeString</code> field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident.</p><note>
    /// <p>By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.</p>
    /// </note>
    pub fn set_dedupe_string(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.dedupe_string = input;
        self
    }
    /// <p>The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account.</p>
    /// <p>A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the <code>dedupeString</code> field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident.</p><note>
    /// <p>By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.</p>
    /// </note>
    pub fn get_dedupe_string(&self) -> &::std::option::Option<::std::string::String> {
        &self.dedupe_string
    }
    /// Appends an item to `notification_targets`.
    ///
    /// To override the contents of this collection use [`set_notification_targets`](Self::set_notification_targets).
    ///
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    pub fn notification_targets(mut self, input: crate::types::NotificationTargetItem) -> Self {
        let mut v = self.notification_targets.unwrap_or_default();
        v.push(input);
        self.notification_targets = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    pub fn set_notification_targets(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::NotificationTargetItem>>) -> Self {
        self.notification_targets = input;
        self
    }
    /// <p>The Amazon SNS targets that are notified when updates are made to an incident.</p>
    pub fn get_notification_targets(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::NotificationTargetItem>> {
        &self.notification_targets
    }
    /// Adds a key-value pair to `incident_tags`.
    ///
    /// To override the contents of this collection use [`set_incident_tags`](Self::set_incident_tags).
    ///
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    pub fn incident_tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.incident_tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.incident_tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    pub fn set_incident_tags(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.incident_tags = input;
        self
    }
    /// <p>Tags to assign to the template. When the <code>StartIncident</code> API action is called, Incident Manager assigns the tags specified in the template to the incident.</p>
    pub fn get_incident_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.incident_tags
    }
    /// Consumes the builder and constructs a [`IncidentTemplate`](crate::types::IncidentTemplate).
    /// This method will fail if any of the following fields are not set:
    /// - [`title`](crate::types::builders::IncidentTemplateBuilder::title)
    /// - [`impact`](crate::types::builders::IncidentTemplateBuilder::impact)
    pub fn build(self) -> ::std::result::Result<crate::types::IncidentTemplate, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::IncidentTemplate {
            title: self.title.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "title",
                    "title was not specified but it is required when building IncidentTemplate",
                )
            })?,
            impact: self.impact.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "impact",
                    "impact was not specified but it is required when building IncidentTemplate",
                )
            })?,
            summary: self.summary,
            dedupe_string: self.dedupe_string,
            notification_targets: self.notification_targets,
            incident_tags: self.incident_tags,
        })
    }
}
