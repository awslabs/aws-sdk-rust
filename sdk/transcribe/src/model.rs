// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LanguageCode {
    AfZa,
    ArAe,
    ArSa,
    CyGb,
    DaDk,
    DeCh,
    DeDe,
    EnAb,
    EnAu,
    EnGb,
    EnIe,
    EnIn,
    EnUs,
    EnWl,
    EsEs,
    EsUs,
    FaIr,
    FrCa,
    FrFr,
    GaIe,
    GdGb,
    HeIl,
    HiIn,
    IdId,
    ItIt,
    JaJp,
    KoKr,
    MsMy,
    NlNl,
    PtBr,
    PtPt,
    RuRu,
    TaIn,
    TeIn,
    TrTr,
    ZhCn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "af-ZA" => LanguageCode::AfZa,
            "ar-AE" => LanguageCode::ArAe,
            "ar-SA" => LanguageCode::ArSa,
            "cy-GB" => LanguageCode::CyGb,
            "da-DK" => LanguageCode::DaDk,
            "de-CH" => LanguageCode::DeCh,
            "de-DE" => LanguageCode::DeDe,
            "en-AB" => LanguageCode::EnAb,
            "en-AU" => LanguageCode::EnAu,
            "en-GB" => LanguageCode::EnGb,
            "en-IE" => LanguageCode::EnIe,
            "en-IN" => LanguageCode::EnIn,
            "en-US" => LanguageCode::EnUs,
            "en-WL" => LanguageCode::EnWl,
            "es-ES" => LanguageCode::EsEs,
            "es-US" => LanguageCode::EsUs,
            "fa-IR" => LanguageCode::FaIr,
            "fr-CA" => LanguageCode::FrCa,
            "fr-FR" => LanguageCode::FrFr,
            "ga-IE" => LanguageCode::GaIe,
            "gd-GB" => LanguageCode::GdGb,
            "he-IL" => LanguageCode::HeIl,
            "hi-IN" => LanguageCode::HiIn,
            "id-ID" => LanguageCode::IdId,
            "it-IT" => LanguageCode::ItIt,
            "ja-JP" => LanguageCode::JaJp,
            "ko-KR" => LanguageCode::KoKr,
            "ms-MY" => LanguageCode::MsMy,
            "nl-NL" => LanguageCode::NlNl,
            "pt-BR" => LanguageCode::PtBr,
            "pt-PT" => LanguageCode::PtPt,
            "ru-RU" => LanguageCode::RuRu,
            "ta-IN" => LanguageCode::TaIn,
            "te-IN" => LanguageCode::TeIn,
            "tr-TR" => LanguageCode::TrTr,
            "zh-CN" => LanguageCode::ZhCn,
            other => LanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LanguageCode::from(s))
    }
}
impl LanguageCode {
    pub fn as_str(&self) -> &str {
        match self {
            LanguageCode::AfZa => "af-ZA",
            LanguageCode::ArAe => "ar-AE",
            LanguageCode::ArSa => "ar-SA",
            LanguageCode::CyGb => "cy-GB",
            LanguageCode::DaDk => "da-DK",
            LanguageCode::DeCh => "de-CH",
            LanguageCode::DeDe => "de-DE",
            LanguageCode::EnAb => "en-AB",
            LanguageCode::EnAu => "en-AU",
            LanguageCode::EnGb => "en-GB",
            LanguageCode::EnIe => "en-IE",
            LanguageCode::EnIn => "en-IN",
            LanguageCode::EnUs => "en-US",
            LanguageCode::EnWl => "en-WL",
            LanguageCode::EsEs => "es-ES",
            LanguageCode::EsUs => "es-US",
            LanguageCode::FaIr => "fa-IR",
            LanguageCode::FrCa => "fr-CA",
            LanguageCode::FrFr => "fr-FR",
            LanguageCode::GaIe => "ga-IE",
            LanguageCode::GdGb => "gd-GB",
            LanguageCode::HeIl => "he-IL",
            LanguageCode::HiIn => "hi-IN",
            LanguageCode::IdId => "id-ID",
            LanguageCode::ItIt => "it-IT",
            LanguageCode::JaJp => "ja-JP",
            LanguageCode::KoKr => "ko-KR",
            LanguageCode::MsMy => "ms-MY",
            LanguageCode::NlNl => "nl-NL",
            LanguageCode::PtBr => "pt-BR",
            LanguageCode::PtPt => "pt-PT",
            LanguageCode::RuRu => "ru-RU",
            LanguageCode::TaIn => "ta-IN",
            LanguageCode::TeIn => "te-IN",
            LanguageCode::TrTr => "tr-TR",
            LanguageCode::ZhCn => "zh-CN",
            LanguageCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "af-ZA", "ar-AE", "ar-SA", "cy-GB", "da-DK", "de-CH", "de-DE", "en-AB", "en-AU",
            "en-GB", "en-IE", "en-IN", "en-US", "en-WL", "es-ES", "es-US", "fa-IR", "fr-CA",
            "fr-FR", "ga-IE", "gd-GB", "he-IL", "hi-IN", "id-ID", "it-IT", "ja-JP", "ko-KR",
            "ms-MY", "nl-NL", "pt-BR", "pt-PT", "ru-RU", "ta-IN", "te-IN", "tr-TR", "zh-CN",
        ]
    }
}
impl AsRef<str> for LanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyState {
    Failed,
    Pending,
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VocabularyState {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => VocabularyState::Failed,
            "PENDING" => VocabularyState::Pending,
            "READY" => VocabularyState::Ready,
            other => VocabularyState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VocabularyState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyState::from(s))
    }
}
impl VocabularyState {
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyState::Failed => "FAILED",
            VocabularyState::Pending => "PENDING",
            VocabularyState::Ready => "READY",
            VocabularyState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "READY"]
    }
}
impl AsRef<str> for VocabularyState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an asynchronous transcription job that was created with the
/// <code>StartTranscriptionJob</code> operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TranscriptionJob {
    /// <p>The name of the transcription job.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
    /// <p>The status of the transcription job.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>The language code for the input speech.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The format of the input media file.</p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>An object that describes the input media for the transcription job.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>An object that describes the output of the transcription job.</p>
    pub transcript: std::option::Option<crate::model::Transcript>,
    /// <p>A timestamp that shows with the job was started processing.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<smithy_types::Instant>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field
    /// contains information about why the job failed.</p>
    /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Unsupported media format</code> - The media format specified in the
    /// <code>MediaFormat</code> field of the request isn't valid. See the
    /// description of the <code>MediaFormat</code> field for a list of valid
    /// values.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The media format provided does not match the detected media
    /// format</code> - The media format of the audio file doesn't match the format
    /// specified in the <code>MediaFormat</code> field in the request. Check the media
    /// format of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid sample rate for audio file</code> - The sample rate specified in
    /// the <code>MediaSampleRateHertz</code> of the request isn't valid. The sample
    /// rate must be between 8000 and 48000 Hertz.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The sample rate provided does not match the detected sample rate</code>
    /// - The sample rate in the audio file doesn't match the sample rate specified in
    /// the <code>MediaSampleRateHertz</code> field in the request. Check the sample
    /// rate of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid file size: file size too large</code> - The size of your audio
    /// file is larger than Amazon Transcribe can process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Limits</a> in the <i>Amazon Transcribe Developer Guide</i>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid number of channels: number of channels too large</code> - Your
    /// audio contains more channels than Amazon Transcribe is configured to process. To request
    /// additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits-amazon-transcribe">Amazon Transcribe Limits</a> in the <i>Amazon Web Services
    /// General Reference</i>.</p>
    /// </li>
    /// </ul>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Optional settings for the transcription job. Use these settings to turn on speaker
    /// recognition, to set the maximum number of speakers that should be identified and to
    /// specify a custom vocabulary to use when processing the transcription job.</p>
    pub settings: std::option::Option<crate::model::Settings>,
    /// <p>An object containing the details of your custom language model.</p>
    pub model_settings: std::option::Option<crate::model::ModelSettings>,
    /// <p>Provides information about how a transcription job is executed.</p>
    pub job_execution_settings: std::option::Option<crate::model::JobExecutionSettings>,
    /// <p>An object that describes content redaction settings for the transcription job.</p>
    pub content_redaction: std::option::Option<crate::model::ContentRedaction>,
    /// <p>A value that shows if automatic language identification was enabled for a
    /// transcription job.</p>
    pub identify_language: std::option::Option<bool>,
    /// <p>An object that shows the optional array of languages inputted for transcription jobs
    /// with automatic language identification enabled.</p>
    pub language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
    /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in
    /// the source audio. Larger values indicate that Amazon Transcribe has higher confidence in the
    /// language it identified.</p>
    pub identified_language_score: std::option::Option<f32>,
}
impl std::fmt::Debug for TranscriptionJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TranscriptionJob");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("transcript", &self.transcript);
        formatter.field("start_time", &self.start_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("settings", &self.settings);
        formatter.field("model_settings", &self.model_settings);
        formatter.field("job_execution_settings", &self.job_execution_settings);
        formatter.field("content_redaction", &self.content_redaction);
        formatter.field("identify_language", &self.identify_language);
        formatter.field("language_options", &self.language_options);
        formatter.field("identified_language_score", &self.identified_language_score);
        formatter.finish()
    }
}
/// See [`TranscriptionJob`](crate::model::TranscriptionJob)
pub mod transcription_job {
    /// A builder for [`TranscriptionJob`](crate::model::TranscriptionJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) transcript: std::option::Option<crate::model::Transcript>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::Settings>,
        pub(crate) model_settings: std::option::Option<crate::model::ModelSettings>,
        pub(crate) job_execution_settings: std::option::Option<crate::model::JobExecutionSettings>,
        pub(crate) content_redaction: std::option::Option<crate::model::ContentRedaction>,
        pub(crate) identify_language: std::option::Option<bool>,
        pub(crate) language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        pub(crate) identified_language_score: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The name of the transcription job.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// <p>The status of the transcription job.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>The language code for the input speech.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>An object that describes the input media for the transcription job.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>An object that describes the output of the transcription job.</p>
        pub fn transcript(mut self, input: crate::model::Transcript) -> Self {
            self.transcript = Some(input);
            self
        }
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::Transcript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// <p>A timestamp that shows with the job was started processing.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field
        /// contains information about why the job failed.</p>
        /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code> - The media format specified in the
        /// <code>MediaFormat</code> field of the request isn't valid. See the
        /// description of the <code>MediaFormat</code> field for a list of valid
        /// values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media
        /// format</code> - The media format of the audio file doesn't match the format
        /// specified in the <code>MediaFormat</code> field in the request. Check the media
        /// format of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code> - The sample rate specified in
        /// the <code>MediaSampleRateHertz</code> of the request isn't valid. The sample
        /// rate must be between 8000 and 48000 Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code>
        /// - The sample rate in the audio file doesn't match the sample rate specified in
        /// the <code>MediaSampleRateHertz</code> field in the request. Check the sample
        /// rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code> - The size of your audio
        /// file is larger than Amazon Transcribe can process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Limits</a> in the <i>Amazon Transcribe Developer Guide</i>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code> - Your
        /// audio contains more channels than Amazon Transcribe is configured to process. To request
        /// additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits-amazon-transcribe">Amazon Transcribe Limits</a> in the <i>Amazon Web Services
        /// General Reference</i>.</p>
        /// </li>
        /// </ul>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Optional settings for the transcription job. Use these settings to turn on speaker
        /// recognition, to set the maximum number of speakers that should be identified and to
        /// specify a custom vocabulary to use when processing the transcription job.</p>
        pub fn settings(mut self, input: crate::model::Settings) -> Self {
            self.settings = Some(input);
            self
        }
        pub fn set_settings(mut self, input: std::option::Option<crate::model::Settings>) -> Self {
            self.settings = input;
            self
        }
        /// <p>An object containing the details of your custom language model.</p>
        pub fn model_settings(mut self, input: crate::model::ModelSettings) -> Self {
            self.model_settings = Some(input);
            self
        }
        pub fn set_model_settings(
            mut self,
            input: std::option::Option<crate::model::ModelSettings>,
        ) -> Self {
            self.model_settings = input;
            self
        }
        /// <p>Provides information about how a transcription job is executed.</p>
        pub fn job_execution_settings(mut self, input: crate::model::JobExecutionSettings) -> Self {
            self.job_execution_settings = Some(input);
            self
        }
        pub fn set_job_execution_settings(
            mut self,
            input: std::option::Option<crate::model::JobExecutionSettings>,
        ) -> Self {
            self.job_execution_settings = input;
            self
        }
        /// <p>An object that describes content redaction settings for the transcription job.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.content_redaction = Some(input);
            self
        }
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.content_redaction = input;
            self
        }
        /// <p>A value that shows if automatic language identification was enabled for a
        /// transcription job.</p>
        pub fn identify_language(mut self, input: bool) -> Self {
            self.identify_language = Some(input);
            self
        }
        pub fn set_identify_language(mut self, input: std::option::Option<bool>) -> Self {
            self.identify_language = input;
            self
        }
        pub fn language_options(mut self, input: impl Into<crate::model::LanguageCode>) -> Self {
            let mut v = self.language_options.unwrap_or_default();
            v.push(input.into());
            self.language_options = Some(v);
            self
        }
        pub fn set_language_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.language_options = input;
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in
        /// the source audio. Larger values indicate that Amazon Transcribe has higher confidence in the
        /// language it identified.</p>
        pub fn identified_language_score(mut self, input: f32) -> Self {
            self.identified_language_score = Some(input);
            self
        }
        pub fn set_identified_language_score(mut self, input: std::option::Option<f32>) -> Self {
            self.identified_language_score = input;
            self
        }
        /// Consumes the builder and constructs a [`TranscriptionJob`](crate::model::TranscriptionJob)
        pub fn build(self) -> crate::model::TranscriptionJob {
            crate::model::TranscriptionJob {
                transcription_job_name: self.transcription_job_name,
                transcription_job_status: self.transcription_job_status,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                transcript: self.transcript,
                start_time: self.start_time,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
                failure_reason: self.failure_reason,
                settings: self.settings,
                model_settings: self.model_settings,
                job_execution_settings: self.job_execution_settings,
                content_redaction: self.content_redaction,
                identify_language: self.identify_language,
                language_options: self.language_options,
                identified_language_score: self.identified_language_score,
            }
        }
    }
}
impl TranscriptionJob {
    /// Creates a new builder-style object to manufacture [`TranscriptionJob`](crate::model::TranscriptionJob)
    pub fn builder() -> crate::model::transcription_job::Builder {
        crate::model::transcription_job::Builder::default()
    }
}

/// <p>Settings for content redaction within a transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContentRedaction {
    /// <p>Request parameter that defines the entities to be redacted. The only accepted value is
    /// <code>PII</code>.</p>
    pub redaction_type: std::option::Option<crate::model::RedactionType>,
    /// <p>The output transcript file stored in either the default S3 bucket or in a bucket you
    /// specify.</p>
    /// <p>When you choose <code>redacted</code> Amazon Transcribe outputs only the redacted
    /// transcript.</p>
    /// <p>When you choose <code>redacted_and_unredacted</code> Amazon Transcribe outputs both the redacted
    /// and unredacted transcripts.</p>
    pub redaction_output: std::option::Option<crate::model::RedactionOutput>,
}
impl std::fmt::Debug for ContentRedaction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContentRedaction");
        formatter.field("redaction_type", &self.redaction_type);
        formatter.field("redaction_output", &self.redaction_output);
        formatter.finish()
    }
}
/// See [`ContentRedaction`](crate::model::ContentRedaction)
pub mod content_redaction {
    /// A builder for [`ContentRedaction`](crate::model::ContentRedaction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) redaction_type: std::option::Option<crate::model::RedactionType>,
        pub(crate) redaction_output: std::option::Option<crate::model::RedactionOutput>,
    }
    impl Builder {
        /// <p>Request parameter that defines the entities to be redacted. The only accepted value is
        /// <code>PII</code>.</p>
        pub fn redaction_type(mut self, input: crate::model::RedactionType) -> Self {
            self.redaction_type = Some(input);
            self
        }
        pub fn set_redaction_type(
            mut self,
            input: std::option::Option<crate::model::RedactionType>,
        ) -> Self {
            self.redaction_type = input;
            self
        }
        /// <p>The output transcript file stored in either the default S3 bucket or in a bucket you
        /// specify.</p>
        /// <p>When you choose <code>redacted</code> Amazon Transcribe outputs only the redacted
        /// transcript.</p>
        /// <p>When you choose <code>redacted_and_unredacted</code> Amazon Transcribe outputs both the redacted
        /// and unredacted transcripts.</p>
        pub fn redaction_output(mut self, input: crate::model::RedactionOutput) -> Self {
            self.redaction_output = Some(input);
            self
        }
        pub fn set_redaction_output(
            mut self,
            input: std::option::Option<crate::model::RedactionOutput>,
        ) -> Self {
            self.redaction_output = input;
            self
        }
        /// Consumes the builder and constructs a [`ContentRedaction`](crate::model::ContentRedaction)
        pub fn build(self) -> crate::model::ContentRedaction {
            crate::model::ContentRedaction {
                redaction_type: self.redaction_type,
                redaction_output: self.redaction_output,
            }
        }
    }
}
impl ContentRedaction {
    /// Creates a new builder-style object to manufacture [`ContentRedaction`](crate::model::ContentRedaction)
    pub fn builder() -> crate::model::content_redaction::Builder {
        crate::model::content_redaction::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedactionOutput {
    Redacted,
    RedactedAndUnredacted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedactionOutput {
    fn from(s: &str) -> Self {
        match s {
            "redacted" => RedactionOutput::Redacted,
            "redacted_and_unredacted" => RedactionOutput::RedactedAndUnredacted,
            other => RedactionOutput::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedactionOutput {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedactionOutput::from(s))
    }
}
impl RedactionOutput {
    pub fn as_str(&self) -> &str {
        match self {
            RedactionOutput::Redacted => "redacted",
            RedactionOutput::RedactedAndUnredacted => "redacted_and_unredacted",
            RedactionOutput::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["redacted", "redacted_and_unredacted"]
    }
}
impl AsRef<str> for RedactionOutput {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedactionType {
    Pii,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedactionType {
    fn from(s: &str) -> Self {
        match s {
            "PII" => RedactionType::Pii,
            other => RedactionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedactionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedactionType::from(s))
    }
}
impl RedactionType {
    pub fn as_str(&self) -> &str {
        match self {
            RedactionType::Pii => "PII",
            RedactionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PII"]
    }
}
impl AsRef<str> for RedactionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about when a transcription job should be executed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JobExecutionSettings {
    /// <p>Indicates whether a job should be queued by Amazon Transcribe when the concurrent execution limit
    /// is exceeded. When the <code>AllowDeferredExecution</code> field is true, jobs are queued
    /// and executed when the number of executing jobs falls below the concurrent execution
    /// limit. If the field is false, Amazon Transcribe returns a <code>LimitExceededException</code>
    /// exception.</p>
    /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
    /// <code>DataAccessRoleArn</code> field.</p>
    pub allow_deferred_execution: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of a role that has access to the S3 bucket that
    /// contains the input files. Amazon Transcribe assumes this role to read queued media files. If you
    /// have specified an output S3 bucket for the transcription results, this role should have
    /// access to the output bucket as well.</p>
    /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
    /// <code>DataAccessRoleArn</code> field.</p>
    pub data_access_role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JobExecutionSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JobExecutionSettings");
        formatter.field("allow_deferred_execution", &self.allow_deferred_execution);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.finish()
    }
}
/// See [`JobExecutionSettings`](crate::model::JobExecutionSettings)
pub mod job_execution_settings {
    /// A builder for [`JobExecutionSettings`](crate::model::JobExecutionSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_deferred_execution: std::option::Option<bool>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether a job should be queued by Amazon Transcribe when the concurrent execution limit
        /// is exceeded. When the <code>AllowDeferredExecution</code> field is true, jobs are queued
        /// and executed when the number of executing jobs falls below the concurrent execution
        /// limit. If the field is false, Amazon Transcribe returns a <code>LimitExceededException</code>
        /// exception.</p>
        /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
        /// <code>DataAccessRoleArn</code> field.</p>
        pub fn allow_deferred_execution(mut self, input: bool) -> Self {
            self.allow_deferred_execution = Some(input);
            self
        }
        pub fn set_allow_deferred_execution(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_deferred_execution = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role that has access to the S3 bucket that
        /// contains the input files. Amazon Transcribe assumes this role to read queued media files. If you
        /// have specified an output S3 bucket for the transcription results, this role should have
        /// access to the output bucket as well.</p>
        /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
        /// <code>DataAccessRoleArn</code> field.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`JobExecutionSettings`](crate::model::JobExecutionSettings)
        pub fn build(self) -> crate::model::JobExecutionSettings {
            crate::model::JobExecutionSettings {
                allow_deferred_execution: self.allow_deferred_execution,
                data_access_role_arn: self.data_access_role_arn,
            }
        }
    }
}
impl JobExecutionSettings {
    /// Creates a new builder-style object to manufacture [`JobExecutionSettings`](crate::model::JobExecutionSettings)
    pub fn builder() -> crate::model::job_execution_settings::Builder {
        crate::model::job_execution_settings::Builder::default()
    }
}

/// <p>The object used to call your custom language model to your transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelSettings {
    /// <p>The name of your custom language model.</p>
    pub language_model_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelSettings");
        formatter.field("language_model_name", &self.language_model_name);
        formatter.finish()
    }
}
/// See [`ModelSettings`](crate::model::ModelSettings)
pub mod model_settings {
    /// A builder for [`ModelSettings`](crate::model::ModelSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your custom language model.</p>
        pub fn language_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_model_name = Some(input.into());
            self
        }
        pub fn set_language_model_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelSettings`](crate::model::ModelSettings)
        pub fn build(self) -> crate::model::ModelSettings {
            crate::model::ModelSettings {
                language_model_name: self.language_model_name,
            }
        }
    }
}
impl ModelSettings {
    /// Creates a new builder-style object to manufacture [`ModelSettings`](crate::model::ModelSettings)
    pub fn builder() -> crate::model::model_settings::Builder {
        crate::model::model_settings::Builder::default()
    }
}

/// <p>Provides optional settings for the <code>StartTranscriptionJob</code>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Settings {
    /// <p>The name of a vocabulary to use when processing the transcription job.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>Determines whether the transcription job uses speaker recognition to identify
    /// different speakers in the input audio. Speaker recognition labels individual speakers in
    /// the audio file. If you set the <code>ShowSpeakerLabels</code> field to true, you must
    /// also set the maximum number of speaker labels <code>MaxSpeakerLabels</code>
    /// field.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and
    /// <code>ChannelIdentification</code> in the same request. If you set both, your
    /// request returns a <code>BadRequestException</code>.</p>
    pub show_speaker_labels: std::option::Option<bool>,
    /// <p>The maximum number of speakers to identify in the input audio. If there are more
    /// speakers in the audio than this number, multiple speakers are identified as a single
    /// speaker. If you specify the <code>MaxSpeakerLabels</code> field, you must set the
    /// <code>ShowSpeakerLabels</code> field to true.</p>
    pub max_speaker_labels: std::option::Option<i32>,
    /// <p>Instructs Amazon Transcribe to process each audio channel separately and then merge the
    /// transcription output of each channel into a single transcription. </p>
    /// <p>Amazon Transcribe also produces a transcription of each item detected on an audio channel,
    /// including the start time and end time of the item and alternative transcriptions of the
    /// item including the confidence that Amazon Transcribe has in the transcription.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and
    /// <code>ChannelIdentification</code> in the same request. If you set both, your
    /// request returns a <code>BadRequestException</code>.</p>
    pub channel_identification: std::option::Option<bool>,
    /// <p>Determines whether the transcription contains alternative transcriptions. If you set
    /// the <code>ShowAlternatives</code> field to true, you must also set the maximum number of
    /// alternatives to return in the <code>MaxAlternatives</code> field.</p>
    pub show_alternatives: std::option::Option<bool>,
    /// <p>The number of alternative transcriptions that the service should return. If you
    /// specify the <code>MaxAlternatives</code> field, you must set the
    /// <code>ShowAlternatives</code> field to true.</p>
    pub max_alternatives: std::option::Option<i32>,
    /// <p>The name of the vocabulary filter to use when transcribing the audio. The filter that
    /// you specify must have the same language code as the transcription job.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>Set to <code>mask</code> to remove filtered text from the transcript and replace it
    /// with three asterisks ("***") as placeholder text. Set to <code>remove</code> to remove
    /// filtered text from the transcript without using placeholder text. Set to
    /// <code>tag</code> to mark the word in the transcription output that matches the
    /// vocabulary filter. When you set the filter method to <code>tag</code>, the words
    /// matching your vocabulary filter are not masked or removed.</p>
    pub vocabulary_filter_method: std::option::Option<crate::model::VocabularyFilterMethod>,
}
impl std::fmt::Debug for Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Settings");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("show_speaker_labels", &self.show_speaker_labels);
        formatter.field("max_speaker_labels", &self.max_speaker_labels);
        formatter.field("channel_identification", &self.channel_identification);
        formatter.field("show_alternatives", &self.show_alternatives);
        formatter.field("max_alternatives", &self.max_alternatives);
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("vocabulary_filter_method", &self.vocabulary_filter_method);
        formatter.finish()
    }
}
/// See [`Settings`](crate::model::Settings)
pub mod settings {
    /// A builder for [`Settings`](crate::model::Settings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) show_speaker_labels: std::option::Option<bool>,
        pub(crate) max_speaker_labels: std::option::Option<i32>,
        pub(crate) channel_identification: std::option::Option<bool>,
        pub(crate) show_alternatives: std::option::Option<bool>,
        pub(crate) max_alternatives: std::option::Option<i32>,
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filter_method:
            std::option::Option<crate::model::VocabularyFilterMethod>,
    }
    impl Builder {
        /// <p>The name of a vocabulary to use when processing the transcription job.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>Determines whether the transcription job uses speaker recognition to identify
        /// different speakers in the input audio. Speaker recognition labels individual speakers in
        /// the audio file. If you set the <code>ShowSpeakerLabels</code> field to true, you must
        /// also set the maximum number of speaker labels <code>MaxSpeakerLabels</code>
        /// field.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and
        /// <code>ChannelIdentification</code> in the same request. If you set both, your
        /// request returns a <code>BadRequestException</code>.</p>
        pub fn show_speaker_labels(mut self, input: bool) -> Self {
            self.show_speaker_labels = Some(input);
            self
        }
        pub fn set_show_speaker_labels(mut self, input: std::option::Option<bool>) -> Self {
            self.show_speaker_labels = input;
            self
        }
        /// <p>The maximum number of speakers to identify in the input audio. If there are more
        /// speakers in the audio than this number, multiple speakers are identified as a single
        /// speaker. If you specify the <code>MaxSpeakerLabels</code> field, you must set the
        /// <code>ShowSpeakerLabels</code> field to true.</p>
        pub fn max_speaker_labels(mut self, input: i32) -> Self {
            self.max_speaker_labels = Some(input);
            self
        }
        pub fn set_max_speaker_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.max_speaker_labels = input;
            self
        }
        /// <p>Instructs Amazon Transcribe to process each audio channel separately and then merge the
        /// transcription output of each channel into a single transcription. </p>
        /// <p>Amazon Transcribe also produces a transcription of each item detected on an audio channel,
        /// including the start time and end time of the item and alternative transcriptions of the
        /// item including the confidence that Amazon Transcribe has in the transcription.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and
        /// <code>ChannelIdentification</code> in the same request. If you set both, your
        /// request returns a <code>BadRequestException</code>.</p>
        pub fn channel_identification(mut self, input: bool) -> Self {
            self.channel_identification = Some(input);
            self
        }
        pub fn set_channel_identification(mut self, input: std::option::Option<bool>) -> Self {
            self.channel_identification = input;
            self
        }
        /// <p>Determines whether the transcription contains alternative transcriptions. If you set
        /// the <code>ShowAlternatives</code> field to true, you must also set the maximum number of
        /// alternatives to return in the <code>MaxAlternatives</code> field.</p>
        pub fn show_alternatives(mut self, input: bool) -> Self {
            self.show_alternatives = Some(input);
            self
        }
        pub fn set_show_alternatives(mut self, input: std::option::Option<bool>) -> Self {
            self.show_alternatives = input;
            self
        }
        /// <p>The number of alternative transcriptions that the service should return. If you
        /// specify the <code>MaxAlternatives</code> field, you must set the
        /// <code>ShowAlternatives</code> field to true.</p>
        pub fn max_alternatives(mut self, input: i32) -> Self {
            self.max_alternatives = Some(input);
            self
        }
        pub fn set_max_alternatives(mut self, input: std::option::Option<i32>) -> Self {
            self.max_alternatives = input;
            self
        }
        /// <p>The name of the vocabulary filter to use when transcribing the audio. The filter that
        /// you specify must have the same language code as the transcription job.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>Set to <code>mask</code> to remove filtered text from the transcript and replace it
        /// with three asterisks ("***") as placeholder text. Set to <code>remove</code> to remove
        /// filtered text from the transcript without using placeholder text. Set to
        /// <code>tag</code> to mark the word in the transcription output that matches the
        /// vocabulary filter. When you set the filter method to <code>tag</code>, the words
        /// matching your vocabulary filter are not masked or removed.</p>
        pub fn vocabulary_filter_method(
            mut self,
            input: crate::model::VocabularyFilterMethod,
        ) -> Self {
            self.vocabulary_filter_method = Some(input);
            self
        }
        pub fn set_vocabulary_filter_method(
            mut self,
            input: std::option::Option<crate::model::VocabularyFilterMethod>,
        ) -> Self {
            self.vocabulary_filter_method = input;
            self
        }
        /// Consumes the builder and constructs a [`Settings`](crate::model::Settings)
        pub fn build(self) -> crate::model::Settings {
            crate::model::Settings {
                vocabulary_name: self.vocabulary_name,
                show_speaker_labels: self.show_speaker_labels,
                max_speaker_labels: self.max_speaker_labels,
                channel_identification: self.channel_identification,
                show_alternatives: self.show_alternatives,
                max_alternatives: self.max_alternatives,
                vocabulary_filter_name: self.vocabulary_filter_name,
                vocabulary_filter_method: self.vocabulary_filter_method,
            }
        }
    }
}
impl Settings {
    /// Creates a new builder-style object to manufacture [`Settings`](crate::model::Settings)
    pub fn builder() -> crate::model::settings::Builder {
        crate::model::settings::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyFilterMethod {
    Mask,
    Remove,
    Tag,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VocabularyFilterMethod {
    fn from(s: &str) -> Self {
        match s {
            "mask" => VocabularyFilterMethod::Mask,
            "remove" => VocabularyFilterMethod::Remove,
            "tag" => VocabularyFilterMethod::Tag,
            other => VocabularyFilterMethod::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VocabularyFilterMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyFilterMethod::from(s))
    }
}
impl VocabularyFilterMethod {
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyFilterMethod::Mask => "mask",
            VocabularyFilterMethod::Remove => "remove",
            VocabularyFilterMethod::Tag => "tag",
            VocabularyFilterMethod::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["mask", "remove", "tag"]
    }
}
impl AsRef<str> for VocabularyFilterMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Identifies the location of a transcription.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Transcript {
    /// <p>The S3 object location of the transcript.</p>
    /// <p>Use this URI to access the transcript. If you specified an S3 bucket in the
    /// <code>OutputBucketName</code> field when you created the job, this is the URI of
    /// that bucket. If you chose to store the transcript in Amazon Transcribe, this is a shareable URL that
    /// provides secure access to that location.</p>
    pub transcript_file_uri: std::option::Option<std::string::String>,
    /// <p>The S3 object location of the redacted transcript.</p>
    /// <p>Use this URI to access the redacted transcript. If you specified an S3 bucket in the
    /// <code>OutputBucketName</code> field when you created the job, this is the URI of
    /// that bucket. If you chose to store the transcript in Amazon Transcribe, this is a shareable URL that
    /// provides secure access to that location.</p>
    pub redacted_transcript_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Transcript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Transcript");
        formatter.field("transcript_file_uri", &self.transcript_file_uri);
        formatter.field(
            "redacted_transcript_file_uri",
            &self.redacted_transcript_file_uri,
        );
        formatter.finish()
    }
}
/// See [`Transcript`](crate::model::Transcript)
pub mod transcript {
    /// A builder for [`Transcript`](crate::model::Transcript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript_file_uri: std::option::Option<std::string::String>,
        pub(crate) redacted_transcript_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 object location of the transcript.</p>
        /// <p>Use this URI to access the transcript. If you specified an S3 bucket in the
        /// <code>OutputBucketName</code> field when you created the job, this is the URI of
        /// that bucket. If you chose to store the transcript in Amazon Transcribe, this is a shareable URL that
        /// provides secure access to that location.</p>
        pub fn transcript_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript_file_uri = Some(input.into());
            self
        }
        pub fn set_transcript_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcript_file_uri = input;
            self
        }
        /// <p>The S3 object location of the redacted transcript.</p>
        /// <p>Use this URI to access the redacted transcript. If you specified an S3 bucket in the
        /// <code>OutputBucketName</code> field when you created the job, this is the URI of
        /// that bucket. If you chose to store the transcript in Amazon Transcribe, this is a shareable URL that
        /// provides secure access to that location.</p>
        pub fn redacted_transcript_file_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.redacted_transcript_file_uri = Some(input.into());
            self
        }
        pub fn set_redacted_transcript_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.redacted_transcript_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`Transcript`](crate::model::Transcript)
        pub fn build(self) -> crate::model::Transcript {
            crate::model::Transcript {
                transcript_file_uri: self.transcript_file_uri,
                redacted_transcript_file_uri: self.redacted_transcript_file_uri,
            }
        }
    }
}
impl Transcript {
    /// Creates a new builder-style object to manufacture [`Transcript`](crate::model::Transcript)
    pub fn builder() -> crate::model::transcript::Builder {
        crate::model::transcript::Builder::default()
    }
}

/// <p>Describes the input media file in a transcription request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Media {
    /// <p>The S3 object location of the input media file. The URI must be in the same region as
    /// the API endpoint that you are calling. The general form is:</p>
    /// <p>For example:</p>
    /// <p>For more information about S3 object names, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3 Developer Guide</i>.</p>
    pub media_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Media {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Media");
        formatter.field("media_file_uri", &self.media_file_uri);
        formatter.finish()
    }
}
/// See [`Media`](crate::model::Media)
pub mod media {
    /// A builder for [`Media`](crate::model::Media)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 object location of the input media file. The URI must be in the same region as
        /// the API endpoint that you are calling. The general form is:</p>
        /// <p>For example:</p>
        /// <p>For more information about S3 object names, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        pub fn media_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_file_uri = Some(input.into());
            self
        }
        pub fn set_media_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`Media`](crate::model::Media)
        pub fn build(self) -> crate::model::Media {
            crate::model::Media {
                media_file_uri: self.media_file_uri,
            }
        }
    }
}
impl Media {
    /// Creates a new builder-style object to manufacture [`Media`](crate::model::Media)
    pub fn builder() -> crate::model::media::Builder {
        crate::model::media::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaFormat {
    Amr,
    Flac,
    Mp3,
    Mp4,
    Ogg,
    Wav,
    Webm,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MediaFormat {
    fn from(s: &str) -> Self {
        match s {
            "amr" => MediaFormat::Amr,
            "flac" => MediaFormat::Flac,
            "mp3" => MediaFormat::Mp3,
            "mp4" => MediaFormat::Mp4,
            "ogg" => MediaFormat::Ogg,
            "wav" => MediaFormat::Wav,
            "webm" => MediaFormat::Webm,
            other => MediaFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MediaFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaFormat::from(s))
    }
}
impl MediaFormat {
    pub fn as_str(&self) -> &str {
        match self {
            MediaFormat::Amr => "amr",
            MediaFormat::Flac => "flac",
            MediaFormat::Mp3 => "mp3",
            MediaFormat::Mp4 => "mp4",
            MediaFormat::Ogg => "ogg",
            MediaFormat::Wav => "wav",
            MediaFormat::Webm => "webm",
            MediaFormat::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["amr", "flac", "mp3", "mp4", "ogg", "wav", "webm"]
    }
}
impl AsRef<str> for MediaFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TranscriptionJobStatus {
    Completed,
    Failed,
    InProgress,
    Queued,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TranscriptionJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => TranscriptionJobStatus::Completed,
            "FAILED" => TranscriptionJobStatus::Failed,
            "IN_PROGRESS" => TranscriptionJobStatus::InProgress,
            "QUEUED" => TranscriptionJobStatus::Queued,
            other => TranscriptionJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TranscriptionJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TranscriptionJobStatus::from(s))
    }
}
impl TranscriptionJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TranscriptionJobStatus::Completed => "COMPLETED",
            TranscriptionJobStatus::Failed => "FAILED",
            TranscriptionJobStatus::InProgress => "IN_PROGRESS",
            TranscriptionJobStatus::Queued => "QUEUED",
            TranscriptionJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "IN_PROGRESS", "QUEUED"]
    }
}
impl AsRef<str> for TranscriptionJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data structure that contains the information for a medical transcription
/// job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscriptionJob {
    /// <p>The name for a given medical transcription job.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
    /// <p>The completion status of a medical transcription job.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>The language code for the language spoken in the source audio file. US English (en-US)
    /// is the only supported language for medical transcriptions. Any other value you enter for
    /// language code results in a <code>BadRequestException</code> error.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the source audio containing medical information.</p>
    /// <p>If you don't specify the sample rate, Amazon Transcribe Medical determines it for you. If you choose to
    /// specify the sample rate, it must match the rate detected by Amazon Transcribe Medical. In most cases, you
    /// should leave the <code>MediaSampleHertz</code> blank and let Amazon Transcribe Medical determine the sample
    /// rate.</p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The format of the input media file.</p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>Describes the input media file in a transcription request.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>An object that contains the <code>MedicalTranscript</code>. The
    /// <code>MedicalTranscript</code> contains the <code>TranscriptFileUri</code>.</p>
    pub transcript: std::option::Option<crate::model::MedicalTranscript>,
    /// <p>A timestamp that shows when the job started processing.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<smithy_types::Instant>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field
    /// contains information about why the job failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Unsupported media format</code>- The media format specified in the
    /// <code>MediaFormat</code> field of the request isn't valid. See the
    /// description of the <code>MediaFormat</code> field for a list of valid
    /// values.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The media format provided does not match the detected media
    /// format</code>- The media format of the audio file doesn't match the format
    /// specified in the <code>MediaFormat</code> field in the request. Check the media
    /// format of your media file and make sure the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid sample rate for audio file</code>- The sample rate specified in
    /// the <code>MediaSampleRateHertz</code> of the request isn't valid. The sample
    /// rate must be between 8000 and 48000 Hertz.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The sample rate provided does not match the detected sample rate</code>-
    /// The sample rate in the audio file doesn't match the sample rate specified in the
    /// <code>MediaSampleRateHertz</code> field in the request. Check the sample
    /// rate of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid file size: file size too large</code>- The size of your audio
    /// file is larger than what Amazon Transcribe Medical can process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Guidelines and
    /// Quotas</a> in the <i>Amazon Transcribe Medical Guide</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid number of channels: number of channels too large</code>- Your
    /// audio contains more channels than Amazon Transcribe Medical is configured to process. To request
    /// additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe-medical.html">Amazon Transcribe Medical Endpoints and
    /// Quotas</a> in the <i>Amazon Web Services General
    /// Reference</i>
    /// </p>
    /// </li>
    /// </ul>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Object that contains  object.</p>
    pub settings: std::option::Option<crate::model::MedicalTranscriptionSetting>,
    /// <p>Shows the type of content that you've configured Amazon Transcribe Medical to identify in a transcription
    /// job. If the value is <code>PHI</code>, you've configured the job to identify personal
    /// health information (PHI) in the transcription output.</p>
    pub content_identification_type:
        std::option::Option<crate::model::MedicalContentIdentificationType>,
    /// <p>The medical specialty of any clinicians providing a dictation or having a
    /// conversation. <code>PRIMARYCARE</code> is the only available setting for this object.
    /// This specialty enables you to generate transcriptions for the following medical
    /// fields:</p>
    /// <ul>
    /// <li>
    /// <p>Family Medicine</p>
    /// </li>
    /// </ul>
    pub specialty: std::option::Option<crate::model::Specialty>,
    /// <p>The type of speech in the transcription job. <code>CONVERSATION</code> is generally
    /// used for patient-physician dialogues. <code>DICTATION</code> is the setting for
    /// physicians speaking their notes after seeing a patient. For more information, see <a>how-it-works-med</a>
    /// </p>
    pub r#type: std::option::Option<crate::model::Type>,
}
impl std::fmt::Debug for MedicalTranscriptionJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscriptionJob");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("transcript", &self.transcript);
        formatter.field("start_time", &self.start_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("settings", &self.settings);
        formatter.field(
            "content_identification_type",
            &self.content_identification_type,
        );
        formatter.field("specialty", &self.specialty);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
pub mod medical_transcription_job {
    /// A builder for [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) transcript: std::option::Option<crate::model::MedicalTranscript>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        pub(crate) content_identification_type:
            std::option::Option<crate::model::MedicalContentIdentificationType>,
        pub(crate) specialty: std::option::Option<crate::model::Specialty>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
    }
    impl Builder {
        /// <p>The name for a given medical transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// <p>The completion status of a medical transcription job.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>The language code for the language spoken in the source audio file. US English (en-US)
        /// is the only supported language for medical transcriptions. Any other value you enter for
        /// language code results in a <code>BadRequestException</code> error.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the source audio containing medical information.</p>
        /// <p>If you don't specify the sample rate, Amazon Transcribe Medical determines it for you. If you choose to
        /// specify the sample rate, it must match the rate detected by Amazon Transcribe Medical. In most cases, you
        /// should leave the <code>MediaSampleHertz</code> blank and let Amazon Transcribe Medical determine the sample
        /// rate.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>An object that contains the <code>MedicalTranscript</code>. The
        /// <code>MedicalTranscript</code> contains the <code>TranscriptFileUri</code>.</p>
        pub fn transcript(mut self, input: crate::model::MedicalTranscript) -> Self {
            self.transcript = Some(input);
            self
        }
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field
        /// contains information about why the job failed.</p>
        /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code>- The media format specified in the
        /// <code>MediaFormat</code> field of the request isn't valid. See the
        /// description of the <code>MediaFormat</code> field for a list of valid
        /// values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media
        /// format</code>- The media format of the audio file doesn't match the format
        /// specified in the <code>MediaFormat</code> field in the request. Check the media
        /// format of your media file and make sure the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code>- The sample rate specified in
        /// the <code>MediaSampleRateHertz</code> of the request isn't valid. The sample
        /// rate must be between 8000 and 48000 Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code>-
        /// The sample rate in the audio file doesn't match the sample rate specified in the
        /// <code>MediaSampleRateHertz</code> field in the request. Check the sample
        /// rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code>- The size of your audio
        /// file is larger than what Amazon Transcribe Medical can process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Guidelines and
        /// Quotas</a> in the <i>Amazon Transcribe Medical Guide</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code>- Your
        /// audio contains more channels than Amazon Transcribe Medical is configured to process. To request
        /// additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe-medical.html">Amazon Transcribe Medical Endpoints and
        /// Quotas</a> in the <i>Amazon Web Services General
        /// Reference</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Object that contains  object.</p>
        pub fn settings(mut self, input: crate::model::MedicalTranscriptionSetting) -> Self {
            self.settings = Some(input);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// <p>Shows the type of content that you've configured Amazon Transcribe Medical to identify in a transcription
        /// job. If the value is <code>PHI</code>, you've configured the job to identify personal
        /// health information (PHI) in the transcription output.</p>
        pub fn content_identification_type(
            mut self,
            input: crate::model::MedicalContentIdentificationType,
        ) -> Self {
            self.content_identification_type = Some(input);
            self
        }
        pub fn set_content_identification_type(
            mut self,
            input: std::option::Option<crate::model::MedicalContentIdentificationType>,
        ) -> Self {
            self.content_identification_type = input;
            self
        }
        /// <p>The medical specialty of any clinicians providing a dictation or having a
        /// conversation. <code>PRIMARYCARE</code> is the only available setting for this object.
        /// This specialty enables you to generate transcriptions for the following medical
        /// fields:</p>
        /// <ul>
        /// <li>
        /// <p>Family Medicine</p>
        /// </li>
        /// </ul>
        pub fn specialty(mut self, input: crate::model::Specialty) -> Self {
            self.specialty = Some(input);
            self
        }
        pub fn set_specialty(
            mut self,
            input: std::option::Option<crate::model::Specialty>,
        ) -> Self {
            self.specialty = input;
            self
        }
        /// <p>The type of speech in the transcription job. <code>CONVERSATION</code> is generally
        /// used for patient-physician dialogues. <code>DICTATION</code> is the setting for
        /// physicians speaking their notes after seeing a patient. For more information, see <a>how-it-works-med</a>
        /// </p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
        pub fn build(self) -> crate::model::MedicalTranscriptionJob {
            crate::model::MedicalTranscriptionJob {
                medical_transcription_job_name: self.medical_transcription_job_name,
                transcription_job_status: self.transcription_job_status,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                transcript: self.transcript,
                start_time: self.start_time,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
                failure_reason: self.failure_reason,
                settings: self.settings,
                content_identification_type: self.content_identification_type,
                specialty: self.specialty,
                r#type: self.r#type,
            }
        }
    }
}
impl MedicalTranscriptionJob {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
    pub fn builder() -> crate::model::medical_transcription_job::Builder {
        crate::model::medical_transcription_job::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    Conversation,
    Dictation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "CONVERSATION" => Type::Conversation,
            "DICTATION" => Type::Dictation,
            other => Type::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    pub fn as_str(&self) -> &str {
        match self {
            Type::Conversation => "CONVERSATION",
            Type::Dictation => "DICTATION",
            Type::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CONVERSATION", "DICTATION"]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Specialty {
    Primarycare,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Specialty {
    fn from(s: &str) -> Self {
        match s {
            "PRIMARYCARE" => Specialty::Primarycare,
            other => Specialty::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Specialty {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Specialty::from(s))
    }
}
impl Specialty {
    pub fn as_str(&self) -> &str {
        match self {
            Specialty::Primarycare => "PRIMARYCARE",
            Specialty::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PRIMARYCARE"]
    }
}
impl AsRef<str> for Specialty {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MedicalContentIdentificationType {
    Phi,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MedicalContentIdentificationType {
    fn from(s: &str) -> Self {
        match s {
            "PHI" => MedicalContentIdentificationType::Phi,
            other => MedicalContentIdentificationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MedicalContentIdentificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MedicalContentIdentificationType::from(s))
    }
}
impl MedicalContentIdentificationType {
    pub fn as_str(&self) -> &str {
        match self {
            MedicalContentIdentificationType::Phi => "PHI",
            MedicalContentIdentificationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PHI"]
    }
}
impl AsRef<str> for MedicalContentIdentificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Optional settings for the <a>StartMedicalTranscriptionJob</a>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscriptionSetting {
    /// <p>Determines whether the transcription job uses speaker recognition to identify
    /// different speakers in the input audio. Speaker recognition labels individual speakers in
    /// the audio file. If you set the <code>ShowSpeakerLabels</code> field to true, you must
    /// also set the maximum number of speaker labels in the <code>MaxSpeakerLabels</code>
    /// field.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and
    /// <code>ChannelIdentification</code> in the same request. If you set both, your
    /// request returns a <code>BadRequestException</code>.</p>
    pub show_speaker_labels: std::option::Option<bool>,
    /// <p>The maximum number of speakers to identify in the input audio. If there are more
    /// speakers in the audio than this number, multiple speakers are identified as a single
    /// speaker. If you specify the <code>MaxSpeakerLabels</code> field, you must set the
    /// <code>ShowSpeakerLabels</code> field to true.</p>
    pub max_speaker_labels: std::option::Option<i32>,
    /// <p>Instructs Amazon Transcribe Medical to process each audio channel separately and then merge the
    /// transcription output of each channel into a single transcription.</p>
    /// <p>Amazon Transcribe Medical also produces a transcription of each item detected on an audio channel,
    /// including the start time and end time of the item and alternative transcriptions of
    /// item. The alternative transcriptions also come with confidence scores provided by
    /// Amazon Transcribe Medical.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and
    /// <code>ChannelIdentification</code> in the same request. If you set both, your
    /// request returns a <code>BadRequestException</code>
    /// </p>
    pub channel_identification: std::option::Option<bool>,
    /// <p>Determines whether alternative transcripts are generated along with the transcript
    /// that has the highest confidence. If you set <code>ShowAlternatives</code> field to true,
    /// you must also set the maximum number of alternatives to return in the
    /// <code>MaxAlternatives</code> field.</p>
    pub show_alternatives: std::option::Option<bool>,
    /// <p>The maximum number of alternatives that you tell the service to return. If you specify
    /// the <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code>
    /// field to true.</p>
    pub max_alternatives: std::option::Option<i32>,
    /// <p>The name of the vocabulary to use when processing a medical transcription job.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MedicalTranscriptionSetting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscriptionSetting");
        formatter.field("show_speaker_labels", &self.show_speaker_labels);
        formatter.field("max_speaker_labels", &self.max_speaker_labels);
        formatter.field("channel_identification", &self.channel_identification);
        formatter.field("show_alternatives", &self.show_alternatives);
        formatter.field("max_alternatives", &self.max_alternatives);
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}
/// See [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
pub mod medical_transcription_setting {
    /// A builder for [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) show_speaker_labels: std::option::Option<bool>,
        pub(crate) max_speaker_labels: std::option::Option<i32>,
        pub(crate) channel_identification: std::option::Option<bool>,
        pub(crate) show_alternatives: std::option::Option<bool>,
        pub(crate) max_alternatives: std::option::Option<i32>,
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines whether the transcription job uses speaker recognition to identify
        /// different speakers in the input audio. Speaker recognition labels individual speakers in
        /// the audio file. If you set the <code>ShowSpeakerLabels</code> field to true, you must
        /// also set the maximum number of speaker labels in the <code>MaxSpeakerLabels</code>
        /// field.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and
        /// <code>ChannelIdentification</code> in the same request. If you set both, your
        /// request returns a <code>BadRequestException</code>.</p>
        pub fn show_speaker_labels(mut self, input: bool) -> Self {
            self.show_speaker_labels = Some(input);
            self
        }
        pub fn set_show_speaker_labels(mut self, input: std::option::Option<bool>) -> Self {
            self.show_speaker_labels = input;
            self
        }
        /// <p>The maximum number of speakers to identify in the input audio. If there are more
        /// speakers in the audio than this number, multiple speakers are identified as a single
        /// speaker. If you specify the <code>MaxSpeakerLabels</code> field, you must set the
        /// <code>ShowSpeakerLabels</code> field to true.</p>
        pub fn max_speaker_labels(mut self, input: i32) -> Self {
            self.max_speaker_labels = Some(input);
            self
        }
        pub fn set_max_speaker_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.max_speaker_labels = input;
            self
        }
        /// <p>Instructs Amazon Transcribe Medical to process each audio channel separately and then merge the
        /// transcription output of each channel into a single transcription.</p>
        /// <p>Amazon Transcribe Medical also produces a transcription of each item detected on an audio channel,
        /// including the start time and end time of the item and alternative transcriptions of
        /// item. The alternative transcriptions also come with confidence scores provided by
        /// Amazon Transcribe Medical.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and
        /// <code>ChannelIdentification</code> in the same request. If you set both, your
        /// request returns a <code>BadRequestException</code>
        /// </p>
        pub fn channel_identification(mut self, input: bool) -> Self {
            self.channel_identification = Some(input);
            self
        }
        pub fn set_channel_identification(mut self, input: std::option::Option<bool>) -> Self {
            self.channel_identification = input;
            self
        }
        /// <p>Determines whether alternative transcripts are generated along with the transcript
        /// that has the highest confidence. If you set <code>ShowAlternatives</code> field to true,
        /// you must also set the maximum number of alternatives to return in the
        /// <code>MaxAlternatives</code> field.</p>
        pub fn show_alternatives(mut self, input: bool) -> Self {
            self.show_alternatives = Some(input);
            self
        }
        pub fn set_show_alternatives(mut self, input: std::option::Option<bool>) -> Self {
            self.show_alternatives = input;
            self
        }
        /// <p>The maximum number of alternatives that you tell the service to return. If you specify
        /// the <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code>
        /// field to true.</p>
        pub fn max_alternatives(mut self, input: i32) -> Self {
            self.max_alternatives = Some(input);
            self
        }
        pub fn set_max_alternatives(mut self, input: std::option::Option<i32>) -> Self {
            self.max_alternatives = input;
            self
        }
        /// <p>The name of the vocabulary to use when processing a medical transcription job.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
        pub fn build(self) -> crate::model::MedicalTranscriptionSetting {
            crate::model::MedicalTranscriptionSetting {
                show_speaker_labels: self.show_speaker_labels,
                max_speaker_labels: self.max_speaker_labels,
                channel_identification: self.channel_identification,
                show_alternatives: self.show_alternatives,
                max_alternatives: self.max_alternatives,
                vocabulary_name: self.vocabulary_name,
            }
        }
    }
}
impl MedicalTranscriptionSetting {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
    pub fn builder() -> crate::model::medical_transcription_setting::Builder {
        crate::model::medical_transcription_setting::Builder::default()
    }
}

/// <p>Identifies the location of a medical transcript.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscript {
    /// <p>The S3 object location of the medical transcript.</p>
    /// <p>Use this URI to access the medical transcript. This URI points to the S3 bucket you
    /// created to store the medical transcript.</p>
    pub transcript_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MedicalTranscript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscript");
        formatter.field("transcript_file_uri", &self.transcript_file_uri);
        formatter.finish()
    }
}
/// See [`MedicalTranscript`](crate::model::MedicalTranscript)
pub mod medical_transcript {
    /// A builder for [`MedicalTranscript`](crate::model::MedicalTranscript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 object location of the medical transcript.</p>
        /// <p>Use this URI to access the medical transcript. This URI points to the S3 bucket you
        /// created to store the medical transcript.</p>
        pub fn transcript_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript_file_uri = Some(input.into());
            self
        }
        pub fn set_transcript_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcript_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscript`](crate::model::MedicalTranscript)
        pub fn build(self) -> crate::model::MedicalTranscript {
            crate::model::MedicalTranscript {
                transcript_file_uri: self.transcript_file_uri,
            }
        }
    }
}
impl MedicalTranscript {
    /// Creates a new builder-style object to manufacture [`MedicalTranscript`](crate::model::MedicalTranscript)
    pub fn builder() -> crate::model::medical_transcript::Builder {
        crate::model::medical_transcript::Builder::default()
    }
}

/// <p>Provides information about a vocabulary filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VocabularyFilterInfo {
    /// <p>The name of the vocabulary filter. The name must be unique in the account that holds
    /// the filter.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The language code of the words in the vocabulary filter.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary was last updated.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for VocabularyFilterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VocabularyFilterInfo");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
pub mod vocabulary_filter_info {
    /// A builder for [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter. The name must be unique in the account that holds
        /// the filter.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary was last updated.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
        pub fn build(self) -> crate::model::VocabularyFilterInfo {
            crate::model::VocabularyFilterInfo {
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl VocabularyFilterInfo {
    /// Creates a new builder-style object to manufacture [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
    pub fn builder() -> crate::model::vocabulary_filter_info::Builder {
        crate::model::vocabulary_filter_info::Builder::default()
    }
}

/// <p>Provides information about a custom vocabulary. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VocabularyInfo {
    /// <p>The name of the vocabulary.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The processing state of the vocabulary. If the state is <code>READY</code> you can use
    /// the vocabulary in a <code>StartTranscriptionJob</code> request.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
}
impl std::fmt::Debug for VocabularyInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VocabularyInfo");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.finish()
    }
}
/// See [`VocabularyInfo`](crate::model::VocabularyInfo)
pub mod vocabulary_info {
    /// A builder for [`VocabularyInfo`](crate::model::VocabularyInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    }
    impl Builder {
        /// <p>The name of the vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The processing state of the vocabulary. If the state is <code>READY</code> you can use
        /// the vocabulary in a <code>StartTranscriptionJob</code> request.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// Consumes the builder and constructs a [`VocabularyInfo`](crate::model::VocabularyInfo)
        pub fn build(self) -> crate::model::VocabularyInfo {
            crate::model::VocabularyInfo {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
                vocabulary_state: self.vocabulary_state,
            }
        }
    }
}
impl VocabularyInfo {
    /// Creates a new builder-style object to manufacture [`VocabularyInfo`](crate::model::VocabularyInfo)
    pub fn builder() -> crate::model::vocabulary_info::Builder {
        crate::model::vocabulary_info::Builder::default()
    }
}

/// <p>Provides a summary of information about a transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TranscriptionJobSummary {
    /// <p>The name of the transcription job.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job started processing.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<smithy_types::Instant>,
    /// <p>The language code for the input speech.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The status of the transcription job. When the status is <code>COMPLETED</code>, use
    /// the <code>GetTranscriptionJob</code> operation to get the results of the
    /// transcription.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description
    /// of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Indicates the location of the output of the transcription job.</p>
    /// <p>If the value is <code>CUSTOMER_BUCKET</code> then the location is the S3 bucket
    /// specified in the <code>outputBucketName</code> field when the transcription job was
    /// started with the <code>StartTranscriptionJob</code> operation.</p>
    /// <p>If the value is <code>SERVICE_BUCKET</code> then the output is stored by Amazon Transcribe and can
    /// be retrieved using the URI in the <code>GetTranscriptionJob</code> response's
    /// <code>TranscriptFileUri</code> field.</p>
    pub output_location_type: std::option::Option<crate::model::OutputLocationType>,
    /// <p>The content redaction settings of the transcription job.</p>
    pub content_redaction: std::option::Option<crate::model::ContentRedaction>,
    /// <p>The object used to call your custom language model to your transcription job.</p>
    pub model_settings: std::option::Option<crate::model::ModelSettings>,
    /// <p>Whether automatic language identification was enabled for a transcription job.</p>
    pub identify_language: std::option::Option<bool>,
    /// <p>A value between zero and one that Amazon Transcribe assigned to the language it identified in the
    /// source audio. A higher score indicates that Amazon Transcribe is more confident in the language it
    /// identified.</p>
    pub identified_language_score: std::option::Option<f32>,
}
impl std::fmt::Debug for TranscriptionJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TranscriptionJobSummary");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("output_location_type", &self.output_location_type);
        formatter.field("content_redaction", &self.content_redaction);
        formatter.field("model_settings", &self.model_settings);
        formatter.field("identify_language", &self.identify_language);
        formatter.field("identified_language_score", &self.identified_language_score);
        formatter.finish()
    }
}
/// See [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
pub mod transcription_job_summary {
    /// A builder for [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) output_location_type: std::option::Option<crate::model::OutputLocationType>,
        pub(crate) content_redaction: std::option::Option<crate::model::ContentRedaction>,
        pub(crate) model_settings: std::option::Option<crate::model::ModelSettings>,
        pub(crate) identify_language: std::option::Option<bool>,
        pub(crate) identified_language_score: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The name of the transcription job.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The language code for the input speech.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The status of the transcription job. When the status is <code>COMPLETED</code>, use
        /// the <code>GetTranscriptionJob</code> operation to get the results of the
        /// transcription.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description
        /// of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Indicates the location of the output of the transcription job.</p>
        /// <p>If the value is <code>CUSTOMER_BUCKET</code> then the location is the S3 bucket
        /// specified in the <code>outputBucketName</code> field when the transcription job was
        /// started with the <code>StartTranscriptionJob</code> operation.</p>
        /// <p>If the value is <code>SERVICE_BUCKET</code> then the output is stored by Amazon Transcribe and can
        /// be retrieved using the URI in the <code>GetTranscriptionJob</code> response's
        /// <code>TranscriptFileUri</code> field.</p>
        pub fn output_location_type(mut self, input: crate::model::OutputLocationType) -> Self {
            self.output_location_type = Some(input);
            self
        }
        pub fn set_output_location_type(
            mut self,
            input: std::option::Option<crate::model::OutputLocationType>,
        ) -> Self {
            self.output_location_type = input;
            self
        }
        /// <p>The content redaction settings of the transcription job.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.content_redaction = Some(input);
            self
        }
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.content_redaction = input;
            self
        }
        /// <p>The object used to call your custom language model to your transcription job.</p>
        pub fn model_settings(mut self, input: crate::model::ModelSettings) -> Self {
            self.model_settings = Some(input);
            self
        }
        pub fn set_model_settings(
            mut self,
            input: std::option::Option<crate::model::ModelSettings>,
        ) -> Self {
            self.model_settings = input;
            self
        }
        /// <p>Whether automatic language identification was enabled for a transcription job.</p>
        pub fn identify_language(mut self, input: bool) -> Self {
            self.identify_language = Some(input);
            self
        }
        pub fn set_identify_language(mut self, input: std::option::Option<bool>) -> Self {
            self.identify_language = input;
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language it identified in the
        /// source audio. A higher score indicates that Amazon Transcribe is more confident in the language it
        /// identified.</p>
        pub fn identified_language_score(mut self, input: f32) -> Self {
            self.identified_language_score = Some(input);
            self
        }
        pub fn set_identified_language_score(mut self, input: std::option::Option<f32>) -> Self {
            self.identified_language_score = input;
            self
        }
        /// Consumes the builder and constructs a [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
        pub fn build(self) -> crate::model::TranscriptionJobSummary {
            crate::model::TranscriptionJobSummary {
                transcription_job_name: self.transcription_job_name,
                creation_time: self.creation_time,
                start_time: self.start_time,
                completion_time: self.completion_time,
                language_code: self.language_code,
                transcription_job_status: self.transcription_job_status,
                failure_reason: self.failure_reason,
                output_location_type: self.output_location_type,
                content_redaction: self.content_redaction,
                model_settings: self.model_settings,
                identify_language: self.identify_language,
                identified_language_score: self.identified_language_score,
            }
        }
    }
}
impl TranscriptionJobSummary {
    /// Creates a new builder-style object to manufacture [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
    pub fn builder() -> crate::model::transcription_job_summary::Builder {
        crate::model::transcription_job_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutputLocationType {
    CustomerBucket,
    ServiceBucket,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OutputLocationType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_BUCKET" => OutputLocationType::CustomerBucket,
            "SERVICE_BUCKET" => OutputLocationType::ServiceBucket,
            other => OutputLocationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OutputLocationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutputLocationType::from(s))
    }
}
impl OutputLocationType {
    pub fn as_str(&self) -> &str {
        match self {
            OutputLocationType::CustomerBucket => "CUSTOMER_BUCKET",
            OutputLocationType::ServiceBucket => "SERVICE_BUCKET",
            OutputLocationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CUSTOMER_BUCKET", "SERVICE_BUCKET"]
    }
}
impl AsRef<str> for OutputLocationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscriptionJobSummary {
    /// <p>The name of a medical transcription job.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the medical transcription job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job began processing.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<smithy_types::Instant>,
    /// <p>The language of the transcript in the source audio file.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The status of the medical transcription job.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description
    /// of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Indicates the location of the transcription job's output.</p>
    /// <p>The <code>CUSTOMER_BUCKET</code> is the S3 location provided in the
    /// <code>OutputBucketName</code> field when the </p>
    pub output_location_type: std::option::Option<crate::model::OutputLocationType>,
    /// <p>The medical specialty of the transcription job. <code>Primary care</code> is the only
    /// valid value.</p>
    pub specialty: std::option::Option<crate::model::Specialty>,
    /// <p>Shows the type of information you've configured Amazon Transcribe Medical to identify in a transcription
    /// job. If the value is <code>PHI</code>, you've configured the transcription job to identify
    /// personal health information (PHI).</p>
    pub content_identification_type:
        std::option::Option<crate::model::MedicalContentIdentificationType>,
    /// <p>The speech of the clinician in the input audio.</p>
    pub r#type: std::option::Option<crate::model::Type>,
}
impl std::fmt::Debug for MedicalTranscriptionJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscriptionJobSummary");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("output_location_type", &self.output_location_type);
        formatter.field("specialty", &self.specialty);
        formatter.field(
            "content_identification_type",
            &self.content_identification_type,
        );
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
pub mod medical_transcription_job_summary {
    /// A builder for [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) output_location_type: std::option::Option<crate::model::OutputLocationType>,
        pub(crate) specialty: std::option::Option<crate::model::Specialty>,
        pub(crate) content_identification_type:
            std::option::Option<crate::model::MedicalContentIdentificationType>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
    }
    impl Builder {
        /// <p>The name of a medical transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// <p>A timestamp that shows when the medical transcription job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job began processing.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The language of the transcript in the source audio file.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The status of the medical transcription job.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description
        /// of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Indicates the location of the transcription job's output.</p>
        /// <p>The <code>CUSTOMER_BUCKET</code> is the S3 location provided in the
        /// <code>OutputBucketName</code> field when the </p>
        pub fn output_location_type(mut self, input: crate::model::OutputLocationType) -> Self {
            self.output_location_type = Some(input);
            self
        }
        pub fn set_output_location_type(
            mut self,
            input: std::option::Option<crate::model::OutputLocationType>,
        ) -> Self {
            self.output_location_type = input;
            self
        }
        /// <p>The medical specialty of the transcription job. <code>Primary care</code> is the only
        /// valid value.</p>
        pub fn specialty(mut self, input: crate::model::Specialty) -> Self {
            self.specialty = Some(input);
            self
        }
        pub fn set_specialty(
            mut self,
            input: std::option::Option<crate::model::Specialty>,
        ) -> Self {
            self.specialty = input;
            self
        }
        /// <p>Shows the type of information you've configured Amazon Transcribe Medical to identify in a transcription
        /// job. If the value is <code>PHI</code>, you've configured the transcription job to identify
        /// personal health information (PHI).</p>
        pub fn content_identification_type(
            mut self,
            input: crate::model::MedicalContentIdentificationType,
        ) -> Self {
            self.content_identification_type = Some(input);
            self
        }
        pub fn set_content_identification_type(
            mut self,
            input: std::option::Option<crate::model::MedicalContentIdentificationType>,
        ) -> Self {
            self.content_identification_type = input;
            self
        }
        /// <p>The speech of the clinician in the input audio.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
        pub fn build(self) -> crate::model::MedicalTranscriptionJobSummary {
            crate::model::MedicalTranscriptionJobSummary {
                medical_transcription_job_name: self.medical_transcription_job_name,
                creation_time: self.creation_time,
                start_time: self.start_time,
                completion_time: self.completion_time,
                language_code: self.language_code,
                transcription_job_status: self.transcription_job_status,
                failure_reason: self.failure_reason,
                output_location_type: self.output_location_type,
                specialty: self.specialty,
                content_identification_type: self.content_identification_type,
                r#type: self.r#type,
            }
        }
    }
}
impl MedicalTranscriptionJobSummary {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
    pub fn builder() -> crate::model::medical_transcription_job_summary::Builder {
        crate::model::medical_transcription_job_summary::Builder::default()
    }
}

/// <p>The structure used to describe a custom language model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LanguageModel {
    /// <p>The name of the custom language model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The time the custom language model was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The most recent time the custom language model was modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The language code you used to create your custom language model.</p>
    pub language_code: std::option::Option<crate::model::ClmLanguageCode>,
    /// <p>The Amazon Transcribe standard language model, or base model used to create the custom language
    /// model.</p>
    pub base_model_name: std::option::Option<crate::model::BaseModelName>,
    /// <p>The creation status of a custom language model. When the status is
    /// <code>COMPLETED</code> the model is ready for use.</p>
    pub model_status: std::option::Option<crate::model::ModelStatus>,
    /// <p>Whether the base model used for the custom language model is up to date. If this field
    /// is <code>true</code> then you are running the most up-to-date version of the base model
    /// in your custom language model.</p>
    pub upgrade_availability: std::option::Option<bool>,
    /// <p>The reason why the custom language model couldn't be created.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The data access role and Amazon S3 prefixes for the input files used to train the custom
    /// language model.</p>
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
}
impl std::fmt::Debug for LanguageModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LanguageModel");
        formatter.field("model_name", &self.model_name);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("base_model_name", &self.base_model_name);
        formatter.field("model_status", &self.model_status);
        formatter.field("upgrade_availability", &self.upgrade_availability);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.finish()
    }
}
/// See [`LanguageModel`](crate::model::LanguageModel)
pub mod language_model {
    /// A builder for [`LanguageModel`](crate::model::LanguageModel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::ClmLanguageCode>,
        pub(crate) base_model_name: std::option::Option<crate::model::BaseModelName>,
        pub(crate) model_status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) upgrade_availability: std::option::Option<bool>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
    }
    impl Builder {
        /// <p>The name of the custom language model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The time the custom language model was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The most recent time the custom language model was modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The language code you used to create your custom language model.</p>
        pub fn language_code(mut self, input: crate::model::ClmLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::ClmLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model used to create the custom language
        /// model.</p>
        pub fn base_model_name(mut self, input: crate::model::BaseModelName) -> Self {
            self.base_model_name = Some(input);
            self
        }
        pub fn set_base_model_name(
            mut self,
            input: std::option::Option<crate::model::BaseModelName>,
        ) -> Self {
            self.base_model_name = input;
            self
        }
        /// <p>The creation status of a custom language model. When the status is
        /// <code>COMPLETED</code> the model is ready for use.</p>
        pub fn model_status(mut self, input: crate::model::ModelStatus) -> Self {
            self.model_status = Some(input);
            self
        }
        pub fn set_model_status(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.model_status = input;
            self
        }
        /// <p>Whether the base model used for the custom language model is up to date. If this field
        /// is <code>true</code> then you are running the most up-to-date version of the base model
        /// in your custom language model.</p>
        pub fn upgrade_availability(mut self, input: bool) -> Self {
            self.upgrade_availability = Some(input);
            self
        }
        pub fn set_upgrade_availability(mut self, input: std::option::Option<bool>) -> Self {
            self.upgrade_availability = input;
            self
        }
        /// <p>The reason why the custom language model couldn't be created.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The data access role and Amazon S3 prefixes for the input files used to train the custom
        /// language model.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LanguageModel`](crate::model::LanguageModel)
        pub fn build(self) -> crate::model::LanguageModel {
            crate::model::LanguageModel {
                model_name: self.model_name,
                create_time: self.create_time,
                last_modified_time: self.last_modified_time,
                language_code: self.language_code,
                base_model_name: self.base_model_name,
                model_status: self.model_status,
                upgrade_availability: self.upgrade_availability,
                failure_reason: self.failure_reason,
                input_data_config: self.input_data_config,
            }
        }
    }
}
impl LanguageModel {
    /// Creates a new builder-style object to manufacture [`LanguageModel`](crate::model::LanguageModel)
    pub fn builder() -> crate::model::language_model::Builder {
        crate::model::language_model::Builder::default()
    }
}

/// <p>The object that contains the Amazon S3 object location and access role required to train
/// and tune your custom language model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputDataConfig {
    /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to train your
    /// custom language model.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to tune your
    /// custom language model.</p>
    pub tuning_data_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the permissions you've given
    /// Amazon Transcribe to access your Amazon S3 buckets containing your media files or text data.</p>
    pub data_access_role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InputDataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputDataConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("tuning_data_s3_uri", &self.tuning_data_s3_uri);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.finish()
    }
}
/// See [`InputDataConfig`](crate::model::InputDataConfig)
pub mod input_data_config {
    /// A builder for [`InputDataConfig`](crate::model::InputDataConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) tuning_data_s3_uri: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to train your
        /// custom language model.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to tune your
        /// custom language model.</p>
        pub fn tuning_data_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.tuning_data_s3_uri = Some(input.into());
            self
        }
        pub fn set_tuning_data_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tuning_data_s3_uri = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the permissions you've given
        /// Amazon Transcribe to access your Amazon S3 buckets containing your media files or text data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`InputDataConfig`](crate::model::InputDataConfig)
        pub fn build(self) -> crate::model::InputDataConfig {
            crate::model::InputDataConfig {
                s3_uri: self.s3_uri,
                tuning_data_s3_uri: self.tuning_data_s3_uri,
                data_access_role_arn: self.data_access_role_arn,
            }
        }
    }
}
impl InputDataConfig {
    /// Creates a new builder-style object to manufacture [`InputDataConfig`](crate::model::InputDataConfig)
    pub fn builder() -> crate::model::input_data_config::Builder {
        crate::model::input_data_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelStatus {
    Completed,
    Failed,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => ModelStatus::Completed,
            "FAILED" => ModelStatus::Failed,
            "IN_PROGRESS" => ModelStatus::InProgress,
            other => ModelStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelStatus::from(s))
    }
}
impl ModelStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ModelStatus::Completed => "COMPLETED",
            ModelStatus::Failed => "FAILED",
            ModelStatus::InProgress => "IN_PROGRESS",
            ModelStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "IN_PROGRESS"]
    }
}
impl AsRef<str> for ModelStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BaseModelName {
    NarrowBand,
    WideBand,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BaseModelName {
    fn from(s: &str) -> Self {
        match s {
            "NarrowBand" => BaseModelName::NarrowBand,
            "WideBand" => BaseModelName::WideBand,
            other => BaseModelName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BaseModelName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BaseModelName::from(s))
    }
}
impl BaseModelName {
    pub fn as_str(&self) -> &str {
        match self {
            BaseModelName::NarrowBand => "NarrowBand",
            BaseModelName::WideBand => "WideBand",
            BaseModelName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["NarrowBand", "WideBand"]
    }
}
impl AsRef<str> for BaseModelName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClmLanguageCode {
    EnAu,
    EnGb,
    EnUs,
    EsUs,
    HiIn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClmLanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "en-AU" => ClmLanguageCode::EnAu,
            "en-GB" => ClmLanguageCode::EnGb,
            "en-US" => ClmLanguageCode::EnUs,
            "es-US" => ClmLanguageCode::EsUs,
            "hi-IN" => ClmLanguageCode::HiIn,
            other => ClmLanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClmLanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClmLanguageCode::from(s))
    }
}
impl ClmLanguageCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClmLanguageCode::EnAu => "en-AU",
            ClmLanguageCode::EnGb => "en-GB",
            ClmLanguageCode::EnUs => "en-US",
            ClmLanguageCode::EsUs => "es-US",
            ClmLanguageCode::HiIn => "hi-IN",
            ClmLanguageCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["en-AU", "en-GB", "en-US", "es-US", "hi-IN"]
    }
}
impl AsRef<str> for ClmLanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
