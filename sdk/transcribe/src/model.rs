// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    AfZa,
    #[allow(missing_docs)] // documentation missing in model
    ArAe,
    #[allow(missing_docs)] // documentation missing in model
    ArSa,
    #[allow(missing_docs)] // documentation missing in model
    CyGb,
    #[allow(missing_docs)] // documentation missing in model
    DaDk,
    #[allow(missing_docs)] // documentation missing in model
    DeCh,
    #[allow(missing_docs)] // documentation missing in model
    DeDe,
    #[allow(missing_docs)] // documentation missing in model
    EnAb,
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnIe,
    #[allow(missing_docs)] // documentation missing in model
    EnIn,
    #[allow(missing_docs)] // documentation missing in model
    EnNz,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EnWl,
    #[allow(missing_docs)] // documentation missing in model
    EnZa,
    #[allow(missing_docs)] // documentation missing in model
    EsEs,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    FaIr,
    #[allow(missing_docs)] // documentation missing in model
    FrCa,
    #[allow(missing_docs)] // documentation missing in model
    FrFr,
    #[allow(missing_docs)] // documentation missing in model
    GaIe,
    #[allow(missing_docs)] // documentation missing in model
    GdGb,
    #[allow(missing_docs)] // documentation missing in model
    HeIl,
    #[allow(missing_docs)] // documentation missing in model
    HiIn,
    #[allow(missing_docs)] // documentation missing in model
    IdId,
    #[allow(missing_docs)] // documentation missing in model
    ItIt,
    #[allow(missing_docs)] // documentation missing in model
    JaJp,
    #[allow(missing_docs)] // documentation missing in model
    KoKr,
    #[allow(missing_docs)] // documentation missing in model
    MsMy,
    #[allow(missing_docs)] // documentation missing in model
    NlNl,
    #[allow(missing_docs)] // documentation missing in model
    PtBr,
    #[allow(missing_docs)] // documentation missing in model
    PtPt,
    #[allow(missing_docs)] // documentation missing in model
    RuRu,
    #[allow(missing_docs)] // documentation missing in model
    TaIn,
    #[allow(missing_docs)] // documentation missing in model
    TeIn,
    #[allow(missing_docs)] // documentation missing in model
    ThTh,
    #[allow(missing_docs)] // documentation missing in model
    TrTr,
    #[allow(missing_docs)] // documentation missing in model
    ZhCn,
    #[allow(missing_docs)] // documentation missing in model
    ZhTw,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "af-ZA" => LanguageCode::AfZa,
            "ar-AE" => LanguageCode::ArAe,
            "ar-SA" => LanguageCode::ArSa,
            "cy-GB" => LanguageCode::CyGb,
            "da-DK" => LanguageCode::DaDk,
            "de-CH" => LanguageCode::DeCh,
            "de-DE" => LanguageCode::DeDe,
            "en-AB" => LanguageCode::EnAb,
            "en-AU" => LanguageCode::EnAu,
            "en-GB" => LanguageCode::EnGb,
            "en-IE" => LanguageCode::EnIe,
            "en-IN" => LanguageCode::EnIn,
            "en-NZ" => LanguageCode::EnNz,
            "en-US" => LanguageCode::EnUs,
            "en-WL" => LanguageCode::EnWl,
            "en-ZA" => LanguageCode::EnZa,
            "es-ES" => LanguageCode::EsEs,
            "es-US" => LanguageCode::EsUs,
            "fa-IR" => LanguageCode::FaIr,
            "fr-CA" => LanguageCode::FrCa,
            "fr-FR" => LanguageCode::FrFr,
            "ga-IE" => LanguageCode::GaIe,
            "gd-GB" => LanguageCode::GdGb,
            "he-IL" => LanguageCode::HeIl,
            "hi-IN" => LanguageCode::HiIn,
            "id-ID" => LanguageCode::IdId,
            "it-IT" => LanguageCode::ItIt,
            "ja-JP" => LanguageCode::JaJp,
            "ko-KR" => LanguageCode::KoKr,
            "ms-MY" => LanguageCode::MsMy,
            "nl-NL" => LanguageCode::NlNl,
            "pt-BR" => LanguageCode::PtBr,
            "pt-PT" => LanguageCode::PtPt,
            "ru-RU" => LanguageCode::RuRu,
            "ta-IN" => LanguageCode::TaIn,
            "te-IN" => LanguageCode::TeIn,
            "th-TH" => LanguageCode::ThTh,
            "tr-TR" => LanguageCode::TrTr,
            "zh-CN" => LanguageCode::ZhCn,
            "zh-TW" => LanguageCode::ZhTw,
            other => LanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LanguageCode::from(s))
    }
}
impl LanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LanguageCode::AfZa => "af-ZA",
            LanguageCode::ArAe => "ar-AE",
            LanguageCode::ArSa => "ar-SA",
            LanguageCode::CyGb => "cy-GB",
            LanguageCode::DaDk => "da-DK",
            LanguageCode::DeCh => "de-CH",
            LanguageCode::DeDe => "de-DE",
            LanguageCode::EnAb => "en-AB",
            LanguageCode::EnAu => "en-AU",
            LanguageCode::EnGb => "en-GB",
            LanguageCode::EnIe => "en-IE",
            LanguageCode::EnIn => "en-IN",
            LanguageCode::EnNz => "en-NZ",
            LanguageCode::EnUs => "en-US",
            LanguageCode::EnWl => "en-WL",
            LanguageCode::EnZa => "en-ZA",
            LanguageCode::EsEs => "es-ES",
            LanguageCode::EsUs => "es-US",
            LanguageCode::FaIr => "fa-IR",
            LanguageCode::FrCa => "fr-CA",
            LanguageCode::FrFr => "fr-FR",
            LanguageCode::GaIe => "ga-IE",
            LanguageCode::GdGb => "gd-GB",
            LanguageCode::HeIl => "he-IL",
            LanguageCode::HiIn => "hi-IN",
            LanguageCode::IdId => "id-ID",
            LanguageCode::ItIt => "it-IT",
            LanguageCode::JaJp => "ja-JP",
            LanguageCode::KoKr => "ko-KR",
            LanguageCode::MsMy => "ms-MY",
            LanguageCode::NlNl => "nl-NL",
            LanguageCode::PtBr => "pt-BR",
            LanguageCode::PtPt => "pt-PT",
            LanguageCode::RuRu => "ru-RU",
            LanguageCode::TaIn => "ta-IN",
            LanguageCode::TeIn => "te-IN",
            LanguageCode::ThTh => "th-TH",
            LanguageCode::TrTr => "tr-TR",
            LanguageCode::ZhCn => "zh-CN",
            LanguageCode::ZhTw => "zh-TW",
            LanguageCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "af-ZA", "ar-AE", "ar-SA", "cy-GB", "da-DK", "de-CH", "de-DE", "en-AB", "en-AU",
            "en-GB", "en-IE", "en-IN", "en-NZ", "en-US", "en-WL", "en-ZA", "es-ES", "es-US",
            "fa-IR", "fr-CA", "fr-FR", "ga-IE", "gd-GB", "he-IL", "hi-IN", "id-ID", "it-IT",
            "ja-JP", "ko-KR", "ms-MY", "nl-NL", "pt-BR", "pt-PT", "ru-RU", "ta-IN", "te-IN",
            "th-TH", "tr-TR", "zh-CN", "zh-TW",
        ]
    }
}
impl AsRef<str> for LanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyState {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VocabularyState {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => VocabularyState::Failed,
            "PENDING" => VocabularyState::Pending,
            "READY" => VocabularyState::Ready,
            other => VocabularyState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VocabularyState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyState::from(s))
    }
}
impl VocabularyState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyState::Failed => "FAILED",
            VocabularyState::Pending => "PENDING",
            VocabularyState::Ready => "READY",
            VocabularyState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "READY"]
    }
}
impl AsRef<str> for VocabularyState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains the rules and additional information about a call analytics category.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CategoryProperties {
    /// <p>The name of the call analytics category.</p>
    pub category_name: std::option::Option<std::string::String>,
    /// <p>The rules used to create a call analytics category.</p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>A timestamp that shows when the call analytics category was created.</p>
    pub create_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the call analytics category was most recently updated.</p>
    pub last_update_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for CategoryProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CategoryProperties");
        formatter.field("category_name", &self.category_name);
        formatter.field("rules", &self.rules);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_update_time", &self.last_update_time);
        formatter.finish()
    }
}
/// See [`CategoryProperties`](crate::model::CategoryProperties)
pub mod category_properties {
    /// A builder for [`CategoryProperties`](crate::model::CategoryProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_name: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the call analytics category.</p>
        pub fn category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.category_name = Some(input.into());
            self
        }
        /// <p>The name of the call analytics category.</p>
        pub fn set_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.category_name = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The rules used to create a call analytics category.</p>
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        /// <p>The rules used to create a call analytics category.</p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>A timestamp that shows when the call analytics category was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the call analytics category was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>A timestamp that shows when the call analytics category was most recently updated.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the call analytics category was most recently updated.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoryProperties`](crate::model::CategoryProperties)
        pub fn build(self) -> crate::model::CategoryProperties {
            crate::model::CategoryProperties {
                category_name: self.category_name,
                rules: self.rules,
                create_time: self.create_time,
                last_update_time: self.last_update_time,
            }
        }
    }
}
impl CategoryProperties {
    /// Creates a new builder-style object to manufacture [`CategoryProperties`](crate::model::CategoryProperties)
    pub fn builder() -> crate::model::category_properties::Builder {
        crate::model::category_properties::Builder::default()
    }
}

/// <p>A condition in the call between the customer and the agent that you want to filter for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Rule {
    /// <p>A condition for a time period when either the customer or agent was interrupting the
    /// other person. </p>
    InterruptionFilter(crate::model::InterruptionFilter),
    /// <p>A condition for a time period when neither the customer nor the agent was talking.</p>
    NonTalkTimeFilter(crate::model::NonTalkTimeFilter),
    /// <p>A condition that is applied to a particular customer sentiment.</p>
    SentimentFilter(crate::model::SentimentFilter),
    /// <p>A condition that catches particular words or phrases based on a exact match. For example, if you set the
    /// phrase "I want to speak to the manager", only that exact phrase will be returned.</p>
    TranscriptFilter(crate::model::TranscriptFilter),
}
impl Rule {
    /// Tries to convert the enum instance into [`InterruptionFilter`](crate::model::Rule::InterruptionFilter), extracting the inner [`InterruptionFilter`](crate::model::InterruptionFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_interruption_filter(
        &self,
    ) -> std::result::Result<&crate::model::InterruptionFilter, &Self> {
        if let Rule::InterruptionFilter(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    /// Returns true if this is a [`InterruptionFilter`](crate::model::Rule::InterruptionFilter).
    pub fn is_interruption_filter(&self) -> bool {
        self.as_interruption_filter().is_ok()
    }
    /// Tries to convert the enum instance into [`NonTalkTimeFilter`](crate::model::Rule::NonTalkTimeFilter), extracting the inner [`NonTalkTimeFilter`](crate::model::NonTalkTimeFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_non_talk_time_filter(
        &self,
    ) -> std::result::Result<&crate::model::NonTalkTimeFilter, &Self> {
        if let Rule::NonTalkTimeFilter(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    /// Returns true if this is a [`NonTalkTimeFilter`](crate::model::Rule::NonTalkTimeFilter).
    pub fn is_non_talk_time_filter(&self) -> bool {
        self.as_non_talk_time_filter().is_ok()
    }
    /// Tries to convert the enum instance into [`SentimentFilter`](crate::model::Rule::SentimentFilter), extracting the inner [`SentimentFilter`](crate::model::SentimentFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_sentiment_filter(
        &self,
    ) -> std::result::Result<&crate::model::SentimentFilter, &Self> {
        if let Rule::SentimentFilter(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    /// Returns true if this is a [`SentimentFilter`](crate::model::Rule::SentimentFilter).
    pub fn is_sentiment_filter(&self) -> bool {
        self.as_sentiment_filter().is_ok()
    }
    /// Tries to convert the enum instance into [`TranscriptFilter`](crate::model::Rule::TranscriptFilter), extracting the inner [`TranscriptFilter`](crate::model::TranscriptFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_transcript_filter(
        &self,
    ) -> std::result::Result<&crate::model::TranscriptFilter, &Self> {
        if let Rule::TranscriptFilter(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    /// Returns true if this is a [`TranscriptFilter`](crate::model::Rule::TranscriptFilter).
    pub fn is_transcript_filter(&self) -> bool {
        self.as_transcript_filter().is_ok()
    }
}

/// <p>An object that enables you to specify a particular customer or agent sentiment. If at least 50 percent of the
/// conversation turns (the back-and-forth between two speakers) in a specified time period match the specified
/// sentiment, Amazon Transcribe will consider the sentiment a match.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SentimentFilter {
    /// <p>An array that enables you to specify sentiments for the customer or agent. You can specify one or more values.</p>
    pub sentiments: std::option::Option<std::vec::Vec<crate::model::SentimentValue>>,
    /// <p>The time range, measured in seconds, of the sentiment.</p>
    pub absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
    /// <p>The time range, set in percentages, that correspond to proportion of the call.</p>
    pub relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
    /// <p>A value that determines whether the sentiment belongs to the customer or the agent.</p>
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
    /// <p>Set to <code>TRUE</code> to look for sentiments that weren't specified in the request. </p>
    pub negate: std::option::Option<bool>,
}
impl std::fmt::Debug for SentimentFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SentimentFilter");
        formatter.field("sentiments", &self.sentiments);
        formatter.field("absolute_time_range", &self.absolute_time_range);
        formatter.field("relative_time_range", &self.relative_time_range);
        formatter.field("participant_role", &self.participant_role);
        formatter.field("negate", &self.negate);
        formatter.finish()
    }
}
/// See [`SentimentFilter`](crate::model::SentimentFilter)
pub mod sentiment_filter {
    /// A builder for [`SentimentFilter`](crate::model::SentimentFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiments: std::option::Option<std::vec::Vec<crate::model::SentimentValue>>,
        pub(crate) absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
        pub(crate) relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
        pub(crate) negate: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `sentiments`.
        ///
        /// To override the contents of this collection use [`set_sentiments`](Self::set_sentiments).
        ///
        /// <p>An array that enables you to specify sentiments for the customer or agent. You can specify one or more values.</p>
        pub fn sentiments(mut self, input: impl Into<crate::model::SentimentValue>) -> Self {
            let mut v = self.sentiments.unwrap_or_default();
            v.push(input.into());
            self.sentiments = Some(v);
            self
        }
        /// <p>An array that enables you to specify sentiments for the customer or agent. You can specify one or more values.</p>
        pub fn set_sentiments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SentimentValue>>,
        ) -> Self {
            self.sentiments = input;
            self
        }
        /// <p>The time range, measured in seconds, of the sentiment.</p>
        pub fn absolute_time_range(mut self, input: crate::model::AbsoluteTimeRange) -> Self {
            self.absolute_time_range = Some(input);
            self
        }
        /// <p>The time range, measured in seconds, of the sentiment.</p>
        pub fn set_absolute_time_range(
            mut self,
            input: std::option::Option<crate::model::AbsoluteTimeRange>,
        ) -> Self {
            self.absolute_time_range = input;
            self
        }
        /// <p>The time range, set in percentages, that correspond to proportion of the call.</p>
        pub fn relative_time_range(mut self, input: crate::model::RelativeTimeRange) -> Self {
            self.relative_time_range = Some(input);
            self
        }
        /// <p>The time range, set in percentages, that correspond to proportion of the call.</p>
        pub fn set_relative_time_range(
            mut self,
            input: std::option::Option<crate::model::RelativeTimeRange>,
        ) -> Self {
            self.relative_time_range = input;
            self
        }
        /// <p>A value that determines whether the sentiment belongs to the customer or the agent.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>A value that determines whether the sentiment belongs to the customer or the agent.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// <p>Set to <code>TRUE</code> to look for sentiments that weren't specified in the request. </p>
        pub fn negate(mut self, input: bool) -> Self {
            self.negate = Some(input);
            self
        }
        /// <p>Set to <code>TRUE</code> to look for sentiments that weren't specified in the request. </p>
        pub fn set_negate(mut self, input: std::option::Option<bool>) -> Self {
            self.negate = input;
            self
        }
        /// Consumes the builder and constructs a [`SentimentFilter`](crate::model::SentimentFilter)
        pub fn build(self) -> crate::model::SentimentFilter {
            crate::model::SentimentFilter {
                sentiments: self.sentiments,
                absolute_time_range: self.absolute_time_range,
                relative_time_range: self.relative_time_range,
                participant_role: self.participant_role,
                negate: self.negate,
            }
        }
    }
}
impl SentimentFilter {
    /// Creates a new builder-style object to manufacture [`SentimentFilter`](crate::model::SentimentFilter)
    pub fn builder() -> crate::model::sentiment_filter::Builder {
        crate::model::sentiment_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParticipantRole {
    #[allow(missing_docs)] // documentation missing in model
    Agent,
    #[allow(missing_docs)] // documentation missing in model
    Customer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParticipantRole {
    fn from(s: &str) -> Self {
        match s {
            "AGENT" => ParticipantRole::Agent,
            "CUSTOMER" => ParticipantRole::Customer,
            other => ParticipantRole::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParticipantRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParticipantRole::from(s))
    }
}
impl ParticipantRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParticipantRole::Agent => "AGENT",
            ParticipantRole::Customer => "CUSTOMER",
            ParticipantRole::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AGENT", "CUSTOMER"]
    }
}
impl AsRef<str> for ParticipantRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that allows percentages to specify the proportion of the call where you would like to apply a filter. For
/// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
/// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can apply
/// relative time ranges across all calls. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RelativeTimeRange {
    /// <p>A value that indicates the percentage of the beginning of the time range. To set a relative time range, you must
    /// specify a start percentage and an end percentage. For example, if you specify the following values:</p>       
    /// <ul>
    /// <li>
    /// <p>StartPercentage - 10</p>
    /// </li>
    /// <li>
    /// <p>EndPercentage - 50</p>
    /// </li>
    /// </ul>
    /// <p>This looks at the time range starting from 10% of the way into the call to 50% of the way through the call. For
    /// a call that lasts 100,000 milliseconds, this example range would apply from the 10,000 millisecond mark to the
    /// 50,000 millisecond mark.</p>
    pub start_percentage: std::option::Option<i32>,
    /// <p>A value that indicates the percentage of the end of the time range. To set a relative time range, you must specify
    /// a start percentage and an end percentage. For example, if you specify the following values:</p>
    /// <ul>
    /// <li>
    /// <p>StartPercentage - 10</p>
    /// </li>
    /// <li>
    /// <p>EndPercentage - 50</p>
    /// </li>
    /// </ul>
    /// <p>This looks at the time range starting from 10% of the way into the call to 50% of the way through the call. For a
    /// call that lasts 100,000 milliseconds, this example range would apply from the 10,000 millisecond mark to the 50,000
    /// millisecond mark.</p>
    pub end_percentage: std::option::Option<i32>,
    /// <p>A range that takes the portion of the call up to the time in milliseconds set by the value that you've specified. For
    /// example, if you specify <code>120000</code>, the time range is set for the first 120,000 milliseconds of the call.</p>
    pub first: std::option::Option<i32>,
    /// <p>A range that takes the portion of the call from the time in milliseconds set by the value that you've specified to
    /// the end of the call. For example, if you specify <code>120000</code>, the time range is set for the last 120,000
    /// milliseconds of the call.</p>
    pub last: std::option::Option<i32>,
}
impl std::fmt::Debug for RelativeTimeRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RelativeTimeRange");
        formatter.field("start_percentage", &self.start_percentage);
        formatter.field("end_percentage", &self.end_percentage);
        formatter.field("first", &self.first);
        formatter.field("last", &self.last);
        formatter.finish()
    }
}
/// See [`RelativeTimeRange`](crate::model::RelativeTimeRange)
pub mod relative_time_range {
    /// A builder for [`RelativeTimeRange`](crate::model::RelativeTimeRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_percentage: std::option::Option<i32>,
        pub(crate) end_percentage: std::option::Option<i32>,
        pub(crate) first: std::option::Option<i32>,
        pub(crate) last: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A value that indicates the percentage of the beginning of the time range. To set a relative time range, you must
        /// specify a start percentage and an end percentage. For example, if you specify the following values:</p>       
        /// <ul>
        /// <li>
        /// <p>StartPercentage - 10</p>
        /// </li>
        /// <li>
        /// <p>EndPercentage - 50</p>
        /// </li>
        /// </ul>
        /// <p>This looks at the time range starting from 10% of the way into the call to 50% of the way through the call. For
        /// a call that lasts 100,000 milliseconds, this example range would apply from the 10,000 millisecond mark to the
        /// 50,000 millisecond mark.</p>
        pub fn start_percentage(mut self, input: i32) -> Self {
            self.start_percentage = Some(input);
            self
        }
        /// <p>A value that indicates the percentage of the beginning of the time range. To set a relative time range, you must
        /// specify a start percentage and an end percentage. For example, if you specify the following values:</p>       
        /// <ul>
        /// <li>
        /// <p>StartPercentage - 10</p>
        /// </li>
        /// <li>
        /// <p>EndPercentage - 50</p>
        /// </li>
        /// </ul>
        /// <p>This looks at the time range starting from 10% of the way into the call to 50% of the way through the call. For
        /// a call that lasts 100,000 milliseconds, this example range would apply from the 10,000 millisecond mark to the
        /// 50,000 millisecond mark.</p>
        pub fn set_start_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.start_percentage = input;
            self
        }
        /// <p>A value that indicates the percentage of the end of the time range. To set a relative time range, you must specify
        /// a start percentage and an end percentage. For example, if you specify the following values:</p>
        /// <ul>
        /// <li>
        /// <p>StartPercentage - 10</p>
        /// </li>
        /// <li>
        /// <p>EndPercentage - 50</p>
        /// </li>
        /// </ul>
        /// <p>This looks at the time range starting from 10% of the way into the call to 50% of the way through the call. For a
        /// call that lasts 100,000 milliseconds, this example range would apply from the 10,000 millisecond mark to the 50,000
        /// millisecond mark.</p>
        pub fn end_percentage(mut self, input: i32) -> Self {
            self.end_percentage = Some(input);
            self
        }
        /// <p>A value that indicates the percentage of the end of the time range. To set a relative time range, you must specify
        /// a start percentage and an end percentage. For example, if you specify the following values:</p>
        /// <ul>
        /// <li>
        /// <p>StartPercentage - 10</p>
        /// </li>
        /// <li>
        /// <p>EndPercentage - 50</p>
        /// </li>
        /// </ul>
        /// <p>This looks at the time range starting from 10% of the way into the call to 50% of the way through the call. For a
        /// call that lasts 100,000 milliseconds, this example range would apply from the 10,000 millisecond mark to the 50,000
        /// millisecond mark.</p>
        pub fn set_end_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.end_percentage = input;
            self
        }
        /// <p>A range that takes the portion of the call up to the time in milliseconds set by the value that you've specified. For
        /// example, if you specify <code>120000</code>, the time range is set for the first 120,000 milliseconds of the call.</p>
        pub fn first(mut self, input: i32) -> Self {
            self.first = Some(input);
            self
        }
        /// <p>A range that takes the portion of the call up to the time in milliseconds set by the value that you've specified. For
        /// example, if you specify <code>120000</code>, the time range is set for the first 120,000 milliseconds of the call.</p>
        pub fn set_first(mut self, input: std::option::Option<i32>) -> Self {
            self.first = input;
            self
        }
        /// <p>A range that takes the portion of the call from the time in milliseconds set by the value that you've specified to
        /// the end of the call. For example, if you specify <code>120000</code>, the time range is set for the last 120,000
        /// milliseconds of the call.</p>
        pub fn last(mut self, input: i32) -> Self {
            self.last = Some(input);
            self
        }
        /// <p>A range that takes the portion of the call from the time in milliseconds set by the value that you've specified to
        /// the end of the call. For example, if you specify <code>120000</code>, the time range is set for the last 120,000
        /// milliseconds of the call.</p>
        pub fn set_last(mut self, input: std::option::Option<i32>) -> Self {
            self.last = input;
            self
        }
        /// Consumes the builder and constructs a [`RelativeTimeRange`](crate::model::RelativeTimeRange)
        pub fn build(self) -> crate::model::RelativeTimeRange {
            crate::model::RelativeTimeRange {
                start_percentage: self.start_percentage,
                end_percentage: self.end_percentage,
                first: self.first,
                last: self.last,
            }
        }
    }
}
impl RelativeTimeRange {
    /// Creates a new builder-style object to manufacture [`RelativeTimeRange`](crate::model::RelativeTimeRange)
    pub fn builder() -> crate::model::relative_time_range::Builder {
        crate::model::relative_time_range::Builder::default()
    }
}

/// <p>A time range, set in seconds, between two points in the call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AbsoluteTimeRange {
    /// <p>A value that indicates the beginning of the time range in seconds. To set absolute time range, you must specify a
    /// start time and an end time. For example, if you specify the following values:</p>
    /// <ul>
    /// <li>
    /// <p>StartTime - 10000</p>
    /// </li>
    /// <li>
    /// <p>Endtime - 50000</p>
    /// </li>
    /// </ul>
    /// <p>The time range is set between 10,000 milliseconds and 50,000 milliseconds into the call.</p>
    pub start_time: std::option::Option<i64>,
    /// <p>A value that indicates the end of the time range in milliseconds. To set absolute time range, you must specify a start
    /// time and an end time. For example, if you specify the following values:</p>
    /// <ul>
    /// <li>
    /// <p>StartTime - 10000</p>
    /// </li>
    /// <li>
    /// <p>Endtime - 50000</p>
    /// </li>
    /// </ul>
    /// <p>The time range is set between 10,000 milliseconds and 50,000 milliseconds into the call. </p>
    pub end_time: std::option::Option<i64>,
    /// <p>A time range from the beginning of the call to the value that you've specified. For example, if you specify 100000, the
    /// time range is set to the first 100,000 milliseconds of the call.</p>
    pub first: std::option::Option<i64>,
    /// <p>A time range from the value that you've specified to the end of the call. For example, if you specify 100000, the time
    /// range is set to the last 100,000 milliseconds of the call.</p>
    pub last: std::option::Option<i64>,
}
impl std::fmt::Debug for AbsoluteTimeRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AbsoluteTimeRange");
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("first", &self.first);
        formatter.field("last", &self.last);
        formatter.finish()
    }
}
/// See [`AbsoluteTimeRange`](crate::model::AbsoluteTimeRange)
pub mod absolute_time_range {
    /// A builder for [`AbsoluteTimeRange`](crate::model::AbsoluteTimeRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<i64>,
        pub(crate) end_time: std::option::Option<i64>,
        pub(crate) first: std::option::Option<i64>,
        pub(crate) last: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>A value that indicates the beginning of the time range in seconds. To set absolute time range, you must specify a
        /// start time and an end time. For example, if you specify the following values:</p>
        /// <ul>
        /// <li>
        /// <p>StartTime - 10000</p>
        /// </li>
        /// <li>
        /// <p>Endtime - 50000</p>
        /// </li>
        /// </ul>
        /// <p>The time range is set between 10,000 milliseconds and 50,000 milliseconds into the call.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A value that indicates the beginning of the time range in seconds. To set absolute time range, you must specify a
        /// start time and an end time. For example, if you specify the following values:</p>
        /// <ul>
        /// <li>
        /// <p>StartTime - 10000</p>
        /// </li>
        /// <li>
        /// <p>Endtime - 50000</p>
        /// </li>
        /// </ul>
        /// <p>The time range is set between 10,000 milliseconds and 50,000 milliseconds into the call.</p>
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A value that indicates the end of the time range in milliseconds. To set absolute time range, you must specify a start
        /// time and an end time. For example, if you specify the following values:</p>
        /// <ul>
        /// <li>
        /// <p>StartTime - 10000</p>
        /// </li>
        /// <li>
        /// <p>Endtime - 50000</p>
        /// </li>
        /// </ul>
        /// <p>The time range is set between 10,000 milliseconds and 50,000 milliseconds into the call. </p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>A value that indicates the end of the time range in milliseconds. To set absolute time range, you must specify a start
        /// time and an end time. For example, if you specify the following values:</p>
        /// <ul>
        /// <li>
        /// <p>StartTime - 10000</p>
        /// </li>
        /// <li>
        /// <p>Endtime - 50000</p>
        /// </li>
        /// </ul>
        /// <p>The time range is set between 10,000 milliseconds and 50,000 milliseconds into the call. </p>
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>A time range from the beginning of the call to the value that you've specified. For example, if you specify 100000, the
        /// time range is set to the first 100,000 milliseconds of the call.</p>
        pub fn first(mut self, input: i64) -> Self {
            self.first = Some(input);
            self
        }
        /// <p>A time range from the beginning of the call to the value that you've specified. For example, if you specify 100000, the
        /// time range is set to the first 100,000 milliseconds of the call.</p>
        pub fn set_first(mut self, input: std::option::Option<i64>) -> Self {
            self.first = input;
            self
        }
        /// <p>A time range from the value that you've specified to the end of the call. For example, if you specify 100000, the time
        /// range is set to the last 100,000 milliseconds of the call.</p>
        pub fn last(mut self, input: i64) -> Self {
            self.last = Some(input);
            self
        }
        /// <p>A time range from the value that you've specified to the end of the call. For example, if you specify 100000, the time
        /// range is set to the last 100,000 milliseconds of the call.</p>
        pub fn set_last(mut self, input: std::option::Option<i64>) -> Self {
            self.last = input;
            self
        }
        /// Consumes the builder and constructs a [`AbsoluteTimeRange`](crate::model::AbsoluteTimeRange)
        pub fn build(self) -> crate::model::AbsoluteTimeRange {
            crate::model::AbsoluteTimeRange {
                start_time: self.start_time,
                end_time: self.end_time,
                first: self.first,
                last: self.last,
            }
        }
    }
}
impl AbsoluteTimeRange {
    /// Creates a new builder-style object to manufacture [`AbsoluteTimeRange`](crate::model::AbsoluteTimeRange)
    pub fn builder() -> crate::model::absolute_time_range::Builder {
        crate::model::absolute_time_range::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SentimentValue {
    #[allow(missing_docs)] // documentation missing in model
    Mixed,
    #[allow(missing_docs)] // documentation missing in model
    Negative,
    #[allow(missing_docs)] // documentation missing in model
    Neutral,
    #[allow(missing_docs)] // documentation missing in model
    Positive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SentimentValue {
    fn from(s: &str) -> Self {
        match s {
            "MIXED" => SentimentValue::Mixed,
            "NEGATIVE" => SentimentValue::Negative,
            "NEUTRAL" => SentimentValue::Neutral,
            "POSITIVE" => SentimentValue::Positive,
            other => SentimentValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SentimentValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SentimentValue::from(s))
    }
}
impl SentimentValue {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SentimentValue::Mixed => "MIXED",
            SentimentValue::Negative => "NEGATIVE",
            SentimentValue::Neutral => "NEUTRAL",
            SentimentValue::Positive => "POSITIVE",
            SentimentValue::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["MIXED", "NEGATIVE", "NEUTRAL", "POSITIVE"]
    }
}
impl AsRef<str> for SentimentValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Matches the output of the transcription to either the specific phrases that you specify, or the intent of the phrases
/// that you specify.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TranscriptFilter {
    /// <p>Matches the phrase to the transcription output in a word for word fashion.
    /// For example, if you specify the phrase "I want to speak to the manager." Amazon Transcribe attempts to match that specific
    /// phrase to the transcription.</p>
    pub transcript_filter_type: std::option::Option<crate::model::TranscriptFilterType>,
    /// <p>A time range, set in seconds, between two points in the call.</p>
    pub absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
    /// <p>An object that allows percentages to specify the proportion of the call where you would like to apply a filter. For
    /// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
    /// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can
    /// apply relative time ranges across all calls.</p>
    pub relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
    /// <p>Determines whether the customer or the agent is speaking the phrases that you've specified.</p>
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
    /// <p>If <code>TRUE</code>, the rule that you specify is applied to everything except for the phrases that you
    /// specify.</p>
    pub negate: std::option::Option<bool>,
    /// <p>The phrases that you're specifying for the transcript filter to match.</p>
    pub targets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for TranscriptFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TranscriptFilter");
        formatter.field("transcript_filter_type", &self.transcript_filter_type);
        formatter.field("absolute_time_range", &self.absolute_time_range);
        formatter.field("relative_time_range", &self.relative_time_range);
        formatter.field("participant_role", &self.participant_role);
        formatter.field("negate", &self.negate);
        formatter.field("targets", &self.targets);
        formatter.finish()
    }
}
/// See [`TranscriptFilter`](crate::model::TranscriptFilter)
pub mod transcript_filter {
    /// A builder for [`TranscriptFilter`](crate::model::TranscriptFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript_filter_type: std::option::Option<crate::model::TranscriptFilterType>,
        pub(crate) absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
        pub(crate) relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
        pub(crate) negate: std::option::Option<bool>,
        pub(crate) targets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Matches the phrase to the transcription output in a word for word fashion.
        /// For example, if you specify the phrase "I want to speak to the manager." Amazon Transcribe attempts to match that specific
        /// phrase to the transcription.</p>
        pub fn transcript_filter_type(mut self, input: crate::model::TranscriptFilterType) -> Self {
            self.transcript_filter_type = Some(input);
            self
        }
        /// <p>Matches the phrase to the transcription output in a word for word fashion.
        /// For example, if you specify the phrase "I want to speak to the manager." Amazon Transcribe attempts to match that specific
        /// phrase to the transcription.</p>
        pub fn set_transcript_filter_type(
            mut self,
            input: std::option::Option<crate::model::TranscriptFilterType>,
        ) -> Self {
            self.transcript_filter_type = input;
            self
        }
        /// <p>A time range, set in seconds, between two points in the call.</p>
        pub fn absolute_time_range(mut self, input: crate::model::AbsoluteTimeRange) -> Self {
            self.absolute_time_range = Some(input);
            self
        }
        /// <p>A time range, set in seconds, between two points in the call.</p>
        pub fn set_absolute_time_range(
            mut self,
            input: std::option::Option<crate::model::AbsoluteTimeRange>,
        ) -> Self {
            self.absolute_time_range = input;
            self
        }
        /// <p>An object that allows percentages to specify the proportion of the call where you would like to apply a filter. For
        /// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
        /// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can
        /// apply relative time ranges across all calls.</p>
        pub fn relative_time_range(mut self, input: crate::model::RelativeTimeRange) -> Self {
            self.relative_time_range = Some(input);
            self
        }
        /// <p>An object that allows percentages to specify the proportion of the call where you would like to apply a filter. For
        /// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
        /// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can
        /// apply relative time ranges across all calls.</p>
        pub fn set_relative_time_range(
            mut self,
            input: std::option::Option<crate::model::RelativeTimeRange>,
        ) -> Self {
            self.relative_time_range = input;
            self
        }
        /// <p>Determines whether the customer or the agent is speaking the phrases that you've specified.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>Determines whether the customer or the agent is speaking the phrases that you've specified.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// <p>If <code>TRUE</code>, the rule that you specify is applied to everything except for the phrases that you
        /// specify.</p>
        pub fn negate(mut self, input: bool) -> Self {
            self.negate = Some(input);
            self
        }
        /// <p>If <code>TRUE</code>, the rule that you specify is applied to everything except for the phrases that you
        /// specify.</p>
        pub fn set_negate(mut self, input: std::option::Option<bool>) -> Self {
            self.negate = input;
            self
        }
        /// Appends an item to `targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        ///
        /// <p>The phrases that you're specifying for the transcript filter to match.</p>
        pub fn targets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        /// <p>The phrases that you're specifying for the transcript filter to match.</p>
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// Consumes the builder and constructs a [`TranscriptFilter`](crate::model::TranscriptFilter)
        pub fn build(self) -> crate::model::TranscriptFilter {
            crate::model::TranscriptFilter {
                transcript_filter_type: self.transcript_filter_type,
                absolute_time_range: self.absolute_time_range,
                relative_time_range: self.relative_time_range,
                participant_role: self.participant_role,
                negate: self.negate,
                targets: self.targets,
            }
        }
    }
}
impl TranscriptFilter {
    /// Creates a new builder-style object to manufacture [`TranscriptFilter`](crate::model::TranscriptFilter)
    pub fn builder() -> crate::model::transcript_filter::Builder {
        crate::model::transcript_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TranscriptFilterType {
    #[allow(missing_docs)] // documentation missing in model
    Exact,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TranscriptFilterType {
    fn from(s: &str) -> Self {
        match s {
            "EXACT" => TranscriptFilterType::Exact,
            other => TranscriptFilterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TranscriptFilterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TranscriptFilterType::from(s))
    }
}
impl TranscriptFilterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TranscriptFilterType::Exact => "EXACT",
            TranscriptFilterType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EXACT"]
    }
}
impl AsRef<str> for TranscriptFilterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that enables you to configure your category to be applied to call analytics jobs where either the
/// customer or agent was interrupted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InterruptionFilter {
    /// <p>The duration of the interruption.</p>
    pub threshold: std::option::Option<i64>,
    /// <p>Indicates whether the caller or customer was interrupting.</p>
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
    /// <p>An object you can use to specify a time range (in milliseconds) for when you'd want to find the interruption. For
    /// example, you could search for an interruption between the 30,000 millisecond mark and the 45,000 millisecond mark.
    /// You could also specify the time period as the first 15,000 milliseconds or the last 15,000 milliseconds. </p>
    pub absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
    /// <p>An object that allows percentages to specify the proportion of the call where there was a interruption. For
    /// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
    /// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can apply
    /// relative time ranges across all calls.</p>
    pub relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
    /// <p>Set to <code>TRUE</code> to look for a time period where there was no interruption.</p>
    pub negate: std::option::Option<bool>,
}
impl std::fmt::Debug for InterruptionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InterruptionFilter");
        formatter.field("threshold", &self.threshold);
        formatter.field("participant_role", &self.participant_role);
        formatter.field("absolute_time_range", &self.absolute_time_range);
        formatter.field("relative_time_range", &self.relative_time_range);
        formatter.field("negate", &self.negate);
        formatter.finish()
    }
}
/// See [`InterruptionFilter`](crate::model::InterruptionFilter)
pub mod interruption_filter {
    /// A builder for [`InterruptionFilter`](crate::model::InterruptionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) threshold: std::option::Option<i64>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
        pub(crate) absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
        pub(crate) relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
        pub(crate) negate: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The duration of the interruption.</p>
        pub fn threshold(mut self, input: i64) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The duration of the interruption.</p>
        pub fn set_threshold(mut self, input: std::option::Option<i64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p>Indicates whether the caller or customer was interrupting.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>Indicates whether the caller or customer was interrupting.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// <p>An object you can use to specify a time range (in milliseconds) for when you'd want to find the interruption. For
        /// example, you could search for an interruption between the 30,000 millisecond mark and the 45,000 millisecond mark.
        /// You could also specify the time period as the first 15,000 milliseconds or the last 15,000 milliseconds. </p>
        pub fn absolute_time_range(mut self, input: crate::model::AbsoluteTimeRange) -> Self {
            self.absolute_time_range = Some(input);
            self
        }
        /// <p>An object you can use to specify a time range (in milliseconds) for when you'd want to find the interruption. For
        /// example, you could search for an interruption between the 30,000 millisecond mark and the 45,000 millisecond mark.
        /// You could also specify the time period as the first 15,000 milliseconds or the last 15,000 milliseconds. </p>
        pub fn set_absolute_time_range(
            mut self,
            input: std::option::Option<crate::model::AbsoluteTimeRange>,
        ) -> Self {
            self.absolute_time_range = input;
            self
        }
        /// <p>An object that allows percentages to specify the proportion of the call where there was a interruption. For
        /// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
        /// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can apply
        /// relative time ranges across all calls.</p>
        pub fn relative_time_range(mut self, input: crate::model::RelativeTimeRange) -> Self {
            self.relative_time_range = Some(input);
            self
        }
        /// <p>An object that allows percentages to specify the proportion of the call where there was a interruption. For
        /// example, you can specify the first half of the call. You can also specify the period of time between halfway through to
        /// three-quarters of the way through the call. Because the length of conversation can vary between calls, you can apply
        /// relative time ranges across all calls.</p>
        pub fn set_relative_time_range(
            mut self,
            input: std::option::Option<crate::model::RelativeTimeRange>,
        ) -> Self {
            self.relative_time_range = input;
            self
        }
        /// <p>Set to <code>TRUE</code> to look for a time period where there was no interruption.</p>
        pub fn negate(mut self, input: bool) -> Self {
            self.negate = Some(input);
            self
        }
        /// <p>Set to <code>TRUE</code> to look for a time period where there was no interruption.</p>
        pub fn set_negate(mut self, input: std::option::Option<bool>) -> Self {
            self.negate = input;
            self
        }
        /// Consumes the builder and constructs a [`InterruptionFilter`](crate::model::InterruptionFilter)
        pub fn build(self) -> crate::model::InterruptionFilter {
            crate::model::InterruptionFilter {
                threshold: self.threshold,
                participant_role: self.participant_role,
                absolute_time_range: self.absolute_time_range,
                relative_time_range: self.relative_time_range,
                negate: self.negate,
            }
        }
    }
}
impl InterruptionFilter {
    /// Creates a new builder-style object to manufacture [`InterruptionFilter`](crate::model::InterruptionFilter)
    pub fn builder() -> crate::model::interruption_filter::Builder {
        crate::model::interruption_filter::Builder::default()
    }
}

/// <p>An object that enables you to configure your category to be applied to call analytics jobs where either the
/// customer or agent was interrupted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NonTalkTimeFilter {
    /// <p>The duration of the period when neither the customer nor agent was talking.</p>
    pub threshold: std::option::Option<i64>,
    /// <p>An object you can use to specify a time range (in milliseconds) for when no one is talking. For example, you
    /// could specify a time period between the 30,000 millisecond mark and the 45,000 millisecond mark. You could also
    /// specify the time period as the first 15,000 milliseconds or the last 15,000 milliseconds.</p>
    pub absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
    /// <p>An object that allows percentages to specify the proportion of the call where there was silence. For example, you
    /// can specify the first half of the call. You can also specify the period of time between halfway through to three-quarters
    /// of the way through the call. Because the length of conversation can vary between calls, you can apply relative time
    /// ranges across all calls.</p>
    pub relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
    /// <p>Set to <code>TRUE</code> to look for a time period when people were talking.</p>
    pub negate: std::option::Option<bool>,
}
impl std::fmt::Debug for NonTalkTimeFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NonTalkTimeFilter");
        formatter.field("threshold", &self.threshold);
        formatter.field("absolute_time_range", &self.absolute_time_range);
        formatter.field("relative_time_range", &self.relative_time_range);
        formatter.field("negate", &self.negate);
        formatter.finish()
    }
}
/// See [`NonTalkTimeFilter`](crate::model::NonTalkTimeFilter)
pub mod non_talk_time_filter {
    /// A builder for [`NonTalkTimeFilter`](crate::model::NonTalkTimeFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) threshold: std::option::Option<i64>,
        pub(crate) absolute_time_range: std::option::Option<crate::model::AbsoluteTimeRange>,
        pub(crate) relative_time_range: std::option::Option<crate::model::RelativeTimeRange>,
        pub(crate) negate: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The duration of the period when neither the customer nor agent was talking.</p>
        pub fn threshold(mut self, input: i64) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The duration of the period when neither the customer nor agent was talking.</p>
        pub fn set_threshold(mut self, input: std::option::Option<i64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p>An object you can use to specify a time range (in milliseconds) for when no one is talking. For example, you
        /// could specify a time period between the 30,000 millisecond mark and the 45,000 millisecond mark. You could also
        /// specify the time period as the first 15,000 milliseconds or the last 15,000 milliseconds.</p>
        pub fn absolute_time_range(mut self, input: crate::model::AbsoluteTimeRange) -> Self {
            self.absolute_time_range = Some(input);
            self
        }
        /// <p>An object you can use to specify a time range (in milliseconds) for when no one is talking. For example, you
        /// could specify a time period between the 30,000 millisecond mark and the 45,000 millisecond mark. You could also
        /// specify the time period as the first 15,000 milliseconds or the last 15,000 milliseconds.</p>
        pub fn set_absolute_time_range(
            mut self,
            input: std::option::Option<crate::model::AbsoluteTimeRange>,
        ) -> Self {
            self.absolute_time_range = input;
            self
        }
        /// <p>An object that allows percentages to specify the proportion of the call where there was silence. For example, you
        /// can specify the first half of the call. You can also specify the period of time between halfway through to three-quarters
        /// of the way through the call. Because the length of conversation can vary between calls, you can apply relative time
        /// ranges across all calls.</p>
        pub fn relative_time_range(mut self, input: crate::model::RelativeTimeRange) -> Self {
            self.relative_time_range = Some(input);
            self
        }
        /// <p>An object that allows percentages to specify the proportion of the call where there was silence. For example, you
        /// can specify the first half of the call. You can also specify the period of time between halfway through to three-quarters
        /// of the way through the call. Because the length of conversation can vary between calls, you can apply relative time
        /// ranges across all calls.</p>
        pub fn set_relative_time_range(
            mut self,
            input: std::option::Option<crate::model::RelativeTimeRange>,
        ) -> Self {
            self.relative_time_range = input;
            self
        }
        /// <p>Set to <code>TRUE</code> to look for a time period when people were talking.</p>
        pub fn negate(mut self, input: bool) -> Self {
            self.negate = Some(input);
            self
        }
        /// <p>Set to <code>TRUE</code> to look for a time period when people were talking.</p>
        pub fn set_negate(mut self, input: std::option::Option<bool>) -> Self {
            self.negate = input;
            self
        }
        /// Consumes the builder and constructs a [`NonTalkTimeFilter`](crate::model::NonTalkTimeFilter)
        pub fn build(self) -> crate::model::NonTalkTimeFilter {
            crate::model::NonTalkTimeFilter {
                threshold: self.threshold,
                absolute_time_range: self.absolute_time_range,
                relative_time_range: self.relative_time_range,
                negate: self.negate,
            }
        }
    }
}
impl NonTalkTimeFilter {
    /// Creates a new builder-style object to manufacture [`NonTalkTimeFilter`](crate::model::NonTalkTimeFilter)
    pub fn builder() -> crate::model::non_talk_time_filter::Builder {
        crate::model::non_talk_time_filter::Builder::default()
    }
}

/// <p>A key:value pair that adds metadata to a resource used by Amazon Transcribe. For example, a tag with the key:value pair
/// Department:Sales might be added to a resource to indicate its use by your organization's sales department.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag
    /// Department:Sales, the key is 'Department'.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag
    /// Department:Sales, the value is 'Sales'.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag
        /// Department:Sales, the key is 'Department'.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag
        /// Department:Sales, the key is 'Department'.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag
        /// Department:Sales, the value is 'Sales'.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag
        /// Department:Sales, the value is 'Sales'.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Describes an asynchronous transcription job that was created with the <code>StartTranscriptionJob</code>
/// operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TranscriptionJob {
    /// <p>The name of the transcription job.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
    /// <p>The status of the transcription job.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>The language code for the input speech.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The format of the input media file.</p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>An object that describes the input media for the transcription job.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>An object that describes the output of the transcription job.</p>
    pub transcript: std::option::Option<crate::model::Transcript>,
    /// <p>A timestamp that shows when the job started processing.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field contains information
    /// about why the job failed.</p>
    /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Unsupported media format</code> - The media format specified in the <code>MediaFormat</code>
    /// field of the request isn't valid. See the description of the <code>MediaFormat</code> field for a list of valid
    /// values.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The media format provided does not match the detected media format</code> - The media format
    /// of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request. Check
    /// the media format of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid sample rate for audio file</code> - The sample rate specified in the
    /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and
    /// 48,000 Hertz.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The sample rate provided does not match the detected sample rate</code> - The sample rate in the
    /// audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the request.
    /// Check the sample rate of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid file size: file size too large</code> - The size of your audio file is larger than Amazon Transcribe can process.
    /// For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Limits</a> in the <i>Amazon Transcribe Developer Guide</i>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid number of channels: number of channels too large</code> - Your audio contains more
    /// channels than Amazon Transcribe is configured to process. To request additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits-amazon-transcribe">Amazon Transcribe Limits</a> in
    /// the <i>Amazon Web Services General Reference</i>.</p>
    /// </li>
    /// </ul>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Optional settings for the transcription job. Use these settings to turn on speaker recognition, to set the
    /// maximum number of speakers that should be identified and to specify a custom vocabulary to use when processing
    /// the transcription job.</p>
    pub settings: std::option::Option<crate::model::Settings>,
    /// <p>An object containing the details of your custom language model.</p>
    pub model_settings: std::option::Option<crate::model::ModelSettings>,
    /// <p>Provides information about how a transcription job is executed.</p>
    pub job_execution_settings: std::option::Option<crate::model::JobExecutionSettings>,
    /// <p>An object that describes content redaction settings for the transcription job.</p>
    pub content_redaction: std::option::Option<crate::model::ContentRedaction>,
    /// <p>A value that shows if automatic language identification was enabled for a transcription job.</p>
    pub identify_language: std::option::Option<bool>,
    /// <p>An object that shows the optional array of languages inputted for transcription jobs  with automatic language
    /// identification enabled.</p>
    pub language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
    /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in the source audio. Larger
    /// values indicate that Amazon Transcribe has higher confidence in the language it identified.</p>
    pub identified_language_score: std::option::Option<f32>,
    /// <p>A key:value pair assigned to a given transcription job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Generate subtitles for your batch transcription job.</p>
    pub subtitles: std::option::Option<crate::model::SubtitlesOutput>,
    /// <p>Language-specific settings that can be specified when language identification is enabled for your transcription
    /// job. These settings include <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
    /// <code>LanguageModelName</code>LanguageModelName.</p>
    pub language_id_settings: std::option::Option<
        std::collections::HashMap<crate::model::LanguageCode, crate::model::LanguageIdSettings>,
    >,
}
impl std::fmt::Debug for TranscriptionJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TranscriptionJob");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("transcript", &self.transcript);
        formatter.field("start_time", &self.start_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("settings", &self.settings);
        formatter.field("model_settings", &self.model_settings);
        formatter.field("job_execution_settings", &self.job_execution_settings);
        formatter.field("content_redaction", &self.content_redaction);
        formatter.field("identify_language", &self.identify_language);
        formatter.field("language_options", &self.language_options);
        formatter.field("identified_language_score", &self.identified_language_score);
        formatter.field("tags", &self.tags);
        formatter.field("subtitles", &self.subtitles);
        formatter.field("language_id_settings", &self.language_id_settings);
        formatter.finish()
    }
}
/// See [`TranscriptionJob`](crate::model::TranscriptionJob)
pub mod transcription_job {
    /// A builder for [`TranscriptionJob`](crate::model::TranscriptionJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) transcript: std::option::Option<crate::model::Transcript>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::Settings>,
        pub(crate) model_settings: std::option::Option<crate::model::ModelSettings>,
        pub(crate) job_execution_settings: std::option::Option<crate::model::JobExecutionSettings>,
        pub(crate) content_redaction: std::option::Option<crate::model::ContentRedaction>,
        pub(crate) identify_language: std::option::Option<bool>,
        pub(crate) language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        pub(crate) identified_language_score: std::option::Option<f32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) subtitles: std::option::Option<crate::model::SubtitlesOutput>,
        pub(crate) language_id_settings: std::option::Option<
            std::collections::HashMap<crate::model::LanguageCode, crate::model::LanguageIdSettings>,
        >,
    }
    impl Builder {
        /// <p>The name of the transcription job.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the transcription job.</p>
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// <p>The status of the transcription job.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        /// <p>The status of the transcription job.</p>
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>The language code for the input speech.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the input speech.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>An object that describes the input media for the transcription job.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        /// <p>An object that describes the input media for the transcription job.</p>
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>An object that describes the output of the transcription job.</p>
        pub fn transcript(mut self, input: crate::model::Transcript) -> Self {
            self.transcript = Some(input);
            self
        }
        /// <p>An object that describes the output of the transcription job.</p>
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::Transcript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field contains information
        /// about why the job failed.</p>
        /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code> - The media format specified in the <code>MediaFormat</code>
        /// field of the request isn't valid. See the description of the <code>MediaFormat</code> field for a list of valid
        /// values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media format</code> - The media format
        /// of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request. Check
        /// the media format of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code> - The sample rate specified in the
        /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and
        /// 48,000 Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code> - The sample rate in the
        /// audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the request.
        /// Check the sample rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code> - The size of your audio file is larger than Amazon Transcribe can process.
        /// For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Limits</a> in the <i>Amazon Transcribe Developer Guide</i>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code> - Your audio contains more
        /// channels than Amazon Transcribe is configured to process. To request additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits-amazon-transcribe">Amazon Transcribe Limits</a> in
        /// the <i>Amazon Web Services General Reference</i>.</p>
        /// </li>
        /// </ul>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field contains information
        /// about why the job failed.</p>
        /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code> - The media format specified in the <code>MediaFormat</code>
        /// field of the request isn't valid. See the description of the <code>MediaFormat</code> field for a list of valid
        /// values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media format</code> - The media format
        /// of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request. Check
        /// the media format of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code> - The sample rate specified in the
        /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and
        /// 48,000 Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code> - The sample rate in the
        /// audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the request.
        /// Check the sample rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code> - The size of your audio file is larger than Amazon Transcribe can process.
        /// For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Limits</a> in the <i>Amazon Transcribe Developer Guide</i>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code> - Your audio contains more
        /// channels than Amazon Transcribe is configured to process. To request additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits-amazon-transcribe">Amazon Transcribe Limits</a> in
        /// the <i>Amazon Web Services General Reference</i>.</p>
        /// </li>
        /// </ul>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Optional settings for the transcription job. Use these settings to turn on speaker recognition, to set the
        /// maximum number of speakers that should be identified and to specify a custom vocabulary to use when processing
        /// the transcription job.</p>
        pub fn settings(mut self, input: crate::model::Settings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>Optional settings for the transcription job. Use these settings to turn on speaker recognition, to set the
        /// maximum number of speakers that should be identified and to specify a custom vocabulary to use when processing
        /// the transcription job.</p>
        pub fn set_settings(mut self, input: std::option::Option<crate::model::Settings>) -> Self {
            self.settings = input;
            self
        }
        /// <p>An object containing the details of your custom language model.</p>
        pub fn model_settings(mut self, input: crate::model::ModelSettings) -> Self {
            self.model_settings = Some(input);
            self
        }
        /// <p>An object containing the details of your custom language model.</p>
        pub fn set_model_settings(
            mut self,
            input: std::option::Option<crate::model::ModelSettings>,
        ) -> Self {
            self.model_settings = input;
            self
        }
        /// <p>Provides information about how a transcription job is executed.</p>
        pub fn job_execution_settings(mut self, input: crate::model::JobExecutionSettings) -> Self {
            self.job_execution_settings = Some(input);
            self
        }
        /// <p>Provides information about how a transcription job is executed.</p>
        pub fn set_job_execution_settings(
            mut self,
            input: std::option::Option<crate::model::JobExecutionSettings>,
        ) -> Self {
            self.job_execution_settings = input;
            self
        }
        /// <p>An object that describes content redaction settings for the transcription job.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.content_redaction = Some(input);
            self
        }
        /// <p>An object that describes content redaction settings for the transcription job.</p>
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.content_redaction = input;
            self
        }
        /// <p>A value that shows if automatic language identification was enabled for a transcription job.</p>
        pub fn identify_language(mut self, input: bool) -> Self {
            self.identify_language = Some(input);
            self
        }
        /// <p>A value that shows if automatic language identification was enabled for a transcription job.</p>
        pub fn set_identify_language(mut self, input: std::option::Option<bool>) -> Self {
            self.identify_language = input;
            self
        }
        /// Appends an item to `language_options`.
        ///
        /// To override the contents of this collection use [`set_language_options`](Self::set_language_options).
        ///
        /// <p>An object that shows the optional array of languages inputted for transcription jobs  with automatic language
        /// identification enabled.</p>
        pub fn language_options(mut self, input: impl Into<crate::model::LanguageCode>) -> Self {
            let mut v = self.language_options.unwrap_or_default();
            v.push(input.into());
            self.language_options = Some(v);
            self
        }
        /// <p>An object that shows the optional array of languages inputted for transcription jobs  with automatic language
        /// identification enabled.</p>
        pub fn set_language_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.language_options = input;
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in the source audio. Larger
        /// values indicate that Amazon Transcribe has higher confidence in the language it identified.</p>
        pub fn identified_language_score(mut self, input: f32) -> Self {
            self.identified_language_score = Some(input);
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in the source audio. Larger
        /// values indicate that Amazon Transcribe has higher confidence in the language it identified.</p>
        pub fn set_identified_language_score(mut self, input: std::option::Option<f32>) -> Self {
            self.identified_language_score = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A key:value pair assigned to a given transcription job.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A key:value pair assigned to a given transcription job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Generate subtitles for your batch transcription job.</p>
        pub fn subtitles(mut self, input: crate::model::SubtitlesOutput) -> Self {
            self.subtitles = Some(input);
            self
        }
        /// <p>Generate subtitles for your batch transcription job.</p>
        pub fn set_subtitles(
            mut self,
            input: std::option::Option<crate::model::SubtitlesOutput>,
        ) -> Self {
            self.subtitles = input;
            self
        }
        /// Adds a key-value pair to `language_id_settings`.
        ///
        /// To override the contents of this collection use [`set_language_id_settings`](Self::set_language_id_settings).
        ///
        /// <p>Language-specific settings that can be specified when language identification is enabled for your transcription
        /// job. These settings include <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
        /// <code>LanguageModelName</code>LanguageModelName.</p>
        pub fn language_id_settings(
            mut self,
            k: impl Into<crate::model::LanguageCode>,
            v: impl Into<crate::model::LanguageIdSettings>,
        ) -> Self {
            let mut hash_map = self.language_id_settings.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.language_id_settings = Some(hash_map);
            self
        }
        /// <p>Language-specific settings that can be specified when language identification is enabled for your transcription
        /// job. These settings include <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
        /// <code>LanguageModelName</code>LanguageModelName.</p>
        pub fn set_language_id_settings(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::LanguageCode,
                    crate::model::LanguageIdSettings,
                >,
            >,
        ) -> Self {
            self.language_id_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`TranscriptionJob`](crate::model::TranscriptionJob)
        pub fn build(self) -> crate::model::TranscriptionJob {
            crate::model::TranscriptionJob {
                transcription_job_name: self.transcription_job_name,
                transcription_job_status: self.transcription_job_status,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                transcript: self.transcript,
                start_time: self.start_time,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
                failure_reason: self.failure_reason,
                settings: self.settings,
                model_settings: self.model_settings,
                job_execution_settings: self.job_execution_settings,
                content_redaction: self.content_redaction,
                identify_language: self.identify_language,
                language_options: self.language_options,
                identified_language_score: self.identified_language_score,
                tags: self.tags,
                subtitles: self.subtitles,
                language_id_settings: self.language_id_settings,
            }
        }
    }
}
impl TranscriptionJob {
    /// Creates a new builder-style object to manufacture [`TranscriptionJob`](crate::model::TranscriptionJob)
    pub fn builder() -> crate::model::transcription_job::Builder {
        crate::model::transcription_job::Builder::default()
    }
}

/// <p>Language-specific settings that can be specified when language identification is enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LanguageIdSettings {
    /// <p>The name of the vocabulary you want to use when processing your transcription job. The
    /// vocabulary you specify must have the same language code as the transcription job; if the languages don't
    /// match, the vocabulary won't be applied.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The name of the vocabulary filter you want to use when transcribing your audio. The filter you specify
    /// must have the same language code as the transcription job; if the languages don't match, the vocabulary
    /// filter won't be applied.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The name of the language model you want to use when transcribing your audio. The model you specify
    /// must have the same language code as the transcription job; if the languages don't match, the language model
    /// won't be applied.</p>
    pub language_model_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LanguageIdSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LanguageIdSettings");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_model_name", &self.language_model_name);
        formatter.finish()
    }
}
/// See [`LanguageIdSettings`](crate::model::LanguageIdSettings)
pub mod language_id_settings {
    /// A builder for [`LanguageIdSettings`](crate::model::LanguageIdSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary you want to use when processing your transcription job. The
        /// vocabulary you specify must have the same language code as the transcription job; if the languages don't
        /// match, the vocabulary won't be applied.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary you want to use when processing your transcription job. The
        /// vocabulary you specify must have the same language code as the transcription job; if the languages don't
        /// match, the vocabulary won't be applied.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The name of the vocabulary filter you want to use when transcribing your audio. The filter you specify
        /// must have the same language code as the transcription job; if the languages don't match, the vocabulary
        /// filter won't be applied.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter you want to use when transcribing your audio. The filter you specify
        /// must have the same language code as the transcription job; if the languages don't match, the vocabulary
        /// filter won't be applied.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The name of the language model you want to use when transcribing your audio. The model you specify
        /// must have the same language code as the transcription job; if the languages don't match, the language model
        /// won't be applied.</p>
        pub fn language_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_model_name = Some(input.into());
            self
        }
        /// <p>The name of the language model you want to use when transcribing your audio. The model you specify
        /// must have the same language code as the transcription job; if the languages don't match, the language model
        /// won't be applied.</p>
        pub fn set_language_model_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LanguageIdSettings`](crate::model::LanguageIdSettings)
        pub fn build(self) -> crate::model::LanguageIdSettings {
            crate::model::LanguageIdSettings {
                vocabulary_name: self.vocabulary_name,
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_model_name: self.language_model_name,
            }
        }
    }
}
impl LanguageIdSettings {
    /// Creates a new builder-style object to manufacture [`LanguageIdSettings`](crate::model::LanguageIdSettings)
    pub fn builder() -> crate::model::language_id_settings::Builder {
        crate::model::language_id_settings::Builder::default()
    }
}

/// <p>Specify the output format for your subtitle file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubtitlesOutput {
    /// <p>Specify the output format for your subtitle file; if you select both SRT and VTT formats, two output files are genereated.</p>
    pub formats: std::option::Option<std::vec::Vec<crate::model::SubtitleFormat>>,
    /// <p>Choose the output location for your subtitle file. This location must be an S3 bucket.</p>
    pub subtitle_file_uris: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SubtitlesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubtitlesOutput");
        formatter.field("formats", &self.formats);
        formatter.field("subtitle_file_uris", &self.subtitle_file_uris);
        formatter.finish()
    }
}
/// See [`SubtitlesOutput`](crate::model::SubtitlesOutput)
pub mod subtitles_output {
    /// A builder for [`SubtitlesOutput`](crate::model::SubtitlesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) formats: std::option::Option<std::vec::Vec<crate::model::SubtitleFormat>>,
        pub(crate) subtitle_file_uris: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `formats`.
        ///
        /// To override the contents of this collection use [`set_formats`](Self::set_formats).
        ///
        /// <p>Specify the output format for your subtitle file; if you select both SRT and VTT formats, two output files are genereated.</p>
        pub fn formats(mut self, input: impl Into<crate::model::SubtitleFormat>) -> Self {
            let mut v = self.formats.unwrap_or_default();
            v.push(input.into());
            self.formats = Some(v);
            self
        }
        /// <p>Specify the output format for your subtitle file; if you select both SRT and VTT formats, two output files are genereated.</p>
        pub fn set_formats(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubtitleFormat>>,
        ) -> Self {
            self.formats = input;
            self
        }
        /// Appends an item to `subtitle_file_uris`.
        ///
        /// To override the contents of this collection use [`set_subtitle_file_uris`](Self::set_subtitle_file_uris).
        ///
        /// <p>Choose the output location for your subtitle file. This location must be an S3 bucket.</p>
        pub fn subtitle_file_uris(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subtitle_file_uris.unwrap_or_default();
            v.push(input.into());
            self.subtitle_file_uris = Some(v);
            self
        }
        /// <p>Choose the output location for your subtitle file. This location must be an S3 bucket.</p>
        pub fn set_subtitle_file_uris(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subtitle_file_uris = input;
            self
        }
        /// Consumes the builder and constructs a [`SubtitlesOutput`](crate::model::SubtitlesOutput)
        pub fn build(self) -> crate::model::SubtitlesOutput {
            crate::model::SubtitlesOutput {
                formats: self.formats,
                subtitle_file_uris: self.subtitle_file_uris,
            }
        }
    }
}
impl SubtitlesOutput {
    /// Creates a new builder-style object to manufacture [`SubtitlesOutput`](crate::model::SubtitlesOutput)
    pub fn builder() -> crate::model::subtitles_output::Builder {
        crate::model::subtitles_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubtitleFormat {
    #[allow(missing_docs)] // documentation missing in model
    Srt,
    #[allow(missing_docs)] // documentation missing in model
    Vtt,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SubtitleFormat {
    fn from(s: &str) -> Self {
        match s {
            "srt" => SubtitleFormat::Srt,
            "vtt" => SubtitleFormat::Vtt,
            other => SubtitleFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SubtitleFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubtitleFormat::from(s))
    }
}
impl SubtitleFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SubtitleFormat::Srt => "srt",
            SubtitleFormat::Vtt => "vtt",
            SubtitleFormat::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["srt", "vtt"]
    }
}
impl AsRef<str> for SubtitleFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Settings for content redaction within a transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContentRedaction {
    /// <p>Request parameter that defines the entities to be redacted. The only accepted value is <code>PII</code>.</p>
    pub redaction_type: std::option::Option<crate::model::RedactionType>,
    /// <p>The output transcript file stored in either the default S3 bucket or in a bucket you specify.</p>
    /// <p>When you choose <code>redacted</code> Amazon Transcribe outputs only the redacted transcript.</p>
    /// <p>When you choose <code>redacted_and_unredacted</code> Amazon Transcribe outputs both the redacted and
    /// unredacted transcripts.</p>
    pub redaction_output: std::option::Option<crate::model::RedactionOutput>,
}
impl std::fmt::Debug for ContentRedaction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContentRedaction");
        formatter.field("redaction_type", &self.redaction_type);
        formatter.field("redaction_output", &self.redaction_output);
        formatter.finish()
    }
}
/// See [`ContentRedaction`](crate::model::ContentRedaction)
pub mod content_redaction {
    /// A builder for [`ContentRedaction`](crate::model::ContentRedaction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) redaction_type: std::option::Option<crate::model::RedactionType>,
        pub(crate) redaction_output: std::option::Option<crate::model::RedactionOutput>,
    }
    impl Builder {
        /// <p>Request parameter that defines the entities to be redacted. The only accepted value is <code>PII</code>.</p>
        pub fn redaction_type(mut self, input: crate::model::RedactionType) -> Self {
            self.redaction_type = Some(input);
            self
        }
        /// <p>Request parameter that defines the entities to be redacted. The only accepted value is <code>PII</code>.</p>
        pub fn set_redaction_type(
            mut self,
            input: std::option::Option<crate::model::RedactionType>,
        ) -> Self {
            self.redaction_type = input;
            self
        }
        /// <p>The output transcript file stored in either the default S3 bucket or in a bucket you specify.</p>
        /// <p>When you choose <code>redacted</code> Amazon Transcribe outputs only the redacted transcript.</p>
        /// <p>When you choose <code>redacted_and_unredacted</code> Amazon Transcribe outputs both the redacted and
        /// unredacted transcripts.</p>
        pub fn redaction_output(mut self, input: crate::model::RedactionOutput) -> Self {
            self.redaction_output = Some(input);
            self
        }
        /// <p>The output transcript file stored in either the default S3 bucket or in a bucket you specify.</p>
        /// <p>When you choose <code>redacted</code> Amazon Transcribe outputs only the redacted transcript.</p>
        /// <p>When you choose <code>redacted_and_unredacted</code> Amazon Transcribe outputs both the redacted and
        /// unredacted transcripts.</p>
        pub fn set_redaction_output(
            mut self,
            input: std::option::Option<crate::model::RedactionOutput>,
        ) -> Self {
            self.redaction_output = input;
            self
        }
        /// Consumes the builder and constructs a [`ContentRedaction`](crate::model::ContentRedaction)
        pub fn build(self) -> crate::model::ContentRedaction {
            crate::model::ContentRedaction {
                redaction_type: self.redaction_type,
                redaction_output: self.redaction_output,
            }
        }
    }
}
impl ContentRedaction {
    /// Creates a new builder-style object to manufacture [`ContentRedaction`](crate::model::ContentRedaction)
    pub fn builder() -> crate::model::content_redaction::Builder {
        crate::model::content_redaction::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedactionOutput {
    #[allow(missing_docs)] // documentation missing in model
    Redacted,
    #[allow(missing_docs)] // documentation missing in model
    RedactedAndUnredacted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedactionOutput {
    fn from(s: &str) -> Self {
        match s {
            "redacted" => RedactionOutput::Redacted,
            "redacted_and_unredacted" => RedactionOutput::RedactedAndUnredacted,
            other => RedactionOutput::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedactionOutput {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedactionOutput::from(s))
    }
}
impl RedactionOutput {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RedactionOutput::Redacted => "redacted",
            RedactionOutput::RedactedAndUnredacted => "redacted_and_unredacted",
            RedactionOutput::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["redacted", "redacted_and_unredacted"]
    }
}
impl AsRef<str> for RedactionOutput {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedactionType {
    #[allow(missing_docs)] // documentation missing in model
    Pii,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedactionType {
    fn from(s: &str) -> Self {
        match s {
            "PII" => RedactionType::Pii,
            other => RedactionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedactionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedactionType::from(s))
    }
}
impl RedactionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RedactionType::Pii => "PII",
            RedactionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PII"]
    }
}
impl AsRef<str> for RedactionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about when a transcription job should be executed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JobExecutionSettings {
    /// <p>Indicates whether a job should be queued by Amazon Transcribe when the concurrent execution limit is exceeded. When the
    /// <code>AllowDeferredExecution</code> field is true, jobs are queued and executed when the number of executing
    /// jobs falls below the concurrent execution limit. If the field is false, Amazon Transcribe returns a
    /// <code>LimitExceededException</code> exception.</p>
    /// <p>Note that job queuing is enabled by default for call analytics jobs.</p>
    /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
    /// <code>DataAccessRoleArn</code> field.</p>
    pub allow_deferred_execution: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN), in the form
    /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>, of a role
    /// that has access to the S3 bucket that contains the input files. Amazon Transcribe assumes this role to read queued
    /// media files. If you have specified an output S3 bucket for the transcription results, this role should
    /// have access to the output bucket as well.</p>      
    /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
    /// <code>DataAccessRoleArn</code> field.</p>
    pub data_access_role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JobExecutionSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JobExecutionSettings");
        formatter.field("allow_deferred_execution", &self.allow_deferred_execution);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.finish()
    }
}
/// See [`JobExecutionSettings`](crate::model::JobExecutionSettings)
pub mod job_execution_settings {
    /// A builder for [`JobExecutionSettings`](crate::model::JobExecutionSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_deferred_execution: std::option::Option<bool>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether a job should be queued by Amazon Transcribe when the concurrent execution limit is exceeded. When the
        /// <code>AllowDeferredExecution</code> field is true, jobs are queued and executed when the number of executing
        /// jobs falls below the concurrent execution limit. If the field is false, Amazon Transcribe returns a
        /// <code>LimitExceededException</code> exception.</p>
        /// <p>Note that job queuing is enabled by default for call analytics jobs.</p>
        /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
        /// <code>DataAccessRoleArn</code> field.</p>
        pub fn allow_deferred_execution(mut self, input: bool) -> Self {
            self.allow_deferred_execution = Some(input);
            self
        }
        /// <p>Indicates whether a job should be queued by Amazon Transcribe when the concurrent execution limit is exceeded. When the
        /// <code>AllowDeferredExecution</code> field is true, jobs are queued and executed when the number of executing
        /// jobs falls below the concurrent execution limit. If the field is false, Amazon Transcribe returns a
        /// <code>LimitExceededException</code> exception.</p>
        /// <p>Note that job queuing is enabled by default for call analytics jobs.</p>
        /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
        /// <code>DataAccessRoleArn</code> field.</p>
        pub fn set_allow_deferred_execution(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_deferred_execution = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN), in the form
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>, of a role
        /// that has access to the S3 bucket that contains the input files. Amazon Transcribe assumes this role to read queued
        /// media files. If you have specified an output S3 bucket for the transcription results, this role should
        /// have access to the output bucket as well.</p>      
        /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
        /// <code>DataAccessRoleArn</code> field.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN), in the form
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>, of a role
        /// that has access to the S3 bucket that contains the input files. Amazon Transcribe assumes this role to read queued
        /// media files. If you have specified an output S3 bucket for the transcription results, this role should
        /// have access to the output bucket as well.</p>      
        /// <p>If you specify the <code>AllowDeferredExecution</code> field, you must specify the
        /// <code>DataAccessRoleArn</code> field.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`JobExecutionSettings`](crate::model::JobExecutionSettings)
        pub fn build(self) -> crate::model::JobExecutionSettings {
            crate::model::JobExecutionSettings {
                allow_deferred_execution: self.allow_deferred_execution,
                data_access_role_arn: self.data_access_role_arn,
            }
        }
    }
}
impl JobExecutionSettings {
    /// Creates a new builder-style object to manufacture [`JobExecutionSettings`](crate::model::JobExecutionSettings)
    pub fn builder() -> crate::model::job_execution_settings::Builder {
        crate::model::job_execution_settings::Builder::default()
    }
}

/// <p>The object used to call your custom language model to your transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelSettings {
    /// <p>The name of your custom language model.</p>
    pub language_model_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelSettings");
        formatter.field("language_model_name", &self.language_model_name);
        formatter.finish()
    }
}
/// See [`ModelSettings`](crate::model::ModelSettings)
pub mod model_settings {
    /// A builder for [`ModelSettings`](crate::model::ModelSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your custom language model.</p>
        pub fn language_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_model_name = Some(input.into());
            self
        }
        /// <p>The name of your custom language model.</p>
        pub fn set_language_model_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelSettings`](crate::model::ModelSettings)
        pub fn build(self) -> crate::model::ModelSettings {
            crate::model::ModelSettings {
                language_model_name: self.language_model_name,
            }
        }
    }
}
impl ModelSettings {
    /// Creates a new builder-style object to manufacture [`ModelSettings`](crate::model::ModelSettings)
    pub fn builder() -> crate::model::model_settings::Builder {
        crate::model::model_settings::Builder::default()
    }
}

/// <p>Provides optional settings for the <code>StartTranscriptionJob</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Settings {
    /// <p>The name of a vocabulary to use when processing the transcription job.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>Determines whether the transcription job uses speaker recognition to identify different speakers in the input
    /// audio. Speaker recognition labels individual speakers in the audio file. If you set the <code>ShowSpeakerLabels</code>
    /// field to true, you must also set the maximum number of speaker labels <code>MaxSpeakerLabels</code> field.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
    /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
    pub show_speaker_labels: std::option::Option<bool>,
    /// <p>The maximum number of speakers to identify in the input audio. If there are more speakers in the audio than
    /// this number, multiple speakers are identified as a single speaker. If you specify the <code>MaxSpeakerLabels</code>
    /// field, you must set the <code>ShowSpeakerLabels</code> field to true.</p>
    pub max_speaker_labels: std::option::Option<i32>,
    /// <p>Instructs Amazon Transcribe to process each audio channel separately and then merge the transcription output of each
    /// channel into a single transcription. </p>
    /// <p>Amazon Transcribe also produces a transcription of each item detected on an audio channel, including the start time and
    /// end time of the item and alternative transcriptions of the item including the confidence that Amazon Transcribe has in the
    /// transcription.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
    /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
    pub channel_identification: std::option::Option<bool>,
    /// <p>Determines whether the transcription contains alternative transcriptions. If you set the
    /// <code>ShowAlternatives</code> field to true, you must also set the maximum number of alternatives to return in the
    /// <code>MaxAlternatives</code> field.</p>
    pub show_alternatives: std::option::Option<bool>,
    /// <p>The number of alternative transcriptions that the service should return. If you specify the
    /// <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code> field to true.</p>
    pub max_alternatives: std::option::Option<i32>,
    /// <p>The name of the vocabulary filter to use when transcribing the audio. The filter that you specify must have the
    /// same language code as the transcription job.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>Set to <code>mask</code> to remove filtered text from the transcript and replace it with three asterisks ("***")
    /// as placeholder text. Set to <code>remove</code> to remove filtered text from the transcript without using
    /// placeholder text. Set to <code>tag</code> to mark the word in the transcription output that matches the
    /// vocabulary filter. When you set the filter method to <code>tag</code>, the words matching your vocabulary filter
    /// are not masked or removed.</p>
    pub vocabulary_filter_method: std::option::Option<crate::model::VocabularyFilterMethod>,
}
impl std::fmt::Debug for Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Settings");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("show_speaker_labels", &self.show_speaker_labels);
        formatter.field("max_speaker_labels", &self.max_speaker_labels);
        formatter.field("channel_identification", &self.channel_identification);
        formatter.field("show_alternatives", &self.show_alternatives);
        formatter.field("max_alternatives", &self.max_alternatives);
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("vocabulary_filter_method", &self.vocabulary_filter_method);
        formatter.finish()
    }
}
/// See [`Settings`](crate::model::Settings)
pub mod settings {
    /// A builder for [`Settings`](crate::model::Settings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) show_speaker_labels: std::option::Option<bool>,
        pub(crate) max_speaker_labels: std::option::Option<i32>,
        pub(crate) channel_identification: std::option::Option<bool>,
        pub(crate) show_alternatives: std::option::Option<bool>,
        pub(crate) max_alternatives: std::option::Option<i32>,
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filter_method:
            std::option::Option<crate::model::VocabularyFilterMethod>,
    }
    impl Builder {
        /// <p>The name of a vocabulary to use when processing the transcription job.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of a vocabulary to use when processing the transcription job.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>Determines whether the transcription job uses speaker recognition to identify different speakers in the input
        /// audio. Speaker recognition labels individual speakers in the audio file. If you set the <code>ShowSpeakerLabels</code>
        /// field to true, you must also set the maximum number of speaker labels <code>MaxSpeakerLabels</code> field.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
        pub fn show_speaker_labels(mut self, input: bool) -> Self {
            self.show_speaker_labels = Some(input);
            self
        }
        /// <p>Determines whether the transcription job uses speaker recognition to identify different speakers in the input
        /// audio. Speaker recognition labels individual speakers in the audio file. If you set the <code>ShowSpeakerLabels</code>
        /// field to true, you must also set the maximum number of speaker labels <code>MaxSpeakerLabels</code> field.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
        pub fn set_show_speaker_labels(mut self, input: std::option::Option<bool>) -> Self {
            self.show_speaker_labels = input;
            self
        }
        /// <p>The maximum number of speakers to identify in the input audio. If there are more speakers in the audio than
        /// this number, multiple speakers are identified as a single speaker. If you specify the <code>MaxSpeakerLabels</code>
        /// field, you must set the <code>ShowSpeakerLabels</code> field to true.</p>
        pub fn max_speaker_labels(mut self, input: i32) -> Self {
            self.max_speaker_labels = Some(input);
            self
        }
        /// <p>The maximum number of speakers to identify in the input audio. If there are more speakers in the audio than
        /// this number, multiple speakers are identified as a single speaker. If you specify the <code>MaxSpeakerLabels</code>
        /// field, you must set the <code>ShowSpeakerLabels</code> field to true.</p>
        pub fn set_max_speaker_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.max_speaker_labels = input;
            self
        }
        /// <p>Instructs Amazon Transcribe to process each audio channel separately and then merge the transcription output of each
        /// channel into a single transcription. </p>
        /// <p>Amazon Transcribe also produces a transcription of each item detected on an audio channel, including the start time and
        /// end time of the item and alternative transcriptions of the item including the confidence that Amazon Transcribe has in the
        /// transcription.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
        pub fn channel_identification(mut self, input: bool) -> Self {
            self.channel_identification = Some(input);
            self
        }
        /// <p>Instructs Amazon Transcribe to process each audio channel separately and then merge the transcription output of each
        /// channel into a single transcription. </p>
        /// <p>Amazon Transcribe also produces a transcription of each item detected on an audio channel, including the start time and
        /// end time of the item and alternative transcriptions of the item including the confidence that Amazon Transcribe has in the
        /// transcription.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
        pub fn set_channel_identification(mut self, input: std::option::Option<bool>) -> Self {
            self.channel_identification = input;
            self
        }
        /// <p>Determines whether the transcription contains alternative transcriptions. If you set the
        /// <code>ShowAlternatives</code> field to true, you must also set the maximum number of alternatives to return in the
        /// <code>MaxAlternatives</code> field.</p>
        pub fn show_alternatives(mut self, input: bool) -> Self {
            self.show_alternatives = Some(input);
            self
        }
        /// <p>Determines whether the transcription contains alternative transcriptions. If you set the
        /// <code>ShowAlternatives</code> field to true, you must also set the maximum number of alternatives to return in the
        /// <code>MaxAlternatives</code> field.</p>
        pub fn set_show_alternatives(mut self, input: std::option::Option<bool>) -> Self {
            self.show_alternatives = input;
            self
        }
        /// <p>The number of alternative transcriptions that the service should return. If you specify the
        /// <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code> field to true.</p>
        pub fn max_alternatives(mut self, input: i32) -> Self {
            self.max_alternatives = Some(input);
            self
        }
        /// <p>The number of alternative transcriptions that the service should return. If you specify the
        /// <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code> field to true.</p>
        pub fn set_max_alternatives(mut self, input: std::option::Option<i32>) -> Self {
            self.max_alternatives = input;
            self
        }
        /// <p>The name of the vocabulary filter to use when transcribing the audio. The filter that you specify must have the
        /// same language code as the transcription job.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter to use when transcribing the audio. The filter that you specify must have the
        /// same language code as the transcription job.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>Set to <code>mask</code> to remove filtered text from the transcript and replace it with three asterisks ("***")
        /// as placeholder text. Set to <code>remove</code> to remove filtered text from the transcript without using
        /// placeholder text. Set to <code>tag</code> to mark the word in the transcription output that matches the
        /// vocabulary filter. When you set the filter method to <code>tag</code>, the words matching your vocabulary filter
        /// are not masked or removed.</p>
        pub fn vocabulary_filter_method(
            mut self,
            input: crate::model::VocabularyFilterMethod,
        ) -> Self {
            self.vocabulary_filter_method = Some(input);
            self
        }
        /// <p>Set to <code>mask</code> to remove filtered text from the transcript and replace it with three asterisks ("***")
        /// as placeholder text. Set to <code>remove</code> to remove filtered text from the transcript without using
        /// placeholder text. Set to <code>tag</code> to mark the word in the transcription output that matches the
        /// vocabulary filter. When you set the filter method to <code>tag</code>, the words matching your vocabulary filter
        /// are not masked or removed.</p>
        pub fn set_vocabulary_filter_method(
            mut self,
            input: std::option::Option<crate::model::VocabularyFilterMethod>,
        ) -> Self {
            self.vocabulary_filter_method = input;
            self
        }
        /// Consumes the builder and constructs a [`Settings`](crate::model::Settings)
        pub fn build(self) -> crate::model::Settings {
            crate::model::Settings {
                vocabulary_name: self.vocabulary_name,
                show_speaker_labels: self.show_speaker_labels,
                max_speaker_labels: self.max_speaker_labels,
                channel_identification: self.channel_identification,
                show_alternatives: self.show_alternatives,
                max_alternatives: self.max_alternatives,
                vocabulary_filter_name: self.vocabulary_filter_name,
                vocabulary_filter_method: self.vocabulary_filter_method,
            }
        }
    }
}
impl Settings {
    /// Creates a new builder-style object to manufacture [`Settings`](crate::model::Settings)
    pub fn builder() -> crate::model::settings::Builder {
        crate::model::settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyFilterMethod {
    #[allow(missing_docs)] // documentation missing in model
    Mask,
    #[allow(missing_docs)] // documentation missing in model
    Remove,
    #[allow(missing_docs)] // documentation missing in model
    Tag,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VocabularyFilterMethod {
    fn from(s: &str) -> Self {
        match s {
            "mask" => VocabularyFilterMethod::Mask,
            "remove" => VocabularyFilterMethod::Remove,
            "tag" => VocabularyFilterMethod::Tag,
            other => VocabularyFilterMethod::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VocabularyFilterMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyFilterMethod::from(s))
    }
}
impl VocabularyFilterMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyFilterMethod::Mask => "mask",
            VocabularyFilterMethod::Remove => "remove",
            VocabularyFilterMethod::Tag => "tag",
            VocabularyFilterMethod::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["mask", "remove", "tag"]
    }
}
impl AsRef<str> for VocabularyFilterMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Identifies the location of a transcription.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Transcript {
    /// <p>The S3 object location of the transcript.</p>
    /// <p>Use this URI to access the transcript. If you specified an S3 bucket in the <code>OutputBucketName</code>
    /// field when you created the job, this is the URI of that bucket. If you chose to store the transcript in Amazon Transcribe, this is a
    /// shareable URL that provides secure access to that location.</p>
    pub transcript_file_uri: std::option::Option<std::string::String>,
    /// <p>The S3 object location of the redacted transcript.</p>
    /// <p>Use this URI to access the redacted transcript. If you specified an S3 bucket in the
    /// <code>OutputBucketName</code> field when you created the job, this is the URI of that bucket. If you chose to store
    /// the transcript in Amazon Transcribe, this is a shareable URL that provides secure access to that location.</p>
    pub redacted_transcript_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Transcript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Transcript");
        formatter.field("transcript_file_uri", &self.transcript_file_uri);
        formatter.field(
            "redacted_transcript_file_uri",
            &self.redacted_transcript_file_uri,
        );
        formatter.finish()
    }
}
/// See [`Transcript`](crate::model::Transcript)
pub mod transcript {
    /// A builder for [`Transcript`](crate::model::Transcript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript_file_uri: std::option::Option<std::string::String>,
        pub(crate) redacted_transcript_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 object location of the transcript.</p>
        /// <p>Use this URI to access the transcript. If you specified an S3 bucket in the <code>OutputBucketName</code>
        /// field when you created the job, this is the URI of that bucket. If you chose to store the transcript in Amazon Transcribe, this is a
        /// shareable URL that provides secure access to that location.</p>
        pub fn transcript_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript_file_uri = Some(input.into());
            self
        }
        /// <p>The S3 object location of the transcript.</p>
        /// <p>Use this URI to access the transcript. If you specified an S3 bucket in the <code>OutputBucketName</code>
        /// field when you created the job, this is the URI of that bucket. If you chose to store the transcript in Amazon Transcribe, this is a
        /// shareable URL that provides secure access to that location.</p>
        pub fn set_transcript_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcript_file_uri = input;
            self
        }
        /// <p>The S3 object location of the redacted transcript.</p>
        /// <p>Use this URI to access the redacted transcript. If you specified an S3 bucket in the
        /// <code>OutputBucketName</code> field when you created the job, this is the URI of that bucket. If you chose to store
        /// the transcript in Amazon Transcribe, this is a shareable URL that provides secure access to that location.</p>
        pub fn redacted_transcript_file_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.redacted_transcript_file_uri = Some(input.into());
            self
        }
        /// <p>The S3 object location of the redacted transcript.</p>
        /// <p>Use this URI to access the redacted transcript. If you specified an S3 bucket in the
        /// <code>OutputBucketName</code> field when you created the job, this is the URI of that bucket. If you chose to store
        /// the transcript in Amazon Transcribe, this is a shareable URL that provides secure access to that location.</p>
        pub fn set_redacted_transcript_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.redacted_transcript_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`Transcript`](crate::model::Transcript)
        pub fn build(self) -> crate::model::Transcript {
            crate::model::Transcript {
                transcript_file_uri: self.transcript_file_uri,
                redacted_transcript_file_uri: self.redacted_transcript_file_uri,
            }
        }
    }
}
impl Transcript {
    /// Creates a new builder-style object to manufacture [`Transcript`](crate::model::Transcript)
    pub fn builder() -> crate::model::transcript::Builder {
        crate::model::transcript::Builder::default()
    }
}

/// <p>Describes the input media file in a transcription request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Media {
    /// <p>The S3 object location of the input media file. The URI must be in the same region as the API endpoint that you
    /// are calling. The general form is:</p>
    ///
    /// <p>For example:</p>
    ///
    ///
    /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
    /// Developer Guide</i>.</p>
    pub media_file_uri: std::option::Option<std::string::String>,
    /// <p> The S3 object location for your redacted output media file. This is only supported for call analytics jobs.</p>
    pub redacted_media_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Media {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Media");
        formatter.field("media_file_uri", &self.media_file_uri);
        formatter.field("redacted_media_file_uri", &self.redacted_media_file_uri);
        formatter.finish()
    }
}
/// See [`Media`](crate::model::Media)
pub mod media {
    /// A builder for [`Media`](crate::model::Media)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_file_uri: std::option::Option<std::string::String>,
        pub(crate) redacted_media_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 object location of the input media file. The URI must be in the same region as the API endpoint that you
        /// are calling. The general form is:</p>
        ///
        /// <p>For example:</p>
        ///
        ///
        /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        pub fn media_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_file_uri = Some(input.into());
            self
        }
        /// <p>The S3 object location of the input media file. The URI must be in the same region as the API endpoint that you
        /// are calling. The general form is:</p>
        ///
        /// <p>For example:</p>
        ///
        ///
        /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        pub fn set_media_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_file_uri = input;
            self
        }
        /// <p> The S3 object location for your redacted output media file. This is only supported for call analytics jobs.</p>
        pub fn redacted_media_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.redacted_media_file_uri = Some(input.into());
            self
        }
        /// <p> The S3 object location for your redacted output media file. This is only supported for call analytics jobs.</p>
        pub fn set_redacted_media_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.redacted_media_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`Media`](crate::model::Media)
        pub fn build(self) -> crate::model::Media {
            crate::model::Media {
                media_file_uri: self.media_file_uri,
                redacted_media_file_uri: self.redacted_media_file_uri,
            }
        }
    }
}
impl Media {
    /// Creates a new builder-style object to manufacture [`Media`](crate::model::Media)
    pub fn builder() -> crate::model::media::Builder {
        crate::model::media::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaFormat {
    #[allow(missing_docs)] // documentation missing in model
    Amr,
    #[allow(missing_docs)] // documentation missing in model
    Flac,
    #[allow(missing_docs)] // documentation missing in model
    Mp3,
    #[allow(missing_docs)] // documentation missing in model
    Mp4,
    #[allow(missing_docs)] // documentation missing in model
    Ogg,
    #[allow(missing_docs)] // documentation missing in model
    Wav,
    #[allow(missing_docs)] // documentation missing in model
    Webm,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MediaFormat {
    fn from(s: &str) -> Self {
        match s {
            "amr" => MediaFormat::Amr,
            "flac" => MediaFormat::Flac,
            "mp3" => MediaFormat::Mp3,
            "mp4" => MediaFormat::Mp4,
            "ogg" => MediaFormat::Ogg,
            "wav" => MediaFormat::Wav,
            "webm" => MediaFormat::Webm,
            other => MediaFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MediaFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaFormat::from(s))
    }
}
impl MediaFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaFormat::Amr => "amr",
            MediaFormat::Flac => "flac",
            MediaFormat::Mp3 => "mp3",
            MediaFormat::Mp4 => "mp4",
            MediaFormat::Ogg => "ogg",
            MediaFormat::Wav => "wav",
            MediaFormat::Webm => "webm",
            MediaFormat::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["amr", "flac", "mp3", "mp4", "ogg", "wav", "webm"]
    }
}
impl AsRef<str> for MediaFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TranscriptionJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TranscriptionJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => TranscriptionJobStatus::Completed,
            "FAILED" => TranscriptionJobStatus::Failed,
            "IN_PROGRESS" => TranscriptionJobStatus::InProgress,
            "QUEUED" => TranscriptionJobStatus::Queued,
            other => TranscriptionJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TranscriptionJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TranscriptionJobStatus::from(s))
    }
}
impl TranscriptionJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TranscriptionJobStatus::Completed => "COMPLETED",
            TranscriptionJobStatus::Failed => "FAILED",
            TranscriptionJobStatus::InProgress => "IN_PROGRESS",
            TranscriptionJobStatus::Queued => "QUEUED",
            TranscriptionJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "IN_PROGRESS", "QUEUED"]
    }
}
impl AsRef<str> for TranscriptionJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Generate subtitles for your batch transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Subtitles {
    /// <p>Specify the output format for your subtitle file.</p>
    pub formats: std::option::Option<std::vec::Vec<crate::model::SubtitleFormat>>,
}
impl std::fmt::Debug for Subtitles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Subtitles");
        formatter.field("formats", &self.formats);
        formatter.finish()
    }
}
/// See [`Subtitles`](crate::model::Subtitles)
pub mod subtitles {
    /// A builder for [`Subtitles`](crate::model::Subtitles)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) formats: std::option::Option<std::vec::Vec<crate::model::SubtitleFormat>>,
    }
    impl Builder {
        /// Appends an item to `formats`.
        ///
        /// To override the contents of this collection use [`set_formats`](Self::set_formats).
        ///
        /// <p>Specify the output format for your subtitle file.</p>
        pub fn formats(mut self, input: impl Into<crate::model::SubtitleFormat>) -> Self {
            let mut v = self.formats.unwrap_or_default();
            v.push(input.into());
            self.formats = Some(v);
            self
        }
        /// <p>Specify the output format for your subtitle file.</p>
        pub fn set_formats(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubtitleFormat>>,
        ) -> Self {
            self.formats = input;
            self
        }
        /// Consumes the builder and constructs a [`Subtitles`](crate::model::Subtitles)
        pub fn build(self) -> crate::model::Subtitles {
            crate::model::Subtitles {
                formats: self.formats,
            }
        }
    }
}
impl Subtitles {
    /// Creates a new builder-style object to manufacture [`Subtitles`](crate::model::Subtitles)
    pub fn builder() -> crate::model::subtitles::Builder {
        crate::model::subtitles::Builder::default()
    }
}

/// <p>The data structure that contains the information for a medical transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscriptionJob {
    /// <p>The name for a given medical transcription job.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
    /// <p>The completion status of a medical transcription job.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>The language code for the language spoken in the source audio file. US English (en-US) is the only supported
    /// language for medical transcriptions. Any other value you enter for language code results in a
    /// <code>BadRequestException</code> error.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the source audio containing medical information.</p>
    /// <p>If you don't specify the sample rate, Amazon Transcribe Medical determines it for you. If you choose to specify the sample rate, it
    /// must match the rate detected by Amazon Transcribe Medical. In most cases, you should leave the
    /// <code>MedicalMediaSampleHertz</code> blank and let Amazon Transcribe Medical determine the sample rate.</p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The format of the input media file.</p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>Describes the input media file in a transcription request.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>An object that contains the <code>MedicalTranscript</code>. The <code>MedicalTranscript</code> contains the
    /// <code>TranscriptFileUri</code>.</p>
    pub transcript: std::option::Option<crate::model::MedicalTranscript>,
    /// <p>A timestamp that shows when the job started processing.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field contains information
    /// about why the job failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Unsupported media format</code>- The media format specified in the
    /// <code>MediaFormat</code> field of the request isn't valid. See the description of the
    /// <code>MediaFormat</code> field for a list of valid values.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The media format provided does not match the detected media format</code>- The media format
    /// of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request.
    /// Check the media format of your media file and make sure the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid sample rate for audio file</code>- The sample rate specified in the
    /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and
    /// 48,000 Hertz.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The sample rate provided does not match the detected sample rate</code>- The sample rate in the
    /// audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the request.
    /// Check the sample rate of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid file size: file size too large</code>- The size of your audio file is larger than what Amazon Transcribe Medical can
    /// process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Guidelines and Quotas</a> in the <i>Amazon Transcribe Medical
    /// Guide</i>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid number of channels: number of channels too large</code>- Your audio contains more channels
    /// than Amazon Transcribe Medical is configured to process. To request additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe-medical.html">Amazon Transcribe Medical Endpoints and Quotas</a> in the <i>Amazon
    /// Web Services General Reference</i>
    /// </p>
    /// </li>
    /// </ul>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Object that contains  object.</p>
    pub settings: std::option::Option<crate::model::MedicalTranscriptionSetting>,
    /// <p>Shows the type of content that you've configured Amazon Transcribe Medical to identify in a transcription job. If the value is
    /// <code>PHI</code>, you've configured the job to identify personal health information (PHI) in the transcription output.</p>
    pub content_identification_type:
        std::option::Option<crate::model::MedicalContentIdentificationType>,
    /// <p>The medical specialty of any clinicians providing a dictation or having a conversation. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-medical-conversation.html">Transcribing a medical conversation</a>for a
    /// list of supported specialties.</p>
    pub specialty: std::option::Option<crate::model::Specialty>,
    /// <p>The type of speech in the transcription job. <code>CONVERSATION</code> is generally used for patient-physician
    /// dialogues. <code>DICTATION</code> is the setting for physicians speaking their notes after seeing a patient. For more
    /// information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/what-is-transcribe-med.html">What is
    /// Amazon Transcribe Medical?</a>.</p>
    pub r#type: std::option::Option<crate::model::Type>,
    /// <p>A key:value pair assigned to a given medical transcription job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for MedicalTranscriptionJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscriptionJob");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("transcript", &self.transcript);
        formatter.field("start_time", &self.start_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("settings", &self.settings);
        formatter.field(
            "content_identification_type",
            &self.content_identification_type,
        );
        formatter.field("specialty", &self.specialty);
        formatter.field("r#type", &self.r#type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
pub mod medical_transcription_job {
    /// A builder for [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) transcript: std::option::Option<crate::model::MedicalTranscript>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        pub(crate) content_identification_type:
            std::option::Option<crate::model::MedicalContentIdentificationType>,
        pub(crate) specialty: std::option::Option<crate::model::Specialty>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name for a given medical transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name for a given medical transcription job.</p>
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// <p>The completion status of a medical transcription job.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        /// <p>The completion status of a medical transcription job.</p>
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>The language code for the language spoken in the source audio file. US English (en-US) is the only supported
        /// language for medical transcriptions. Any other value you enter for language code results in a
        /// <code>BadRequestException</code> error.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the language spoken in the source audio file. US English (en-US) is the only supported
        /// language for medical transcriptions. Any other value you enter for language code results in a
        /// <code>BadRequestException</code> error.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the source audio containing medical information.</p>
        /// <p>If you don't specify the sample rate, Amazon Transcribe Medical determines it for you. If you choose to specify the sample rate, it
        /// must match the rate detected by Amazon Transcribe Medical. In most cases, you should leave the
        /// <code>MedicalMediaSampleHertz</code> blank and let Amazon Transcribe Medical determine the sample rate.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the source audio containing medical information.</p>
        /// <p>If you don't specify the sample rate, Amazon Transcribe Medical determines it for you. If you choose to specify the sample rate, it
        /// must match the rate detected by Amazon Transcribe Medical. In most cases, you should leave the
        /// <code>MedicalMediaSampleHertz</code> blank and let Amazon Transcribe Medical determine the sample rate.</p>
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>An object that contains the <code>MedicalTranscript</code>. The <code>MedicalTranscript</code> contains the
        /// <code>TranscriptFileUri</code>.</p>
        pub fn transcript(mut self, input: crate::model::MedicalTranscript) -> Self {
            self.transcript = Some(input);
            self
        }
        /// <p>An object that contains the <code>MedicalTranscript</code>. The <code>MedicalTranscript</code> contains the
        /// <code>TranscriptFileUri</code>.</p>
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field contains information
        /// about why the job failed.</p>
        /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code>- The media format specified in the
        /// <code>MediaFormat</code> field of the request isn't valid. See the description of the
        /// <code>MediaFormat</code> field for a list of valid values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media format</code>- The media format
        /// of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request.
        /// Check the media format of your media file and make sure the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code>- The sample rate specified in the
        /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and
        /// 48,000 Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code>- The sample rate in the
        /// audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the request.
        /// Check the sample rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code>- The size of your audio file is larger than what Amazon Transcribe Medical can
        /// process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Guidelines and Quotas</a> in the <i>Amazon Transcribe Medical
        /// Guide</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code>- Your audio contains more channels
        /// than Amazon Transcribe Medical is configured to process. To request additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe-medical.html">Amazon Transcribe Medical Endpoints and Quotas</a> in the <i>Amazon
        /// Web Services General Reference</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, this field contains information
        /// about why the job failed.</p>
        /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code>- The media format specified in the
        /// <code>MediaFormat</code> field of the request isn't valid. See the description of the
        /// <code>MediaFormat</code> field for a list of valid values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media format</code>- The media format
        /// of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request.
        /// Check the media format of your media file and make sure the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code>- The sample rate specified in the
        /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and
        /// 48,000 Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code>- The sample rate in the
        /// audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the request.
        /// Check the sample rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code>- The size of your audio file is larger than what Amazon Transcribe Medical can
        /// process. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/limits-guidelines.html#limits">Guidelines and Quotas</a> in the <i>Amazon Transcribe Medical
        /// Guide</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code>- Your audio contains more channels
        /// than Amazon Transcribe Medical is configured to process. To request additional channels, see <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe-medical.html">Amazon Transcribe Medical Endpoints and Quotas</a> in the <i>Amazon
        /// Web Services General Reference</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Object that contains  object.</p>
        pub fn settings(mut self, input: crate::model::MedicalTranscriptionSetting) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>Object that contains  object.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// <p>Shows the type of content that you've configured Amazon Transcribe Medical to identify in a transcription job. If the value is
        /// <code>PHI</code>, you've configured the job to identify personal health information (PHI) in the transcription output.</p>
        pub fn content_identification_type(
            mut self,
            input: crate::model::MedicalContentIdentificationType,
        ) -> Self {
            self.content_identification_type = Some(input);
            self
        }
        /// <p>Shows the type of content that you've configured Amazon Transcribe Medical to identify in a transcription job. If the value is
        /// <code>PHI</code>, you've configured the job to identify personal health information (PHI) in the transcription output.</p>
        pub fn set_content_identification_type(
            mut self,
            input: std::option::Option<crate::model::MedicalContentIdentificationType>,
        ) -> Self {
            self.content_identification_type = input;
            self
        }
        /// <p>The medical specialty of any clinicians providing a dictation or having a conversation. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-medical-conversation.html">Transcribing a medical conversation</a>for a
        /// list of supported specialties.</p>
        pub fn specialty(mut self, input: crate::model::Specialty) -> Self {
            self.specialty = Some(input);
            self
        }
        /// <p>The medical specialty of any clinicians providing a dictation or having a conversation. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-medical-conversation.html">Transcribing a medical conversation</a>for a
        /// list of supported specialties.</p>
        pub fn set_specialty(
            mut self,
            input: std::option::Option<crate::model::Specialty>,
        ) -> Self {
            self.specialty = input;
            self
        }
        /// <p>The type of speech in the transcription job. <code>CONVERSATION</code> is generally used for patient-physician
        /// dialogues. <code>DICTATION</code> is the setting for physicians speaking their notes after seeing a patient. For more
        /// information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/what-is-transcribe-med.html">What is
        /// Amazon Transcribe Medical?</a>.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of speech in the transcription job. <code>CONVERSATION</code> is generally used for patient-physician
        /// dialogues. <code>DICTATION</code> is the setting for physicians speaking their notes after seeing a patient. For more
        /// information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/what-is-transcribe-med.html">What is
        /// Amazon Transcribe Medical?</a>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A key:value pair assigned to a given medical transcription job.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A key:value pair assigned to a given medical transcription job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
        pub fn build(self) -> crate::model::MedicalTranscriptionJob {
            crate::model::MedicalTranscriptionJob {
                medical_transcription_job_name: self.medical_transcription_job_name,
                transcription_job_status: self.transcription_job_status,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                transcript: self.transcript,
                start_time: self.start_time,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
                failure_reason: self.failure_reason,
                settings: self.settings,
                content_identification_type: self.content_identification_type,
                specialty: self.specialty,
                r#type: self.r#type,
                tags: self.tags,
            }
        }
    }
}
impl MedicalTranscriptionJob {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionJob`](crate::model::MedicalTranscriptionJob)
    pub fn builder() -> crate::model::medical_transcription_job::Builder {
        crate::model::medical_transcription_job::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    Conversation,
    #[allow(missing_docs)] // documentation missing in model
    Dictation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "CONVERSATION" => Type::Conversation,
            "DICTATION" => Type::Dictation,
            other => Type::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::Conversation => "CONVERSATION",
            Type::Dictation => "DICTATION",
            Type::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CONVERSATION", "DICTATION"]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Specialty {
    #[allow(missing_docs)] // documentation missing in model
    Primarycare,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Specialty {
    fn from(s: &str) -> Self {
        match s {
            "PRIMARYCARE" => Specialty::Primarycare,
            other => Specialty::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Specialty {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Specialty::from(s))
    }
}
impl Specialty {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Specialty::Primarycare => "PRIMARYCARE",
            Specialty::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PRIMARYCARE"]
    }
}
impl AsRef<str> for Specialty {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MedicalContentIdentificationType {
    #[allow(missing_docs)] // documentation missing in model
    Phi,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MedicalContentIdentificationType {
    fn from(s: &str) -> Self {
        match s {
            "PHI" => MedicalContentIdentificationType::Phi,
            other => MedicalContentIdentificationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MedicalContentIdentificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MedicalContentIdentificationType::from(s))
    }
}
impl MedicalContentIdentificationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MedicalContentIdentificationType::Phi => "PHI",
            MedicalContentIdentificationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PHI"]
    }
}
impl AsRef<str> for MedicalContentIdentificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Optional settings for the <a>StartMedicalTranscriptionJob</a>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscriptionSetting {
    /// <p>Determines whether the transcription job uses speaker recognition to identify different speakers in the input
    /// audio. Speaker recognition labels individual speakers in the audio file. If you set the <code>ShowSpeakerLabels</code>
    /// field to true, you must also set the maximum number of speaker labels in the <code>MaxSpeakerLabels</code>
    /// field.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
    /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
    pub show_speaker_labels: std::option::Option<bool>,
    /// <p>The maximum number of speakers to identify in the input audio. If there are more speakers in the audio than this
    /// number, multiple speakers are identified as a single speaker. If you specify the <code>MaxSpeakerLabels</code> field,
    /// you must set the <code>ShowSpeakerLabels</code> field to true.</p>
    pub max_speaker_labels: std::option::Option<i32>,
    /// <p>Instructs Amazon Transcribe Medical to process each audio channel separately and then merge the transcription output of each
    /// channel into a single transcription.</p>
    /// <p>Amazon Transcribe Medical also produces a transcription of each item detected on an audio channel, including the start time and end
    /// time of the item and alternative transcriptions of item. The alternative transcriptions also come with confidence scores
    /// provided by Amazon Transcribe Medical.</p>
    /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
    /// request. If you set both, your request returns a <code>BadRequestException</code>
    /// </p>
    pub channel_identification: std::option::Option<bool>,
    /// <p>Determines whether alternative transcripts are generated along with the transcript that has the highest confidence.
    /// If you set <code>ShowAlternatives</code> field to true, you must also set the maximum number of alternatives to
    /// return in the <code>MaxAlternatives</code> field.</p>
    pub show_alternatives: std::option::Option<bool>,
    /// <p>The maximum number of alternatives that you tell the service to return. If you specify the
    /// <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code> field to true.</p>
    pub max_alternatives: std::option::Option<i32>,
    /// <p>The name of the vocabulary to use when processing a medical transcription job.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MedicalTranscriptionSetting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscriptionSetting");
        formatter.field("show_speaker_labels", &self.show_speaker_labels);
        formatter.field("max_speaker_labels", &self.max_speaker_labels);
        formatter.field("channel_identification", &self.channel_identification);
        formatter.field("show_alternatives", &self.show_alternatives);
        formatter.field("max_alternatives", &self.max_alternatives);
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}
/// See [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
pub mod medical_transcription_setting {
    /// A builder for [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) show_speaker_labels: std::option::Option<bool>,
        pub(crate) max_speaker_labels: std::option::Option<i32>,
        pub(crate) channel_identification: std::option::Option<bool>,
        pub(crate) show_alternatives: std::option::Option<bool>,
        pub(crate) max_alternatives: std::option::Option<i32>,
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines whether the transcription job uses speaker recognition to identify different speakers in the input
        /// audio. Speaker recognition labels individual speakers in the audio file. If you set the <code>ShowSpeakerLabels</code>
        /// field to true, you must also set the maximum number of speaker labels in the <code>MaxSpeakerLabels</code>
        /// field.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
        pub fn show_speaker_labels(mut self, input: bool) -> Self {
            self.show_speaker_labels = Some(input);
            self
        }
        /// <p>Determines whether the transcription job uses speaker recognition to identify different speakers in the input
        /// audio. Speaker recognition labels individual speakers in the audio file. If you set the <code>ShowSpeakerLabels</code>
        /// field to true, you must also set the maximum number of speaker labels in the <code>MaxSpeakerLabels</code>
        /// field.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>.</p>
        pub fn set_show_speaker_labels(mut self, input: std::option::Option<bool>) -> Self {
            self.show_speaker_labels = input;
            self
        }
        /// <p>The maximum number of speakers to identify in the input audio. If there are more speakers in the audio than this
        /// number, multiple speakers are identified as a single speaker. If you specify the <code>MaxSpeakerLabels</code> field,
        /// you must set the <code>ShowSpeakerLabels</code> field to true.</p>
        pub fn max_speaker_labels(mut self, input: i32) -> Self {
            self.max_speaker_labels = Some(input);
            self
        }
        /// <p>The maximum number of speakers to identify in the input audio. If there are more speakers in the audio than this
        /// number, multiple speakers are identified as a single speaker. If you specify the <code>MaxSpeakerLabels</code> field,
        /// you must set the <code>ShowSpeakerLabels</code> field to true.</p>
        pub fn set_max_speaker_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.max_speaker_labels = input;
            self
        }
        /// <p>Instructs Amazon Transcribe Medical to process each audio channel separately and then merge the transcription output of each
        /// channel into a single transcription.</p>
        /// <p>Amazon Transcribe Medical also produces a transcription of each item detected on an audio channel, including the start time and end
        /// time of the item and alternative transcriptions of item. The alternative transcriptions also come with confidence scores
        /// provided by Amazon Transcribe Medical.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>
        /// </p>
        pub fn channel_identification(mut self, input: bool) -> Self {
            self.channel_identification = Some(input);
            self
        }
        /// <p>Instructs Amazon Transcribe Medical to process each audio channel separately and then merge the transcription output of each
        /// channel into a single transcription.</p>
        /// <p>Amazon Transcribe Medical also produces a transcription of each item detected on an audio channel, including the start time and end
        /// time of the item and alternative transcriptions of item. The alternative transcriptions also come with confidence scores
        /// provided by Amazon Transcribe Medical.</p>
        /// <p>You can't set both <code>ShowSpeakerLabels</code> and <code>ChannelIdentification</code> in the same
        /// request. If you set both, your request returns a <code>BadRequestException</code>
        /// </p>
        pub fn set_channel_identification(mut self, input: std::option::Option<bool>) -> Self {
            self.channel_identification = input;
            self
        }
        /// <p>Determines whether alternative transcripts are generated along with the transcript that has the highest confidence.
        /// If you set <code>ShowAlternatives</code> field to true, you must also set the maximum number of alternatives to
        /// return in the <code>MaxAlternatives</code> field.</p>
        pub fn show_alternatives(mut self, input: bool) -> Self {
            self.show_alternatives = Some(input);
            self
        }
        /// <p>Determines whether alternative transcripts are generated along with the transcript that has the highest confidence.
        /// If you set <code>ShowAlternatives</code> field to true, you must also set the maximum number of alternatives to
        /// return in the <code>MaxAlternatives</code> field.</p>
        pub fn set_show_alternatives(mut self, input: std::option::Option<bool>) -> Self {
            self.show_alternatives = input;
            self
        }
        /// <p>The maximum number of alternatives that you tell the service to return. If you specify the
        /// <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code> field to true.</p>
        pub fn max_alternatives(mut self, input: i32) -> Self {
            self.max_alternatives = Some(input);
            self
        }
        /// <p>The maximum number of alternatives that you tell the service to return. If you specify the
        /// <code>MaxAlternatives</code> field, you must set the <code>ShowAlternatives</code> field to true.</p>
        pub fn set_max_alternatives(mut self, input: std::option::Option<i32>) -> Self {
            self.max_alternatives = input;
            self
        }
        /// <p>The name of the vocabulary to use when processing a medical transcription job.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary to use when processing a medical transcription job.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
        pub fn build(self) -> crate::model::MedicalTranscriptionSetting {
            crate::model::MedicalTranscriptionSetting {
                show_speaker_labels: self.show_speaker_labels,
                max_speaker_labels: self.max_speaker_labels,
                channel_identification: self.channel_identification,
                show_alternatives: self.show_alternatives,
                max_alternatives: self.max_alternatives,
                vocabulary_name: self.vocabulary_name,
            }
        }
    }
}
impl MedicalTranscriptionSetting {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionSetting`](crate::model::MedicalTranscriptionSetting)
    pub fn builder() -> crate::model::medical_transcription_setting::Builder {
        crate::model::medical_transcription_setting::Builder::default()
    }
}

/// <p>Identifies the location of a medical transcript.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscript {
    /// <p>The S3 object location of the medical transcript.</p>
    /// <p>Use this URI to access the medical transcript. This URI points to the S3 bucket you created to store the medical
    /// transcript.</p>
    pub transcript_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MedicalTranscript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscript");
        formatter.field("transcript_file_uri", &self.transcript_file_uri);
        formatter.finish()
    }
}
/// See [`MedicalTranscript`](crate::model::MedicalTranscript)
pub mod medical_transcript {
    /// A builder for [`MedicalTranscript`](crate::model::MedicalTranscript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 object location of the medical transcript.</p>
        /// <p>Use this URI to access the medical transcript. This URI points to the S3 bucket you created to store the medical
        /// transcript.</p>
        pub fn transcript_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript_file_uri = Some(input.into());
            self
        }
        /// <p>The S3 object location of the medical transcript.</p>
        /// <p>Use this URI to access the medical transcript. This URI points to the S3 bucket you created to store the medical
        /// transcript.</p>
        pub fn set_transcript_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcript_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscript`](crate::model::MedicalTranscript)
        pub fn build(self) -> crate::model::MedicalTranscript {
            crate::model::MedicalTranscript {
                transcript_file_uri: self.transcript_file_uri,
            }
        }
    }
}
impl MedicalTranscript {
    /// Creates a new builder-style object to manufacture [`MedicalTranscript`](crate::model::MedicalTranscript)
    pub fn builder() -> crate::model::medical_transcript::Builder {
        crate::model::medical_transcript::Builder::default()
    }
}

/// <p>Describes an asynchronous analytics job that was created with the <code>StartAnalyticsJob</code>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CallAnalyticsJob {
    /// <p>The name of the call analytics job.</p>
    pub call_analytics_job_name: std::option::Option<std::string::String>,
    /// <p>The status of the analytics job.</p>
    pub call_analytics_job_status: std::option::Option<crate::model::CallAnalyticsJobStatus>,
    /// <p>If you know the language spoken between the customer and the agent, specify a language code for this field.</p>
    /// <p>If you don't know the language, you can leave this field blank, and Amazon Transcribe will use machine learning to automatically
    /// identify the language. To improve the accuracy of language identification, you can provide an array containing the
    /// possible language codes for the language spoken in your audio. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html">Supported languages and language-specific features</a> for
    /// additional information.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the audio.</p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The format of the input audio file. Note: for call analytics jobs, only the following media formats are supported: MP3,
    /// MP4, WAV, FLAC, OGG, and WebM. </p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>Describes the input media file in a transcription request.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>Identifies the location of a transcription.</p>
    pub transcript: std::option::Option<crate::model::Transcript>,
    /// <p>A timestamp that shows when the analytics job started processing.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the analytics job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the analytics job was completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>AnalyticsJobStatus</code> is <code>FAILED</code>, this field contains information about why
    /// the job failed.</p>
    /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Unsupported media format</code>: The media format specified in the
    /// <code>MediaFormat</code> field of the request isn't valid. See the description of the <code>MediaFormat</code>
    /// field for a list of valid values.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The media format provided does not match the detected media format</code>: The media
    /// format of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request.
    /// Check the media format of your media file and make sure the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid sample rate for audio file</code>: The sample rate specified in the
    /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and 48,000
    /// Hertz.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>The sample rate provided does not match the detected sample rate</code>: The sample rate
    /// in the audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the
    /// request. Check the sample rate of your media file and make sure that the two values match.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid file size: file size too large</code>: The size of your audio file is larger than what Amazon Transcribe Medical
    /// can process. For more information, see <i>Guidelines and Quotas</i> in the Amazon Transcribe Medical
    /// Guide.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Invalid number of channels: number of channels too large</code>: Your audio contains more
    /// channels than Amazon Transcribe Medical is configured to process. To request additional channels, see Amazon Transcribe Medical Endpoints and Quotas in the
    /// <a href="https://docs.aws.amazon.com/general/latest/gr/Welcome.html">Amazon Web Services General
    /// Reference</a>.</p>
    /// </li>
    /// </ul>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Number (ARN) that you use to access the analytics job. ARNs have the format
    /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>.</p>
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in the source audio. This value
    /// appears only when you don't provide a single language code. Larger values indicate that Amazon Transcribe has higher confidence in
    /// the language that it identified</p>
    pub identified_language_score: std::option::Option<f32>,
    /// <p>Provides information about the settings used to run a transcription job.</p>
    pub settings: std::option::Option<crate::model::CallAnalyticsJobSettings>,
    /// <p>Shows numeric values to indicate the channel assigned to the agent's audio and the channel assigned to the
    /// customer's audio. </p>
    pub channel_definitions: std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
}
impl std::fmt::Debug for CallAnalyticsJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CallAnalyticsJob");
        formatter.field("call_analytics_job_name", &self.call_analytics_job_name);
        formatter.field("call_analytics_job_status", &self.call_analytics_job_status);
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("transcript", &self.transcript);
        formatter.field("start_time", &self.start_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.field("identified_language_score", &self.identified_language_score);
        formatter.field("settings", &self.settings);
        formatter.field("channel_definitions", &self.channel_definitions);
        formatter.finish()
    }
}
/// See [`CallAnalyticsJob`](crate::model::CallAnalyticsJob)
pub mod call_analytics_job {
    /// A builder for [`CallAnalyticsJob`](crate::model::CallAnalyticsJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job_name: std::option::Option<std::string::String>,
        pub(crate) call_analytics_job_status:
            std::option::Option<crate::model::CallAnalyticsJobStatus>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) transcript: std::option::Option<crate::model::Transcript>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) identified_language_score: std::option::Option<f32>,
        pub(crate) settings: std::option::Option<crate::model::CallAnalyticsJobSettings>,
        pub(crate) channel_definitions:
            std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
    }
    impl Builder {
        /// <p>The name of the call analytics job.</p>
        pub fn call_analytics_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.call_analytics_job_name = Some(input.into());
            self
        }
        /// <p>The name of the call analytics job.</p>
        pub fn set_call_analytics_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.call_analytics_job_name = input;
            self
        }
        /// <p>The status of the analytics job.</p>
        pub fn call_analytics_job_status(
            mut self,
            input: crate::model::CallAnalyticsJobStatus,
        ) -> Self {
            self.call_analytics_job_status = Some(input);
            self
        }
        /// <p>The status of the analytics job.</p>
        pub fn set_call_analytics_job_status(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJobStatus>,
        ) -> Self {
            self.call_analytics_job_status = input;
            self
        }
        /// <p>If you know the language spoken between the customer and the agent, specify a language code for this field.</p>
        /// <p>If you don't know the language, you can leave this field blank, and Amazon Transcribe will use machine learning to automatically
        /// identify the language. To improve the accuracy of language identification, you can provide an array containing the
        /// possible language codes for the language spoken in your audio. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html">Supported languages and language-specific features</a> for
        /// additional information.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>If you know the language spoken between the customer and the agent, specify a language code for this field.</p>
        /// <p>If you don't know the language, you can leave this field blank, and Amazon Transcribe will use machine learning to automatically
        /// identify the language. To improve the accuracy of language identification, you can provide an array containing the
        /// possible language codes for the language spoken in your audio. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html">Supported languages and language-specific features</a> for
        /// additional information.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the audio.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the audio.</p>
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The format of the input audio file. Note: for call analytics jobs, only the following media formats are supported: MP3,
        /// MP4, WAV, FLAC, OGG, and WebM. </p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        /// <p>The format of the input audio file. Note: for call analytics jobs, only the following media formats are supported: MP3,
        /// MP4, WAV, FLAC, OGG, and WebM. </p>
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>Identifies the location of a transcription.</p>
        pub fn transcript(mut self, input: crate::model::Transcript) -> Self {
            self.transcript = Some(input);
            self
        }
        /// <p>Identifies the location of a transcription.</p>
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::Transcript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// <p>A timestamp that shows when the analytics job started processing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the analytics job started processing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the analytics job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the analytics job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the analytics job was completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the analytics job was completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>If the <code>AnalyticsJobStatus</code> is <code>FAILED</code>, this field contains information about why
        /// the job failed.</p>
        /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code>: The media format specified in the
        /// <code>MediaFormat</code> field of the request isn't valid. See the description of the <code>MediaFormat</code>
        /// field for a list of valid values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media format</code>: The media
        /// format of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request.
        /// Check the media format of your media file and make sure the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code>: The sample rate specified in the
        /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and 48,000
        /// Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code>: The sample rate
        /// in the audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the
        /// request. Check the sample rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code>: The size of your audio file is larger than what Amazon Transcribe Medical
        /// can process. For more information, see <i>Guidelines and Quotas</i> in the Amazon Transcribe Medical
        /// Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code>: Your audio contains more
        /// channels than Amazon Transcribe Medical is configured to process. To request additional channels, see Amazon Transcribe Medical Endpoints and Quotas in the
        /// <a href="https://docs.aws.amazon.com/general/latest/gr/Welcome.html">Amazon Web Services General
        /// Reference</a>.</p>
        /// </li>
        /// </ul>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>AnalyticsJobStatus</code> is <code>FAILED</code>, this field contains information about why
        /// the job failed.</p>
        /// <p>The <code>FailureReason</code> field can contain one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Unsupported media format</code>: The media format specified in the
        /// <code>MediaFormat</code> field of the request isn't valid. See the description of the <code>MediaFormat</code>
        /// field for a list of valid values.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The media format provided does not match the detected media format</code>: The media
        /// format of the audio file doesn't match the format specified in the <code>MediaFormat</code> field in the request.
        /// Check the media format of your media file and make sure the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid sample rate for audio file</code>: The sample rate specified in the
        /// <code>MediaSampleRateHertz</code> of the request isn't valid. The sample rate must be between 8,000 and 48,000
        /// Hertz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>The sample rate provided does not match the detected sample rate</code>: The sample rate
        /// in the audio file doesn't match the sample rate specified in the <code>MediaSampleRateHertz</code> field in the
        /// request. Check the sample rate of your media file and make sure that the two values match.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid file size: file size too large</code>: The size of your audio file is larger than what Amazon Transcribe Medical
        /// can process. For more information, see <i>Guidelines and Quotas</i> in the Amazon Transcribe Medical
        /// Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invalid number of channels: number of channels too large</code>: Your audio contains more
        /// channels than Amazon Transcribe Medical is configured to process. To request additional channels, see Amazon Transcribe Medical Endpoints and Quotas in the
        /// <a href="https://docs.aws.amazon.com/general/latest/gr/Welcome.html">Amazon Web Services General
        /// Reference</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The Amazon Resource Number (ARN) that you use to access the analytics job. ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) that you use to access the analytics job. ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in the source audio. This value
        /// appears only when you don't provide a single language code. Larger values indicate that Amazon Transcribe has higher confidence in
        /// the language that it identified</p>
        pub fn identified_language_score(mut self, input: f32) -> Self {
            self.identified_language_score = Some(input);
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language that it identified in the source audio. This value
        /// appears only when you don't provide a single language code. Larger values indicate that Amazon Transcribe has higher confidence in
        /// the language that it identified</p>
        pub fn set_identified_language_score(mut self, input: std::option::Option<f32>) -> Self {
            self.identified_language_score = input;
            self
        }
        /// <p>Provides information about the settings used to run a transcription job.</p>
        pub fn settings(mut self, input: crate::model::CallAnalyticsJobSettings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>Provides information about the settings used to run a transcription job.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJobSettings>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// Appends an item to `channel_definitions`.
        ///
        /// To override the contents of this collection use [`set_channel_definitions`](Self::set_channel_definitions).
        ///
        /// <p>Shows numeric values to indicate the channel assigned to the agent's audio and the channel assigned to the
        /// customer's audio. </p>
        pub fn channel_definitions(
            mut self,
            input: impl Into<crate::model::ChannelDefinition>,
        ) -> Self {
            let mut v = self.channel_definitions.unwrap_or_default();
            v.push(input.into());
            self.channel_definitions = Some(v);
            self
        }
        /// <p>Shows numeric values to indicate the channel assigned to the agent's audio and the channel assigned to the
        /// customer's audio. </p>
        pub fn set_channel_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
        ) -> Self {
            self.channel_definitions = input;
            self
        }
        /// Consumes the builder and constructs a [`CallAnalyticsJob`](crate::model::CallAnalyticsJob)
        pub fn build(self) -> crate::model::CallAnalyticsJob {
            crate::model::CallAnalyticsJob {
                call_analytics_job_name: self.call_analytics_job_name,
                call_analytics_job_status: self.call_analytics_job_status,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                transcript: self.transcript,
                start_time: self.start_time,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
                failure_reason: self.failure_reason,
                data_access_role_arn: self.data_access_role_arn,
                identified_language_score: self.identified_language_score,
                settings: self.settings,
                channel_definitions: self.channel_definitions,
            }
        }
    }
}
impl CallAnalyticsJob {
    /// Creates a new builder-style object to manufacture [`CallAnalyticsJob`](crate::model::CallAnalyticsJob)
    pub fn builder() -> crate::model::call_analytics_job::Builder {
        crate::model::call_analytics_job::Builder::default()
    }
}

/// <p>For a call analytics job, an object that indicates the audio channel that belongs to the agent and the audio
/// channel that belongs to the customer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChannelDefinition {
    /// <p>A value that indicates the audio channel.</p>
    pub channel_id: i32,
    /// <p>Indicates whether the person speaking on the audio channel is the agent or customer.</p>
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
}
impl std::fmt::Debug for ChannelDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChannelDefinition");
        formatter.field("channel_id", &self.channel_id);
        formatter.field("participant_role", &self.participant_role);
        formatter.finish()
    }
}
/// See [`ChannelDefinition`](crate::model::ChannelDefinition)
pub mod channel_definition {
    /// A builder for [`ChannelDefinition`](crate::model::ChannelDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_id: std::option::Option<i32>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
    }
    impl Builder {
        /// <p>A value that indicates the audio channel.</p>
        pub fn channel_id(mut self, input: i32) -> Self {
            self.channel_id = Some(input);
            self
        }
        /// <p>A value that indicates the audio channel.</p>
        pub fn set_channel_id(mut self, input: std::option::Option<i32>) -> Self {
            self.channel_id = input;
            self
        }
        /// <p>Indicates whether the person speaking on the audio channel is the agent or customer.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>Indicates whether the person speaking on the audio channel is the agent or customer.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelDefinition`](crate::model::ChannelDefinition)
        pub fn build(self) -> crate::model::ChannelDefinition {
            crate::model::ChannelDefinition {
                channel_id: self.channel_id.unwrap_or_default(),
                participant_role: self.participant_role,
            }
        }
    }
}
impl ChannelDefinition {
    /// Creates a new builder-style object to manufacture [`ChannelDefinition`](crate::model::ChannelDefinition)
    pub fn builder() -> crate::model::channel_definition::Builder {
        crate::model::channel_definition::Builder::default()
    }
}

/// <p>Provides optional settings for the <code>CallAnalyticsJob</code> operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CallAnalyticsJobSettings {
    /// <p>The name of a vocabulary to use when processing the call analytics job.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The name of the vocabulary filter to use when running a call analytics job. The filter that you specify must have the
    /// same language code as the analytics job.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>Set to mask to remove filtered text from the transcript and replace it with three asterisks ("***") as placeholder text.
    /// Set to <code>remove</code> to remove filtered text from the transcript without using placeholder text. Set to
    /// <code>tag</code> to mark the word in the transcription output that matches the vocabulary filter. When you set the
    /// filter method to <code>tag</code>, the words matching your vocabulary filter are not masked or removed.</p>
    pub vocabulary_filter_method: std::option::Option<crate::model::VocabularyFilterMethod>,
    /// <p>The structure used to describe a custom language model.</p>
    pub language_model_name: std::option::Option<std::string::String>,
    /// <p>Settings for content redaction within a transcription job.</p>
    pub content_redaction: std::option::Option<crate::model::ContentRedaction>,
    /// <p>When you run a call analytics job, you can specify the language spoken in the audio, or you can have Amazon Transcribe identify
    /// the language for you.</p>
    /// <p>To specify a language, specify an array with one language code. If you don't know the language, you can leave this
    /// field blank and Amazon Transcribe will use machine learning to identify the language for you. To improve the ability of Amazon Transcribe to
    /// correctly identify the language, you can provide an array of the languages that can be present in the audio. Refer to
    /// <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html">Supported languages and language-specific
    /// features</a> for additional information.</p>
    pub language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
    /// <p>The language identification settings associated with your call analytics job. These settings include
    /// <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
    /// <code>LanguageModelName</code>.</p>
    pub language_id_settings: std::option::Option<
        std::collections::HashMap<crate::model::LanguageCode, crate::model::LanguageIdSettings>,
    >,
}
impl std::fmt::Debug for CallAnalyticsJobSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CallAnalyticsJobSettings");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("vocabulary_filter_method", &self.vocabulary_filter_method);
        formatter.field("language_model_name", &self.language_model_name);
        formatter.field("content_redaction", &self.content_redaction);
        formatter.field("language_options", &self.language_options);
        formatter.field("language_id_settings", &self.language_id_settings);
        formatter.finish()
    }
}
/// See [`CallAnalyticsJobSettings`](crate::model::CallAnalyticsJobSettings)
pub mod call_analytics_job_settings {
    /// A builder for [`CallAnalyticsJobSettings`](crate::model::CallAnalyticsJobSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filter_method:
            std::option::Option<crate::model::VocabularyFilterMethod>,
        pub(crate) language_model_name: std::option::Option<std::string::String>,
        pub(crate) content_redaction: std::option::Option<crate::model::ContentRedaction>,
        pub(crate) language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        pub(crate) language_id_settings: std::option::Option<
            std::collections::HashMap<crate::model::LanguageCode, crate::model::LanguageIdSettings>,
        >,
    }
    impl Builder {
        /// <p>The name of a vocabulary to use when processing the call analytics job.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of a vocabulary to use when processing the call analytics job.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The name of the vocabulary filter to use when running a call analytics job. The filter that you specify must have the
        /// same language code as the analytics job.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter to use when running a call analytics job. The filter that you specify must have the
        /// same language code as the analytics job.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>Set to mask to remove filtered text from the transcript and replace it with three asterisks ("***") as placeholder text.
        /// Set to <code>remove</code> to remove filtered text from the transcript without using placeholder text. Set to
        /// <code>tag</code> to mark the word in the transcription output that matches the vocabulary filter. When you set the
        /// filter method to <code>tag</code>, the words matching your vocabulary filter are not masked or removed.</p>
        pub fn vocabulary_filter_method(
            mut self,
            input: crate::model::VocabularyFilterMethod,
        ) -> Self {
            self.vocabulary_filter_method = Some(input);
            self
        }
        /// <p>Set to mask to remove filtered text from the transcript and replace it with three asterisks ("***") as placeholder text.
        /// Set to <code>remove</code> to remove filtered text from the transcript without using placeholder text. Set to
        /// <code>tag</code> to mark the word in the transcription output that matches the vocabulary filter. When you set the
        /// filter method to <code>tag</code>, the words matching your vocabulary filter are not masked or removed.</p>
        pub fn set_vocabulary_filter_method(
            mut self,
            input: std::option::Option<crate::model::VocabularyFilterMethod>,
        ) -> Self {
            self.vocabulary_filter_method = input;
            self
        }
        /// <p>The structure used to describe a custom language model.</p>
        pub fn language_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_model_name = Some(input.into());
            self
        }
        /// <p>The structure used to describe a custom language model.</p>
        pub fn set_language_model_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_model_name = input;
            self
        }
        /// <p>Settings for content redaction within a transcription job.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.content_redaction = Some(input);
            self
        }
        /// <p>Settings for content redaction within a transcription job.</p>
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.content_redaction = input;
            self
        }
        /// Appends an item to `language_options`.
        ///
        /// To override the contents of this collection use [`set_language_options`](Self::set_language_options).
        ///
        /// <p>When you run a call analytics job, you can specify the language spoken in the audio, or you can have Amazon Transcribe identify
        /// the language for you.</p>
        /// <p>To specify a language, specify an array with one language code. If you don't know the language, you can leave this
        /// field blank and Amazon Transcribe will use machine learning to identify the language for you. To improve the ability of Amazon Transcribe to
        /// correctly identify the language, you can provide an array of the languages that can be present in the audio. Refer to
        /// <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html">Supported languages and language-specific
        /// features</a> for additional information.</p>
        pub fn language_options(mut self, input: impl Into<crate::model::LanguageCode>) -> Self {
            let mut v = self.language_options.unwrap_or_default();
            v.push(input.into());
            self.language_options = Some(v);
            self
        }
        /// <p>When you run a call analytics job, you can specify the language spoken in the audio, or you can have Amazon Transcribe identify
        /// the language for you.</p>
        /// <p>To specify a language, specify an array with one language code. If you don't know the language, you can leave this
        /// field blank and Amazon Transcribe will use machine learning to identify the language for you. To improve the ability of Amazon Transcribe to
        /// correctly identify the language, you can provide an array of the languages that can be present in the audio. Refer to
        /// <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html">Supported languages and language-specific
        /// features</a> for additional information.</p>
        pub fn set_language_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.language_options = input;
            self
        }
        /// Adds a key-value pair to `language_id_settings`.
        ///
        /// To override the contents of this collection use [`set_language_id_settings`](Self::set_language_id_settings).
        ///
        /// <p>The language identification settings associated with your call analytics job. These settings include
        /// <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
        /// <code>LanguageModelName</code>.</p>
        pub fn language_id_settings(
            mut self,
            k: impl Into<crate::model::LanguageCode>,
            v: impl Into<crate::model::LanguageIdSettings>,
        ) -> Self {
            let mut hash_map = self.language_id_settings.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.language_id_settings = Some(hash_map);
            self
        }
        /// <p>The language identification settings associated with your call analytics job. These settings include
        /// <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
        /// <code>LanguageModelName</code>.</p>
        pub fn set_language_id_settings(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::LanguageCode,
                    crate::model::LanguageIdSettings,
                >,
            >,
        ) -> Self {
            self.language_id_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`CallAnalyticsJobSettings`](crate::model::CallAnalyticsJobSettings)
        pub fn build(self) -> crate::model::CallAnalyticsJobSettings {
            crate::model::CallAnalyticsJobSettings {
                vocabulary_name: self.vocabulary_name,
                vocabulary_filter_name: self.vocabulary_filter_name,
                vocabulary_filter_method: self.vocabulary_filter_method,
                language_model_name: self.language_model_name,
                content_redaction: self.content_redaction,
                language_options: self.language_options,
                language_id_settings: self.language_id_settings,
            }
        }
    }
}
impl CallAnalyticsJobSettings {
    /// Creates a new builder-style object to manufacture [`CallAnalyticsJobSettings`](crate::model::CallAnalyticsJobSettings)
    pub fn builder() -> crate::model::call_analytics_job_settings::Builder {
        crate::model::call_analytics_job_settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CallAnalyticsJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CallAnalyticsJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => CallAnalyticsJobStatus::Completed,
            "FAILED" => CallAnalyticsJobStatus::Failed,
            "IN_PROGRESS" => CallAnalyticsJobStatus::InProgress,
            "QUEUED" => CallAnalyticsJobStatus::Queued,
            other => CallAnalyticsJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CallAnalyticsJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CallAnalyticsJobStatus::from(s))
    }
}
impl CallAnalyticsJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CallAnalyticsJobStatus::Completed => "COMPLETED",
            CallAnalyticsJobStatus::Failed => "FAILED",
            CallAnalyticsJobStatus::InProgress => "IN_PROGRESS",
            CallAnalyticsJobStatus::Queued => "QUEUED",
            CallAnalyticsJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "IN_PROGRESS", "QUEUED"]
    }
}
impl AsRef<str> for CallAnalyticsJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about a vocabulary filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VocabularyFilterInfo {
    /// <p>The name of the vocabulary filter. The name must be unique in the account that holds the filter.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The language code of the words in the vocabulary filter.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary was last updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for VocabularyFilterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VocabularyFilterInfo");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
pub mod vocabulary_filter_info {
    /// A builder for [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter. The name must be unique in the account that holds the filter.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter. The name must be unique in the account that holds the filter.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary was last updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was last updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
        pub fn build(self) -> crate::model::VocabularyFilterInfo {
            crate::model::VocabularyFilterInfo {
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl VocabularyFilterInfo {
    /// Creates a new builder-style object to manufacture [`VocabularyFilterInfo`](crate::model::VocabularyFilterInfo)
    pub fn builder() -> crate::model::vocabulary_filter_info::Builder {
        crate::model::vocabulary_filter_info::Builder::default()
    }
}

/// <p>Provides information about a custom vocabulary. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VocabularyInfo {
    /// <p>The name of the vocabulary.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The processing state of the vocabulary. If the state is <code>READY</code> you can use
    /// the vocabulary in a <code>StartTranscriptionJob</code> request.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
}
impl std::fmt::Debug for VocabularyInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VocabularyInfo");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.finish()
    }
}
/// See [`VocabularyInfo`](crate::model::VocabularyInfo)
pub mod vocabulary_info {
    /// A builder for [`VocabularyInfo`](crate::model::VocabularyInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    }
    impl Builder {
        /// <p>The name of the vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The processing state of the vocabulary. If the state is <code>READY</code> you can use
        /// the vocabulary in a <code>StartTranscriptionJob</code> request.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of the vocabulary. If the state is <code>READY</code> you can use
        /// the vocabulary in a <code>StartTranscriptionJob</code> request.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// Consumes the builder and constructs a [`VocabularyInfo`](crate::model::VocabularyInfo)
        pub fn build(self) -> crate::model::VocabularyInfo {
            crate::model::VocabularyInfo {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
                vocabulary_state: self.vocabulary_state,
            }
        }
    }
}
impl VocabularyInfo {
    /// Creates a new builder-style object to manufacture [`VocabularyInfo`](crate::model::VocabularyInfo)
    pub fn builder() -> crate::model::vocabulary_info::Builder {
        crate::model::vocabulary_info::Builder::default()
    }
}

/// <p>Provides a summary of information about a transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TranscriptionJobSummary {
    /// <p>The name of the transcription job.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job started processing.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The language code for the input speech.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The status of the transcription job. When the status is <code>COMPLETED</code>, use the
    /// <code>GetTranscriptionJob</code> operation to get the results of the transcription.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Indicates the location of the output of the transcription job.</p>
    /// <p>If the value is <code>CUSTOMER_BUCKET</code> then the location is the S3 bucket specified in the
    /// <code>outputBucketName</code> field when the transcription job was started with the
    /// <code>StartTranscriptionJob</code> operation.</p>
    /// <p>If the value is <code>SERVICE_BUCKET</code> then the output is stored by Amazon Transcribe and can be retrieved using
    /// the URI in the <code>GetTranscriptionJob</code> response's <code>TranscriptFileUri</code> field.</p>
    pub output_location_type: std::option::Option<crate::model::OutputLocationType>,
    /// <p>The content redaction settings of the transcription job.</p>
    pub content_redaction: std::option::Option<crate::model::ContentRedaction>,
    /// <p>The object used to call your custom language model to your transcription job.</p>
    pub model_settings: std::option::Option<crate::model::ModelSettings>,
    /// <p>Whether automatic language identification was enabled for a transcription job.</p>
    pub identify_language: std::option::Option<bool>,
    /// <p>A value between zero and one that Amazon Transcribe assigned to the language it identified in the source audio. A higher
    /// score indicates that Amazon Transcribe is more confident in the language it identified.</p>
    pub identified_language_score: std::option::Option<f32>,
}
impl std::fmt::Debug for TranscriptionJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TranscriptionJobSummary");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("output_location_type", &self.output_location_type);
        formatter.field("content_redaction", &self.content_redaction);
        formatter.field("model_settings", &self.model_settings);
        formatter.field("identify_language", &self.identify_language);
        formatter.field("identified_language_score", &self.identified_language_score);
        formatter.finish()
    }
}
/// See [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
pub mod transcription_job_summary {
    /// A builder for [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) output_location_type: std::option::Option<crate::model::OutputLocationType>,
        pub(crate) content_redaction: std::option::Option<crate::model::ContentRedaction>,
        pub(crate) model_settings: std::option::Option<crate::model::ModelSettings>,
        pub(crate) identify_language: std::option::Option<bool>,
        pub(crate) identified_language_score: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The name of the transcription job.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the transcription job.</p>
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job started processing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The language code for the input speech.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the input speech.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The status of the transcription job. When the status is <code>COMPLETED</code>, use the
        /// <code>GetTranscriptionJob</code> operation to get the results of the transcription.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        /// <p>The status of the transcription job. When the status is <code>COMPLETED</code>, use the
        /// <code>GetTranscriptionJob</code> operation to get the results of the transcription.</p>
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description of the error.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Indicates the location of the output of the transcription job.</p>
        /// <p>If the value is <code>CUSTOMER_BUCKET</code> then the location is the S3 bucket specified in the
        /// <code>outputBucketName</code> field when the transcription job was started with the
        /// <code>StartTranscriptionJob</code> operation.</p>
        /// <p>If the value is <code>SERVICE_BUCKET</code> then the output is stored by Amazon Transcribe and can be retrieved using
        /// the URI in the <code>GetTranscriptionJob</code> response's <code>TranscriptFileUri</code> field.</p>
        pub fn output_location_type(mut self, input: crate::model::OutputLocationType) -> Self {
            self.output_location_type = Some(input);
            self
        }
        /// <p>Indicates the location of the output of the transcription job.</p>
        /// <p>If the value is <code>CUSTOMER_BUCKET</code> then the location is the S3 bucket specified in the
        /// <code>outputBucketName</code> field when the transcription job was started with the
        /// <code>StartTranscriptionJob</code> operation.</p>
        /// <p>If the value is <code>SERVICE_BUCKET</code> then the output is stored by Amazon Transcribe and can be retrieved using
        /// the URI in the <code>GetTranscriptionJob</code> response's <code>TranscriptFileUri</code> field.</p>
        pub fn set_output_location_type(
            mut self,
            input: std::option::Option<crate::model::OutputLocationType>,
        ) -> Self {
            self.output_location_type = input;
            self
        }
        /// <p>The content redaction settings of the transcription job.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.content_redaction = Some(input);
            self
        }
        /// <p>The content redaction settings of the transcription job.</p>
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.content_redaction = input;
            self
        }
        /// <p>The object used to call your custom language model to your transcription job.</p>
        pub fn model_settings(mut self, input: crate::model::ModelSettings) -> Self {
            self.model_settings = Some(input);
            self
        }
        /// <p>The object used to call your custom language model to your transcription job.</p>
        pub fn set_model_settings(
            mut self,
            input: std::option::Option<crate::model::ModelSettings>,
        ) -> Self {
            self.model_settings = input;
            self
        }
        /// <p>Whether automatic language identification was enabled for a transcription job.</p>
        pub fn identify_language(mut self, input: bool) -> Self {
            self.identify_language = Some(input);
            self
        }
        /// <p>Whether automatic language identification was enabled for a transcription job.</p>
        pub fn set_identify_language(mut self, input: std::option::Option<bool>) -> Self {
            self.identify_language = input;
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language it identified in the source audio. A higher
        /// score indicates that Amazon Transcribe is more confident in the language it identified.</p>
        pub fn identified_language_score(mut self, input: f32) -> Self {
            self.identified_language_score = Some(input);
            self
        }
        /// <p>A value between zero and one that Amazon Transcribe assigned to the language it identified in the source audio. A higher
        /// score indicates that Amazon Transcribe is more confident in the language it identified.</p>
        pub fn set_identified_language_score(mut self, input: std::option::Option<f32>) -> Self {
            self.identified_language_score = input;
            self
        }
        /// Consumes the builder and constructs a [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
        pub fn build(self) -> crate::model::TranscriptionJobSummary {
            crate::model::TranscriptionJobSummary {
                transcription_job_name: self.transcription_job_name,
                creation_time: self.creation_time,
                start_time: self.start_time,
                completion_time: self.completion_time,
                language_code: self.language_code,
                transcription_job_status: self.transcription_job_status,
                failure_reason: self.failure_reason,
                output_location_type: self.output_location_type,
                content_redaction: self.content_redaction,
                model_settings: self.model_settings,
                identify_language: self.identify_language,
                identified_language_score: self.identified_language_score,
            }
        }
    }
}
impl TranscriptionJobSummary {
    /// Creates a new builder-style object to manufacture [`TranscriptionJobSummary`](crate::model::TranscriptionJobSummary)
    pub fn builder() -> crate::model::transcription_job_summary::Builder {
        crate::model::transcription_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutputLocationType {
    #[allow(missing_docs)] // documentation missing in model
    CustomerBucket,
    #[allow(missing_docs)] // documentation missing in model
    ServiceBucket,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OutputLocationType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_BUCKET" => OutputLocationType::CustomerBucket,
            "SERVICE_BUCKET" => OutputLocationType::ServiceBucket,
            other => OutputLocationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OutputLocationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutputLocationType::from(s))
    }
}
impl OutputLocationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OutputLocationType::CustomerBucket => "CUSTOMER_BUCKET",
            OutputLocationType::ServiceBucket => "SERVICE_BUCKET",
            OutputLocationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CUSTOMER_BUCKET", "SERVICE_BUCKET"]
    }
}
impl AsRef<str> for OutputLocationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a transcription job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MedicalTranscriptionJobSummary {
    /// <p>The name of a medical transcription job.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the medical transcription job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job began processing.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The language of the transcript in the source audio file.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The status of the medical transcription job.</p>
    pub transcription_job_status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Indicates the location of the transcription job's output. This field must be the path of an S3 bucket; if you don't
    /// already have an S3 bucket, one is created based on the path you add.</p>
    pub output_location_type: std::option::Option<crate::model::OutputLocationType>,
    /// <p>The medical specialty of the transcription job. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-medical-conversation.html">Transcribing a medical conversation</a>for a
    /// list of supported specialties.</p>
    pub specialty: std::option::Option<crate::model::Specialty>,
    /// <p>Shows the type of information you've configured Amazon Transcribe Medical to identify in a transcription job. If the value is
    /// <code>PHI</code>, you've configured the transcription job to identify personal health information (PHI).</p>
    pub content_identification_type:
        std::option::Option<crate::model::MedicalContentIdentificationType>,
    /// <p>The speech of the clinician in the input audio.</p>
    pub r#type: std::option::Option<crate::model::Type>,
}
impl std::fmt::Debug for MedicalTranscriptionJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MedicalTranscriptionJobSummary");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("transcription_job_status", &self.transcription_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("output_location_type", &self.output_location_type);
        formatter.field("specialty", &self.specialty);
        formatter.field(
            "content_identification_type",
            &self.content_identification_type,
        );
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
pub mod medical_transcription_job_summary {
    /// A builder for [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) transcription_job_status:
            std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) output_location_type: std::option::Option<crate::model::OutputLocationType>,
        pub(crate) specialty: std::option::Option<crate::model::Specialty>,
        pub(crate) content_identification_type:
            std::option::Option<crate::model::MedicalContentIdentificationType>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
    }
    impl Builder {
        /// <p>The name of a medical transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of a medical transcription job.</p>
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// <p>A timestamp that shows when the medical transcription job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the medical transcription job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job began processing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job began processing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The language of the transcript in the source audio file.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language of the transcript in the source audio file.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The status of the medical transcription job.</p>
        pub fn transcription_job_status(
            mut self,
            input: crate::model::TranscriptionJobStatus,
        ) -> Self {
            self.transcription_job_status = Some(input);
            self
        }
        /// <p>The status of the medical transcription job.</p>
        pub fn set_transcription_job_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.transcription_job_status = input;
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>TranscriptionJobStatus</code> field is <code>FAILED</code>, a description of the error.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Indicates the location of the transcription job's output. This field must be the path of an S3 bucket; if you don't
        /// already have an S3 bucket, one is created based on the path you add.</p>
        pub fn output_location_type(mut self, input: crate::model::OutputLocationType) -> Self {
            self.output_location_type = Some(input);
            self
        }
        /// <p>Indicates the location of the transcription job's output. This field must be the path of an S3 bucket; if you don't
        /// already have an S3 bucket, one is created based on the path you add.</p>
        pub fn set_output_location_type(
            mut self,
            input: std::option::Option<crate::model::OutputLocationType>,
        ) -> Self {
            self.output_location_type = input;
            self
        }
        /// <p>The medical specialty of the transcription job. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-medical-conversation.html">Transcribing a medical conversation</a>for a
        /// list of supported specialties.</p>
        pub fn specialty(mut self, input: crate::model::Specialty) -> Self {
            self.specialty = Some(input);
            self
        }
        /// <p>The medical specialty of the transcription job. Refer to <a href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-medical-conversation.html">Transcribing a medical conversation</a>for a
        /// list of supported specialties.</p>
        pub fn set_specialty(
            mut self,
            input: std::option::Option<crate::model::Specialty>,
        ) -> Self {
            self.specialty = input;
            self
        }
        /// <p>Shows the type of information you've configured Amazon Transcribe Medical to identify in a transcription job. If the value is
        /// <code>PHI</code>, you've configured the transcription job to identify personal health information (PHI).</p>
        pub fn content_identification_type(
            mut self,
            input: crate::model::MedicalContentIdentificationType,
        ) -> Self {
            self.content_identification_type = Some(input);
            self
        }
        /// <p>Shows the type of information you've configured Amazon Transcribe Medical to identify in a transcription job. If the value is
        /// <code>PHI</code>, you've configured the transcription job to identify personal health information (PHI).</p>
        pub fn set_content_identification_type(
            mut self,
            input: std::option::Option<crate::model::MedicalContentIdentificationType>,
        ) -> Self {
            self.content_identification_type = input;
            self
        }
        /// <p>The speech of the clinician in the input audio.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The speech of the clinician in the input audio.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
        pub fn build(self) -> crate::model::MedicalTranscriptionJobSummary {
            crate::model::MedicalTranscriptionJobSummary {
                medical_transcription_job_name: self.medical_transcription_job_name,
                creation_time: self.creation_time,
                start_time: self.start_time,
                completion_time: self.completion_time,
                language_code: self.language_code,
                transcription_job_status: self.transcription_job_status,
                failure_reason: self.failure_reason,
                output_location_type: self.output_location_type,
                specialty: self.specialty,
                content_identification_type: self.content_identification_type,
                r#type: self.r#type,
            }
        }
    }
}
impl MedicalTranscriptionJobSummary {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionJobSummary`](crate::model::MedicalTranscriptionJobSummary)
    pub fn builder() -> crate::model::medical_transcription_job_summary::Builder {
        crate::model::medical_transcription_job_summary::Builder::default()
    }
}

/// <p>The structure used to describe a custom language model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LanguageModel {
    /// <p>The name of the custom language model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The time the custom language model was created.</p>
    pub create_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The most recent time the custom language model was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The language code you used to create your custom language model.</p>
    pub language_code: std::option::Option<crate::model::ClmLanguageCode>,
    /// <p>The Amazon Transcribe standard language model, or base model used to create the custom language model.</p>
    pub base_model_name: std::option::Option<crate::model::BaseModelName>,
    /// <p>The creation status of a custom language model. When the status is <code>COMPLETED</code> the model is
    /// ready for use.</p>
    pub model_status: std::option::Option<crate::model::ModelStatus>,
    /// <p>Whether the base model used for the custom language model is up to date. If this field is <code>true</code>
    /// then you are running the most up-to-date version of the base model in your custom language model.</p>
    pub upgrade_availability: std::option::Option<bool>,
    /// <p>The reason why the custom language model couldn't be created.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The data access role and Amazon S3 prefixes for the input files used to train the custom language model.</p>
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
}
impl std::fmt::Debug for LanguageModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LanguageModel");
        formatter.field("model_name", &self.model_name);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("base_model_name", &self.base_model_name);
        formatter.field("model_status", &self.model_status);
        formatter.field("upgrade_availability", &self.upgrade_availability);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.finish()
    }
}
/// See [`LanguageModel`](crate::model::LanguageModel)
pub mod language_model {
    /// A builder for [`LanguageModel`](crate::model::LanguageModel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::ClmLanguageCode>,
        pub(crate) base_model_name: std::option::Option<crate::model::BaseModelName>,
        pub(crate) model_status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) upgrade_availability: std::option::Option<bool>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
    }
    impl Builder {
        /// <p>The name of the custom language model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the custom language model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The time the custom language model was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the custom language model was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The most recent time the custom language model was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The most recent time the custom language model was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The language code you used to create your custom language model.</p>
        pub fn language_code(mut self, input: crate::model::ClmLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code you used to create your custom language model.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::ClmLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model used to create the custom language model.</p>
        pub fn base_model_name(mut self, input: crate::model::BaseModelName) -> Self {
            self.base_model_name = Some(input);
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model used to create the custom language model.</p>
        pub fn set_base_model_name(
            mut self,
            input: std::option::Option<crate::model::BaseModelName>,
        ) -> Self {
            self.base_model_name = input;
            self
        }
        /// <p>The creation status of a custom language model. When the status is <code>COMPLETED</code> the model is
        /// ready for use.</p>
        pub fn model_status(mut self, input: crate::model::ModelStatus) -> Self {
            self.model_status = Some(input);
            self
        }
        /// <p>The creation status of a custom language model. When the status is <code>COMPLETED</code> the model is
        /// ready for use.</p>
        pub fn set_model_status(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.model_status = input;
            self
        }
        /// <p>Whether the base model used for the custom language model is up to date. If this field is <code>true</code>
        /// then you are running the most up-to-date version of the base model in your custom language model.</p>
        pub fn upgrade_availability(mut self, input: bool) -> Self {
            self.upgrade_availability = Some(input);
            self
        }
        /// <p>Whether the base model used for the custom language model is up to date. If this field is <code>true</code>
        /// then you are running the most up-to-date version of the base model in your custom language model.</p>
        pub fn set_upgrade_availability(mut self, input: std::option::Option<bool>) -> Self {
            self.upgrade_availability = input;
            self
        }
        /// <p>The reason why the custom language model couldn't be created.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the custom language model couldn't be created.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The data access role and Amazon S3 prefixes for the input files used to train the custom language model.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The data access role and Amazon S3 prefixes for the input files used to train the custom language model.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LanguageModel`](crate::model::LanguageModel)
        pub fn build(self) -> crate::model::LanguageModel {
            crate::model::LanguageModel {
                model_name: self.model_name,
                create_time: self.create_time,
                last_modified_time: self.last_modified_time,
                language_code: self.language_code,
                base_model_name: self.base_model_name,
                model_status: self.model_status,
                upgrade_availability: self.upgrade_availability,
                failure_reason: self.failure_reason,
                input_data_config: self.input_data_config,
            }
        }
    }
}
impl LanguageModel {
    /// Creates a new builder-style object to manufacture [`LanguageModel`](crate::model::LanguageModel)
    pub fn builder() -> crate::model::language_model::Builder {
        crate::model::language_model::Builder::default()
    }
}

/// <p>The object that contains the Amazon S3 object location and access role required to train and tune your custom
/// language model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputDataConfig {
    /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to train your custom language model.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to tune your custom language model.</p>
    pub tuning_data_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the permissions you've given Amazon Transcribe to access your
    /// Amazon S3 buckets containing your media files or text data. ARNs have the format
    /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>.</p>
    pub data_access_role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InputDataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputDataConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("tuning_data_s3_uri", &self.tuning_data_s3_uri);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.finish()
    }
}
/// See [`InputDataConfig`](crate::model::InputDataConfig)
pub mod input_data_config {
    /// A builder for [`InputDataConfig`](crate::model::InputDataConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) tuning_data_s3_uri: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to train your custom language model.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to train your custom language model.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to tune your custom language model.</p>
        pub fn tuning_data_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.tuning_data_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 prefix you specify to access the plain text files that you use to tune your custom language model.</p>
        pub fn set_tuning_data_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tuning_data_s3_uri = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the permissions you've given Amazon Transcribe to access your
        /// Amazon S3 buckets containing your media files or text data. ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the permissions you've given Amazon Transcribe to access your
        /// Amazon S3 buckets containing your media files or text data. ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code>.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`InputDataConfig`](crate::model::InputDataConfig)
        pub fn build(self) -> crate::model::InputDataConfig {
            crate::model::InputDataConfig {
                s3_uri: self.s3_uri,
                tuning_data_s3_uri: self.tuning_data_s3_uri,
                data_access_role_arn: self.data_access_role_arn,
            }
        }
    }
}
impl InputDataConfig {
    /// Creates a new builder-style object to manufacture [`InputDataConfig`](crate::model::InputDataConfig)
    pub fn builder() -> crate::model::input_data_config::Builder {
        crate::model::input_data_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => ModelStatus::Completed,
            "FAILED" => ModelStatus::Failed,
            "IN_PROGRESS" => ModelStatus::InProgress,
            other => ModelStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelStatus::from(s))
    }
}
impl ModelStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelStatus::Completed => "COMPLETED",
            ModelStatus::Failed => "FAILED",
            ModelStatus::InProgress => "IN_PROGRESS",
            ModelStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "IN_PROGRESS"]
    }
}
impl AsRef<str> for ModelStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BaseModelName {
    #[allow(missing_docs)] // documentation missing in model
    NarrowBand,
    #[allow(missing_docs)] // documentation missing in model
    WideBand,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BaseModelName {
    fn from(s: &str) -> Self {
        match s {
            "NarrowBand" => BaseModelName::NarrowBand,
            "WideBand" => BaseModelName::WideBand,
            other => BaseModelName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BaseModelName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BaseModelName::from(s))
    }
}
impl BaseModelName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BaseModelName::NarrowBand => "NarrowBand",
            BaseModelName::WideBand => "WideBand",
            BaseModelName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["NarrowBand", "WideBand"]
    }
}
impl AsRef<str> for BaseModelName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClmLanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    HiIn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClmLanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "en-AU" => ClmLanguageCode::EnAu,
            "en-GB" => ClmLanguageCode::EnGb,
            "en-US" => ClmLanguageCode::EnUs,
            "es-US" => ClmLanguageCode::EsUs,
            "hi-IN" => ClmLanguageCode::HiIn,
            other => ClmLanguageCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClmLanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClmLanguageCode::from(s))
    }
}
impl ClmLanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClmLanguageCode::EnAu => "en-AU",
            ClmLanguageCode::EnGb => "en-GB",
            ClmLanguageCode::EnUs => "en-US",
            ClmLanguageCode::EsUs => "es-US",
            ClmLanguageCode::HiIn => "hi-IN",
            ClmLanguageCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["en-AU", "en-GB", "en-US", "es-US", "hi-IN"]
    }
}
impl AsRef<str> for ClmLanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a call analytics job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CallAnalyticsJobSummary {
    /// <p>The name of the call analytics job.</p>
    pub call_analytics_job_name: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the call analytics job was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job began processing.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A timestamp that shows when the job was completed.</p>
    pub completion_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The language of the transcript in the source audio file.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The status of the call analytics job.</p>
    pub call_analytics_job_status: std::option::Option<crate::model::CallAnalyticsJobStatus>,
    /// <p>If the <code>CallAnalyticsJobStatus</code> is <code>FAILED</code>, a description of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CallAnalyticsJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CallAnalyticsJobSummary");
        formatter.field("call_analytics_job_name", &self.call_analytics_job_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.field("language_code", &self.language_code);
        formatter.field("call_analytics_job_status", &self.call_analytics_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`CallAnalyticsJobSummary`](crate::model::CallAnalyticsJobSummary)
pub mod call_analytics_job_summary {
    /// A builder for [`CallAnalyticsJobSummary`](crate::model::CallAnalyticsJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) call_analytics_job_status:
            std::option::Option<crate::model::CallAnalyticsJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the call analytics job.</p>
        pub fn call_analytics_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.call_analytics_job_name = Some(input.into());
            self
        }
        /// <p>The name of the call analytics job.</p>
        pub fn set_call_analytics_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.call_analytics_job_name = input;
            self
        }
        /// <p>A timestamp that shows when the call analytics job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the call analytics job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the job began processing.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job began processing.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>A timestamp that shows when the job was completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The language of the transcript in the source audio file.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language of the transcript in the source audio file.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The status of the call analytics job.</p>
        pub fn call_analytics_job_status(
            mut self,
            input: crate::model::CallAnalyticsJobStatus,
        ) -> Self {
            self.call_analytics_job_status = Some(input);
            self
        }
        /// <p>The status of the call analytics job.</p>
        pub fn set_call_analytics_job_status(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJobStatus>,
        ) -> Self {
            self.call_analytics_job_status = input;
            self
        }
        /// <p>If the <code>CallAnalyticsJobStatus</code> is <code>FAILED</code>, a description of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>CallAnalyticsJobStatus</code> is <code>FAILED</code>, a description of the error.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`CallAnalyticsJobSummary`](crate::model::CallAnalyticsJobSummary)
        pub fn build(self) -> crate::model::CallAnalyticsJobSummary {
            crate::model::CallAnalyticsJobSummary {
                call_analytics_job_name: self.call_analytics_job_name,
                creation_time: self.creation_time,
                start_time: self.start_time,
                completion_time: self.completion_time,
                language_code: self.language_code,
                call_analytics_job_status: self.call_analytics_job_status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl CallAnalyticsJobSummary {
    /// Creates a new builder-style object to manufacture [`CallAnalyticsJobSummary`](crate::model::CallAnalyticsJobSummary)
    pub fn builder() -> crate::model::call_analytics_job_summary::Builder {
        crate::model::call_analytics_job_summary::Builder::default()
    }
}
