// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_language_model(&self) -> fluent_builders::CreateLanguageModel<C> {
        fluent_builders::CreateLanguageModel::new(self.handle.clone())
    }
    pub fn create_medical_vocabulary(&self) -> fluent_builders::CreateMedicalVocabulary<C> {
        fluent_builders::CreateMedicalVocabulary::new(self.handle.clone())
    }
    pub fn create_vocabulary(&self) -> fluent_builders::CreateVocabulary<C> {
        fluent_builders::CreateVocabulary::new(self.handle.clone())
    }
    pub fn create_vocabulary_filter(&self) -> fluent_builders::CreateVocabularyFilter<C> {
        fluent_builders::CreateVocabularyFilter::new(self.handle.clone())
    }
    pub fn delete_language_model(&self) -> fluent_builders::DeleteLanguageModel<C> {
        fluent_builders::DeleteLanguageModel::new(self.handle.clone())
    }
    pub fn delete_medical_transcription_job(
        &self,
    ) -> fluent_builders::DeleteMedicalTranscriptionJob<C> {
        fluent_builders::DeleteMedicalTranscriptionJob::new(self.handle.clone())
    }
    pub fn delete_medical_vocabulary(&self) -> fluent_builders::DeleteMedicalVocabulary<C> {
        fluent_builders::DeleteMedicalVocabulary::new(self.handle.clone())
    }
    pub fn delete_transcription_job(&self) -> fluent_builders::DeleteTranscriptionJob<C> {
        fluent_builders::DeleteTranscriptionJob::new(self.handle.clone())
    }
    pub fn delete_vocabulary(&self) -> fluent_builders::DeleteVocabulary<C> {
        fluent_builders::DeleteVocabulary::new(self.handle.clone())
    }
    pub fn delete_vocabulary_filter(&self) -> fluent_builders::DeleteVocabularyFilter<C> {
        fluent_builders::DeleteVocabularyFilter::new(self.handle.clone())
    }
    pub fn describe_language_model(&self) -> fluent_builders::DescribeLanguageModel<C> {
        fluent_builders::DescribeLanguageModel::new(self.handle.clone())
    }
    pub fn get_medical_transcription_job(&self) -> fluent_builders::GetMedicalTranscriptionJob<C> {
        fluent_builders::GetMedicalTranscriptionJob::new(self.handle.clone())
    }
    pub fn get_medical_vocabulary(&self) -> fluent_builders::GetMedicalVocabulary<C> {
        fluent_builders::GetMedicalVocabulary::new(self.handle.clone())
    }
    pub fn get_transcription_job(&self) -> fluent_builders::GetTranscriptionJob<C> {
        fluent_builders::GetTranscriptionJob::new(self.handle.clone())
    }
    pub fn get_vocabulary(&self) -> fluent_builders::GetVocabulary<C> {
        fluent_builders::GetVocabulary::new(self.handle.clone())
    }
    pub fn get_vocabulary_filter(&self) -> fluent_builders::GetVocabularyFilter<C> {
        fluent_builders::GetVocabularyFilter::new(self.handle.clone())
    }
    pub fn list_language_models(&self) -> fluent_builders::ListLanguageModels<C> {
        fluent_builders::ListLanguageModels::new(self.handle.clone())
    }
    pub fn list_medical_transcription_jobs(
        &self,
    ) -> fluent_builders::ListMedicalTranscriptionJobs<C> {
        fluent_builders::ListMedicalTranscriptionJobs::new(self.handle.clone())
    }
    pub fn list_medical_vocabularies(&self) -> fluent_builders::ListMedicalVocabularies<C> {
        fluent_builders::ListMedicalVocabularies::new(self.handle.clone())
    }
    pub fn list_transcription_jobs(&self) -> fluent_builders::ListTranscriptionJobs<C> {
        fluent_builders::ListTranscriptionJobs::new(self.handle.clone())
    }
    pub fn list_vocabularies(&self) -> fluent_builders::ListVocabularies<C> {
        fluent_builders::ListVocabularies::new(self.handle.clone())
    }
    pub fn list_vocabulary_filters(&self) -> fluent_builders::ListVocabularyFilters<C> {
        fluent_builders::ListVocabularyFilters::new(self.handle.clone())
    }
    pub fn start_medical_transcription_job(
        &self,
    ) -> fluent_builders::StartMedicalTranscriptionJob<C> {
        fluent_builders::StartMedicalTranscriptionJob::new(self.handle.clone())
    }
    pub fn start_transcription_job(&self) -> fluent_builders::StartTranscriptionJob<C> {
        fluent_builders::StartTranscriptionJob::new(self.handle.clone())
    }
    pub fn update_medical_vocabulary(&self) -> fluent_builders::UpdateMedicalVocabulary<C> {
        fluent_builders::UpdateMedicalVocabulary::new(self.handle.clone())
    }
    pub fn update_vocabulary(&self) -> fluent_builders::UpdateVocabulary<C> {
        fluent_builders::UpdateVocabulary::new(self.handle.clone())
    }
    pub fn update_vocabulary_filter(&self) -> fluent_builders::UpdateVocabularyFilter<C> {
        fluent_builders::UpdateVocabularyFilter::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateLanguageModel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_language_model_input::Builder,
    }
    impl<C> CreateLanguageModel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLanguageModelOutput,
            smithy_http::result::SdkError<crate::error::CreateLanguageModelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The language of the input text you're using to train your custom language
        /// model.</p>
        pub fn language_code(mut self, input: crate::model::ClmLanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::ClmLanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model used to create your custom language
        /// model.</p>
        /// <p>If you want to use your custom language model to transcribe audio with a sample rate
        /// of 16 kHz or greater, choose <code>Wideband</code>.</p>
        /// <p>If you want to use your custom language model to transcribe audio with a sample rate
        /// that is less than 16 kHz, choose <code>Narrowband</code>.</p>
        pub fn base_model_name(mut self, input: crate::model::BaseModelName) -> Self {
            self.inner = self.inner.base_model_name(input);
            self
        }
        pub fn set_base_model_name(
            mut self,
            input: std::option::Option<crate::model::BaseModelName>,
        ) -> Self {
            self.inner = self.inner.set_base_model_name(input);
            self
        }
        /// <p>The name you choose for your custom language model when you create it.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.model_name(input);
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_model_name(input);
            self
        }
        /// <p>Contains the data access role and the Amazon S3 prefixes to read the required input files
        /// to create a custom language model.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.inner = self.inner.input_data_config(input);
            self
        }
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.inner = self.inner.set_input_data_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMedicalVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_medical_vocabulary_input::Builder,
    }
    impl<C> CreateMedicalVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMedicalVocabularyOutput,
            smithy_http::result::SdkError<crate::error::CreateMedicalVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the custom vocabulary. This case-sensitive name must be unique within an
        /// AWS account. If you try to create a vocabulary with the same name as a previous
        /// vocabulary, you get a <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
        /// <p>The language code for the language used for the entries in your custom vocabulary. The
        /// language code of your custom vocabulary must match the language code of your
        /// transcription job. US English (en-US) is the only language code available for
        /// Amazon Transcribe Medical.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>The location in Amazon S3 of the text file you use to define your custom vocabulary. The
        /// URI must be in the same AWS Region as the
        /// resource
        /// that you're calling. Enter information about your
        /// <code>VocabularyFileUri</code> in the following format:</p>
        /// <p>
        /// <code>
        /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
        /// </code>
        /// </p>
        /// <p>The following is an example URI for a vocabulary file that is stored in Amazon S3:</p>
        /// <p>
        /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
        /// </p>
        /// <p>For more information about Amazon S3 object names, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="http://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary-med">Medical Custom Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_file_uri(input);
            self
        }
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_file_uri(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vocabulary_input::Builder,
    }
    impl<C> CreateVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVocabularyOutput,
            smithy_http::result::SdkError<crate::error::CreateVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary. The name must be unique within an AWS account. The name is
        /// case sensitive. If you try to create a vocabulary with the same name as a previous
        /// vocabulary you will receive a <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their
        /// corresponding language codes, see <a>what-is-transcribe</a>.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>An array of strings that contains the vocabulary entries. </p>
        pub fn phrases(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phrases(inp);
            self
        }
        pub fn set_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_phrases(input);
            self
        }
        /// <p>The S3 location of the text file that contains the definition of the custom
        /// vocabulary. The URI must be in the same region as the API endpoint that you are calling.
        /// The general form is </p>
        /// <p>For more information about S3 object names, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="http://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary">Custom
        /// Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_file_uri(input);
            self
        }
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_file_uri(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVocabularyFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vocabulary_filter_input::Builder,
    }
    impl<C> CreateVocabularyFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVocabularyFilterOutput,
            smithy_http::result::SdkError<crate::error::CreateVocabularyFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The vocabulary filter name. The name must be unique within the account that contains
        /// it. If you try to create a vocabulary filter with the same name as another vocabulary
        /// filter, you get a <code>ConflictException</code> error.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_filter_name(input);
            self
        }
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_filter_name(input);
            self
        }
        /// <p>The language code of the words in the vocabulary filter. All words in the filter must
        /// be in the same language. The vocabulary filter can only be used with transcription jobs
        /// in the specified language.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>The words to use in the vocabulary filter. Only use characters from the character set
        /// defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
        /// <code>VocabularyFilterFileUri</code> parameter.</p>
        pub fn words(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.words(inp);
            self
        }
        pub fn set_words(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_words(input);
            self
        }
        /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter.
        /// Only use characters from the character set defined for custom vocabularies. For a list
        /// of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom
        /// Vocabularies</a>.</p>
        /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
        /// <p>If you provide the location of a list of words in the
        /// <code>VocabularyFilterFileUri</code> parameter, you can't use the <code>Words</code>
        /// parameter.</p>
        pub fn vocabulary_filter_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_filter_file_uri(input);
            self
        }
        pub fn set_vocabulary_filter_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_filter_file_uri(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLanguageModel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_language_model_input::Builder,
    }
    impl<C> DeleteLanguageModel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLanguageModelOutput,
            smithy_http::result::SdkError<crate::error::DeleteLanguageModelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the model you're choosing to delete.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.model_name(input);
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_model_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMedicalTranscriptionJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_medical_transcription_job_input::Builder,
    }
    impl<C> DeleteMedicalTranscriptionJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMedicalTranscriptionJobOutput,
            smithy_http::result::SdkError<crate::error::DeleteMedicalTranscriptionJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name you provide to the <code>DeleteMedicalTranscriptionJob</code> object to
        /// delete a transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.medical_transcription_job_name(input);
            self
        }
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_medical_transcription_job_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMedicalVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_medical_vocabulary_input::Builder,
    }
    impl<C> DeleteMedicalVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMedicalVocabularyOutput,
            smithy_http::result::SdkError<crate::error::DeleteMedicalVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary that you want to delete.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTranscriptionJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transcription_job_input::Builder,
    }
    impl<C> DeleteTranscriptionJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTranscriptionJobOutput,
            smithy_http::result::SdkError<crate::error::DeleteTranscriptionJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the transcription job to be deleted.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transcription_job_name(input);
            self
        }
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transcription_job_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vocabulary_input::Builder,
    }
    impl<C> DeleteVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVocabularyOutput,
            smithy_http::result::SdkError<crate::error::DeleteVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary to delete. </p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVocabularyFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vocabulary_filter_input::Builder,
    }
    impl<C> DeleteVocabularyFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVocabularyFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteVocabularyFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary filter to remove.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_filter_name(input);
            self
        }
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLanguageModel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_language_model_input::Builder,
    }
    impl<C> DescribeLanguageModel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLanguageModelOutput,
            smithy_http::result::SdkError<crate::error::DescribeLanguageModelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the custom language model you submit to get more information.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.model_name(input);
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_model_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMedicalTranscriptionJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_medical_transcription_job_input::Builder,
    }
    impl<C> GetMedicalTranscriptionJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMedicalTranscriptionJobOutput,
            smithy_http::result::SdkError<crate::error::GetMedicalTranscriptionJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the medical transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.medical_transcription_job_name(input);
            self
        }
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_medical_transcription_job_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMedicalVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_medical_vocabulary_input::Builder,
    }
    impl<C> GetMedicalVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMedicalVocabularyOutput,
            smithy_http::result::SdkError<crate::error::GetMedicalVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary that you want information about. The value is case
        /// sensitive. </p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTranscriptionJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_transcription_job_input::Builder,
    }
    impl<C> GetTranscriptionJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTranscriptionJobOutput,
            smithy_http::result::SdkError<crate::error::GetTranscriptionJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transcription_job_name(input);
            self
        }
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transcription_job_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_vocabulary_input::Builder,
    }
    impl<C> GetVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetVocabularyOutput,
            smithy_http::result::SdkError<crate::error::GetVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary to return information about. The name is case
        /// sensitive.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetVocabularyFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_vocabulary_filter_input::Builder,
    }
    impl<C> GetVocabularyFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetVocabularyFilterOutput,
            smithy_http::result::SdkError<crate::error::GetVocabularyFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary filter for which to return information.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_filter_name(input);
            self
        }
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLanguageModels<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_language_models_input::Builder,
    }
    impl<C> ListLanguageModels<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLanguageModelsOutput,
            smithy_http::result::SdkError<crate::error::ListLanguageModelsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When specified, returns only custom language models with the specified status.
        /// Language models are ordered by creation date, with the newest models first. If you don't
        /// specify a status, Amazon Transcribe returns all custom language models ordered by date.</p>
        pub fn status_equals(mut self, input: crate::model::ModelStatus) -> Self {
            self.inner = self.inner.status_equals(input);
            self
        }
        pub fn set_status_equals(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.inner = self.inner.set_status_equals(input);
            self
        }
        /// <p>When specified, the custom language model names returned contain the substring you've
        /// specified.</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name_contains(input);
            self
        }
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_name_contains(input);
            self
        }
        /// <p>When included, fetches the next set of jobs if the result of the previous request was
        /// truncated.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of language models to return in the response. If there are fewer
        /// results in the list, the response contains only the actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMedicalTranscriptionJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_medical_transcription_jobs_input::Builder,
    }
    impl<C> ListMedicalTranscriptionJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMedicalTranscriptionJobsOutput,
            smithy_http::result::SdkError<crate::error::ListMedicalTranscriptionJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When specified, returns only medical transcription jobs with the specified status.
        /// Jobs are ordered by creation date, with the newest jobs returned first. If you don't
        /// specify a status, Amazon Transcribe Medical returns all transcription jobs ordered by creation date.</p>
        pub fn status(mut self, input: crate::model::TranscriptionJobStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains
        /// the specified string.</p>
        pub fn job_name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name_contains(input);
            self
        }
        pub fn set_job_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_name_contains(input);
            self
        }
        /// <p>If you a receive a truncated result in the previous request of
        /// <code>ListMedicalTranscriptionJobs</code>, include <code>NextToken</code> to fetch
        /// the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of medical transcription jobs to return in the response. IF there
        /// are fewer results in the list, this response contains only the actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMedicalVocabularies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_medical_vocabularies_input::Builder,
    }
    impl<C> ListMedicalVocabularies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMedicalVocabulariesOutput,
            smithy_http::result::SdkError<crate::error::ListMedicalVocabulariesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the result of your previous request to <code>ListMedicalVocabularies</code> was
        /// truncated, include the <code>NextToken</code> to fetch the next set of
        /// vocabularies.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The
        /// maximum number of vocabularies to return in the response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When specified, returns only vocabularies
        /// with
        /// the <code>VocabularyState</code> equal to the specified vocabulary state. Use this field
        /// to see which vocabularies are ready for your medical transcription
        /// jobs.</p>
        pub fn state_equals(mut self, input: crate::model::VocabularyState) -> Self {
            self.inner = self.inner.state_equals(input);
            self
        }
        pub fn set_state_equals(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.inner = self.inner.set_state_equals(input);
            self
        }
        /// <p>Returns vocabularies whose names contain the specified string. The search is not case
        /// sensitive. <code>ListMedicalVocabularies</code> returns both
        /// "<code>vocabularyname</code>" and "<code>VocabularyName</code>".</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name_contains(input);
            self
        }
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_name_contains(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTranscriptionJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_transcription_jobs_input::Builder,
    }
    impl<C> ListTranscriptionJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTranscriptionJobsOutput,
            smithy_http::result::SdkError<crate::error::ListTranscriptionJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When specified, returns only transcription jobs with the specified status. Jobs are
        /// ordered by creation date, with the newest jobs returned first. If you don’t specify a
        /// status, Amazon Transcribe returns all transcription jobs ordered by creation date. </p>
        pub fn status(mut self, input: crate::model::TranscriptionJobStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains
        /// the specified string.</p>
        pub fn job_name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name_contains(input);
            self
        }
        pub fn set_job_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_name_contains(input);
            self
        }
        /// <p>If the result of the previous request to <code>ListTranscriptionJobs</code> was
        /// truncated, include the <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of jobs to return in the response. If there are fewer results in
        /// the list, this response contains only the actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVocabularies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_vocabularies_input::Builder,
    }
    impl<C> ListVocabularies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVocabulariesOutput,
            smithy_http::result::SdkError<crate::error::ListVocabulariesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the result of the previous request to <code>ListVocabularies</code> was truncated,
        /// include the <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of vocabularies to return in the response. If there are fewer
        /// results in the list, this response contains only the actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When specified, only returns vocabularies with the <code>VocabularyState</code> field
        /// equal to the specified state.</p>
        pub fn state_equals(mut self, input: crate::model::VocabularyState) -> Self {
            self.inner = self.inner.state_equals(input);
            self
        }
        pub fn set_state_equals(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.inner = self.inner.set_state_equals(input);
            self
        }
        /// <p>When specified, the vocabularies returned in the list are limited to vocabularies
        /// whose name contains the specified string. The search is not case sensitive,
        /// <code>ListVocabularies</code> returns both "vocabularyname" and "VocabularyName" in
        /// the response list.</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name_contains(input);
            self
        }
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_name_contains(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVocabularyFilters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_vocabulary_filters_input::Builder,
    }
    impl<C> ListVocabularyFilters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVocabularyFiltersOutput,
            smithy_http::result::SdkError<crate::error::ListVocabularyFiltersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the result of the previous request to <code>ListVocabularyFilters</code> was
        /// truncated, include the <code>NextToken</code> to fetch the next set of
        /// collections.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of filters to return in the response. If there are fewer results in
        /// the list, this response contains only the actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Filters the response so that it only contains vocabulary filters whose name contains
        /// the specified string.</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name_contains(input);
            self
        }
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_name_contains(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMedicalTranscriptionJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_medical_transcription_job_input::Builder,
    }
    impl<C> StartMedicalTranscriptionJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartMedicalTranscriptionJobOutput,
            smithy_http::result::SdkError<crate::error::StartMedicalTranscriptionJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the medical transcription job. You can't use the strings "<code>.</code>"
        /// or "<code>..</code>" by themselves as the job name. The name must also be unique within
        /// an AWS account. If you try to create a medical transcription job with the same name as a
        /// previous medical transcription job, you get a <code>ConflictException</code>
        /// error.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.medical_transcription_job_name(input);
            self
        }
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_medical_transcription_job_name(input);
            self
        }
        /// <p>The language code for the language spoken in the input media file. US English (en-US)
        /// is the valid value for medical transcription jobs. Any other value you enter for
        /// language code results in a <code>BadRequestException</code> error.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file.</p>
        /// <p>If you do not specify the media sample rate, Amazon Transcribe Medical determines the sample rate. If you
        /// specify the sample rate, it must match the rate detected by Amazon Transcribe Medical. In most cases, you
        /// should leave the <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe Medical determine
        /// the sample rate.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.inner = self.inner.media_sample_rate_hertz(input);
            self
        }
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_media_sample_rate_hertz(input);
            self
        }
        /// <p>The audio format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.inner = self.inner.media_format(input);
            self
        }
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.inner = self.inner.set_media_format(input);
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.inner = self.inner.media(input);
            self
        }
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.inner = self.inner.set_media(input);
            self
        }
        /// <p>The Amazon S3 location where the transcription is stored.</p>
        /// <p>You must set <code>OutputBucketName</code> for Amazon Transcribe Medical to store the transcription
        /// results. Your transcript appears in the S3 location you specify. When you call the <a>GetMedicalTranscriptionJob</a>, the operation returns this location in the
        /// <code>TranscriptFileUri</code> field. The S3 bucket must have permissions that allow
        /// Amazon Transcribe Medical to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for IAM User Roles</a>.</p>
        /// <p>You can specify an AWS Key Management Service (KMS) key to encrypt the output of your
        /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't
        /// specify a KMS key, Amazon Transcribe Medical uses the default Amazon S3 key for server-side encryption of
        /// transcripts that are placed in your S3 bucket.</p>
        pub fn output_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_bucket_name(input);
            self
        }
        pub fn set_output_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_bucket_name(input);
            self
        }
        /// <p>You can specify a location in an Amazon S3 bucket to store the output of your medical
        /// transcription job.</p>
        /// <p>If you don't specify an output key, Amazon Transcribe Medical stores the output of your transcription job
        /// in the Amazon S3 bucket you specified. By default, the object key is
        /// "your-transcription-job-name.json".</p>
        /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription
        /// output. For example, specifying the Amazon S3 prefix, "folder1/folder2/", as an output key
        /// would lead to the output being stored as
        /// "folder1/folder2/your-transcription-job-name.json". If you specify
        /// "my-other-job-name.json" as the output key, the object key is changed to
        /// "my-other-job-name.json". You can use an output key to change both the prefix and the
        /// file name, for example "folder/my-other-job-name.json".</p>
        /// <p>If you specify an output key, you must also specify an S3 bucket in the
        /// <code>OutputBucketName</code> parameter.</p>
        pub fn output_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_key(input);
            self
        }
        pub fn set_output_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_output_key(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key used to
        /// encrypt the output of the transcription job. The user calling the <a>StartMedicalTranscriptionJob</a> operation must have permission to use the
        /// specified KMS key.</p>
        /// <p>You use either of the following to identify a KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>You can use either of the following to identify a KMS key in the current account or
        /// another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another
        /// account: "arn:aws:kms:region:account
        /// ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account
        /// ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the medical transcription job is
        /// encrypted with the default Amazon S3 key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output
        /// location in the <code>OutputBucketName</code> parameter.</p>
        pub fn output_encryption_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.output_encryption_kms_key_id(input);
            self
        }
        pub fn set_output_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_encryption_kms_key_id(input);
            self
        }
        /// <p>Optional settings for the medical transcription job.</p>
        pub fn settings(mut self, input: crate::model::MedicalTranscriptionSetting) -> Self {
            self.inner = self.inner.settings(input);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        ) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
        /// <p>You can configure Amazon Transcribe Medical to label content in the transcription output. If you specify
        /// <code>PHI</code>, Amazon Transcribe Medical labels the personal health information (PHI) that it identifies in the transcription
        /// output.</p>
        pub fn content_identification_type(
            mut self,
            input: crate::model::MedicalContentIdentificationType,
        ) -> Self {
            self.inner = self.inner.content_identification_type(input);
            self
        }
        pub fn set_content_identification_type(
            mut self,
            input: std::option::Option<crate::model::MedicalContentIdentificationType>,
        ) -> Self {
            self.inner = self.inner.set_content_identification_type(input);
            self
        }
        /// <p>The medical specialty of any clinician speaking in the input media.</p>
        pub fn specialty(mut self, input: crate::model::Specialty) -> Self {
            self.inner = self.inner.specialty(input);
            self
        }
        pub fn set_specialty(
            mut self,
            input: std::option::Option<crate::model::Specialty>,
        ) -> Self {
            self.inner = self.inner.set_specialty(input);
            self
        }
        /// <p>The type of speech in the input audio. <code>CONVERSATION</code> refers to
        /// conversations between two or more speakers, e.g., a conversations between doctors and
        /// patients. <code>DICTATION</code> refers to single-speaker dictated speech, e.g., for
        /// clinical notes.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartTranscriptionJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_transcription_job_input::Builder,
    }
    impl<C> StartTranscriptionJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartTranscriptionJobOutput,
            smithy_http::result::SdkError<crate::error::StartTranscriptionJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job. You can't use the strings "<code>.</code>" or "<code>..</code>"
        /// by themselves as the job name. The name must also be unique within an AWS account. If
        /// you try to create a transcription job with the same name as a previous transcription
        /// job, you get a <code>ConflictException</code> error.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transcription_job_name(input);
            self
        }
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transcription_job_name(input);
            self
        }
        /// <p>The language code for the language used in the input media file.</p>
        /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must
        /// be encoded at a sample rate of 16000 Hz or higher.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
        /// <p>If you do not specify the media sample rate, Amazon Transcribe determines the sample rate. If you
        /// specify the sample rate, it must match the sample rate detected by Amazon Transcribe. In most cases,
        /// you should leave the <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe
        /// determine the sample rate.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.inner = self.inner.media_sample_rate_hertz(input);
            self
        }
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_media_sample_rate_hertz(input);
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.inner = self.inner.media_format(input);
            self
        }
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.inner = self.inner.set_media_format(input);
            self
        }
        /// <p>An object that describes the input media for a transcription job.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.inner = self.inner.media(input);
            self
        }
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.inner = self.inner.set_media(input);
            self
        }
        /// <p>The location where the transcription is stored.</p>
        /// <p>If you set the <code>OutputBucketName</code>, Amazon Transcribe puts the transcript in the
        /// specified S3 bucket. When you call the <a>GetTranscriptionJob</a> operation,
        /// the operation returns this location in the <code>TranscriptFileUri</code> field. If you
        /// enable content redaction, the redacted transcript appears in
        /// <code>RedactedTranscriptFileUri</code>. If you enable content redaction and choose
        /// to output an unredacted transcript, that transcript's location still appears in the
        /// <code>TranscriptFileUri</code>. The S3 bucket must have permissions that allow Amazon Transcribe
        /// to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for IAM User Roles</a>.</p>
        /// <p>You can specify an AWS Key Management Service (KMS) key to encrypt the output of your
        /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't
        /// specify a KMS key, Amazon Transcribe uses the default Amazon S3 key for server-side encryption of
        /// transcripts that are placed in your S3 bucket.</p>
        /// <p>If you don't set the <code>OutputBucketName</code>, Amazon Transcribe generates a pre-signed URL,
        /// a shareable URL that provides secure access to your transcription, and returns it in the
        /// <code>TranscriptFileUri</code> field. Use this URL to download the
        /// transcription.</p>
        pub fn output_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_bucket_name(input);
            self
        }
        pub fn set_output_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_bucket_name(input);
            self
        }
        /// <p>You can specify a location in an Amazon S3 bucket to store the output of your transcription
        /// job.</p>
        /// <p>If you don't specify an output key, Amazon Transcribe stores the output of your transcription job
        /// in the Amazon S3 bucket you specified. By default, the object key is
        /// "your-transcription-job-name.json".</p>
        /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription
        /// output. For example, specifying the Amazon S3 prefix, "folder1/folder2/", as an output key
        /// would lead to the output being stored as
        /// "folder1/folder2/your-transcription-job-name.json". If you specify
        /// "my-other-job-name.json" as the output key, the object key is changed to
        /// "my-other-job-name.json". You can use an output key to change both the prefix and the
        /// file name, for example "folder/my-other-job-name.json".</p>
        /// <p>If you specify an output key, you must also specify an S3 bucket in the
        /// <code>OutputBucketName</code> parameter.</p>
        pub fn output_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_key(input);
            self
        }
        pub fn set_output_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_output_key(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key used to
        /// encrypt the output of the transcription job. The user calling the
        /// <code>StartTranscriptionJob</code> operation must have permission to use the
        /// specified KMS key.</p>
        /// <p>You can use either of the following to identify a KMS key in the current
        /// account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>You can use either of the following to identify a KMS key in the current account or
        /// another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS Key: "arn:aws:kms:region:account
        /// ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account
        /// ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the transcription job is
        /// encrypted with the default Amazon S3 key (SSE-S3). </p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output
        /// location in the <code>OutputBucketName</code> parameter.</p>
        pub fn output_encryption_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.output_encryption_kms_key_id(input);
            self
        }
        pub fn set_output_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_encryption_kms_key_id(input);
            self
        }
        /// <p>A <code>Settings</code> object that provides optional settings for a transcription
        /// job.</p>
        pub fn settings(mut self, input: crate::model::Settings) -> Self {
            self.inner = self.inner.settings(input);
            self
        }
        pub fn set_settings(mut self, input: std::option::Option<crate::model::Settings>) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
        /// <p>Choose the custom language model you use for your transcription job in this
        /// parameter.</p>
        pub fn model_settings(mut self, input: crate::model::ModelSettings) -> Self {
            self.inner = self.inner.model_settings(input);
            self
        }
        pub fn set_model_settings(
            mut self,
            input: std::option::Option<crate::model::ModelSettings>,
        ) -> Self {
            self.inner = self.inner.set_model_settings(input);
            self
        }
        /// <p>Provides information about how a transcription job is executed. Use this field to
        /// indicate that the job can be queued for deferred execution if the concurrency limit is
        /// reached and there are no slots available to immediately run the job.</p>
        pub fn job_execution_settings(mut self, input: crate::model::JobExecutionSettings) -> Self {
            self.inner = self.inner.job_execution_settings(input);
            self
        }
        pub fn set_job_execution_settings(
            mut self,
            input: std::option::Option<crate::model::JobExecutionSettings>,
        ) -> Self {
            self.inner = self.inner.set_job_execution_settings(input);
            self
        }
        /// <p>An object that contains the request parameters for content redaction.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.inner = self.inner.content_redaction(input);
            self
        }
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.inner = self.inner.set_content_redaction(input);
            self
        }
        /// <p>Set this field to <code>true</code> to enable automatic language identification.
        /// Automatic language identification is disabled by default. You receive a
        /// <code>BadRequestException</code> error if you enter a value for a
        /// <code>LanguageCode</code>.</p>
        pub fn identify_language(mut self, input: bool) -> Self {
            self.inner = self.inner.identify_language(input);
            self
        }
        pub fn set_identify_language(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_identify_language(input);
            self
        }
        /// <p>An object containing a list of languages that might be present in your collection of
        /// audio files. Automatic language identification chooses a language that best matches the
        /// source audio from that list.</p>
        pub fn language_options(mut self, inp: impl Into<crate::model::LanguageCode>) -> Self {
            self.inner = self.inner.language_options(inp);
            self
        }
        pub fn set_language_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.inner = self.inner.set_language_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMedicalVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_medical_vocabulary_input::Builder,
    }
    impl<C> UpdateMedicalVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMedicalVocabularyOutput,
            smithy_http::result::SdkError<crate::error::UpdateMedicalVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update
        /// a vocabulary with the same name
        /// as
        /// a vocabulary you've already made, you get a
        /// <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
        /// <p>The language code of the language used for the entries in the updated vocabulary. US
        /// English (en-US) is the only valid language code in Amazon Transcribe Medical.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>The location in Amazon S3 of the text file that contains
        /// the
        /// you use for your custom vocabulary. The URI must be in the same AWS
        /// Region as the resource that you are calling. The following is the format for a
        /// URI:</p>
        /// <p>
        /// <code>
        /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
        /// </code>
        /// </p>
        /// <p>For example:</p>
        /// <p>
        /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
        /// </p>
        /// <p>For more information about Amazon S3 object names, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies in Amazon Transcribe Medical, see <a href="http://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Medical Custom Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_file_uri(input);
            self
        }
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_file_uri(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateVocabulary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_vocabulary_input::Builder,
    }
    impl<C> UpdateVocabulary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateVocabularyOutput,
            smithy_http::result::SdkError<crate::error::UpdateVocabularyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update
        /// a vocabulary with the same name as a previous vocabulary you will receive a
        /// <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_name(input);
            self
        }
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_name(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their
        /// corresponding language codes, see <a>what-is-transcribe</a>.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.inner = self.inner.language_code(input);
            self
        }
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.inner = self.inner.set_language_code(input);
            self
        }
        /// <p>An array of strings containing the vocabulary entries.</p>
        pub fn phrases(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.phrases(inp);
            self
        }
        pub fn set_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_phrases(input);
            self
        }
        /// <p>The S3 location of the text file that contains the definition of the custom
        /// vocabulary. The URI must be in the same region as the API endpoint that you are calling.
        /// The general form is </p>
        /// <p>For example:</p>
        /// <p>For more information about S3 object names, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="http://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Custom Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_file_uri(input);
            self
        }
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_file_uri(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateVocabularyFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_vocabulary_filter_input::Builder,
    }
    impl<C> UpdateVocabularyFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateVocabularyFilterOutput,
            smithy_http::result::SdkError<crate::error::UpdateVocabularyFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the vocabulary filter to update. If you try to update a vocabulary filter
        /// with the same name as another vocabulary filter, you get a
        /// <code>ConflictException</code> error.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_filter_name(input);
            self
        }
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_filter_name(input);
            self
        }
        /// <p>The words to use in the vocabulary filter. Only use characters from the character set
        /// defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
        /// <code>VocabularyFilterFileUri</code> parameter.</p>
        pub fn words(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.words(inp);
            self
        }
        pub fn set_words(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_words(input);
            self
        }
        /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter.
        /// Only use characters from the character set defined for custom vocabularies. For a list
        /// of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom
        /// Vocabularies</a>.</p>
        /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
        /// <p>If you provide the location of a list of words in the
        /// <code>VocabularyFilterFileUri</code> parameter, you can't use the <code>Words</code>
        /// parameter.</p>
        pub fn vocabulary_filter_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vocabulary_filter_file_uri(input);
            self
        }
        pub fn set_vocabulary_filter_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vocabulary_filter_file_uri(input);
            self
        }
    }
}
