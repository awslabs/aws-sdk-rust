// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Your request didn't pass one or more validation tests. This can occur when the entity you're trying to delete doesn't exist or if it's in a non-terminal state (such as <code>IN PROGRESS</code>). See the exception message field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>A resource already exists with this name. Resource names must be unique within an Amazon Web Services account.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message, correct the issue, and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>You've either sent too many requests or your input file is too long. Wait before retrying your request, or use a smaller file and try your request again.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check that the specified name is correct and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::BadRequestException(inner) => inner.fmt(f),
            Error::ConflictException(inner) => inner.fmt(f),
            Error::InternalFailureException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::NotFoundException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCallAnalyticsCategoryError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateCallAnalyticsCategoryError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCallAnalyticsCategoryError> for Error {
    fn from(err: crate::error::CreateCallAnalyticsCategoryError) -> Self {
        match err {
            crate::error::CreateCallAnalyticsCategoryError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::CreateCallAnalyticsCategoryError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::CreateCallAnalyticsCategoryError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::CreateCallAnalyticsCategoryError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateCallAnalyticsCategoryError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateLanguageModelError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateLanguageModelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateLanguageModelError> for Error {
    fn from(err: crate::error::CreateLanguageModelError) -> Self {
        match err {
            crate::error::CreateLanguageModelError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::CreateLanguageModelError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::CreateLanguageModelError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::CreateLanguageModelError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateLanguageModelError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateMedicalVocabularyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateMedicalVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateMedicalVocabularyError> for Error {
    fn from(err: crate::error::CreateMedicalVocabularyError) -> Self {
        match err {
            crate::error::CreateMedicalVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::CreateMedicalVocabularyError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::CreateMedicalVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::CreateMedicalVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateMedicalVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateVocabularyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateVocabularyError> for Error {
    fn from(err: crate::error::CreateVocabularyError) -> Self {
        match err {
            crate::error::CreateVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::CreateVocabularyError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::CreateVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::CreateVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateVocabularyFilterError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateVocabularyFilterError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateVocabularyFilterError> for Error {
    fn from(err: crate::error::CreateVocabularyFilterError) -> Self {
        match err {
            crate::error::CreateVocabularyFilterError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::CreateVocabularyFilterError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::CreateVocabularyFilterError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::CreateVocabularyFilterError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateVocabularyFilterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCallAnalyticsCategoryError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCallAnalyticsCategoryError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCallAnalyticsCategoryError> for Error {
    fn from(err: crate::error::DeleteCallAnalyticsCategoryError) -> Self {
        match err {
            crate::error::DeleteCallAnalyticsCategoryError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteCallAnalyticsCategoryError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteCallAnalyticsCategoryError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteCallAnalyticsCategoryError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DeleteCallAnalyticsCategoryError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCallAnalyticsJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCallAnalyticsJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCallAnalyticsJobError> for Error {
    fn from(err: crate::error::DeleteCallAnalyticsJobError) -> Self {
        match err {
            crate::error::DeleteCallAnalyticsJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteCallAnalyticsJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteCallAnalyticsJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteCallAnalyticsJobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteLanguageModelError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteLanguageModelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteLanguageModelError> for Error {
    fn from(err: crate::error::DeleteLanguageModelError) -> Self {
        match err {
            crate::error::DeleteLanguageModelError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteLanguageModelError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteLanguageModelError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteLanguageModelError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteMedicalTranscriptionJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteMedicalTranscriptionJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteMedicalTranscriptionJobError> for Error {
    fn from(err: crate::error::DeleteMedicalTranscriptionJobError) -> Self {
        match err {
            crate::error::DeleteMedicalTranscriptionJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteMedicalTranscriptionJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteMedicalTranscriptionJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteMedicalTranscriptionJobError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteMedicalVocabularyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteMedicalVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteMedicalVocabularyError> for Error {
    fn from(err: crate::error::DeleteMedicalVocabularyError) -> Self {
        match err {
            crate::error::DeleteMedicalVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteMedicalVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteMedicalVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteMedicalVocabularyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DeleteMedicalVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTranscriptionJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteTranscriptionJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTranscriptionJobError> for Error {
    fn from(err: crate::error::DeleteTranscriptionJobError) -> Self {
        match err {
            crate::error::DeleteTranscriptionJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteTranscriptionJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteTranscriptionJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteTranscriptionJobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteVocabularyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteVocabularyError> for Error {
    fn from(err: crate::error::DeleteVocabularyError) -> Self {
        match err {
            crate::error::DeleteVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteVocabularyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DeleteVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteVocabularyFilterError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteVocabularyFilterError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteVocabularyFilterError> for Error {
    fn from(err: crate::error::DeleteVocabularyFilterError) -> Self {
        match err {
            crate::error::DeleteVocabularyFilterError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DeleteVocabularyFilterError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DeleteVocabularyFilterError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteVocabularyFilterError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DeleteVocabularyFilterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeLanguageModelError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeLanguageModelError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeLanguageModelError> for Error {
    fn from(err: crate::error::DescribeLanguageModelError) -> Self {
        match err {
            crate::error::DescribeLanguageModelError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::DescribeLanguageModelError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::DescribeLanguageModelError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DescribeLanguageModelError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DescribeLanguageModelError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCallAnalyticsCategoryError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetCallAnalyticsCategoryError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCallAnalyticsCategoryError> for Error {
    fn from(err: crate::error::GetCallAnalyticsCategoryError) -> Self {
        match err {
            crate::error::GetCallAnalyticsCategoryError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetCallAnalyticsCategoryError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetCallAnalyticsCategoryError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetCallAnalyticsCategoryError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetCallAnalyticsCategoryError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCallAnalyticsJobError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetCallAnalyticsJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCallAnalyticsJobError> for Error {
    fn from(err: crate::error::GetCallAnalyticsJobError) -> Self {
        match err {
            crate::error::GetCallAnalyticsJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetCallAnalyticsJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetCallAnalyticsJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetCallAnalyticsJobError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetCallAnalyticsJobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetMedicalTranscriptionJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetMedicalTranscriptionJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetMedicalTranscriptionJobError> for Error {
    fn from(err: crate::error::GetMedicalTranscriptionJobError) -> Self {
        match err {
            crate::error::GetMedicalTranscriptionJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetMedicalTranscriptionJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetMedicalTranscriptionJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetMedicalTranscriptionJobError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetMedicalTranscriptionJobError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetMedicalVocabularyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetMedicalVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetMedicalVocabularyError> for Error {
    fn from(err: crate::error::GetMedicalVocabularyError) -> Self {
        match err {
            crate::error::GetMedicalVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetMedicalVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetMedicalVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetMedicalVocabularyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetMedicalVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTranscriptionJobError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetTranscriptionJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetTranscriptionJobError> for Error {
    fn from(err: crate::error::GetTranscriptionJobError) -> Self {
        match err {
            crate::error::GetTranscriptionJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetTranscriptionJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetTranscriptionJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetTranscriptionJobError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetTranscriptionJobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetVocabularyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetVocabularyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetVocabularyError> for Error {
    fn from(err: crate::error::GetVocabularyError) -> Self {
        match err {
            crate::error::GetVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetVocabularyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetVocabularyFilterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetVocabularyFilterError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetVocabularyFilterError> for Error {
    fn from(err: crate::error::GetVocabularyFilterError) -> Self {
        match err {
            crate::error::GetVocabularyFilterError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::GetVocabularyFilterError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::GetVocabularyFilterError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetVocabularyFilterError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetVocabularyFilterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCallAnalyticsCategoriesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCallAnalyticsCategoriesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCallAnalyticsCategoriesError> for Error {
    fn from(err: crate::error::ListCallAnalyticsCategoriesError) -> Self {
        match err {
            crate::error::ListCallAnalyticsCategoriesError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListCallAnalyticsCategoriesError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListCallAnalyticsCategoriesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListCallAnalyticsCategoriesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCallAnalyticsJobsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCallAnalyticsJobsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCallAnalyticsJobsError> for Error {
    fn from(err: crate::error::ListCallAnalyticsJobsError) -> Self {
        match err {
            crate::error::ListCallAnalyticsJobsError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListCallAnalyticsJobsError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListCallAnalyticsJobsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListCallAnalyticsJobsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListLanguageModelsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListLanguageModelsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListLanguageModelsError> for Error {
    fn from(err: crate::error::ListLanguageModelsError) -> Self {
        match err {
            crate::error::ListLanguageModelsError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListLanguageModelsError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListLanguageModelsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListLanguageModelsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListMedicalTranscriptionJobsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListMedicalTranscriptionJobsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListMedicalTranscriptionJobsError> for Error {
    fn from(err: crate::error::ListMedicalTranscriptionJobsError) -> Self {
        match err {
            crate::error::ListMedicalTranscriptionJobsError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListMedicalTranscriptionJobsError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListMedicalTranscriptionJobsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListMedicalTranscriptionJobsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListMedicalVocabulariesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListMedicalVocabulariesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListMedicalVocabulariesError> for Error {
    fn from(err: crate::error::ListMedicalVocabulariesError) -> Self {
        match err {
            crate::error::ListMedicalVocabulariesError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListMedicalVocabulariesError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListMedicalVocabulariesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListMedicalVocabulariesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListTagsForResourceError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListTagsForResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListTagsForResourceError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTranscriptionJobsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTranscriptionJobsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTranscriptionJobsError> for Error {
    fn from(err: crate::error::ListTranscriptionJobsError) -> Self {
        match err {
            crate::error::ListTranscriptionJobsError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListTranscriptionJobsError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListTranscriptionJobsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListTranscriptionJobsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListVocabulariesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListVocabulariesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListVocabulariesError> for Error {
    fn from(err: crate::error::ListVocabulariesError) -> Self {
        match err {
            crate::error::ListVocabulariesError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListVocabulariesError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListVocabulariesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListVocabulariesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListVocabularyFiltersError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListVocabularyFiltersError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListVocabularyFiltersError> for Error {
    fn from(err: crate::error::ListVocabularyFiltersError) -> Self {
        match err {
            crate::error::ListVocabularyFiltersError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::ListVocabularyFiltersError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::ListVocabularyFiltersError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListVocabularyFiltersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartCallAnalyticsJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::StartCallAnalyticsJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StartCallAnalyticsJobError> for Error {
    fn from(err: crate::error::StartCallAnalyticsJobError) -> Self {
        match err {
            crate::error::StartCallAnalyticsJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::StartCallAnalyticsJobError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::StartCallAnalyticsJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::StartCallAnalyticsJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::StartCallAnalyticsJobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartMedicalTranscriptionJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::StartMedicalTranscriptionJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StartMedicalTranscriptionJobError> for Error {
    fn from(err: crate::error::StartMedicalTranscriptionJobError) -> Self {
        match err {
            crate::error::StartMedicalTranscriptionJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::StartMedicalTranscriptionJobError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::StartMedicalTranscriptionJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::StartMedicalTranscriptionJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::StartMedicalTranscriptionJobError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartTranscriptionJobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::StartTranscriptionJobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StartTranscriptionJobError> for Error {
    fn from(err: crate::error::StartTranscriptionJobError) -> Self {
        match err {
            crate::error::StartTranscriptionJobError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::StartTranscriptionJobError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::StartTranscriptionJobError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::StartTranscriptionJobError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::StartTranscriptionJobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::TagResourceError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::TagResourceError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::TagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::TagResourceError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::UntagResourceError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::UntagResourceError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::UntagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UntagResourceError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCallAnalyticsCategoryError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateCallAnalyticsCategoryError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateCallAnalyticsCategoryError> for Error {
    fn from(err: crate::error::UpdateCallAnalyticsCategoryError) -> Self {
        match err {
            crate::error::UpdateCallAnalyticsCategoryError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::UpdateCallAnalyticsCategoryError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::UpdateCallAnalyticsCategoryError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::UpdateCallAnalyticsCategoryError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateCallAnalyticsCategoryError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdateCallAnalyticsCategoryError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateMedicalVocabularyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateMedicalVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateMedicalVocabularyError> for Error {
    fn from(err: crate::error::UpdateMedicalVocabularyError) -> Self {
        match err {
            crate::error::UpdateMedicalVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::UpdateMedicalVocabularyError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::UpdateMedicalVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::UpdateMedicalVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateMedicalVocabularyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdateMedicalVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateVocabularyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateVocabularyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateVocabularyError> for Error {
    fn from(err: crate::error::UpdateVocabularyError) -> Self {
        match err {
            crate::error::UpdateVocabularyError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::UpdateVocabularyError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::error::UpdateVocabularyError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::UpdateVocabularyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateVocabularyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdateVocabularyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateVocabularyFilterError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateVocabularyFilterError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateVocabularyFilterError> for Error {
    fn from(err: crate::error::UpdateVocabularyFilterError) -> Self {
        match err {
            crate::error::UpdateVocabularyFilterError::BadRequestException(inner) => {
                Error::BadRequestException(inner)
            }
            crate::error::UpdateVocabularyFilterError::InternalFailureException(inner) => {
                Error::InternalFailureException(inner)
            }
            crate::error::UpdateVocabularyFilterError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateVocabularyFilterError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdateVocabularyFilterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::BadRequestException(e) => e.request_id(),
            Self::ConflictException(e) => e.request_id(),
            Self::InternalFailureException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::NotFoundException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
