// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CreateCallAnalyticsCategoryInput`](crate::input::CreateCallAnalyticsCategoryInput)
pub mod create_call_analytics_category_input {
    /// A builder for [`CreateCallAnalyticsCategoryInput`](crate::input::CreateCallAnalyticsCategoryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_name: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    }
    impl Builder {
        /// <p>The name that you choose for your category when you create it. </p>
        pub fn category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.category_name = Some(input.into());
            self
        }
        /// <p>The name that you choose for your category when you create it. </p>
        pub fn set_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.category_name = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>To create a category, you must specify between 1 and 20 rules. For each rule, you specify a
        /// filter to be applied to the attributes of the call. For example, you can specify a sentiment
        /// filter to detect if the customer's sentiment was negative or neutral. </p>
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        /// <p>To create a category, you must specify between 1 and 20 rules. For each rule, you specify a
        /// filter to be applied to the attributes of the call. For example, you can specify a sentiment
        /// filter to detect if the customer's sentiment was negative or neutral. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCallAnalyticsCategoryInput`](crate::input::CreateCallAnalyticsCategoryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCallAnalyticsCategoryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCallAnalyticsCategoryInput {
                category_name: self.category_name,
                rules: self.rules,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCallAnalyticsCategoryInputOperationOutputAlias =
    crate::operation::CreateCallAnalyticsCategory;
#[doc(hidden)]
pub type CreateCallAnalyticsCategoryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateCallAnalyticsCategoryInput {
    /// Consumes the builder and constructs an Operation<[`CreateCallAnalyticsCategory`](crate::operation::CreateCallAnalyticsCategory)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCallAnalyticsCategory,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateCallAnalyticsCategoryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateCallAnalyticsCategoryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateCallAnalyticsCategoryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.CreateCallAnalyticsCategory",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_call_analytics_category(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCallAnalyticsCategory::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCallAnalyticsCategory",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateCallAnalyticsCategoryInput`](crate::input::CreateCallAnalyticsCategoryInput)
    pub fn builder() -> crate::input::create_call_analytics_category_input::Builder {
        crate::input::create_call_analytics_category_input::Builder::default()
    }
}

/// See [`CreateLanguageModelInput`](crate::input::CreateLanguageModelInput)
pub mod create_language_model_input {
    /// A builder for [`CreateLanguageModelInput`](crate::input::CreateLanguageModelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_code: std::option::Option<crate::model::ClmLanguageCode>,
        pub(crate) base_model_name: std::option::Option<crate::model::BaseModelName>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The language of the input text you're using to train your custom language
        /// model.</p>
        pub fn language_code(mut self, input: crate::model::ClmLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language of the input text you're using to train your custom language
        /// model.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::ClmLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model used to create your custom language model.</p>
        /// <p>If you want to use your custom language model to transcribe audio with a sample rate of 16,000 Hz or greater,
        /// choose <code>Wideband</code>.</p>
        /// <p>If you want to use your custom language model to transcribe audio with a sample rate that is less than
        /// 16,000 Hz, choose <code>Narrowband</code>.</p>
        pub fn base_model_name(mut self, input: crate::model::BaseModelName) -> Self {
            self.base_model_name = Some(input);
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model used to create your custom language model.</p>
        /// <p>If you want to use your custom language model to transcribe audio with a sample rate of 16,000 Hz or greater,
        /// choose <code>Wideband</code>.</p>
        /// <p>If you want to use your custom language model to transcribe audio with a sample rate that is less than
        /// 16,000 Hz, choose <code>Narrowband</code>.</p>
        pub fn set_base_model_name(
            mut self,
            input: std::option::Option<crate::model::BaseModelName>,
        ) -> Self {
            self.base_model_name = input;
            self
        }
        /// <p>The name you choose for your custom language model when you create it.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name you choose for your custom language model when you create it.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>Contains the data access role and the Amazon S3 prefixes to read the required input files to create a custom
        /// language model.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>Contains the data access role and the Amazon S3 prefixes to read the required input files to create a custom
        /// language model.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new language model at the time you create
        /// this new model.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new language model at the time you create
        /// this new model.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLanguageModelInput`](crate::input::CreateLanguageModelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLanguageModelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLanguageModelInput {
                language_code: self.language_code,
                base_model_name: self.base_model_name,
                model_name: self.model_name,
                input_data_config: self.input_data_config,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLanguageModelInputOperationOutputAlias = crate::operation::CreateLanguageModel;
#[doc(hidden)]
pub type CreateLanguageModelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateLanguageModelInput {
    /// Consumes the builder and constructs an Operation<[`CreateLanguageModel`](crate::operation::CreateLanguageModel)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLanguageModel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateLanguageModelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateLanguageModelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateLanguageModelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.CreateLanguageModel",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_language_model(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLanguageModel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLanguageModel",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLanguageModelInput`](crate::input::CreateLanguageModelInput)
    pub fn builder() -> crate::input::create_language_model_input::Builder {
        crate::input::create_language_model_input::Builder::default()
    }
}

/// See [`CreateMedicalVocabularyInput`](crate::input::CreateMedicalVocabularyInput)
pub mod create_medical_vocabulary_input {
    /// A builder for [`CreateMedicalVocabularyInput`](crate::input::CreateMedicalVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) vocabulary_file_uri: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the custom vocabulary. This case-sensitive name must be unique within an Amazon Web Services
        /// account. If you try to create a vocabulary with the same name as a previous vocabulary, you get a
        /// <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the custom vocabulary. This case-sensitive name must be unique within an Amazon Web Services
        /// account. If you try to create a vocabulary with the same name as a previous vocabulary, you get a
        /// <code>ConflictException</code> error.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code for the language used for the entries in your custom vocabulary. The language code of your
        /// custom vocabulary must match the language code of your transcription job. US English (en-US) is the only language
        /// code available for Amazon Transcribe Medical.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the language used for the entries in your custom vocabulary. The language code of your
        /// custom vocabulary must match the language code of your transcription job. US English (en-US) is the only language
        /// code available for Amazon Transcribe Medical.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The location in Amazon S3 of the text file you use to define your custom vocabulary. The URI must be in the same
        /// Amazon Web Services Region as the resource that you're calling. Enter information about your
        /// <code>VocabularyFileUri</code> in the following format:</p>
        /// <p>
        /// <code>
        /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
        /// </code>
        /// </p>
        /// <p>The following is an example URI for a vocabulary file that is stored in Amazon S3:</p>
        /// <p>
        /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
        /// </p>
        /// <p>For more information about Amazon S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary-med">Medical Custom Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_file_uri = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 of the text file you use to define your custom vocabulary. The URI must be in the same
        /// Amazon Web Services Region as the resource that you're calling. Enter information about your
        /// <code>VocabularyFileUri</code> in the following format:</p>
        /// <p>
        /// <code>
        /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
        /// </code>
        /// </p>
        /// <p>The following is an example URI for a vocabulary file that is stored in Amazon S3:</p>
        /// <p>
        /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
        /// </p>
        /// <p>For more information about Amazon S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary-med">Medical Custom Vocabularies</a>.</p>
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_file_uri = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new medical vocabulary at the time you
        /// create this new vocabulary.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new medical vocabulary at the time you
        /// create this new vocabulary.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMedicalVocabularyInput`](crate::input::CreateMedicalVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMedicalVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMedicalVocabularyInput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                vocabulary_file_uri: self.vocabulary_file_uri,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMedicalVocabularyInputOperationOutputAlias =
    crate::operation::CreateMedicalVocabulary;
#[doc(hidden)]
pub type CreateMedicalVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateMedicalVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`CreateMedicalVocabulary`](crate::operation::CreateMedicalVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMedicalVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateMedicalVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateMedicalVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateMedicalVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.CreateMedicalVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_medical_vocabulary(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMedicalVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMedicalVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateMedicalVocabularyInput`](crate::input::CreateMedicalVocabularyInput)
    pub fn builder() -> crate::input::create_medical_vocabulary_input::Builder {
        crate::input::create_medical_vocabulary_input::Builder::default()
    }
}

/// See [`CreateVocabularyInput`](crate::input::CreateVocabularyInput)
pub mod create_vocabulary_input {
    /// A builder for [`CreateVocabularyInput`](crate::input::CreateVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) phrases: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vocabulary_file_uri: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the vocabulary. The name must be unique within an Amazon Web Services account. The name
        /// is case sensitive. If you try to create a vocabulary with the same name as a previous vocabulary you will receive a
        /// <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary. The name must be unique within an Amazon Web Services account. The name
        /// is case sensitive. If you try to create a vocabulary with the same name as a previous vocabulary you will receive a
        /// <code>ConflictException</code> error.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language
        /// codes, see <a>transcribe-whatis</a>.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language
        /// codes, see <a>transcribe-whatis</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Appends an item to `phrases`.
        ///
        /// To override the contents of this collection use [`set_phrases`](Self::set_phrases).
        ///
        /// <p>An array of strings that contains the vocabulary entries. </p>
        pub fn phrases(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.phrases.unwrap_or_default();
            v.push(input.into());
            self.phrases = Some(v);
            self
        }
        /// <p>An array of strings that contains the vocabulary entries. </p>
        pub fn set_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phrases = input;
            self
        }
        /// <p>The S3 location of the text file that contains the definition of the custom vocabulary. The URI must be in the
        /// same region as the API endpoint that you are calling. The general form is:</p>
        ///
        ///
        ///
        /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the
        /// <i>Amazon S3 Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary">Custom vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_file_uri = Some(input.into());
            self
        }
        /// <p>The S3 location of the text file that contains the definition of the custom vocabulary. The URI must be in the
        /// same region as the API endpoint that you are calling. The general form is:</p>
        ///
        ///
        ///
        /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the
        /// <i>Amazon S3 Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary">Custom vocabularies</a>.</p>
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_file_uri = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new Amazon Transcribe vocabulary at the time you create
        /// this new vocabulary.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new Amazon Transcribe vocabulary at the time you create
        /// this new vocabulary.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVocabularyInput`](crate::input::CreateVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVocabularyInput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                phrases: self.phrases,
                vocabulary_file_uri: self.vocabulary_file_uri,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVocabularyInputOperationOutputAlias = crate::operation::CreateVocabulary;
#[doc(hidden)]
pub type CreateVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`CreateVocabulary`](crate::operation::CreateVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.CreateVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_vocabulary(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateVocabularyInput`](crate::input::CreateVocabularyInput)
    pub fn builder() -> crate::input::create_vocabulary_input::Builder {
        crate::input::create_vocabulary_input::Builder::default()
    }
}

/// See [`CreateVocabularyFilterInput`](crate::input::CreateVocabularyFilterInput)
pub mod create_vocabulary_filter_input {
    /// A builder for [`CreateVocabularyFilterInput`](crate::input::CreateVocabularyFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) words: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vocabulary_filter_file_uri: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The vocabulary filter name. The name must be unique within the account that contains it. If you try to create a
        /// vocabulary filter with the same name as another vocabulary filter, you get a <code>ConflictException</code>
        /// error.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The vocabulary filter name. The name must be unique within the account that contains it. If you try to create a
        /// vocabulary filter with the same name as another vocabulary filter, you get a <code>ConflictException</code>
        /// error.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The language code of the words in the vocabulary filter. All words in the filter must be in the same language.
        /// The vocabulary filter can only be used with transcription jobs in the specified language.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the words in the vocabulary filter. All words in the filter must be in the same language.
        /// The vocabulary filter can only be used with transcription jobs in the specified language.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Appends an item to `words`.
        ///
        /// To override the contents of this collection use [`set_words`](Self::set_words).
        ///
        /// <p>The words to use in the vocabulary filter. Only use characters from the character set defined for custom
        /// vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
        /// <code>VocabularyFilterFileUri</code> parameter.</p>
        pub fn words(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.words.unwrap_or_default();
            v.push(input.into());
            self.words = Some(v);
            self
        }
        /// <p>The words to use in the vocabulary filter. Only use characters from the character set defined for custom
        /// vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
        /// <code>VocabularyFilterFileUri</code> parameter.</p>
        pub fn set_words(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.words = input;
            self
        }
        /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter. Only use characters from
        /// the character set defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
        /// <p>If you provide the location of a list of words in the <code>VocabularyFilterFileUri</code> parameter, you can't
        /// use the <code>Words</code> parameter.</p>
        pub fn vocabulary_filter_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_file_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter. Only use characters from
        /// the character set defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
        /// <p>If you provide the location of a list of words in the <code>VocabularyFilterFileUri</code> parameter, you can't
        /// use the <code>Words</code> parameter.</p>
        pub fn set_vocabulary_filter_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_file_uri = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new Amazon Transcribe vocabulary filter at the time you
        /// create this new vocabulary filter.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Adds one or more tags, each in the form of a key:value pair, to a new Amazon Transcribe vocabulary filter at the time you
        /// create this new vocabulary filter.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVocabularyFilterInput`](crate::input::CreateVocabularyFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVocabularyFilterInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVocabularyFilterInput {
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_code: self.language_code,
                words: self.words,
                vocabulary_filter_file_uri: self.vocabulary_filter_file_uri,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVocabularyFilterInputOperationOutputAlias = crate::operation::CreateVocabularyFilter;
#[doc(hidden)]
pub type CreateVocabularyFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateVocabularyFilterInput {
    /// Consumes the builder and constructs an Operation<[`CreateVocabularyFilter`](crate::operation::CreateVocabularyFilter)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVocabularyFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateVocabularyFilterInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateVocabularyFilterInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateVocabularyFilterInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.CreateVocabularyFilter",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_vocabulary_filter(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVocabularyFilter::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVocabularyFilter",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateVocabularyFilterInput`](crate::input::CreateVocabularyFilterInput)
    pub fn builder() -> crate::input::create_vocabulary_filter_input::Builder {
        crate::input::create_vocabulary_filter_input::Builder::default()
    }
}

/// See [`DeleteCallAnalyticsCategoryInput`](crate::input::DeleteCallAnalyticsCategoryInput)
pub mod delete_call_analytics_category_input {
    /// A builder for [`DeleteCallAnalyticsCategoryInput`](crate::input::DeleteCallAnalyticsCategoryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the call analytics category that you're choosing to delete. The value is case
        /// sensitive. </p>
        pub fn category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.category_name = Some(input.into());
            self
        }
        /// <p>The name of the call analytics category that you're choosing to delete. The value is case
        /// sensitive. </p>
        pub fn set_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.category_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCallAnalyticsCategoryInput`](crate::input::DeleteCallAnalyticsCategoryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCallAnalyticsCategoryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCallAnalyticsCategoryInput {
                category_name: self.category_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCallAnalyticsCategoryInputOperationOutputAlias =
    crate::operation::DeleteCallAnalyticsCategory;
#[doc(hidden)]
pub type DeleteCallAnalyticsCategoryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteCallAnalyticsCategoryInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCallAnalyticsCategory`](crate::operation::DeleteCallAnalyticsCategory)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCallAnalyticsCategory,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteCallAnalyticsCategoryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteCallAnalyticsCategoryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteCallAnalyticsCategoryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteCallAnalyticsCategory",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_call_analytics_category(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCallAnalyticsCategory::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCallAnalyticsCategory",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteCallAnalyticsCategoryInput`](crate::input::DeleteCallAnalyticsCategoryInput)
    pub fn builder() -> crate::input::delete_call_analytics_category_input::Builder {
        crate::input::delete_call_analytics_category_input::Builder::default()
    }
}

/// See [`DeleteCallAnalyticsJobInput`](crate::input::DeleteCallAnalyticsJobInput)
pub mod delete_call_analytics_job_input {
    /// A builder for [`DeleteCallAnalyticsJobInput`](crate::input::DeleteCallAnalyticsJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the call analytics job you want to delete.</p>
        pub fn call_analytics_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.call_analytics_job_name = Some(input.into());
            self
        }
        /// <p>The name of the call analytics job you want to delete.</p>
        pub fn set_call_analytics_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.call_analytics_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCallAnalyticsJobInput`](crate::input::DeleteCallAnalyticsJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCallAnalyticsJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCallAnalyticsJobInput {
                call_analytics_job_name: self.call_analytics_job_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCallAnalyticsJobInputOperationOutputAlias = crate::operation::DeleteCallAnalyticsJob;
#[doc(hidden)]
pub type DeleteCallAnalyticsJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteCallAnalyticsJobInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCallAnalyticsJob`](crate::operation::DeleteCallAnalyticsJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCallAnalyticsJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteCallAnalyticsJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteCallAnalyticsJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteCallAnalyticsJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteCallAnalyticsJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_call_analytics_job(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCallAnalyticsJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCallAnalyticsJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteCallAnalyticsJobInput`](crate::input::DeleteCallAnalyticsJobInput)
    pub fn builder() -> crate::input::delete_call_analytics_job_input::Builder {
        crate::input::delete_call_analytics_job_input::Builder::default()
    }
}

/// See [`DeleteLanguageModelInput`](crate::input::DeleteLanguageModelInput)
pub mod delete_language_model_input {
    /// A builder for [`DeleteLanguageModelInput`](crate::input::DeleteLanguageModelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the model you're choosing to delete.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the model you're choosing to delete.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLanguageModelInput`](crate::input::DeleteLanguageModelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLanguageModelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLanguageModelInput {
                model_name: self.model_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLanguageModelInputOperationOutputAlias = crate::operation::DeleteLanguageModel;
#[doc(hidden)]
pub type DeleteLanguageModelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLanguageModelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLanguageModel`](crate::operation::DeleteLanguageModel)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLanguageModel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteLanguageModelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteLanguageModelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteLanguageModelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteLanguageModel",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_language_model(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLanguageModel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLanguageModel",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLanguageModelInput`](crate::input::DeleteLanguageModelInput)
    pub fn builder() -> crate::input::delete_language_model_input::Builder {
        crate::input::delete_language_model_input::Builder::default()
    }
}

/// See [`DeleteMedicalTranscriptionJobInput`](crate::input::DeleteMedicalTranscriptionJobInput)
pub mod delete_medical_transcription_job_input {
    /// A builder for [`DeleteMedicalTranscriptionJobInput`](crate::input::DeleteMedicalTranscriptionJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name you provide to the <code>DeleteMedicalTranscriptionJob</code> object to
        /// delete a transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name you provide to the <code>DeleteMedicalTranscriptionJob</code> object to
        /// delete a transcription job.</p>
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMedicalTranscriptionJobInput`](crate::input::DeleteMedicalTranscriptionJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMedicalTranscriptionJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMedicalTranscriptionJobInput {
                medical_transcription_job_name: self.medical_transcription_job_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteMedicalTranscriptionJobInputOperationOutputAlias =
    crate::operation::DeleteMedicalTranscriptionJob;
#[doc(hidden)]
pub type DeleteMedicalTranscriptionJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteMedicalTranscriptionJobInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMedicalTranscriptionJob`](crate::operation::DeleteMedicalTranscriptionJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteMedicalTranscriptionJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteMedicalTranscriptionJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteMedicalTranscriptionJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteMedicalTranscriptionJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteMedicalTranscriptionJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_medical_transcription_job(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteMedicalTranscriptionJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteMedicalTranscriptionJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteMedicalTranscriptionJobInput`](crate::input::DeleteMedicalTranscriptionJobInput)
    pub fn builder() -> crate::input::delete_medical_transcription_job_input::Builder {
        crate::input::delete_medical_transcription_job_input::Builder::default()
    }
}

/// See [`DeleteMedicalVocabularyInput`](crate::input::DeleteMedicalVocabularyInput)
pub mod delete_medical_vocabulary_input {
    /// A builder for [`DeleteMedicalVocabularyInput`](crate::input::DeleteMedicalVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary that you want to delete.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary that you want to delete.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMedicalVocabularyInput`](crate::input::DeleteMedicalVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMedicalVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMedicalVocabularyInput {
                vocabulary_name: self.vocabulary_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteMedicalVocabularyInputOperationOutputAlias =
    crate::operation::DeleteMedicalVocabulary;
#[doc(hidden)]
pub type DeleteMedicalVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteMedicalVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMedicalVocabulary`](crate::operation::DeleteMedicalVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteMedicalVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteMedicalVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteMedicalVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteMedicalVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteMedicalVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_medical_vocabulary(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteMedicalVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteMedicalVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteMedicalVocabularyInput`](crate::input::DeleteMedicalVocabularyInput)
    pub fn builder() -> crate::input::delete_medical_vocabulary_input::Builder {
        crate::input::delete_medical_vocabulary_input::Builder::default()
    }
}

/// See [`DeleteTranscriptionJobInput`](crate::input::DeleteTranscriptionJobInput)
pub mod delete_transcription_job_input {
    /// A builder for [`DeleteTranscriptionJobInput`](crate::input::DeleteTranscriptionJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the transcription job to be deleted.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the transcription job to be deleted.</p>
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteTranscriptionJobInput`](crate::input::DeleteTranscriptionJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteTranscriptionJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteTranscriptionJobInput {
                transcription_job_name: self.transcription_job_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteTranscriptionJobInputOperationOutputAlias = crate::operation::DeleteTranscriptionJob;
#[doc(hidden)]
pub type DeleteTranscriptionJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteTranscriptionJobInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTranscriptionJob`](crate::operation::DeleteTranscriptionJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteTranscriptionJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteTranscriptionJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteTranscriptionJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteTranscriptionJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteTranscriptionJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_transcription_job(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteTranscriptionJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteTranscriptionJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteTranscriptionJobInput`](crate::input::DeleteTranscriptionJobInput)
    pub fn builder() -> crate::input::delete_transcription_job_input::Builder {
        crate::input::delete_transcription_job_input::Builder::default()
    }
}

/// See [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput)
pub mod delete_vocabulary_input {
    /// A builder for [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary to delete. </p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary to delete. </p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVocabularyInput {
                vocabulary_name: self.vocabulary_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVocabularyInputOperationOutputAlias = crate::operation::DeleteVocabulary;
#[doc(hidden)]
pub type DeleteVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVocabulary`](crate::operation::DeleteVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_vocabulary(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteVocabularyInput`](crate::input::DeleteVocabularyInput)
    pub fn builder() -> crate::input::delete_vocabulary_input::Builder {
        crate::input::delete_vocabulary_input::Builder::default()
    }
}

/// See [`DeleteVocabularyFilterInput`](crate::input::DeleteVocabularyFilterInput)
pub mod delete_vocabulary_filter_input {
    /// A builder for [`DeleteVocabularyFilterInput`](crate::input::DeleteVocabularyFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter to remove.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter to remove.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVocabularyFilterInput`](crate::input::DeleteVocabularyFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVocabularyFilterInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVocabularyFilterInput {
                vocabulary_filter_name: self.vocabulary_filter_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVocabularyFilterInputOperationOutputAlias = crate::operation::DeleteVocabularyFilter;
#[doc(hidden)]
pub type DeleteVocabularyFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteVocabularyFilterInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVocabularyFilter`](crate::operation::DeleteVocabularyFilter)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVocabularyFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteVocabularyFilterInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteVocabularyFilterInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteVocabularyFilterInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DeleteVocabularyFilter",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_vocabulary_filter(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVocabularyFilter::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVocabularyFilter",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteVocabularyFilterInput`](crate::input::DeleteVocabularyFilterInput)
    pub fn builder() -> crate::input::delete_vocabulary_filter_input::Builder {
        crate::input::delete_vocabulary_filter_input::Builder::default()
    }
}

/// See [`DescribeLanguageModelInput`](crate::input::DescribeLanguageModelInput)
pub mod describe_language_model_input {
    /// A builder for [`DescribeLanguageModelInput`](crate::input::DescribeLanguageModelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the custom language model you submit to get more information.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name of the custom language model you submit to get more information.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLanguageModelInput`](crate::input::DescribeLanguageModelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeLanguageModelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeLanguageModelInput {
                model_name: self.model_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeLanguageModelInputOperationOutputAlias = crate::operation::DescribeLanguageModel;
#[doc(hidden)]
pub type DescribeLanguageModelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeLanguageModelInput {
    /// Consumes the builder and constructs an Operation<[`DescribeLanguageModel`](crate::operation::DescribeLanguageModel)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeLanguageModel,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeLanguageModelInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeLanguageModelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeLanguageModelInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.DescribeLanguageModel",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_language_model(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeLanguageModel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeLanguageModel",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeLanguageModelInput`](crate::input::DescribeLanguageModelInput)
    pub fn builder() -> crate::input::describe_language_model_input::Builder {
        crate::input::describe_language_model_input::Builder::default()
    }
}

/// See [`GetCallAnalyticsCategoryInput`](crate::input::GetCallAnalyticsCategoryInput)
pub mod get_call_analytics_category_input {
    /// A builder for [`GetCallAnalyticsCategoryInput`](crate::input::GetCallAnalyticsCategoryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the category you want information about. This value is case sensitive.</p>
        pub fn category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.category_name = Some(input.into());
            self
        }
        /// <p>The name of the category you want information about. This value is case sensitive.</p>
        pub fn set_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.category_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCallAnalyticsCategoryInput`](crate::input::GetCallAnalyticsCategoryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCallAnalyticsCategoryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCallAnalyticsCategoryInput {
                category_name: self.category_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCallAnalyticsCategoryInputOperationOutputAlias =
    crate::operation::GetCallAnalyticsCategory;
#[doc(hidden)]
pub type GetCallAnalyticsCategoryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCallAnalyticsCategoryInput {
    /// Consumes the builder and constructs an Operation<[`GetCallAnalyticsCategory`](crate::operation::GetCallAnalyticsCategory)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCallAnalyticsCategory,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCallAnalyticsCategoryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCallAnalyticsCategoryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCallAnalyticsCategoryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetCallAnalyticsCategory",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_call_analytics_category(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCallAnalyticsCategory::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCallAnalyticsCategory",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCallAnalyticsCategoryInput`](crate::input::GetCallAnalyticsCategoryInput)
    pub fn builder() -> crate::input::get_call_analytics_category_input::Builder {
        crate::input::get_call_analytics_category_input::Builder::default()
    }
}

/// See [`GetCallAnalyticsJobInput`](crate::input::GetCallAnalyticsJobInput)
pub mod get_call_analytics_job_input {
    /// A builder for [`GetCallAnalyticsJobInput`](crate::input::GetCallAnalyticsJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the analytics job you want information about. This value is case
        /// sensitive. </p>
        pub fn call_analytics_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.call_analytics_job_name = Some(input.into());
            self
        }
        /// <p>The name of the analytics job you want information about. This value is case
        /// sensitive. </p>
        pub fn set_call_analytics_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.call_analytics_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCallAnalyticsJobInput`](crate::input::GetCallAnalyticsJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCallAnalyticsJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCallAnalyticsJobInput {
                call_analytics_job_name: self.call_analytics_job_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCallAnalyticsJobInputOperationOutputAlias = crate::operation::GetCallAnalyticsJob;
#[doc(hidden)]
pub type GetCallAnalyticsJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCallAnalyticsJobInput {
    /// Consumes the builder and constructs an Operation<[`GetCallAnalyticsJob`](crate::operation::GetCallAnalyticsJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCallAnalyticsJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCallAnalyticsJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCallAnalyticsJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCallAnalyticsJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetCallAnalyticsJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_call_analytics_job(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCallAnalyticsJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCallAnalyticsJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCallAnalyticsJobInput`](crate::input::GetCallAnalyticsJobInput)
    pub fn builder() -> crate::input::get_call_analytics_job_input::Builder {
        crate::input::get_call_analytics_job_input::Builder::default()
    }
}

/// See [`GetMedicalTranscriptionJobInput`](crate::input::GetMedicalTranscriptionJobInput)
pub mod get_medical_transcription_job_input {
    /// A builder for [`GetMedicalTranscriptionJobInput`](crate::input::GetMedicalTranscriptionJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the medical transcription job.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the medical transcription job.</p>
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMedicalTranscriptionJobInput`](crate::input::GetMedicalTranscriptionJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMedicalTranscriptionJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMedicalTranscriptionJobInput {
                medical_transcription_job_name: self.medical_transcription_job_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMedicalTranscriptionJobInputOperationOutputAlias =
    crate::operation::GetMedicalTranscriptionJob;
#[doc(hidden)]
pub type GetMedicalTranscriptionJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMedicalTranscriptionJobInput {
    /// Consumes the builder and constructs an Operation<[`GetMedicalTranscriptionJob`](crate::operation::GetMedicalTranscriptionJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMedicalTranscriptionJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMedicalTranscriptionJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMedicalTranscriptionJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMedicalTranscriptionJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetMedicalTranscriptionJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_medical_transcription_job(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMedicalTranscriptionJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMedicalTranscriptionJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMedicalTranscriptionJobInput`](crate::input::GetMedicalTranscriptionJobInput)
    pub fn builder() -> crate::input::get_medical_transcription_job_input::Builder {
        crate::input::get_medical_transcription_job_input::Builder::default()
    }
}

/// See [`GetMedicalVocabularyInput`](crate::input::GetMedicalVocabularyInput)
pub mod get_medical_vocabulary_input {
    /// A builder for [`GetMedicalVocabularyInput`](crate::input::GetMedicalVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary that you want information about. The value is case sensitive. </p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary that you want information about. The value is case sensitive. </p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMedicalVocabularyInput`](crate::input::GetMedicalVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMedicalVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMedicalVocabularyInput {
                vocabulary_name: self.vocabulary_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMedicalVocabularyInputOperationOutputAlias = crate::operation::GetMedicalVocabulary;
#[doc(hidden)]
pub type GetMedicalVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMedicalVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`GetMedicalVocabulary`](crate::operation::GetMedicalVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMedicalVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMedicalVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMedicalVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMedicalVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetMedicalVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_medical_vocabulary(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMedicalVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMedicalVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMedicalVocabularyInput`](crate::input::GetMedicalVocabularyInput)
    pub fn builder() -> crate::input::get_medical_vocabulary_input::Builder {
        crate::input::get_medical_vocabulary_input::Builder::default()
    }
}

/// See [`GetTranscriptionJobInput`](crate::input::GetTranscriptionJobInput)
pub mod get_transcription_job_input {
    /// A builder for [`GetTranscriptionJobInput`](crate::input::GetTranscriptionJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the job.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the job.</p>
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTranscriptionJobInput`](crate::input::GetTranscriptionJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetTranscriptionJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetTranscriptionJobInput {
                transcription_job_name: self.transcription_job_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetTranscriptionJobInputOperationOutputAlias = crate::operation::GetTranscriptionJob;
#[doc(hidden)]
pub type GetTranscriptionJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetTranscriptionJobInput {
    /// Consumes the builder and constructs an Operation<[`GetTranscriptionJob`](crate::operation::GetTranscriptionJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTranscriptionJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetTranscriptionJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetTranscriptionJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetTranscriptionJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetTranscriptionJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_transcription_job(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTranscriptionJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTranscriptionJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetTranscriptionJobInput`](crate::input::GetTranscriptionJobInput)
    pub fn builder() -> crate::input::get_transcription_job_input::Builder {
        crate::input::get_transcription_job_input::Builder::default()
    }
}

/// See [`GetVocabularyInput`](crate::input::GetVocabularyInput)
pub mod get_vocabulary_input {
    /// A builder for [`GetVocabularyInput`](crate::input::GetVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary to return information about. The name is case
        /// sensitive.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary to return information about. The name is case
        /// sensitive.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVocabularyInput`](crate::input::GetVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVocabularyInput {
                vocabulary_name: self.vocabulary_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVocabularyInputOperationOutputAlias = crate::operation::GetVocabulary;
#[doc(hidden)]
pub type GetVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`GetVocabulary`](crate::operation::GetVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_vocabulary(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetVocabularyInput`](crate::input::GetVocabularyInput)
    pub fn builder() -> crate::input::get_vocabulary_input::Builder {
        crate::input::get_vocabulary_input::Builder::default()
    }
}

/// See [`GetVocabularyFilterInput`](crate::input::GetVocabularyFilterInput)
pub mod get_vocabulary_filter_input {
    /// A builder for [`GetVocabularyFilterInput`](crate::input::GetVocabularyFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter for which to return information.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter for which to return information.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVocabularyFilterInput`](crate::input::GetVocabularyFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVocabularyFilterInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVocabularyFilterInput {
                vocabulary_filter_name: self.vocabulary_filter_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVocabularyFilterInputOperationOutputAlias = crate::operation::GetVocabularyFilter;
#[doc(hidden)]
pub type GetVocabularyFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetVocabularyFilterInput {
    /// Consumes the builder and constructs an Operation<[`GetVocabularyFilter`](crate::operation::GetVocabularyFilter)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVocabularyFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetVocabularyFilterInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetVocabularyFilterInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetVocabularyFilterInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.GetVocabularyFilter",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_vocabulary_filter(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVocabularyFilter::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVocabularyFilter",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetVocabularyFilterInput`](crate::input::GetVocabularyFilterInput)
    pub fn builder() -> crate::input::get_vocabulary_filter_input::Builder {
        crate::input::get_vocabulary_filter_input::Builder::default()
    }
}

/// See [`ListCallAnalyticsCategoriesInput`](crate::input::ListCallAnalyticsCategoriesInput)
pub mod list_call_analytics_categories_input {
    /// A builder for [`ListCallAnalyticsCategoriesInput`](crate::input::ListCallAnalyticsCategoriesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When included, <code>NextToken</code>fetches the next set of categories if the result
        /// of the previous request was truncated.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>When included, <code>NextToken</code>fetches the next set of categories if the result
        /// of the previous request was truncated.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of categories to return in each page of results. If there are fewer
        /// results than the value you specify, only the actual results are returned. If you do not specify a
        /// value, the default of 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of categories to return in each page of results. If there are fewer
        /// results than the value you specify, only the actual results are returned. If you do not specify a
        /// value, the default of 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCallAnalyticsCategoriesInput`](crate::input::ListCallAnalyticsCategoriesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCallAnalyticsCategoriesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCallAnalyticsCategoriesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCallAnalyticsCategoriesInputOperationOutputAlias =
    crate::operation::ListCallAnalyticsCategories;
#[doc(hidden)]
pub type ListCallAnalyticsCategoriesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListCallAnalyticsCategoriesInput {
    /// Consumes the builder and constructs an Operation<[`ListCallAnalyticsCategories`](crate::operation::ListCallAnalyticsCategories)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCallAnalyticsCategories,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListCallAnalyticsCategoriesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListCallAnalyticsCategoriesInput,
            mut output: &mut String,
        ) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_1) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_1));
            }
            if let Some(inner_2) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_2).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListCallAnalyticsCategoriesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListCallAnalyticsCategoriesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListCallAnalyticsCategories",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_call_analytics_categories(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCallAnalyticsCategories::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCallAnalyticsCategories",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListCallAnalyticsCategoriesInput`](crate::input::ListCallAnalyticsCategoriesInput)
    pub fn builder() -> crate::input::list_call_analytics_categories_input::Builder {
        crate::input::list_call_analytics_categories_input::Builder::default()
    }
}

/// See [`ListCallAnalyticsJobsInput`](crate::input::ListCallAnalyticsJobsInput)
pub mod list_call_analytics_jobs_input {
    /// A builder for [`ListCallAnalyticsJobsInput`](crate::input::ListCallAnalyticsJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::CallAnalyticsJobStatus>,
        pub(crate) job_name_contains: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When specified, returns only call analytics jobs with the specified status. Jobs are ordered
        /// by creation date, with the most recent jobs returned first. If you don't specify a status, Amazon Transcribe
        /// returns all analytics jobs ordered by creation date.</p>
        pub fn status(mut self, input: crate::model::CallAnalyticsJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>When specified, returns only call analytics jobs with the specified status. Jobs are ordered
        /// by creation date, with the most recent jobs returned first. If you don't specify a status, Amazon Transcribe
        /// returns all analytics jobs ordered by creation date.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the
        /// specified string.</p>
        pub fn job_name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name_contains = Some(input.into());
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the
        /// specified string.</p>
        pub fn set_job_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_name_contains = input;
            self
        }
        /// <p>If you receive a truncated result in the previous request of
        /// ,
        /// include <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If you receive a truncated result in the previous request of
        /// ,
        /// include <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>  The maximum number of call analytics jobs to return in each page of results. If there are
        /// fewer results than the value you specify, only the actual results are returned. If you do not
        /// specify a value, the default of 5 is used. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>  The maximum number of call analytics jobs to return in each page of results. If there are
        /// fewer results than the value you specify, only the actual results are returned. If you do not
        /// specify a value, the default of 5 is used. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCallAnalyticsJobsInput`](crate::input::ListCallAnalyticsJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCallAnalyticsJobsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCallAnalyticsJobsInput {
                status: self.status,
                job_name_contains: self.job_name_contains,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCallAnalyticsJobsInputOperationOutputAlias = crate::operation::ListCallAnalyticsJobs;
#[doc(hidden)]
pub type ListCallAnalyticsJobsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListCallAnalyticsJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListCallAnalyticsJobs`](crate::operation::ListCallAnalyticsJobs)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCallAnalyticsJobs,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListCallAnalyticsJobsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::ListCallAnalyticsJobsInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_3) = &_input.status {
                query.push_kv("Status", &aws_smithy_http::query::fmt_string(&inner_3));
            }
            if let Some(inner_4) = &_input.job_name_contains {
                query.push_kv(
                    "JobNameContains",
                    &aws_smithy_http::query::fmt_string(&inner_4),
                );
            }
            if let Some(inner_5) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_5));
            }
            if let Some(inner_6) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_6).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListCallAnalyticsJobsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListCallAnalyticsJobsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListCallAnalyticsJobs",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_call_analytics_jobs(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCallAnalyticsJobs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCallAnalyticsJobs",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListCallAnalyticsJobsInput`](crate::input::ListCallAnalyticsJobsInput)
    pub fn builder() -> crate::input::list_call_analytics_jobs_input::Builder {
        crate::input::list_call_analytics_jobs_input::Builder::default()
    }
}

/// See [`ListLanguageModelsInput`](crate::input::ListLanguageModelsInput)
pub mod list_language_models_input {
    /// A builder for [`ListLanguageModelsInput`](crate::input::ListLanguageModelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_equals: std::option::Option<crate::model::ModelStatus>,
        pub(crate) name_contains: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When specified, returns only custom language models with the specified status. Language models are ordered
        /// by creation date, with the newest models first. If you don't specify a status, Amazon Transcribe returns all custom language
        /// models ordered by date.</p>
        pub fn status_equals(mut self, input: crate::model::ModelStatus) -> Self {
            self.status_equals = Some(input);
            self
        }
        /// <p>When specified, returns only custom language models with the specified status. Language models are ordered
        /// by creation date, with the newest models first. If you don't specify a status, Amazon Transcribe returns all custom language
        /// models ordered by date.</p>
        pub fn set_status_equals(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.status_equals = input;
            self
        }
        /// <p>When specified, the custom language model names returned contain the substring you've specified.</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_contains = Some(input.into());
            self
        }
        /// <p>When specified, the custom language model names returned contain the substring you've specified.</p>
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_contains = input;
            self
        }
        /// <p>When included, fetches the next set of jobs if the result of the previous request was truncated.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>When included, fetches the next set of jobs if the result of the previous request was truncated.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of language models to return in each page of results. If there are fewer results than the
        /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of language models to return in each page of results. If there are fewer results than the
        /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLanguageModelsInput`](crate::input::ListLanguageModelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListLanguageModelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListLanguageModelsInput {
                status_equals: self.status_equals,
                name_contains: self.name_contains,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListLanguageModelsInputOperationOutputAlias = crate::operation::ListLanguageModels;
#[doc(hidden)]
pub type ListLanguageModelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListLanguageModelsInput {
    /// Consumes the builder and constructs an Operation<[`ListLanguageModels`](crate::operation::ListLanguageModels)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLanguageModels,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListLanguageModelsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::ListLanguageModelsInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_7) = &_input.status_equals {
                query.push_kv(
                    "         StatusEquals",
                    &aws_smithy_http::query::fmt_string(&inner_7),
                );
            }
            if let Some(inner_8) = &_input.name_contains {
                query.push_kv(
                    "NameContains",
                    &aws_smithy_http::query::fmt_string(&inner_8),
                );
            }
            if let Some(inner_9) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_9));
            }
            if let Some(inner_10) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_10).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListLanguageModelsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListLanguageModelsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListLanguageModels",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_language_models(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLanguageModels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLanguageModels",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListLanguageModelsInput`](crate::input::ListLanguageModelsInput)
    pub fn builder() -> crate::input::list_language_models_input::Builder {
        crate::input::list_language_models_input::Builder::default()
    }
}

/// See [`ListMedicalTranscriptionJobsInput`](crate::input::ListMedicalTranscriptionJobsInput)
pub mod list_medical_transcription_jobs_input {
    /// A builder for [`ListMedicalTranscriptionJobsInput`](crate::input::ListMedicalTranscriptionJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) job_name_contains: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When specified, returns only medical transcription jobs with the specified status. Jobs are ordered by creation
        /// date, with the newest jobs returned first. If you don't specify a status, Amazon Transcribe Medical returns all transcription jobs ordered
        /// by creation date.</p>
        pub fn status(mut self, input: crate::model::TranscriptionJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>When specified, returns only medical transcription jobs with the specified status. Jobs are ordered by creation
        /// date, with the newest jobs returned first. If you don't specify a status, Amazon Transcribe Medical returns all transcription jobs ordered
        /// by creation date.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the specified string.</p>
        pub fn job_name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name_contains = Some(input.into());
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the specified string.</p>
        pub fn set_job_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_name_contains = input;
            self
        }
        /// <p>If you a receive a truncated result in the previous request of <code>ListMedicalTranscriptionJobs</code>,
        /// include <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If you a receive a truncated result in the previous request of <code>ListMedicalTranscriptionJobs</code>,
        /// include <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of medical transcription jobs to return in each page of results. If there are fewer
        /// results than the value you specify, only the actual results are returned. If you do not specify a value, the default of
        /// 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of medical transcription jobs to return in each page of results. If there are fewer
        /// results than the value you specify, only the actual results are returned. If you do not specify a value, the default of
        /// 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMedicalTranscriptionJobsInput`](crate::input::ListMedicalTranscriptionJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMedicalTranscriptionJobsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMedicalTranscriptionJobsInput {
                status: self.status,
                job_name_contains: self.job_name_contains,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMedicalTranscriptionJobsInputOperationOutputAlias =
    crate::operation::ListMedicalTranscriptionJobs;
#[doc(hidden)]
pub type ListMedicalTranscriptionJobsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMedicalTranscriptionJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListMedicalTranscriptionJobs`](crate::operation::ListMedicalTranscriptionJobs)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMedicalTranscriptionJobs,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListMedicalTranscriptionJobsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListMedicalTranscriptionJobsInput,
            mut output: &mut String,
        ) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_11) = &_input.status {
                query.push_kv("Status", &aws_smithy_http::query::fmt_string(&inner_11));
            }
            if let Some(inner_12) = &_input.job_name_contains {
                query.push_kv(
                    "JobNameContains",
                    &aws_smithy_http::query::fmt_string(&inner_12),
                );
            }
            if let Some(inner_13) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_13));
            }
            if let Some(inner_14) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_14).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListMedicalTranscriptionJobsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListMedicalTranscriptionJobsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListMedicalTranscriptionJobs",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_medical_transcription_jobs(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMedicalTranscriptionJobs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMedicalTranscriptionJobs",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMedicalTranscriptionJobsInput`](crate::input::ListMedicalTranscriptionJobsInput)
    pub fn builder() -> crate::input::list_medical_transcription_jobs_input::Builder {
        crate::input::list_medical_transcription_jobs_input::Builder::default()
    }
}

/// See [`ListMedicalVocabulariesInput`](crate::input::ListMedicalVocabulariesInput)
pub mod list_medical_vocabularies_input {
    /// A builder for [`ListMedicalVocabulariesInput`](crate::input::ListMedicalVocabulariesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) state_equals: std::option::Option<crate::model::VocabularyState>,
        pub(crate) name_contains: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If the result of your previous request to <code>ListMedicalVocabularies</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of vocabularies.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the result of your previous request to <code>ListMedicalVocabularies</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of vocabularies.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of vocabularies to return in each page of results. If there are fewer results than the
        /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of vocabularies to return in each page of results. If there are fewer results than the
        /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>When specified, returns only vocabularies with the <code>VocabularyState</code> equal to the specified
        /// vocabulary state. Use this field to see which vocabularies are ready for your medical transcription jobs.</p>
        pub fn state_equals(mut self, input: crate::model::VocabularyState) -> Self {
            self.state_equals = Some(input);
            self
        }
        /// <p>When specified, returns only vocabularies with the <code>VocabularyState</code> equal to the specified
        /// vocabulary state. Use this field to see which vocabularies are ready for your medical transcription jobs.</p>
        pub fn set_state_equals(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state_equals = input;
            self
        }
        /// <p>Returns vocabularies whose names contain the specified string. The search is not case sensitive.
        /// <code>ListMedicalVocabularies</code> returns both "<code>vocabularyname</code>" and
        /// "<code>VocabularyName</code>".</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_contains = Some(input.into());
            self
        }
        /// <p>Returns vocabularies whose names contain the specified string. The search is not case sensitive.
        /// <code>ListMedicalVocabularies</code> returns both "<code>vocabularyname</code>" and
        /// "<code>VocabularyName</code>".</p>
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_contains = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMedicalVocabulariesInput`](crate::input::ListMedicalVocabulariesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMedicalVocabulariesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMedicalVocabulariesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                state_equals: self.state_equals,
                name_contains: self.name_contains,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMedicalVocabulariesInputOperationOutputAlias =
    crate::operation::ListMedicalVocabularies;
#[doc(hidden)]
pub type ListMedicalVocabulariesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMedicalVocabulariesInput {
    /// Consumes the builder and constructs an Operation<[`ListMedicalVocabularies`](crate::operation::ListMedicalVocabularies)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMedicalVocabularies,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListMedicalVocabulariesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::ListMedicalVocabulariesInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_15) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_15));
            }
            if let Some(inner_16) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_16).encode(),
                );
            }
            if let Some(inner_17) = &_input.state_equals {
                query.push_kv(
                    "StateEquals",
                    &aws_smithy_http::query::fmt_string(&inner_17),
                );
            }
            if let Some(inner_18) = &_input.name_contains {
                query.push_kv(
                    "NameContains",
                    &aws_smithy_http::query::fmt_string(&inner_18),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListMedicalVocabulariesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListMedicalVocabulariesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListMedicalVocabularies",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_medical_vocabularies(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMedicalVocabularies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMedicalVocabularies",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMedicalVocabulariesInput`](crate::input::ListMedicalVocabulariesInput)
    pub fn builder() -> crate::input::list_medical_vocabularies_input::Builder {
        crate::input::list_medical_vocabularies_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Lists all tags associated with a given Amazon Resource Name (ARN). ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
        /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
        /// values for <code>resource-type</code> are: <code>transcription-job</code>,
        /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
        /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
        /// <code>language-model</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>Lists all tags associated with a given Amazon Resource Name (ARN). ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
        /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
        /// values for <code>resource-type</code> are: <code>transcription-job</code>,
        /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
        /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
        /// <code>language-model</code>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListTagsForResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_tags_for_resource(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTranscriptionJobsInput`](crate::input::ListTranscriptionJobsInput)
pub mod list_transcription_jobs_input {
    /// A builder for [`ListTranscriptionJobsInput`](crate::input::ListTranscriptionJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) job_name_contains: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When specified, returns only transcription jobs with the specified status. Jobs are ordered by creation date, with
        /// the newest jobs returned first. If you don’t specify a status, Amazon Transcribe returns all transcription jobs ordered by creation
        /// date.</p>
        pub fn status(mut self, input: crate::model::TranscriptionJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>When specified, returns only transcription jobs with the specified status. Jobs are ordered by creation date, with
        /// the newest jobs returned first. If you don’t specify a status, Amazon Transcribe returns all transcription jobs ordered by creation
        /// date.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the specified string.</p>
        pub fn job_name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name_contains = Some(input.into());
            self
        }
        /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the specified string.</p>
        pub fn set_job_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_name_contains = input;
            self
        }
        /// <p>If the result of the previous request to <code>ListTranscriptionJobs</code> is truncated, include the
        /// <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>ListTranscriptionJobs</code> is truncated, include the
        /// <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of jobs to return in each page of results. If there are fewer results than the value you
        /// specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of jobs to return in each page of results. If there are fewer results than the value you
        /// specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTranscriptionJobsInput`](crate::input::ListTranscriptionJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTranscriptionJobsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTranscriptionJobsInput {
                status: self.status,
                job_name_contains: self.job_name_contains,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTranscriptionJobsInputOperationOutputAlias = crate::operation::ListTranscriptionJobs;
#[doc(hidden)]
pub type ListTranscriptionJobsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTranscriptionJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListTranscriptionJobs`](crate::operation::ListTranscriptionJobs)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTranscriptionJobs,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTranscriptionJobsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::ListTranscriptionJobsInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_19) = &_input.status {
                query.push_kv("Status", &aws_smithy_http::query::fmt_string(&inner_19));
            }
            if let Some(inner_20) = &_input.job_name_contains {
                query.push_kv(
                    "JobNameContains",
                    &aws_smithy_http::query::fmt_string(&inner_20),
                );
            }
            if let Some(inner_21) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_21));
            }
            if let Some(inner_22) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_22).encode(),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTranscriptionJobsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTranscriptionJobsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListTranscriptionJobs",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_transcription_jobs(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTranscriptionJobs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTranscriptionJobs",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTranscriptionJobsInput`](crate::input::ListTranscriptionJobsInput)
    pub fn builder() -> crate::input::list_transcription_jobs_input::Builder {
        crate::input::list_transcription_jobs_input::Builder::default()
    }
}

/// See [`ListVocabulariesInput`](crate::input::ListVocabulariesInput)
pub mod list_vocabularies_input {
    /// A builder for [`ListVocabulariesInput`](crate::input::ListVocabulariesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) state_equals: std::option::Option<crate::model::VocabularyState>,
        pub(crate) name_contains: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If the result of the previous request to <code>ListVocabularies</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>ListVocabularies</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of vocabularies to return in each page of results. If there are fewer results than the
        /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of vocabularies to return in each page of results. If there are fewer results than the
        /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>When specified, only returns vocabularies with the <code>VocabularyState</code> field equal to the
        /// specified state.</p>
        pub fn state_equals(mut self, input: crate::model::VocabularyState) -> Self {
            self.state_equals = Some(input);
            self
        }
        /// <p>When specified, only returns vocabularies with the <code>VocabularyState</code> field equal to the
        /// specified state.</p>
        pub fn set_state_equals(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.state_equals = input;
            self
        }
        /// <p>When specified, the vocabularies returned in the list are limited to vocabularies whose name contains the
        /// specified string. The search is not case sensitive, <code>ListVocabularies</code> returns both "vocabularyname"
        /// and "VocabularyName" in the response list.</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_contains = Some(input.into());
            self
        }
        /// <p>When specified, the vocabularies returned in the list are limited to vocabularies whose name contains the
        /// specified string. The search is not case sensitive, <code>ListVocabularies</code> returns both "vocabularyname"
        /// and "VocabularyName" in the response list.</p>
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_contains = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVocabulariesInput`](crate::input::ListVocabulariesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVocabulariesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListVocabulariesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                state_equals: self.state_equals,
                name_contains: self.name_contains,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVocabulariesInputOperationOutputAlias = crate::operation::ListVocabularies;
#[doc(hidden)]
pub type ListVocabulariesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListVocabulariesInput {
    /// Consumes the builder and constructs an Operation<[`ListVocabularies`](crate::operation::ListVocabularies)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVocabularies,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListVocabulariesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::ListVocabulariesInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_23) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_23));
            }
            if let Some(inner_24) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_24).encode(),
                );
            }
            if let Some(inner_25) = &_input.state_equals {
                query.push_kv(
                    "StateEquals",
                    &aws_smithy_http::query::fmt_string(&inner_25),
                );
            }
            if let Some(inner_26) = &_input.name_contains {
                query.push_kv(
                    "NameContains",
                    &aws_smithy_http::query::fmt_string(&inner_26),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListVocabulariesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListVocabulariesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListVocabularies",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_vocabularies(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVocabularies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVocabularies",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListVocabulariesInput`](crate::input::ListVocabulariesInput)
    pub fn builder() -> crate::input::list_vocabularies_input::Builder {
        crate::input::list_vocabularies_input::Builder::default()
    }
}

/// See [`ListVocabularyFiltersInput`](crate::input::ListVocabularyFiltersInput)
pub mod list_vocabulary_filters_input {
    /// A builder for [`ListVocabularyFiltersInput`](crate::input::ListVocabularyFiltersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) name_contains: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If the result of the previous request to <code>ListVocabularyFilters</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of collections.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>ListVocabularyFilters</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of collections.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of filters to return in each page of results. If there are fewer results than the value you
        /// specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of filters to return in each page of results. If there are fewer results than the value you
        /// specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Filters the response so that it only contains vocabulary filters whose name contains the specified string.</p>
        pub fn name_contains(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_contains = Some(input.into());
            self
        }
        /// <p>Filters the response so that it only contains vocabulary filters whose name contains the specified string.</p>
        pub fn set_name_contains(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_contains = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVocabularyFiltersInput`](crate::input::ListVocabularyFiltersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVocabularyFiltersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListVocabularyFiltersInput {
                next_token: self.next_token,
                max_results: self.max_results,
                name_contains: self.name_contains,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVocabularyFiltersInputOperationOutputAlias = crate::operation::ListVocabularyFilters;
#[doc(hidden)]
pub type ListVocabularyFiltersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListVocabularyFiltersInput {
    /// Consumes the builder and constructs an Operation<[`ListVocabularyFilters`](crate::operation::ListVocabularyFilters)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVocabularyFilters,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListVocabularyFiltersInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::ListVocabularyFiltersInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_27) = &_input.next_token {
                query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_27));
            }
            if let Some(inner_28) = &_input.max_results {
                query.push_kv(
                    "MaxResults",
                    &aws_smithy_types::primitive::Encoder::from(*inner_28).encode(),
                );
            }
            if let Some(inner_29) = &_input.name_contains {
                query.push_kv(
                    "NameContains",
                    &aws_smithy_http::query::fmt_string(&inner_29),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListVocabularyFiltersInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListVocabularyFiltersInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.ListVocabularyFilters",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_vocabulary_filters(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVocabularyFilters::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVocabularyFilters",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListVocabularyFiltersInput`](crate::input::ListVocabularyFiltersInput)
    pub fn builder() -> crate::input::list_vocabulary_filters_input::Builder {
        crate::input::list_vocabulary_filters_input::Builder::default()
    }
}

/// See [`StartCallAnalyticsJobInput`](crate::input::StartCallAnalyticsJobInput)
pub mod start_call_analytics_job_input {
    /// A builder for [`StartCallAnalyticsJobInput`](crate::input::StartCallAnalyticsJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job_name: std::option::Option<std::string::String>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) output_location: std::option::Option<std::string::String>,
        pub(crate) output_encryption_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::CallAnalyticsJobSettings>,
        pub(crate) channel_definitions:
            std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
    }
    impl Builder {
        /// <p>The name of the call analytics job. You can't use the string "." or ".." by themselves as the job name. The name
        /// must also be unique within an Amazon Web Services account. If you try to create a call analytics job with the same
        /// name as a previous call analytics job, you get a <code>ConflictException</code> error.</p>
        pub fn call_analytics_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.call_analytics_job_name = Some(input.into());
            self
        }
        /// <p>The name of the call analytics job. You can't use the string "." or ".." by themselves as the job name. The name
        /// must also be unique within an Amazon Web Services account. If you try to create a call analytics job with the same
        /// name as a previous call analytics job, you get a <code>ConflictException</code> error.</p>
        pub fn set_call_analytics_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.call_analytics_job_name = input;
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>The Amazon S3 location where the output of the call analytics job is stored. You can provide the following
        /// location types to store the output of call analytics job:</p>
        /// <ul>
        /// <li>
        /// <p>s3://DOC-EXAMPLE-BUCKET1</p>
        /// <p> If you specify a bucket, Amazon Transcribe saves the output of the analytics job as a JSON file at the root level of the
        /// bucket.</p>
        /// </li>
        /// <li>
        /// <p>s3://DOC-EXAMPLE-BUCKET1/folder/</p>
        /// <p>f you specify a path, Amazon Transcribe saves the output of the analytics job as
        /// s3://DOC-EXAMPLE-BUCKET1/folder/your-transcription-job-name.json</p>
        /// <p>If you specify a folder, you must provide a trailing slash.</p>
        /// </li>
        /// <li>
        /// <p>s3://DOC-EXAMPLE-BUCKET1/folder/filename.json</p>
        /// <p> If you provide a path that has the filename specified, Amazon Transcribe saves the output of the analytics job as
        /// s3://DOC-EXAMPLEBUCKET1/folder/filename.json</p>
        /// </li>
        /// </ul>
        /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of our
        /// analytics job using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key,
        /// Amazon Transcribe uses the default Amazon S3 key for server-side encryption of the analytics job output that is placed in your
        /// S3 bucket.</p>
        pub fn output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_location = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location where the output of the call analytics job is stored. You can provide the following
        /// location types to store the output of call analytics job:</p>
        /// <ul>
        /// <li>
        /// <p>s3://DOC-EXAMPLE-BUCKET1</p>
        /// <p> If you specify a bucket, Amazon Transcribe saves the output of the analytics job as a JSON file at the root level of the
        /// bucket.</p>
        /// </li>
        /// <li>
        /// <p>s3://DOC-EXAMPLE-BUCKET1/folder/</p>
        /// <p>f you specify a path, Amazon Transcribe saves the output of the analytics job as
        /// s3://DOC-EXAMPLE-BUCKET1/folder/your-transcription-job-name.json</p>
        /// <p>If you specify a folder, you must provide a trailing slash.</p>
        /// </li>
        /// <li>
        /// <p>s3://DOC-EXAMPLE-BUCKET1/folder/filename.json</p>
        /// <p> If you provide a path that has the filename specified, Amazon Transcribe saves the output of the analytics job as
        /// s3://DOC-EXAMPLEBUCKET1/folder/filename.json</p>
        /// </li>
        /// </ul>
        /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of our
        /// analytics job using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key,
        /// Amazon Transcribe uses the default Amazon S3 key for server-side encryption of the analytics job output that is placed in your
        /// S3 bucket.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service key used to encrypt
        /// the output of the call analytics job. The user calling the  operation must
        /// have permission to use the specified KMS key.</p>
        /// <p>You use either of the following to identify an Amazon Web Services KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p> You can use either of the following to identify a KMS key in the current account or another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another account:
        /// "arn:aws:kms:region:account ID:key/1234abcd-12ab-34cd-56ef1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the call analytics job is encrypted with the default Amazon
        /// S3 key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
        /// <code>OutputLocation</code> parameter. </p>
        pub fn output_encryption_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service key used to encrypt
        /// the output of the call analytics job. The user calling the  operation must
        /// have permission to use the specified KMS key.</p>
        /// <p>You use either of the following to identify an Amazon Web Services KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p> You can use either of the following to identify a KMS key in the current account or another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another account:
        /// "arn:aws:kms:region:account ID:key/1234abcd-12ab-34cd-56ef1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the call analytics job is encrypted with the default Amazon
        /// S3 key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
        /// <code>OutputLocation</code> parameter. </p>
        pub fn set_output_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role that has access to the S3 bucket that contains your input files.
        /// Amazon Transcribe assumes this role to read queued audio files. If you have specified an output S3 bucket for your transcription
        /// results, this role should have access to the output bucket as well.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role that has access to the S3 bucket that contains your input files.
        /// Amazon Transcribe assumes this role to read queued audio files. If you have specified an output S3 bucket for your transcription
        /// results, this role should have access to the output bucket as well.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>A <code>Settings</code> object that provides optional settings for a call analytics job. </p>
        pub fn settings(mut self, input: crate::model::CallAnalyticsJobSettings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>A <code>Settings</code> object that provides optional settings for a call analytics job. </p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJobSettings>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// Appends an item to `channel_definitions`.
        ///
        /// To override the contents of this collection use [`set_channel_definitions`](Self::set_channel_definitions).
        ///
        /// <p>When you start a call analytics job, you must pass an array that maps the agent and the customer to specific
        /// audio channels. The values you can assign to a channel are 0 and 1. The agent and the customer must each have
        /// their own channel. You can't assign more than one channel to an agent or customer. </p>
        pub fn channel_definitions(
            mut self,
            input: impl Into<crate::model::ChannelDefinition>,
        ) -> Self {
            let mut v = self.channel_definitions.unwrap_or_default();
            v.push(input.into());
            self.channel_definitions = Some(v);
            self
        }
        /// <p>When you start a call analytics job, you must pass an array that maps the agent and the customer to specific
        /// audio channels. The values you can assign to a channel are 0 and 1. The agent and the customer must each have
        /// their own channel. You can't assign more than one channel to an agent or customer. </p>
        pub fn set_channel_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
        ) -> Self {
            self.channel_definitions = input;
            self
        }
        /// Consumes the builder and constructs a [`StartCallAnalyticsJobInput`](crate::input::StartCallAnalyticsJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartCallAnalyticsJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartCallAnalyticsJobInput {
                call_analytics_job_name: self.call_analytics_job_name,
                media: self.media,
                output_location: self.output_location,
                output_encryption_kms_key_id: self.output_encryption_kms_key_id,
                data_access_role_arn: self.data_access_role_arn,
                settings: self.settings,
                channel_definitions: self.channel_definitions,
            })
        }
    }
}
#[doc(hidden)]
pub type StartCallAnalyticsJobInputOperationOutputAlias = crate::operation::StartCallAnalyticsJob;
#[doc(hidden)]
pub type StartCallAnalyticsJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartCallAnalyticsJobInput {
    /// Consumes the builder and constructs an Operation<[`StartCallAnalyticsJob`](crate::operation::StartCallAnalyticsJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartCallAnalyticsJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartCallAnalyticsJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartCallAnalyticsJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartCallAnalyticsJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.StartCallAnalyticsJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_call_analytics_job(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartCallAnalyticsJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartCallAnalyticsJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartCallAnalyticsJobInput`](crate::input::StartCallAnalyticsJobInput)
    pub fn builder() -> crate::input::start_call_analytics_job_input::Builder {
        crate::input::start_call_analytics_job_input::Builder::default()
    }
}

/// See [`StartMedicalTranscriptionJobInput`](crate::input::StartMedicalTranscriptionJobInput)
pub mod start_medical_transcription_job_input {
    /// A builder for [`StartMedicalTranscriptionJobInput`](crate::input::StartMedicalTranscriptionJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) output_bucket_name: std::option::Option<std::string::String>,
        pub(crate) output_key: std::option::Option<std::string::String>,
        pub(crate) output_encryption_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) kms_encryption_context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) settings: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        pub(crate) content_identification_type:
            std::option::Option<crate::model::MedicalContentIdentificationType>,
        pub(crate) specialty: std::option::Option<crate::model::Specialty>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the medical transcription job. You can't use the strings "<code>.</code>" or "<code>..</code>"
        /// by themselves as the job name. The name must also be unique within an Amazon Web Services account. If you try to
        /// create a medical transcription job with the same name as a previous medical transcription job, you get a
        /// <code>ConflictException</code> error.</p>
        pub fn medical_transcription_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the medical transcription job. You can't use the strings "<code>.</code>" or "<code>..</code>"
        /// by themselves as the job name. The name must also be unique within an Amazon Web Services account. If you try to
        /// create a medical transcription job with the same name as a previous medical transcription job, you get a
        /// <code>ConflictException</code> error.</p>
        pub fn set_medical_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.medical_transcription_job_name = input;
            self
        }
        /// <p>The language code for the language spoken in the input media file. US English (en-US) is the valid value for
        /// medical transcription jobs. Any other value you enter for language code results in a
        /// <code>BadRequestException</code> error.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the language spoken in the input media file. US English (en-US) is the valid value for
        /// medical transcription jobs. Any other value you enter for language code results in a
        /// <code>BadRequestException</code> error.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file.</p>
        /// <p>If you do not specify the media sample rate, Amazon Transcribe Medical determines the sample rate. If you specify the sample rate,
        /// it must match the rate detected by Amazon Transcribe Medical. In most cases, you should leave the
        /// <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe Medical determine the sample rate.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file.</p>
        /// <p>If you do not specify the media sample rate, Amazon Transcribe Medical determines the sample rate. If you specify the sample rate,
        /// it must match the rate detected by Amazon Transcribe Medical. In most cases, you should leave the
        /// <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe Medical determine the sample rate.</p>
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The audio format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        /// <p>The audio format of the input media file.</p>
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        /// <p>Describes the input media file in a transcription request.</p>
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>The Amazon S3 location where the transcription is stored.</p>
        /// <p>You must set <code>OutputBucketName</code> for Amazon Transcribe Medical to store the transcription results. Your transcript
        /// appears in the S3 location you specify. When you call the <a>GetMedicalTranscriptionJob</a>, the operation
        /// returns this location in the <code>TranscriptFileUri</code> field. The S3 bucket must have permissions that allow
        /// Amazon Transcribe Medical to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for
        /// IAM User Roles</a>.</p>
        /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of your
        /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key, Amazon Transcribe Medical
        /// uses the default Amazon S3 key for server-side encryption of transcripts that are placed in your S3 bucket.</p>
        pub fn output_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_bucket_name = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location where the transcription is stored.</p>
        /// <p>You must set <code>OutputBucketName</code> for Amazon Transcribe Medical to store the transcription results. Your transcript
        /// appears in the S3 location you specify. When you call the <a>GetMedicalTranscriptionJob</a>, the operation
        /// returns this location in the <code>TranscriptFileUri</code> field. The S3 bucket must have permissions that allow
        /// Amazon Transcribe Medical to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for
        /// IAM User Roles</a>.</p>
        /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of your
        /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key, Amazon Transcribe Medical
        /// uses the default Amazon S3 key for server-side encryption of transcripts that are placed in your S3 bucket.</p>
        pub fn set_output_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_bucket_name = input;
            self
        }
        /// <p>You can specify a location in an Amazon S3 bucket to store the output of your medical transcription job.</p>
        /// <p>If you don't specify an output key, Amazon Transcribe Medical stores the output of your transcription job in the Amazon S3 bucket you
        /// specified. By default, the object key is "your-transcription-job-name.json".</p>
        /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription output. For example,
        /// specifying the Amazon S3 prefix, "folder1/folder2/", as an output key would lead to the output being stored as
        /// "folder1/folder2/your-transcription-job-name.json". If you specify "my-other-job-name.json" as the output key, the object
        /// key is changed to "my-other-job-name.json". You can use an output key to change both the prefix and the file name, for
        /// example "folder/my-other-job-name.json".</p>
        /// <p>If you specify an output key, you must also specify an S3 bucket in the <code>OutputBucketName</code>
        /// parameter.</p>
        pub fn output_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_key = Some(input.into());
            self
        }
        /// <p>You can specify a location in an Amazon S3 bucket to store the output of your medical transcription job.</p>
        /// <p>If you don't specify an output key, Amazon Transcribe Medical stores the output of your transcription job in the Amazon S3 bucket you
        /// specified. By default, the object key is "your-transcription-job-name.json".</p>
        /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription output. For example,
        /// specifying the Amazon S3 prefix, "folder1/folder2/", as an output key would lead to the output being stored as
        /// "folder1/folder2/your-transcription-job-name.json". If you specify "my-other-job-name.json" as the output key, the object
        /// key is changed to "my-other-job-name.json". You can use an output key to change both the prefix and the file name, for
        /// example "folder/my-other-job-name.json".</p>
        /// <p>If you specify an output key, you must also specify an S3 bucket in the <code>OutputBucketName</code>
        /// parameter.</p>
        pub fn set_output_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_key = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service (KMS) key used to
        /// encrypt the output of the transcription job. The user calling the <a>StartMedicalTranscriptionJob</a>
        /// operation must have permission to use the specified KMS key.</p>
        /// <p>You use either of the following to identify a KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>You can use either of the following to identify a KMS key in the current account or another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another
        /// account: "arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the medical transcription job is encrypted with the default Amazon S3
        /// key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
        /// <code>OutputBucketName</code> parameter.</p>
        pub fn output_encryption_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service (KMS) key used to
        /// encrypt the output of the transcription job. The user calling the <a>StartMedicalTranscriptionJob</a>
        /// operation must have permission to use the specified KMS key.</p>
        /// <p>You use either of the following to identify a KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>You can use either of the following to identify a KMS key in the current account or another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another
        /// account: "arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the medical transcription job is encrypted with the default Amazon S3
        /// key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
        /// <code>OutputBucketName</code> parameter.</p>
        pub fn set_output_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = input;
            self
        }
        /// Adds a key-value pair to `kms_encryption_context`.
        ///
        /// To override the contents of this collection use [`set_kms_encryption_context`](Self::set_kms_encryption_context).
        ///
        /// <p>A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added
        /// layer of security for your data.</p>
        pub fn kms_encryption_context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.kms_encryption_context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.kms_encryption_context = Some(hash_map);
            self
        }
        /// <p>A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added
        /// layer of security for your data.</p>
        pub fn set_kms_encryption_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.kms_encryption_context = input;
            self
        }
        /// <p>Optional settings for the medical transcription job.</p>
        pub fn settings(mut self, input: crate::model::MedicalTranscriptionSetting) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>Optional settings for the medical transcription job.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscriptionSetting>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// <p>You can configure Amazon Transcribe Medical to label content in the transcription output. If you specify <code>PHI</code>,
        /// Amazon Transcribe Medical labels the personal health information (PHI) that it identifies in the transcription output.</p>
        pub fn content_identification_type(
            mut self,
            input: crate::model::MedicalContentIdentificationType,
        ) -> Self {
            self.content_identification_type = Some(input);
            self
        }
        /// <p>You can configure Amazon Transcribe Medical to label content in the transcription output. If you specify <code>PHI</code>,
        /// Amazon Transcribe Medical labels the personal health information (PHI) that it identifies in the transcription output.</p>
        pub fn set_content_identification_type(
            mut self,
            input: std::option::Option<crate::model::MedicalContentIdentificationType>,
        ) -> Self {
            self.content_identification_type = input;
            self
        }
        /// <p>The medical specialty of any clinician speaking in the input media.</p>
        pub fn specialty(mut self, input: crate::model::Specialty) -> Self {
            self.specialty = Some(input);
            self
        }
        /// <p>The medical specialty of any clinician speaking in the input media.</p>
        pub fn set_specialty(
            mut self,
            input: std::option::Option<crate::model::Specialty>,
        ) -> Self {
            self.specialty = input;
            self
        }
        /// <p>The type of speech in the input audio. <code>CONVERSATION</code> refers to conversations between two or
        /// more speakers, e.g., a conversations between doctors and patients. <code>DICTATION</code> refers to
        /// single-speaker dictated speech, such as clinical notes.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of speech in the input audio. <code>CONVERSATION</code> refers to conversations between two or
        /// more speakers, e.g., a conversations between doctors and patients. <code>DICTATION</code> refers to
        /// single-speaker dictated speech, such as clinical notes.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Add tags to an Amazon Transcribe medical transcription job.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Add tags to an Amazon Transcribe medical transcription job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StartMedicalTranscriptionJobInput`](crate::input::StartMedicalTranscriptionJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartMedicalTranscriptionJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartMedicalTranscriptionJobInput {
                medical_transcription_job_name: self.medical_transcription_job_name,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                output_bucket_name: self.output_bucket_name,
                output_key: self.output_key,
                output_encryption_kms_key_id: self.output_encryption_kms_key_id,
                kms_encryption_context: self.kms_encryption_context,
                settings: self.settings,
                content_identification_type: self.content_identification_type,
                specialty: self.specialty,
                r#type: self.r#type,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type StartMedicalTranscriptionJobInputOperationOutputAlias =
    crate::operation::StartMedicalTranscriptionJob;
#[doc(hidden)]
pub type StartMedicalTranscriptionJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartMedicalTranscriptionJobInput {
    /// Consumes the builder and constructs an Operation<[`StartMedicalTranscriptionJob`](crate::operation::StartMedicalTranscriptionJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartMedicalTranscriptionJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartMedicalTranscriptionJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartMedicalTranscriptionJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartMedicalTranscriptionJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.StartMedicalTranscriptionJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_medical_transcription_job(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartMedicalTranscriptionJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartMedicalTranscriptionJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartMedicalTranscriptionJobInput`](crate::input::StartMedicalTranscriptionJobInput)
    pub fn builder() -> crate::input::start_medical_transcription_job_input::Builder {
        crate::input::start_medical_transcription_job_input::Builder::default()
    }
}

/// See [`StartTranscriptionJobInput`](crate::input::StartTranscriptionJobInput)
pub mod start_transcription_job_input {
    /// A builder for [`StartTranscriptionJobInput`](crate::input::StartTranscriptionJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) media_sample_rate_hertz: std::option::Option<i32>,
        pub(crate) media_format: std::option::Option<crate::model::MediaFormat>,
        pub(crate) media: std::option::Option<crate::model::Media>,
        pub(crate) output_bucket_name: std::option::Option<std::string::String>,
        pub(crate) output_key: std::option::Option<std::string::String>,
        pub(crate) output_encryption_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) kms_encryption_context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) settings: std::option::Option<crate::model::Settings>,
        pub(crate) model_settings: std::option::Option<crate::model::ModelSettings>,
        pub(crate) job_execution_settings: std::option::Option<crate::model::JobExecutionSettings>,
        pub(crate) content_redaction: std::option::Option<crate::model::ContentRedaction>,
        pub(crate) identify_language: std::option::Option<bool>,
        pub(crate) language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        pub(crate) subtitles: std::option::Option<crate::model::Subtitles>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) language_id_settings: std::option::Option<
            std::collections::HashMap<crate::model::LanguageCode, crate::model::LanguageIdSettings>,
        >,
    }
    impl Builder {
        /// <p>The name of the job. You can't use the strings "<code>.</code>" or "<code>..</code>" by themselves as the
        /// job name. The name must also be unique within an Amazon Web Services account. If you try to create a transcription
        /// job with the same name as a previous transcription job, you get a <code>ConflictException</code> error.</p>
        pub fn transcription_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcription_job_name = Some(input.into());
            self
        }
        /// <p>The name of the job. You can't use the strings "<code>.</code>" or "<code>..</code>" by themselves as the
        /// job name. The name must also be unique within an Amazon Web Services account. If you try to create a transcription
        /// job with the same name as a previous transcription job, you get a <code>ConflictException</code> error.</p>
        pub fn set_transcription_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transcription_job_name = input;
            self
        }
        /// <p>The language code for the language used in the input media file.</p>
        /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must be encoded at a sample
        /// rate of 16,000 Hz or higher.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the language used in the input media file.</p>
        /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must be encoded at a sample
        /// rate of 16,000 Hz or higher.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
        /// <p>If you do not specify the media sample rate, Amazon Transcribe determines the sample rate. If you specify the sample rate, it
        /// must match the sample rate detected by Amazon Transcribe. In most cases, you should leave the
        /// <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe determine the sample rate.</p>
        pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
            self.media_sample_rate_hertz = Some(input);
            self
        }
        /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
        /// <p>If you do not specify the media sample rate, Amazon Transcribe determines the sample rate. If you specify the sample rate, it
        /// must match the sample rate detected by Amazon Transcribe. In most cases, you should leave the
        /// <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe determine the sample rate.</p>
        pub fn set_media_sample_rate_hertz(mut self, input: std::option::Option<i32>) -> Self {
            self.media_sample_rate_hertz = input;
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn media_format(mut self, input: crate::model::MediaFormat) -> Self {
            self.media_format = Some(input);
            self
        }
        /// <p>The format of the input media file.</p>
        pub fn set_media_format(
            mut self,
            input: std::option::Option<crate::model::MediaFormat>,
        ) -> Self {
            self.media_format = input;
            self
        }
        /// <p>An object that describes the input media for a transcription job.</p>
        pub fn media(mut self, input: crate::model::Media) -> Self {
            self.media = Some(input);
            self
        }
        /// <p>An object that describes the input media for a transcription job.</p>
        pub fn set_media(mut self, input: std::option::Option<crate::model::Media>) -> Self {
            self.media = input;
            self
        }
        /// <p>The location where the transcription is stored.</p>
        /// <p>If you set the <code>OutputBucketName</code>, Amazon Transcribe puts the transcript in the specified S3 bucket. When
        /// you call the <a>GetTranscriptionJob</a> operation, the operation returns this location in the
        /// <code>TranscriptFileUri</code> field. If you enable content redaction, the redacted transcript appears in
        /// <code>RedactedTranscriptFileUri</code>. If you enable content redaction and choose to output an unredacted
        /// transcript, that transcript's location still appears in the <code>TranscriptFileUri</code>. The S3 bucket must have
        /// permissions that allow Amazon Transcribe to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for
        /// IAM User Roles</a>.</p>
        /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of your
        /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key, Amazon Transcribe
        /// uses the default Amazon S3 key for server-side encryption of transcripts that are placed in your S3 bucket.</p>
        /// <p>If you don't set the <code>OutputBucketName</code>, Amazon Transcribe generates a pre-signed URL, a shareable URL that
        /// provides secure access to your transcription, and returns it in the <code>TranscriptFileUri</code> field. Use this URL
        /// to download the transcription.</p>
        pub fn output_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_bucket_name = Some(input.into());
            self
        }
        /// <p>The location where the transcription is stored.</p>
        /// <p>If you set the <code>OutputBucketName</code>, Amazon Transcribe puts the transcript in the specified S3 bucket. When
        /// you call the <a>GetTranscriptionJob</a> operation, the operation returns this location in the
        /// <code>TranscriptFileUri</code> field. If you enable content redaction, the redacted transcript appears in
        /// <code>RedactedTranscriptFileUri</code>. If you enable content redaction and choose to output an unredacted
        /// transcript, that transcript's location still appears in the <code>TranscriptFileUri</code>. The S3 bucket must have
        /// permissions that allow Amazon Transcribe to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for
        /// IAM User Roles</a>.</p>
        /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of your
        /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key, Amazon Transcribe
        /// uses the default Amazon S3 key for server-side encryption of transcripts that are placed in your S3 bucket.</p>
        /// <p>If you don't set the <code>OutputBucketName</code>, Amazon Transcribe generates a pre-signed URL, a shareable URL that
        /// provides secure access to your transcription, and returns it in the <code>TranscriptFileUri</code> field. Use this URL
        /// to download the transcription.</p>
        pub fn set_output_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_bucket_name = input;
            self
        }
        /// <p>You can specify a location in an Amazon S3 bucket to store the output of your transcription job.</p>
        /// <p>If you don't specify an output key, Amazon Transcribe stores the output of your transcription job in the Amazon S3 bucket you
        /// specified. By default, the object key is "your-transcription-job-name.json".</p>
        /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription output. For example,
        /// specifying the Amazon S3 prefix, "folder1/folder2/", as an output key would lead to the output being stored as
        /// "folder1/folder2/your-transcription-job-name.json". If you specify "my-other-job-name.json" as the output key, the
        /// object key is changed to "my-other-job-name.json". You can use an output key to change both the prefix and the file
        /// name, for example "folder/my-other-job-name.json".</p>
        /// <p>If you specify an output key, you must also specify an S3 bucket in the <code>OutputBucketName</code>
        /// parameter.</p>
        pub fn output_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_key = Some(input.into());
            self
        }
        /// <p>You can specify a location in an Amazon S3 bucket to store the output of your transcription job.</p>
        /// <p>If you don't specify an output key, Amazon Transcribe stores the output of your transcription job in the Amazon S3 bucket you
        /// specified. By default, the object key is "your-transcription-job-name.json".</p>
        /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription output. For example,
        /// specifying the Amazon S3 prefix, "folder1/folder2/", as an output key would lead to the output being stored as
        /// "folder1/folder2/your-transcription-job-name.json". If you specify "my-other-job-name.json" as the output key, the
        /// object key is changed to "my-other-job-name.json". You can use an output key to change both the prefix and the file
        /// name, for example "folder/my-other-job-name.json".</p>
        /// <p>If you specify an output key, you must also specify an S3 bucket in the <code>OutputBucketName</code>
        /// parameter.</p>
        pub fn set_output_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_key = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service (KMS) key used to
        /// encrypt the output of the transcription job. The user calling the <code>StartTranscriptionJob</code>
        /// operation must have permission to use the specified KMS key.</p>
        /// <p>You can use either of the following to identify a KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>You can use either of the following to identify a KMS key in the current account or another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS Key: "arn:aws:kms:region:account
        /// ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account-ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the transcription job is encrypted with the default
        /// Amazon S3 key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
        /// <code>OutputBucketName</code> parameter.</p>
        pub fn output_encryption_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service (KMS) key used to
        /// encrypt the output of the transcription job. The user calling the <code>StartTranscriptionJob</code>
        /// operation must have permission to use the specified KMS key.</p>
        /// <p>You can use either of the following to identify a KMS key in the current account:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>You can use either of the following to identify a KMS key in the current account or another account:</p>
        /// <ul>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS Key: "arn:aws:kms:region:account
        /// ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
        /// </li>
        /// <li>
        /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account-ID:alias/ExampleAlias"</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify an encryption key, the output of the transcription job is encrypted with the default
        /// Amazon S3 key (SSE-S3).</p>
        /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
        /// <code>OutputBucketName</code> parameter.</p>
        pub fn set_output_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = input;
            self
        }
        /// Adds a key-value pair to `kms_encryption_context`.
        ///
        /// To override the contents of this collection use [`set_kms_encryption_context`](Self::set_kms_encryption_context).
        ///
        /// <p>A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added
        /// layer of security for your data.</p>
        pub fn kms_encryption_context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.kms_encryption_context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.kms_encryption_context = Some(hash_map);
            self
        }
        /// <p>A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added
        /// layer of security for your data.</p>
        pub fn set_kms_encryption_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.kms_encryption_context = input;
            self
        }
        /// <p>A <code>Settings</code> object that provides optional settings for a transcription job.</p>
        pub fn settings(mut self, input: crate::model::Settings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>A <code>Settings</code> object that provides optional settings for a transcription job.</p>
        pub fn set_settings(mut self, input: std::option::Option<crate::model::Settings>) -> Self {
            self.settings = input;
            self
        }
        /// <p>Choose the custom language model you use for your transcription job in this parameter.</p>
        pub fn model_settings(mut self, input: crate::model::ModelSettings) -> Self {
            self.model_settings = Some(input);
            self
        }
        /// <p>Choose the custom language model you use for your transcription job in this parameter.</p>
        pub fn set_model_settings(
            mut self,
            input: std::option::Option<crate::model::ModelSettings>,
        ) -> Self {
            self.model_settings = input;
            self
        }
        /// <p>Provides information about how a transcription job is executed. Use this field to indicate that the job can be
        /// queued for deferred execution if the concurrency limit is reached and there are no slots available to immediately run
        /// the job.</p>
        pub fn job_execution_settings(mut self, input: crate::model::JobExecutionSettings) -> Self {
            self.job_execution_settings = Some(input);
            self
        }
        /// <p>Provides information about how a transcription job is executed. Use this field to indicate that the job can be
        /// queued for deferred execution if the concurrency limit is reached and there are no slots available to immediately run
        /// the job.</p>
        pub fn set_job_execution_settings(
            mut self,
            input: std::option::Option<crate::model::JobExecutionSettings>,
        ) -> Self {
            self.job_execution_settings = input;
            self
        }
        /// <p>An object that contains the request parameters for content redaction.</p>
        pub fn content_redaction(mut self, input: crate::model::ContentRedaction) -> Self {
            self.content_redaction = Some(input);
            self
        }
        /// <p>An object that contains the request parameters for content redaction.</p>
        pub fn set_content_redaction(
            mut self,
            input: std::option::Option<crate::model::ContentRedaction>,
        ) -> Self {
            self.content_redaction = input;
            self
        }
        /// <p>Set this field to <code>true</code> to enable automatic language identification. Automatic language identification
        /// is disabled by default. You receive a <code>BadRequestException</code> error if you enter a value for a
        /// <code>LanguageCode</code>.</p>
        pub fn identify_language(mut self, input: bool) -> Self {
            self.identify_language = Some(input);
            self
        }
        /// <p>Set this field to <code>true</code> to enable automatic language identification. Automatic language identification
        /// is disabled by default. You receive a <code>BadRequestException</code> error if you enter a value for a
        /// <code>LanguageCode</code>.</p>
        pub fn set_identify_language(mut self, input: std::option::Option<bool>) -> Self {
            self.identify_language = input;
            self
        }
        /// Appends an item to `language_options`.
        ///
        /// To override the contents of this collection use [`set_language_options`](Self::set_language_options).
        ///
        /// <p>An object containing a list of languages that might be present in your collection of audio files. Automatic language
        /// identification chooses a language that best matches the source audio from that list.</p>
        /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must be encoded at a sample
        /// rate of 16,000 Hz or higher.</p>
        pub fn language_options(mut self, input: impl Into<crate::model::LanguageCode>) -> Self {
            let mut v = self.language_options.unwrap_or_default();
            v.push(input.into());
            self.language_options = Some(v);
            self
        }
        /// <p>An object containing a list of languages that might be present in your collection of audio files. Automatic language
        /// identification chooses a language that best matches the source audio from that list.</p>
        /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must be encoded at a sample
        /// rate of 16,000 Hz or higher.</p>
        pub fn set_language_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
        ) -> Self {
            self.language_options = input;
            self
        }
        /// <p>Add subtitles to your batch transcription job.</p>
        pub fn subtitles(mut self, input: crate::model::Subtitles) -> Self {
            self.subtitles = Some(input);
            self
        }
        /// <p>Add subtitles to your batch transcription job.</p>
        pub fn set_subtitles(
            mut self,
            input: std::option::Option<crate::model::Subtitles>,
        ) -> Self {
            self.subtitles = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Add tags to an Amazon Transcribe transcription job.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Add tags to an Amazon Transcribe transcription job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `language_id_settings`.
        ///
        /// To override the contents of this collection use [`set_language_id_settings`](Self::set_language_id_settings).
        ///
        /// <p>The language identification settings associated with your transcription job. These settings include
        /// <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
        /// <code>LanguageModelName</code>.</p>
        pub fn language_id_settings(
            mut self,
            k: impl Into<crate::model::LanguageCode>,
            v: impl Into<crate::model::LanguageIdSettings>,
        ) -> Self {
            let mut hash_map = self.language_id_settings.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.language_id_settings = Some(hash_map);
            self
        }
        /// <p>The language identification settings associated with your transcription job. These settings include
        /// <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
        /// <code>LanguageModelName</code>.</p>
        pub fn set_language_id_settings(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::LanguageCode,
                    crate::model::LanguageIdSettings,
                >,
            >,
        ) -> Self {
            self.language_id_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTranscriptionJobInput`](crate::input::StartTranscriptionJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartTranscriptionJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartTranscriptionJobInput {
                transcription_job_name: self.transcription_job_name,
                language_code: self.language_code,
                media_sample_rate_hertz: self.media_sample_rate_hertz,
                media_format: self.media_format,
                media: self.media,
                output_bucket_name: self.output_bucket_name,
                output_key: self.output_key,
                output_encryption_kms_key_id: self.output_encryption_kms_key_id,
                kms_encryption_context: self.kms_encryption_context,
                settings: self.settings,
                model_settings: self.model_settings,
                job_execution_settings: self.job_execution_settings,
                content_redaction: self.content_redaction,
                identify_language: self.identify_language,
                language_options: self.language_options,
                subtitles: self.subtitles,
                tags: self.tags,
                language_id_settings: self.language_id_settings,
            })
        }
    }
}
#[doc(hidden)]
pub type StartTranscriptionJobInputOperationOutputAlias = crate::operation::StartTranscriptionJob;
#[doc(hidden)]
pub type StartTranscriptionJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartTranscriptionJobInput {
    /// Consumes the builder and constructs an Operation<[`StartTranscriptionJob`](crate::operation::StartTranscriptionJob)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartTranscriptionJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartTranscriptionJobInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartTranscriptionJobInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartTranscriptionJobInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.StartTranscriptionJob",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_transcription_job(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartTranscriptionJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartTranscriptionJob",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartTranscriptionJobInput`](crate::input::StartTranscriptionJobInput)
    pub fn builder() -> crate::input::start_transcription_job_input::Builder {
        crate::input::start_transcription_job_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to tag. ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
        /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
        /// values for <code>resource-type</code> are: <code>transcription-job</code>,
        /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
        /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
        /// <code>language-model</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to tag. ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
        /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
        /// values for <code>resource-type</code> are: <code>transcription-job</code>,
        /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
        /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
        /// <code>language-model</code>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags you are assigning to a given Amazon Transcribe resource.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tags you are assigning to a given Amazon Transcribe resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.TagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to remove tags from.
        /// ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
        /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
        /// values for <code>resource-type</code> are: <code>transcription-job</code>,
        /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
        /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
        /// <code>language-model</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to remove tags from.
        /// ARNs have the format
        /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
        /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
        /// values for <code>resource-type</code> are: <code>transcription-job</code>,
        /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
        /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
        /// <code>language-model</code>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of tag keys you want to remove from a specified Amazon Transcribe resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>A list of tag keys you want to remove from a specified Amazon Transcribe resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.UntagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateCallAnalyticsCategoryInput`](crate::input::UpdateCallAnalyticsCategoryInput)
pub mod update_call_analytics_category_input {
    /// A builder for [`UpdateCallAnalyticsCategoryInput`](crate::input::UpdateCallAnalyticsCategoryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_name: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    }
    impl Builder {
        /// <p>The name of the analytics category to update. The name is case sensitive. If you try to update a call analytics
        /// category with the same name as a previous category you will receive a <code>ConflictException</code> error.</p>
        pub fn category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.category_name = Some(input.into());
            self
        }
        /// <p>The name of the analytics category to update. The name is case sensitive. If you try to update a call analytics
        /// category with the same name as a previous category you will receive a <code>ConflictException</code> error.</p>
        pub fn set_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.category_name = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The rules used for the updated analytics category. The rules that you provide in this field replace the ones
        /// that are currently being used. </p>
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        /// <p>The rules used for the updated analytics category. The rules that you provide in this field replace the ones
        /// that are currently being used. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCallAnalyticsCategoryInput`](crate::input::UpdateCallAnalyticsCategoryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateCallAnalyticsCategoryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateCallAnalyticsCategoryInput {
                category_name: self.category_name,
                rules: self.rules,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateCallAnalyticsCategoryInputOperationOutputAlias =
    crate::operation::UpdateCallAnalyticsCategory;
#[doc(hidden)]
pub type UpdateCallAnalyticsCategoryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateCallAnalyticsCategoryInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCallAnalyticsCategory`](crate::operation::UpdateCallAnalyticsCategory)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCallAnalyticsCategory,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateCallAnalyticsCategoryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateCallAnalyticsCategoryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateCallAnalyticsCategoryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.UpdateCallAnalyticsCategory",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_call_analytics_category(&self).map_err(|err|aws_smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCallAnalyticsCategory::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCallAnalyticsCategory",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateCallAnalyticsCategoryInput`](crate::input::UpdateCallAnalyticsCategoryInput)
    pub fn builder() -> crate::input::update_call_analytics_category_input::Builder {
        crate::input::update_call_analytics_category_input::Builder::default()
    }
}

/// See [`UpdateMedicalVocabularyInput`](crate::input::UpdateMedicalVocabularyInput)
pub mod update_medical_vocabulary_input {
    /// A builder for [`UpdateMedicalVocabularyInput`](crate::input::UpdateMedicalVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) vocabulary_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update a vocabulary with the
        /// same name as a vocabulary you've already made, you get a <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update a vocabulary with the
        /// same name as a vocabulary you've already made, you get a <code>ConflictException</code> error.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the language used for the entries in the updated vocabulary. US English (en-US) is the
        /// only valid language code in Amazon Transcribe Medical.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the language used for the entries in the updated vocabulary. US English (en-US) is the
        /// only valid language code in Amazon Transcribe Medical.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The location in Amazon S3 of the text file that contains your custom vocabulary. The URI must be in the same
        /// Amazon Web Services Region as the resource that you are calling. The following is the format for a  URI:</p>
        /// <p>
        /// <code>
        /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
        /// </code>
        /// </p>
        /// <p>For example:</p>
        /// <p>
        /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
        /// </p>
        /// <p>For more information about Amazon S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies in Amazon Transcribe Medical, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Medical Custom Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_file_uri = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 of the text file that contains your custom vocabulary. The URI must be in the same
        /// Amazon Web Services Region as the resource that you are calling. The following is the format for a  URI:</p>
        /// <p>
        /// <code>
        /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
        /// </code>
        /// </p>
        /// <p>For example:</p>
        /// <p>
        /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
        /// </p>
        /// <p>For more information about Amazon S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies in Amazon Transcribe Medical, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Medical Custom Vocabularies</a>.</p>
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateMedicalVocabularyInput`](crate::input::UpdateMedicalVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateMedicalVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateMedicalVocabularyInput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                vocabulary_file_uri: self.vocabulary_file_uri,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateMedicalVocabularyInputOperationOutputAlias =
    crate::operation::UpdateMedicalVocabulary;
#[doc(hidden)]
pub type UpdateMedicalVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateMedicalVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateMedicalVocabulary`](crate::operation::UpdateMedicalVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateMedicalVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateMedicalVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateMedicalVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateMedicalVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.UpdateMedicalVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_medical_vocabulary(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateMedicalVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateMedicalVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateMedicalVocabularyInput`](crate::input::UpdateMedicalVocabularyInput)
    pub fn builder() -> crate::input::update_medical_vocabulary_input::Builder {
        crate::input::update_medical_vocabulary_input::Builder::default()
    }
}

/// See [`UpdateVocabularyInput`](crate::input::UpdateVocabularyInput)
pub mod update_vocabulary_input {
    /// A builder for [`UpdateVocabularyInput`](crate::input::UpdateVocabularyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) phrases: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vocabulary_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update a vocabulary with the
        /// same name as a previous vocabulary you will receive a <code>ConflictException</code> error.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update a vocabulary with the
        /// same name as a previous vocabulary you will receive a <code>ConflictException</code> error.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes,
        /// see <a>transcribe-whatis</a>.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes,
        /// see <a>transcribe-whatis</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Appends an item to `phrases`.
        ///
        /// To override the contents of this collection use [`set_phrases`](Self::set_phrases).
        ///
        /// <p>An array of strings containing the vocabulary entries.</p>
        pub fn phrases(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.phrases.unwrap_or_default();
            v.push(input.into());
            self.phrases = Some(v);
            self
        }
        /// <p>An array of strings containing the vocabulary entries.</p>
        pub fn set_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phrases = input;
            self
        }
        /// <p>The S3 location of the text file that contains the definition of the custom vocabulary. The URI must be in the
        /// same region as the API endpoint that you are calling. The general form is </p>
        ///
        /// <p>For example:</p>
        ///
        /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Custom Vocabularies</a>.</p>
        pub fn vocabulary_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_file_uri = Some(input.into());
            self
        }
        /// <p>The S3 location of the text file that contains the definition of the custom vocabulary. The URI must be in the
        /// same region as the API endpoint that you are calling. The general form is </p>
        ///
        /// <p>For example:</p>
        ///
        /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
        /// Developer Guide</i>.</p>
        /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Custom Vocabularies</a>.</p>
        pub fn set_vocabulary_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVocabularyInput`](crate::input::UpdateVocabularyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVocabularyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVocabularyInput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                phrases: self.phrases,
                vocabulary_file_uri: self.vocabulary_file_uri,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVocabularyInputOperationOutputAlias = crate::operation::UpdateVocabulary;
#[doc(hidden)]
pub type UpdateVocabularyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateVocabularyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVocabulary`](crate::operation::UpdateVocabulary)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVocabulary,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateVocabularyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateVocabularyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateVocabularyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.UpdateVocabulary",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_vocabulary(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVocabulary::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVocabulary",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateVocabularyInput`](crate::input::UpdateVocabularyInput)
    pub fn builder() -> crate::input::update_vocabulary_input::Builder {
        crate::input::update_vocabulary_input::Builder::default()
    }
}

/// See [`UpdateVocabularyFilterInput`](crate::input::UpdateVocabularyFilterInput)
pub mod update_vocabulary_filter_input {
    /// A builder for [`UpdateVocabularyFilterInput`](crate::input::UpdateVocabularyFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) words: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vocabulary_filter_file_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter to update. If you try to update a vocabulary filter with the same name as
        /// another vocabulary filter, you get a <code>ConflictException</code> error.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter to update. If you try to update a vocabulary filter with the same name as
        /// another vocabulary filter, you get a <code>ConflictException</code> error.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// Appends an item to `words`.
        ///
        /// To override the contents of this collection use [`set_words`](Self::set_words).
        ///
        /// <p>The words to use in the vocabulary filter. Only use characters from the character set defined for custom
        /// vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
        /// <code>VocabularyFilterFileUri</code> parameter.</p>
        pub fn words(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.words.unwrap_or_default();
            v.push(input.into());
            self.words = Some(v);
            self
        }
        /// <p>The words to use in the vocabulary filter. Only use characters from the character set defined for custom
        /// vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
        /// <code>VocabularyFilterFileUri</code> parameter.</p>
        pub fn set_words(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.words = input;
            self
        }
        /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter. Only use characters from
        /// the character set defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
        /// <p>If you provide the location of a list of words in the
        /// <code>VocabularyFilterFileUri</code> parameter, you can't use the <code>Words</code>
        /// parameter.</p>
        pub fn vocabulary_filter_file_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_file_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter. Only use characters from
        /// the character set defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
        /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
        /// <p>If you provide the location of a list of words in the
        /// <code>VocabularyFilterFileUri</code> parameter, you can't use the <code>Words</code>
        /// parameter.</p>
        pub fn set_vocabulary_filter_file_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_file_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVocabularyFilterInput`](crate::input::UpdateVocabularyFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVocabularyFilterInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVocabularyFilterInput {
                vocabulary_filter_name: self.vocabulary_filter_name,
                words: self.words,
                vocabulary_filter_file_uri: self.vocabulary_filter_file_uri,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVocabularyFilterInputOperationOutputAlias = crate::operation::UpdateVocabularyFilter;
#[doc(hidden)]
pub type UpdateVocabularyFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateVocabularyFilterInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVocabularyFilter`](crate::operation::UpdateVocabularyFilter)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVocabularyFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateVocabularyFilterInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateVocabularyFilterInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateVocabularyFilterInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Transcribe.UpdateVocabularyFilter",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_vocabulary_filter(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVocabularyFilter::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVocabularyFilter",
            "transcribe",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateVocabularyFilterInput`](crate::input::UpdateVocabularyFilterInput)
    pub fn builder() -> crate::input::update_vocabulary_filter_input::Builder {
        crate::input::update_vocabulary_filter_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVocabularyFilterInput {
    /// <p>The name of the vocabulary filter to update. If you try to update a vocabulary filter with the same name as
    /// another vocabulary filter, you get a <code>ConflictException</code> error.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The words to use in the vocabulary filter. Only use characters from the character set defined for custom
    /// vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
    /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
    /// <code>VocabularyFilterFileUri</code> parameter.</p>
    pub words: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter. Only use characters from
    /// the character set defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
    /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
    /// <p>If you provide the location of a list of words in the
    /// <code>VocabularyFilterFileUri</code> parameter, you can't use the <code>Words</code>
    /// parameter.</p>
    pub vocabulary_filter_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateVocabularyFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVocabularyFilterInput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("words", &self.words);
        formatter.field(
            "vocabulary_filter_file_uri",
            &self.vocabulary_filter_file_uri,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVocabularyInput {
    /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update a vocabulary with the
    /// same name as a previous vocabulary you will receive a <code>ConflictException</code> error.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language codes,
    /// see <a>transcribe-whatis</a>.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>An array of strings containing the vocabulary entries.</p>
    pub phrases: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The S3 location of the text file that contains the definition of the custom vocabulary. The URI must be in the
    /// same region as the API endpoint that you are calling. The general form is </p>
    ///
    /// <p>For example:</p>
    ///
    /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
    /// Developer Guide</i>.</p>
    /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Custom Vocabularies</a>.</p>
    pub vocabulary_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("phrases", &self.phrases);
        formatter.field("vocabulary_file_uri", &self.vocabulary_file_uri);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMedicalVocabularyInput {
    /// <p>The name of the vocabulary to update. The name is case sensitive. If you try to update a vocabulary with the
    /// same name as a vocabulary you've already made, you get a <code>ConflictException</code> error.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the language used for the entries in the updated vocabulary. US English (en-US) is the
    /// only valid language code in Amazon Transcribe Medical.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The location in Amazon S3 of the text file that contains your custom vocabulary. The URI must be in the same
    /// Amazon Web Services Region as the resource that you are calling. The following is the format for a  URI:</p>
    /// <p>
    /// <code>
    /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
    /// </code>
    /// </p>
    /// <p>For example:</p>
    /// <p>
    /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
    /// </p>
    /// <p>For more information about Amazon S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
    /// Developer Guide</i>.</p>
    /// <p>For more information about custom vocabularies in Amazon Transcribe Medical, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary">Medical Custom Vocabularies</a>.</p>
    pub vocabulary_file_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateMedicalVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMedicalVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_file_uri", &self.vocabulary_file_uri);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCallAnalyticsCategoryInput {
    /// <p>The name of the analytics category to update. The name is case sensitive. If you try to update a call analytics
    /// category with the same name as a previous category you will receive a <code>ConflictException</code> error.</p>
    pub category_name: std::option::Option<std::string::String>,
    /// <p>The rules used for the updated analytics category. The rules that you provide in this field replace the ones
    /// that are currently being used. </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
}
impl std::fmt::Debug for UpdateCallAnalyticsCategoryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCallAnalyticsCategoryInput");
        formatter.field("category_name", &self.category_name);
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to remove tags from.
    /// ARNs have the format
    /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
    /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
    /// values for <code>resource-type</code> are: <code>transcription-job</code>,
    /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
    /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
    /// <code>language-model</code>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of tag keys you want to remove from a specified Amazon Transcribe resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Transcribe resource you want to tag. ARNs have the format
    /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
    /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
    /// values for <code>resource-type</code> are: <code>transcription-job</code>,
    /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
    /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
    /// <code>language-model</code>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags you are assigning to a given Amazon Transcribe resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartTranscriptionJobInput {
    /// <p>The name of the job. You can't use the strings "<code>.</code>" or "<code>..</code>" by themselves as the
    /// job name. The name must also be unique within an Amazon Web Services account. If you try to create a transcription
    /// job with the same name as a previous transcription job, you get a <code>ConflictException</code> error.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
    /// <p>The language code for the language used in the input media file.</p>
    /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must be encoded at a sample
    /// rate of 16,000 Hz or higher.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the audio track in the input media file. </p>
    /// <p>If you do not specify the media sample rate, Amazon Transcribe determines the sample rate. If you specify the sample rate, it
    /// must match the sample rate detected by Amazon Transcribe. In most cases, you should leave the
    /// <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe determine the sample rate.</p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The format of the input media file.</p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>An object that describes the input media for a transcription job.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>The location where the transcription is stored.</p>
    /// <p>If you set the <code>OutputBucketName</code>, Amazon Transcribe puts the transcript in the specified S3 bucket. When
    /// you call the <a>GetTranscriptionJob</a> operation, the operation returns this location in the
    /// <code>TranscriptFileUri</code> field. If you enable content redaction, the redacted transcript appears in
    /// <code>RedactedTranscriptFileUri</code>. If you enable content redaction and choose to output an unredacted
    /// transcript, that transcript's location still appears in the <code>TranscriptFileUri</code>. The S3 bucket must have
    /// permissions that allow Amazon Transcribe to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for
    /// IAM User Roles</a>.</p>
    /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of your
    /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key, Amazon Transcribe
    /// uses the default Amazon S3 key for server-side encryption of transcripts that are placed in your S3 bucket.</p>
    /// <p>If you don't set the <code>OutputBucketName</code>, Amazon Transcribe generates a pre-signed URL, a shareable URL that
    /// provides secure access to your transcription, and returns it in the <code>TranscriptFileUri</code> field. Use this URL
    /// to download the transcription.</p>
    pub output_bucket_name: std::option::Option<std::string::String>,
    /// <p>You can specify a location in an Amazon S3 bucket to store the output of your transcription job.</p>
    /// <p>If you don't specify an output key, Amazon Transcribe stores the output of your transcription job in the Amazon S3 bucket you
    /// specified. By default, the object key is "your-transcription-job-name.json".</p>
    /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription output. For example,
    /// specifying the Amazon S3 prefix, "folder1/folder2/", as an output key would lead to the output being stored as
    /// "folder1/folder2/your-transcription-job-name.json". If you specify "my-other-job-name.json" as the output key, the
    /// object key is changed to "my-other-job-name.json". You can use an output key to change both the prefix and the file
    /// name, for example "folder/my-other-job-name.json".</p>
    /// <p>If you specify an output key, you must also specify an S3 bucket in the <code>OutputBucketName</code>
    /// parameter.</p>
    pub output_key: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service (KMS) key used to
    /// encrypt the output of the transcription job. The user calling the <code>StartTranscriptionJob</code>
    /// operation must have permission to use the specified KMS key.</p>
    /// <p>You can use either of the following to identify a KMS key in the current account:</p>
    /// <ul>
    /// <li>
    /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
    /// </li>
    /// <li>
    /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
    /// </li>
    /// </ul>
    /// <p>You can use either of the following to identify a KMS key in the current account or another account:</p>
    /// <ul>
    /// <li>
    /// <p>Amazon Resource Name (ARN) of a KMS Key: "arn:aws:kms:region:account
    /// ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
    /// </li>
    /// <li>
    /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account-ID:alias/ExampleAlias"</p>
    /// </li>
    /// </ul>
    /// <p>If you don't specify an encryption key, the output of the transcription job is encrypted with the default
    /// Amazon S3 key (SSE-S3).</p>
    /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
    /// <code>OutputBucketName</code> parameter.</p>
    pub output_encryption_kms_key_id: std::option::Option<std::string::String>,
    /// <p>A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added
    /// layer of security for your data.</p>
    pub kms_encryption_context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A <code>Settings</code> object that provides optional settings for a transcription job.</p>
    pub settings: std::option::Option<crate::model::Settings>,
    /// <p>Choose the custom language model you use for your transcription job in this parameter.</p>
    pub model_settings: std::option::Option<crate::model::ModelSettings>,
    /// <p>Provides information about how a transcription job is executed. Use this field to indicate that the job can be
    /// queued for deferred execution if the concurrency limit is reached and there are no slots available to immediately run
    /// the job.</p>
    pub job_execution_settings: std::option::Option<crate::model::JobExecutionSettings>,
    /// <p>An object that contains the request parameters for content redaction.</p>
    pub content_redaction: std::option::Option<crate::model::ContentRedaction>,
    /// <p>Set this field to <code>true</code> to enable automatic language identification. Automatic language identification
    /// is disabled by default. You receive a <code>BadRequestException</code> error if you enter a value for a
    /// <code>LanguageCode</code>.</p>
    pub identify_language: std::option::Option<bool>,
    /// <p>An object containing a list of languages that might be present in your collection of audio files. Automatic language
    /// identification chooses a language that best matches the source audio from that list.</p>
    /// <p>To transcribe speech in Modern Standard Arabic (ar-SA), your audio or video file must be encoded at a sample
    /// rate of 16,000 Hz or higher.</p>
    pub language_options: std::option::Option<std::vec::Vec<crate::model::LanguageCode>>,
    /// <p>Add subtitles to your batch transcription job.</p>
    pub subtitles: std::option::Option<crate::model::Subtitles>,
    /// <p>Add tags to an Amazon Transcribe transcription job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The language identification settings associated with your transcription job. These settings include
    /// <code>VocabularyName</code>, <code>VocabularyFilterName</code>, and
    /// <code>LanguageModelName</code>.</p>
    pub language_id_settings: std::option::Option<
        std::collections::HashMap<crate::model::LanguageCode, crate::model::LanguageIdSettings>,
    >,
}
impl std::fmt::Debug for StartTranscriptionJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartTranscriptionJobInput");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("output_bucket_name", &self.output_bucket_name);
        formatter.field("output_key", &self.output_key);
        formatter.field(
            "output_encryption_kms_key_id",
            &self.output_encryption_kms_key_id,
        );
        formatter.field("kms_encryption_context", &self.kms_encryption_context);
        formatter.field("settings", &self.settings);
        formatter.field("model_settings", &self.model_settings);
        formatter.field("job_execution_settings", &self.job_execution_settings);
        formatter.field("content_redaction", &self.content_redaction);
        formatter.field("identify_language", &self.identify_language);
        formatter.field("language_options", &self.language_options);
        formatter.field("subtitles", &self.subtitles);
        formatter.field("tags", &self.tags);
        formatter.field("language_id_settings", &self.language_id_settings);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartMedicalTranscriptionJobInput {
    /// <p>The name of the medical transcription job. You can't use the strings "<code>.</code>" or "<code>..</code>"
    /// by themselves as the job name. The name must also be unique within an Amazon Web Services account. If you try to
    /// create a medical transcription job with the same name as a previous medical transcription job, you get a
    /// <code>ConflictException</code> error.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
    /// <p>The language code for the language spoken in the input media file. US English (en-US) is the valid value for
    /// medical transcription jobs. Any other value you enter for language code results in a
    /// <code>BadRequestException</code> error.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The sample rate, in Hertz, of the audio track in the input media file.</p>
    /// <p>If you do not specify the media sample rate, Amazon Transcribe Medical determines the sample rate. If you specify the sample rate,
    /// it must match the rate detected by Amazon Transcribe Medical. In most cases, you should leave the
    /// <code>MediaSampleRateHertz</code> field blank and let Amazon Transcribe Medical determine the sample rate.</p>
    pub media_sample_rate_hertz: std::option::Option<i32>,
    /// <p>The audio format of the input media file.</p>
    pub media_format: std::option::Option<crate::model::MediaFormat>,
    /// <p>Describes the input media file in a transcription request.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>The Amazon S3 location where the transcription is stored.</p>
    /// <p>You must set <code>OutputBucketName</code> for Amazon Transcribe Medical to store the transcription results. Your transcript
    /// appears in the S3 location you specify. When you call the <a>GetMedicalTranscriptionJob</a>, the operation
    /// returns this location in the <code>TranscriptFileUri</code> field. The S3 bucket must have permissions that allow
    /// Amazon Transcribe Medical to put files in the bucket. For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user">Permissions Required for
    /// IAM User Roles</a>.</p>
    /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of your
    /// transcription using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key, Amazon Transcribe Medical
    /// uses the default Amazon S3 key for server-side encryption of transcripts that are placed in your S3 bucket.</p>
    pub output_bucket_name: std::option::Option<std::string::String>,
    /// <p>You can specify a location in an Amazon S3 bucket to store the output of your medical transcription job.</p>
    /// <p>If you don't specify an output key, Amazon Transcribe Medical stores the output of your transcription job in the Amazon S3 bucket you
    /// specified. By default, the object key is "your-transcription-job-name.json".</p>
    /// <p>You can use output keys to specify the Amazon S3 prefix and file name of the transcription output. For example,
    /// specifying the Amazon S3 prefix, "folder1/folder2/", as an output key would lead to the output being stored as
    /// "folder1/folder2/your-transcription-job-name.json". If you specify "my-other-job-name.json" as the output key, the object
    /// key is changed to "my-other-job-name.json". You can use an output key to change both the prefix and the file name, for
    /// example "folder/my-other-job-name.json".</p>
    /// <p>If you specify an output key, you must also specify an S3 bucket in the <code>OutputBucketName</code>
    /// parameter.</p>
    pub output_key: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service (KMS) key used to
    /// encrypt the output of the transcription job. The user calling the <a>StartMedicalTranscriptionJob</a>
    /// operation must have permission to use the specified KMS key.</p>
    /// <p>You use either of the following to identify a KMS key in the current account:</p>
    /// <ul>
    /// <li>
    /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
    /// </li>
    /// <li>
    /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
    /// </li>
    /// </ul>
    /// <p>You can use either of the following to identify a KMS key in the current account or another account:</p>
    /// <ul>
    /// <li>
    /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another
    /// account: "arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab"</p>
    /// </li>
    /// <li>
    /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account ID:alias/ExampleAlias"</p>
    /// </li>
    /// </ul>
    /// <p>If you don't specify an encryption key, the output of the medical transcription job is encrypted with the default Amazon S3
    /// key (SSE-S3).</p>
    /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
    /// <code>OutputBucketName</code> parameter.</p>
    pub output_encryption_kms_key_id: std::option::Option<std::string::String>,
    /// <p>A map of plain text, non-secret key:value pairs, known as encryption context pairs, that provide an added
    /// layer of security for your data.</p>
    pub kms_encryption_context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Optional settings for the medical transcription job.</p>
    pub settings: std::option::Option<crate::model::MedicalTranscriptionSetting>,
    /// <p>You can configure Amazon Transcribe Medical to label content in the transcription output. If you specify <code>PHI</code>,
    /// Amazon Transcribe Medical labels the personal health information (PHI) that it identifies in the transcription output.</p>
    pub content_identification_type:
        std::option::Option<crate::model::MedicalContentIdentificationType>,
    /// <p>The medical specialty of any clinician speaking in the input media.</p>
    pub specialty: std::option::Option<crate::model::Specialty>,
    /// <p>The type of speech in the input audio. <code>CONVERSATION</code> refers to conversations between two or
    /// more speakers, e.g., a conversations between doctors and patients. <code>DICTATION</code> refers to
    /// single-speaker dictated speech, such as clinical notes.</p>
    pub r#type: std::option::Option<crate::model::Type>,
    /// <p>Add tags to an Amazon Transcribe medical transcription job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for StartMedicalTranscriptionJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartMedicalTranscriptionJobInput");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.field("language_code", &self.language_code);
        formatter.field("media_sample_rate_hertz", &self.media_sample_rate_hertz);
        formatter.field("media_format", &self.media_format);
        formatter.field("media", &self.media);
        formatter.field("output_bucket_name", &self.output_bucket_name);
        formatter.field("output_key", &self.output_key);
        formatter.field(
            "output_encryption_kms_key_id",
            &self.output_encryption_kms_key_id,
        );
        formatter.field("kms_encryption_context", &self.kms_encryption_context);
        formatter.field("settings", &self.settings);
        formatter.field(
            "content_identification_type",
            &self.content_identification_type,
        );
        formatter.field("specialty", &self.specialty);
        formatter.field("r#type", &self.r#type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartCallAnalyticsJobInput {
    /// <p>The name of the call analytics job. You can't use the string "." or ".." by themselves as the job name. The name
    /// must also be unique within an Amazon Web Services account. If you try to create a call analytics job with the same
    /// name as a previous call analytics job, you get a <code>ConflictException</code> error.</p>
    pub call_analytics_job_name: std::option::Option<std::string::String>,
    /// <p>Describes the input media file in a transcription request.</p>
    pub media: std::option::Option<crate::model::Media>,
    /// <p>The Amazon S3 location where the output of the call analytics job is stored. You can provide the following
    /// location types to store the output of call analytics job:</p>
    /// <ul>
    /// <li>
    /// <p>s3://DOC-EXAMPLE-BUCKET1</p>
    /// <p> If you specify a bucket, Amazon Transcribe saves the output of the analytics job as a JSON file at the root level of the
    /// bucket.</p>
    /// </li>
    /// <li>
    /// <p>s3://DOC-EXAMPLE-BUCKET1/folder/</p>
    /// <p>f you specify a path, Amazon Transcribe saves the output of the analytics job as
    /// s3://DOC-EXAMPLE-BUCKET1/folder/your-transcription-job-name.json</p>
    /// <p>If you specify a folder, you must provide a trailing slash.</p>
    /// </li>
    /// <li>
    /// <p>s3://DOC-EXAMPLE-BUCKET1/folder/filename.json</p>
    /// <p> If you provide a path that has the filename specified, Amazon Transcribe saves the output of the analytics job as
    /// s3://DOC-EXAMPLEBUCKET1/folder/filename.json</p>
    /// </li>
    /// </ul>
    /// <p>You can specify an Amazon Web Services Key Management Service (KMS) key to encrypt the output of our
    /// analytics job using the <code>OutputEncryptionKMSKeyId</code> parameter. If you don't specify a KMS key,
    /// Amazon Transcribe uses the default Amazon S3 key for server-side encryption of the analytics job output that is placed in your
    /// S3 bucket.</p>
    pub output_location: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Key Management Service key used to encrypt
    /// the output of the call analytics job. The user calling the  operation must
    /// have permission to use the specified KMS key.</p>
    /// <p>You use either of the following to identify an Amazon Web Services KMS key in the current account:</p>
    /// <ul>
    /// <li>
    /// <p>KMS Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"</p>
    /// </li>
    /// <li>
    /// <p>KMS Key Alias: "alias/ExampleAlias"</p>
    /// </li>
    /// </ul>
    /// <p> You can use either of the following to identify a KMS key in the current account or another account:</p>
    /// <ul>
    /// <li>
    /// <p>Amazon Resource Name (ARN) of a KMS key in the current account or another account:
    /// "arn:aws:kms:region:account ID:key/1234abcd-12ab-34cd-56ef1234567890ab"</p>
    /// </li>
    /// <li>
    /// <p>ARN of a KMS Key Alias: "arn:aws:kms:region:account ID:alias/ExampleAlias"</p>
    /// </li>
    /// </ul>
    /// <p>If you don't specify an encryption key, the output of the call analytics job is encrypted with the default Amazon
    /// S3 key (SSE-S3).</p>
    /// <p>If you specify a KMS key to encrypt your output, you must also specify an output location in the
    /// <code>OutputLocation</code> parameter. </p>
    pub output_encryption_kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a role that has access to the S3 bucket that contains your input files.
    /// Amazon Transcribe assumes this role to read queued audio files. If you have specified an output S3 bucket for your transcription
    /// results, this role should have access to the output bucket as well.</p>
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>A <code>Settings</code> object that provides optional settings for a call analytics job. </p>
    pub settings: std::option::Option<crate::model::CallAnalyticsJobSettings>,
    /// <p>When you start a call analytics job, you must pass an array that maps the agent and the customer to specific
    /// audio channels. The values you can assign to a channel are 0 and 1. The agent and the customer must each have
    /// their own channel. You can't assign more than one channel to an agent or customer. </p>
    pub channel_definitions: std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
}
impl std::fmt::Debug for StartCallAnalyticsJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartCallAnalyticsJobInput");
        formatter.field("call_analytics_job_name", &self.call_analytics_job_name);
        formatter.field("media", &self.media);
        formatter.field("output_location", &self.output_location);
        formatter.field(
            "output_encryption_kms_key_id",
            &self.output_encryption_kms_key_id,
        );
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.field("settings", &self.settings);
        formatter.field("channel_definitions", &self.channel_definitions);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVocabularyFiltersInput {
    /// <p>If the result of the previous request to <code>ListVocabularyFilters</code> was truncated, include the
    /// <code>NextToken</code> to fetch the next set of collections.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of filters to return in each page of results. If there are fewer results than the value you
    /// specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Filters the response so that it only contains vocabulary filters whose name contains the specified string.</p>
    pub name_contains: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListVocabularyFiltersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVocabularyFiltersInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_contains", &self.name_contains);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVocabulariesInput {
    /// <p>If the result of the previous request to <code>ListVocabularies</code> was truncated, include the
    /// <code>NextToken</code> to fetch the next set of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of vocabularies to return in each page of results. If there are fewer results than the
    /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>When specified, only returns vocabularies with the <code>VocabularyState</code> field equal to the
    /// specified state.</p>
    pub state_equals: std::option::Option<crate::model::VocabularyState>,
    /// <p>When specified, the vocabularies returned in the list are limited to vocabularies whose name contains the
    /// specified string. The search is not case sensitive, <code>ListVocabularies</code> returns both "vocabularyname"
    /// and "VocabularyName" in the response list.</p>
    pub name_contains: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListVocabulariesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVocabulariesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("state_equals", &self.state_equals);
        formatter.field("name_contains", &self.name_contains);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTranscriptionJobsInput {
    /// <p>When specified, returns only transcription jobs with the specified status. Jobs are ordered by creation date, with
    /// the newest jobs returned first. If you don’t specify a status, Amazon Transcribe returns all transcription jobs ordered by creation
    /// date.</p>
    pub status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the specified string.</p>
    pub job_name_contains: std::option::Option<std::string::String>,
    /// <p>If the result of the previous request to <code>ListTranscriptionJobs</code> is truncated, include the
    /// <code>NextToken</code> to fetch the next set of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of jobs to return in each page of results. If there are fewer results than the value you
    /// specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListTranscriptionJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTranscriptionJobsInput");
        formatter.field("status", &self.status);
        formatter.field("job_name_contains", &self.job_name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>Lists all tags associated with a given Amazon Resource Name (ARN). ARNs have the format
    /// <code>arn:partition:service:region:account-id:resource-type/resource-id</code> (for example,
    /// <code>arn:aws:transcribe:us-east-1:account-id:transcription-job/your-job-name</code>). Valid
    /// values for <code>resource-type</code> are: <code>transcription-job</code>,
    /// <code>medical-transcription-job</code>, <code>vocabulary</code>,
    /// <code>medical-vocabulary</code>, <code>vocabulary-filter</code>, and
    /// <code>language-model</code>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMedicalVocabulariesInput {
    /// <p>If the result of your previous request to <code>ListMedicalVocabularies</code> was truncated, include the
    /// <code>NextToken</code> to fetch the next set of vocabularies.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of vocabularies to return in each page of results. If there are fewer results than the
    /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>When specified, returns only vocabularies with the <code>VocabularyState</code> equal to the specified
    /// vocabulary state. Use this field to see which vocabularies are ready for your medical transcription jobs.</p>
    pub state_equals: std::option::Option<crate::model::VocabularyState>,
    /// <p>Returns vocabularies whose names contain the specified string. The search is not case sensitive.
    /// <code>ListMedicalVocabularies</code> returns both "<code>vocabularyname</code>" and
    /// "<code>VocabularyName</code>".</p>
    pub name_contains: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMedicalVocabulariesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMedicalVocabulariesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("state_equals", &self.state_equals);
        formatter.field("name_contains", &self.name_contains);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMedicalTranscriptionJobsInput {
    /// <p>When specified, returns only medical transcription jobs with the specified status. Jobs are ordered by creation
    /// date, with the newest jobs returned first. If you don't specify a status, Amazon Transcribe Medical returns all transcription jobs ordered
    /// by creation date.</p>
    pub status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the specified string.</p>
    pub job_name_contains: std::option::Option<std::string::String>,
    /// <p>If you a receive a truncated result in the previous request of <code>ListMedicalTranscriptionJobs</code>,
    /// include <code>NextToken</code> to fetch the next set of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of medical transcription jobs to return in each page of results. If there are fewer
    /// results than the value you specify, only the actual results are returned. If you do not specify a value, the default of
    /// 5 is used.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListMedicalTranscriptionJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMedicalTranscriptionJobsInput");
        formatter.field("status", &self.status);
        formatter.field("job_name_contains", &self.job_name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLanguageModelsInput {
    /// <p>When specified, returns only custom language models with the specified status. Language models are ordered
    /// by creation date, with the newest models first. If you don't specify a status, Amazon Transcribe returns all custom language
    /// models ordered by date.</p>
    pub status_equals: std::option::Option<crate::model::ModelStatus>,
    /// <p>When specified, the custom language model names returned contain the substring you've specified.</p>
    pub name_contains: std::option::Option<std::string::String>,
    /// <p>When included, fetches the next set of jobs if the result of the previous request was truncated.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of language models to return in each page of results. If there are fewer results than the
    /// value you specify, only the actual results are returned. If you do not specify a value, the default of 5 is used.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListLanguageModelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLanguageModelsInput");
        formatter.field("status_equals", &self.status_equals);
        formatter.field("name_contains", &self.name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCallAnalyticsJobsInput {
    /// <p>When specified, returns only call analytics jobs with the specified status. Jobs are ordered
    /// by creation date, with the most recent jobs returned first. If you don't specify a status, Amazon Transcribe
    /// returns all analytics jobs ordered by creation date.</p>
    pub status: std::option::Option<crate::model::CallAnalyticsJobStatus>,
    /// <p>When specified, the jobs returned in the list are limited to jobs whose name contains the
    /// specified string.</p>
    pub job_name_contains: std::option::Option<std::string::String>,
    /// <p>If you receive a truncated result in the previous request of
    /// ,
    /// include <code>NextToken</code> to fetch the next set of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>  The maximum number of call analytics jobs to return in each page of results. If there are
    /// fewer results than the value you specify, only the actual results are returned. If you do not
    /// specify a value, the default of 5 is used. </p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListCallAnalyticsJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCallAnalyticsJobsInput");
        formatter.field("status", &self.status);
        formatter.field("job_name_contains", &self.job_name_contains);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCallAnalyticsCategoriesInput {
    /// <p>When included, <code>NextToken</code>fetches the next set of categories if the result
    /// of the previous request was truncated.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of categories to return in each page of results. If there are fewer
    /// results than the value you specify, only the actual results are returned. If you do not specify a
    /// value, the default of 5 is used.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListCallAnalyticsCategoriesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCallAnalyticsCategoriesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVocabularyFilterInput {
    /// <p>The name of the vocabulary filter for which to return information.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetVocabularyFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVocabularyFilterInput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVocabularyInput {
    /// <p>The name of the vocabulary to return information about. The name is case
    /// sensitive.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTranscriptionJobInput {
    /// <p>The name of the job.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetTranscriptionJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTranscriptionJobInput");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMedicalVocabularyInput {
    /// <p>The name of the vocabulary that you want information about. The value is case sensitive. </p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMedicalVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMedicalVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMedicalTranscriptionJobInput {
    /// <p>The name of the medical transcription job.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMedicalTranscriptionJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMedicalTranscriptionJobInput");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCallAnalyticsJobInput {
    /// <p>The name of the analytics job you want information about. This value is case
    /// sensitive. </p>
    pub call_analytics_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetCallAnalyticsJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCallAnalyticsJobInput");
        formatter.field("call_analytics_job_name", &self.call_analytics_job_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCallAnalyticsCategoryInput {
    /// <p>The name of the category you want information about. This value is case sensitive.</p>
    pub category_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetCallAnalyticsCategoryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCallAnalyticsCategoryInput");
        formatter.field("category_name", &self.category_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLanguageModelInput {
    /// <p>The name of the custom language model you submit to get more information.</p>
    pub model_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeLanguageModelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLanguageModelInput");
        formatter.field("model_name", &self.model_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVocabularyFilterInput {
    /// <p>The name of the vocabulary filter to remove.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteVocabularyFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVocabularyFilterInput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVocabularyInput {
    /// <p>The name of the vocabulary to delete. </p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTranscriptionJobInput {
    /// <p>The name of the transcription job to be deleted.</p>
    pub transcription_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteTranscriptionJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTranscriptionJobInput");
        formatter.field("transcription_job_name", &self.transcription_job_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMedicalVocabularyInput {
    /// <p>The name of the vocabulary that you want to delete.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMedicalVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMedicalVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMedicalTranscriptionJobInput {
    /// <p>The name you provide to the <code>DeleteMedicalTranscriptionJob</code> object to
    /// delete a transcription job.</p>
    pub medical_transcription_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMedicalTranscriptionJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMedicalTranscriptionJobInput");
        formatter.field(
            "medical_transcription_job_name",
            &self.medical_transcription_job_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLanguageModelInput {
    /// <p>The name of the model you're choosing to delete.</p>
    pub model_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteLanguageModelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLanguageModelInput");
        formatter.field("model_name", &self.model_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCallAnalyticsJobInput {
    /// <p>The name of the call analytics job you want to delete.</p>
    pub call_analytics_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteCallAnalyticsJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCallAnalyticsJobInput");
        formatter.field("call_analytics_job_name", &self.call_analytics_job_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCallAnalyticsCategoryInput {
    /// <p>The name of the call analytics category that you're choosing to delete. The value is case
    /// sensitive. </p>
    pub category_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteCallAnalyticsCategoryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCallAnalyticsCategoryInput");
        formatter.field("category_name", &self.category_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVocabularyFilterInput {
    /// <p>The vocabulary filter name. The name must be unique within the account that contains it. If you try to create a
    /// vocabulary filter with the same name as another vocabulary filter, you get a <code>ConflictException</code>
    /// error.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The language code of the words in the vocabulary filter. All words in the filter must be in the same language.
    /// The vocabulary filter can only be used with transcription jobs in the specified language.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The words to use in the vocabulary filter. Only use characters from the character set defined for custom
    /// vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
    /// <p>If you provide a list of words in the <code>Words</code> parameter, you can't use the
    /// <code>VocabularyFilterFileUri</code> parameter.</p>
    pub words: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon S3 location of a text file used as input to create the vocabulary filter. Only use characters from
    /// the character set defined for custom vocabularies. For a list of character sets, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html#charsets">Character Sets for Custom Vocabularies</a>.</p>
    /// <p>The specified file must be less than 50 KB of UTF-8 characters.</p>
    /// <p>If you provide the location of a list of words in the <code>VocabularyFilterFileUri</code> parameter, you can't
    /// use the <code>Words</code> parameter.</p>
    pub vocabulary_filter_file_uri: std::option::Option<std::string::String>,
    /// <p>Adds one or more tags, each in the form of a key:value pair, to a new Amazon Transcribe vocabulary filter at the time you
    /// create this new vocabulary filter.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateVocabularyFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVocabularyFilterInput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("words", &self.words);
        formatter.field(
            "vocabulary_filter_file_uri",
            &self.vocabulary_filter_file_uri,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVocabularyInput {
    /// <p>The name of the vocabulary. The name must be unique within an Amazon Web Services account. The name
    /// is case sensitive. If you try to create a vocabulary with the same name as a previous vocabulary you will receive a
    /// <code>ConflictException</code> error.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries. For a list of languages and their corresponding language
    /// codes, see <a>transcribe-whatis</a>.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>An array of strings that contains the vocabulary entries. </p>
    pub phrases: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The S3 location of the text file that contains the definition of the custom vocabulary. The URI must be in the
    /// same region as the API endpoint that you are calling. The general form is:</p>
    ///
    ///
    ///
    /// <p>For more information about S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the
    /// <i>Amazon S3 Developer Guide</i>.</p>
    /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary">Custom vocabularies</a>.</p>
    pub vocabulary_file_uri: std::option::Option<std::string::String>,
    /// <p>Adds one or more tags, each in the form of a key:value pair, to a new Amazon Transcribe vocabulary at the time you create
    /// this new vocabulary.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("phrases", &self.phrases);
        formatter.field("vocabulary_file_uri", &self.vocabulary_file_uri);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMedicalVocabularyInput {
    /// <p>The name of the custom vocabulary. This case-sensitive name must be unique within an Amazon Web Services
    /// account. If you try to create a vocabulary with the same name as a previous vocabulary, you get a
    /// <code>ConflictException</code> error.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code for the language used for the entries in your custom vocabulary. The language code of your
    /// custom vocabulary must match the language code of your transcription job. US English (en-US) is the only language
    /// code available for Amazon Transcribe Medical.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The location in Amazon S3 of the text file you use to define your custom vocabulary. The URI must be in the same
    /// Amazon Web Services Region as the resource that you're calling. Enter information about your
    /// <code>VocabularyFileUri</code> in the following format:</p>
    /// <p>
    /// <code>
    /// https://s3.<aws-region>.amazonaws.com/<bucket-name>/<keyprefix>/<objectkey>
    /// </code>
    /// </p>
    /// <p>The following is an example URI for a vocabulary file that is stored in Amazon S3:</p>
    /// <p>
    /// <code>https://s3.us-east-1.amazonaws.com/AWSDOC-EXAMPLE-BUCKET/vocab.txt</code>
    /// </p>
    /// <p>For more information about Amazon S3 object names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#object-keys">Object Keys</a> in the <i>Amazon S3
    /// Developer Guide</i>.</p>
    /// <p>For more information about custom vocabularies, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works.html#how-vocabulary-med">Medical Custom Vocabularies</a>.</p>
    pub vocabulary_file_uri: std::option::Option<std::string::String>,
    /// <p>Adds one or more tags, each in the form of a key:value pair, to a new medical vocabulary at the time you
    /// create this new vocabulary.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateMedicalVocabularyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMedicalVocabularyInput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_file_uri", &self.vocabulary_file_uri);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLanguageModelInput {
    /// <p>The language of the input text you're using to train your custom language
    /// model.</p>
    pub language_code: std::option::Option<crate::model::ClmLanguageCode>,
    /// <p>The Amazon Transcribe standard language model, or base model used to create your custom language model.</p>
    /// <p>If you want to use your custom language model to transcribe audio with a sample rate of 16,000 Hz or greater,
    /// choose <code>Wideband</code>.</p>
    /// <p>If you want to use your custom language model to transcribe audio with a sample rate that is less than
    /// 16,000 Hz, choose <code>Narrowband</code>.</p>
    pub base_model_name: std::option::Option<crate::model::BaseModelName>,
    /// <p>The name you choose for your custom language model when you create it.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>Contains the data access role and the Amazon S3 prefixes to read the required input files to create a custom
    /// language model.</p>
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>Adds one or more tags, each in the form of a key:value pair, to a new language model at the time you create
    /// this new model.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateLanguageModelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLanguageModelInput");
        formatter.field("language_code", &self.language_code);
        formatter.field("base_model_name", &self.base_model_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCallAnalyticsCategoryInput {
    /// <p>The name that you choose for your category when you create it. </p>
    pub category_name: std::option::Option<std::string::String>,
    /// <p>To create a category, you must specify between 1 and 20 rules. For each rule, you specify a
    /// filter to be applied to the attributes of the call. For example, you can specify a sentiment
    /// filter to detect if the customer's sentiment was negative or neutral. </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
}
impl std::fmt::Debug for CreateCallAnalyticsCategoryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCallAnalyticsCategoryInput");
        formatter.field("category_name", &self.category_name);
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}
